Tue Mar 12 00:45:24 PDT 2024
diff --git a/.DS_Store b/.DS_Store
index bf7630a..1e09479 100644
Binary files a/.DS_Store and b/.DS_Store differ
diff --git a/.ipynb_checkpoints/analyze_models-checkpoint.ipynb b/.ipynb_checkpoints/analyze_models-checkpoint.ipynb
index a605da2..57b272a 100644
--- a/.ipynb_checkpoints/analyze_models-checkpoint.ipynb
+++ b/.ipynb_checkpoints/analyze_models-checkpoint.ipynb
@@ -9,13 +9,14 @@
    "source": [
     "import numpy as np\n",
     "import matplotlib.pyplot as plt\n",
-    "\n",
-    "import eval_tools as eval"
+    "from os import path as osp\n",
+    "import eval_tools as eval\n",
+    "import deepdish as dd"
    ]
   },
   {
    "cell_type": "code",
-   "execution_count": 3,
+   "execution_count": 2,
    "id": "14bf950d-a4f6-43a5-a1f1-51fd50ea0a8d",
    "metadata": {
     "scrolled": true
@@ -25,22 +26,72 @@
      "name": "stdout",
      "output_type": "stream",
      "text": [
-      "Getting metrics from checkpoints/penn_data/feedforward/plotting/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1\n",
-      "Loading 'basic_feedforward' from checkpoints/penn_data/feedforward/plotting/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/basic_feedforward.py\n",
-      "Loading 'penn_dataset' from checkpoints/penn_data/feedforward/plotting/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/penn_dataset.py\n",
-      "Data is 1-fold partitioned.\n",
-      "Evaluating fold 1...\n",
-      "in subset train\n",
-      "in subset test\n",
-      "in subset val\n",
-      "Models evaluated. Computing metrics...\n",
-      "Done.\n"
+      "Getting metrics from checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2\n",
+      "Loading 'basic_feedforward' from checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/basic_feedforward.py\n",
+      "Loading 'penn_dataset' from checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/penn_dataset.py\n"
      ]
     },
+    {
+     "ename": "ValueError",
+     "evalue": "too many values to unpack (expected 2)",
+     "output_type": "error",
+     "traceback": [
+      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
+      "\u001b[0;31mValueError\u001b[0m                                Traceback (most recent call last)",
+      "Cell \u001b[0;32mIn[2], line 5\u001b[0m\n\u001b[1;32m      3\u001b[0m specific_run \u001b[38;5;241m=\u001b[39m \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mbs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_\u001b[39m\u001b[38;5;124m\"\u001b[39m\n\u001b[1;32m      4\u001b[0m runDir \u001b[38;5;241m=\u001b[39m osp\u001b[38;5;241m.\u001b[39mjoin(general_dir,run_name,specific_run)\n\u001b[0;32m----> 5\u001b[0m info \u001b[38;5;241m=\u001b[39m \u001b[38;5;28;43meval\u001b[39;49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mget_metrics\u001b[49m\u001b[43m(\u001b[49m\u001b[43mrunDir\u001b[49m\u001b[43m,\u001b[49m\u001b[43mn_thresholds\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43m \u001b[49m\u001b[38;5;241;43m1000\u001b[39;49m\u001b[43m,\u001b[49m\u001b[43mnonlin_thresholds\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43m \u001b[49m\u001b[38;5;28;43;01mFalse\u001b[39;49;00m\u001b[43m)\u001b[49m\n",
+      "File \u001b[0;32m~/segmentation/eval_tools.py:107\u001b[0m, in \u001b[0;36mget_metrics\u001b[0;34m(run_dir, n_thresholds, checkpoint_num, softmax, nonlin_thresholds, write_file, read_file)\u001b[0m\n\u001b[1;32m    104\u001b[0m model,model_name \u001b[38;5;241m=\u001b[39m fet\u001b[38;5;241m.\u001b[39mload(model_config,config)\n\u001b[1;32m    106\u001b[0m \u001b[38;5;66;03m# load data\u001b[39;00m\n\u001b[0;32m--> 107\u001b[0m kfold_loaders,k_inds \u001b[38;5;241m=\u001b[39m fet\u001b[38;5;241m.\u001b[39mload(data_config, config)\n\u001b[1;32m    108\u001b[0m nfolds \u001b[38;5;241m=\u001b[39m \u001b[38;5;28mlen\u001b[39m(kfold_loaders)\n\u001b[1;32m    109\u001b[0m \u001b[38;5;28mprint\u001b[39m(\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mData is \u001b[39m\u001b[38;5;132;01m{}\u001b[39;00m\u001b[38;5;124m-fold partitioned.\u001b[39m\u001b[38;5;124m\"\u001b[39m\u001b[38;5;241m.\u001b[39mformat(nfolds))\n",
+      "\u001b[0;31mValueError\u001b[0m: too many values to unpack (expected 2)"
+     ]
+    }
+   ],
+   "source": [
+    "general_dir = 'checkpoints/penn_data'\n",
+    "run_name = 'gpt-FCNN/hyperparam_testing'\n",
+    "specific_run = \"bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_\"\n",
+    "runDir = osp.join(general_dir,run_name,specific_run)\n",
+    "info = eval.get_metrics(runDir,n_thresholds = 1000,nonlin_thresholds = False)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 2,
+   "id": "6b6f0bf3-ebdf-4bc1-9faa-c53bc3305815",
+   "metadata": {},
+   "outputs": [
+    {
+     "ename": "FileNotFoundError",
+     "evalue": "``/Users/gorg/segmentation/model_evals/FFNN_basic_metrics.h5`` does not exist",
+     "output_type": "error",
+     "traceback": [
+      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
+      "\u001b[0;31mFileNotFoundError\u001b[0m                         Traceback (most recent call last)",
+      "Cell \u001b[0;32mIn[2], line 4\u001b[0m\n\u001b[1;32m      2\u001b[0m save_dir \u001b[38;5;241m=\u001b[39m \u001b[38;5;124m'\u001b[39m\u001b[38;5;124mmodel_evals\u001b[39m\u001b[38;5;124m'\u001b[39m\n\u001b[1;32m      3\u001b[0m metricDict \u001b[38;5;241m=\u001b[39m \u001b[38;5;124m'\u001b[39m\u001b[38;5;124mFFNN_basic_metrics.h5\u001b[39m\u001b[38;5;124m'\u001b[39m\n\u001b[0;32m----> 4\u001b[0m info \u001b[38;5;241m=\u001b[39m \u001b[43mdd\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mio\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mload\u001b[49m\u001b[43m(\u001b[49m\u001b[43mosp\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mjoin\u001b[49m\u001b[43m(\u001b[49m\u001b[43msave_dir\u001b[49m\u001b[43m,\u001b[49m\u001b[43mmetricDict\u001b[49m\u001b[43m)\u001b[49m\u001b[43m)\u001b[49m\n",
+      "File \u001b[0;32m/Applications/miniconda3/envs/lietransformer/lib/python3.9/site-packages/deepdish/io/hdf5io.py:636\u001b[0m, in \u001b[0;36mload\u001b[0;34m(path, group, sel, unpack)\u001b[0m\n\u001b[1;32m    602\u001b[0m \u001b[38;5;28;01mdef\u001b[39;00m \u001b[38;5;21mload\u001b[39m(path, group\u001b[38;5;241m=\u001b[39m\u001b[38;5;28;01mNone\u001b[39;00m, sel\u001b[38;5;241m=\u001b[39m\u001b[38;5;28;01mNone\u001b[39;00m, unpack\u001b[38;5;241m=\u001b[39m\u001b[38;5;28;01mFalse\u001b[39;00m):\n\u001b[1;32m    603\u001b[0m \u001b[38;5;250m    \u001b[39m\u001b[38;5;124;03m\"\"\"\u001b[39;00m\n\u001b[1;32m    604\u001b[0m \u001b[38;5;124;03m    Loads an HDF5 saved with `save`.\u001b[39;00m\n\u001b[1;32m    605\u001b[0m \n\u001b[0;32m   (...)\u001b[0m\n\u001b[1;32m    634\u001b[0m \n\u001b[1;32m    635\u001b[0m \u001b[38;5;124;03m    \"\"\"\u001b[39;00m\n\u001b[0;32m--> 636\u001b[0m     \u001b[38;5;28;01mwith\u001b[39;00m \u001b[43mtables\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mopen_file\u001b[49m\u001b[43m(\u001b[49m\u001b[43mpath\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mmode\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[38;5;124;43mr\u001b[39;49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[43m)\u001b[49m \u001b[38;5;28;01mas\u001b[39;00m h5file:\n\u001b[1;32m    637\u001b[0m         pathtable \u001b[38;5;241m=\u001b[39m {}  \u001b[38;5;66;03m# dict to keep track of objects already loaded\u001b[39;00m\n\u001b[1;32m    638\u001b[0m         \u001b[38;5;28;01mif\u001b[39;00m group \u001b[38;5;129;01mis\u001b[39;00m \u001b[38;5;129;01mnot\u001b[39;00m \u001b[38;5;28;01mNone\u001b[39;00m:\n",
+      "File \u001b[0;32m/Applications/miniconda3/envs/lietransformer/lib/python3.9/site-packages/tables/file.py:294\u001b[0m, in \u001b[0;36mopen_file\u001b[0;34m(filename, mode, title, root_uep, filters, **kwargs)\u001b[0m\n\u001b[1;32m    289\u001b[0m             \u001b[38;5;28;01mraise\u001b[39;00m \u001b[38;5;167;01mValueError\u001b[39;00m(\n\u001b[1;32m    290\u001b[0m                 \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mThe file \u001b[39m\u001b[38;5;124m'\u001b[39m\u001b[38;5;132;01m%s\u001b[39;00m\u001b[38;5;124m'\u001b[39m\u001b[38;5;124m is already opened.  Please \u001b[39m\u001b[38;5;124m\"\u001b[39m\n\u001b[1;32m    291\u001b[0m                 \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mclose it before reopening in write mode.\u001b[39m\u001b[38;5;124m\"\u001b[39m \u001b[38;5;241m%\u001b[39m filename)\n\u001b[1;32m    293\u001b[0m \u001b[38;5;66;03m# Finally, create the File instance, and return it\u001b[39;00m\n\u001b[0;32m--> 294\u001b[0m \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[43mFile\u001b[49m\u001b[43m(\u001b[49m\u001b[43mfilename\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mmode\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mtitle\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mroot_uep\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mfilters\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;241;43m*\u001b[39;49m\u001b[38;5;241;43m*\u001b[39;49m\u001b[43mkwargs\u001b[49m\u001b[43m)\u001b[49m\n",
+      "File \u001b[0;32m/Applications/miniconda3/envs/lietransformer/lib/python3.9/site-packages/tables/file.py:744\u001b[0m, in \u001b[0;36mFile.__init__\u001b[0;34m(self, filename, mode, title, root_uep, filters, **kwargs)\u001b[0m\n\u001b[1;32m    741\u001b[0m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39mparams \u001b[38;5;241m=\u001b[39m params\n\u001b[1;32m    743\u001b[0m \u001b[38;5;66;03m# Now, it is time to initialize the File extension\u001b[39;00m\n\u001b[0;32m--> 744\u001b[0m \u001b[38;5;28;43mself\u001b[39;49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43m_g_new\u001b[49m\u001b[43m(\u001b[49m\u001b[43mfilename\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mmode\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;241;43m*\u001b[39;49m\u001b[38;5;241;43m*\u001b[39;49m\u001b[43mparams\u001b[49m\u001b[43m)\u001b[49m\n\u001b[1;32m    746\u001b[0m \u001b[38;5;66;03m# Check filters and set PyTables format version for new files.\u001b[39;00m\n\u001b[1;32m    747\u001b[0m new \u001b[38;5;241m=\u001b[39m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_v_new\n",
+      "File \u001b[0;32m/Applications/miniconda3/envs/lietransformer/lib/python3.9/site-packages/tables/hdf5extension.pyx:394\u001b[0m, in \u001b[0;36mtables.hdf5extension.File._g_new\u001b[0;34m()\u001b[0m\n",
+      "File \u001b[0;32m/Applications/miniconda3/envs/lietransformer/lib/python3.9/site-packages/tables/utils.py:146\u001b[0m, in \u001b[0;36mcheck_file_access\u001b[0;34m(filename, mode)\u001b[0m\n\u001b[1;32m    143\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m mode \u001b[38;5;241m==\u001b[39m \u001b[38;5;124m'\u001b[39m\u001b[38;5;124mr\u001b[39m\u001b[38;5;124m'\u001b[39m:\n\u001b[1;32m    144\u001b[0m     \u001b[38;5;66;03m# The file should be readable.\u001b[39;00m\n\u001b[1;32m    145\u001b[0m     \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;129;01mnot\u001b[39;00m os\u001b[38;5;241m.\u001b[39maccess(path, os\u001b[38;5;241m.\u001b[39mF_OK):\n\u001b[0;32m--> 146\u001b[0m         \u001b[38;5;28;01mraise\u001b[39;00m \u001b[38;5;167;01mFileNotFoundError\u001b[39;00m(\u001b[38;5;124mf\u001b[39m\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124m``\u001b[39m\u001b[38;5;132;01m{\u001b[39;00mpath\u001b[38;5;132;01m}\u001b[39;00m\u001b[38;5;124m`` does not exist\u001b[39m\u001b[38;5;124m\"\u001b[39m)\n\u001b[1;32m    147\u001b[0m     \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;129;01mnot\u001b[39;00m path\u001b[38;5;241m.\u001b[39mis_file():\n\u001b[1;32m    148\u001b[0m         \u001b[38;5;28;01mraise\u001b[39;00m \u001b[38;5;167;01mIsADirectoryError\u001b[39;00m(\u001b[38;5;124mf\u001b[39m\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124m``\u001b[39m\u001b[38;5;132;01m{\u001b[39;00mpath\u001b[38;5;132;01m}\u001b[39;00m\u001b[38;5;124m`` is not a regular file\u001b[39m\u001b[38;5;124m\"\u001b[39m)\n",
+      "\u001b[0;31mFileNotFoundError\u001b[0m: ``/Users/gorg/segmentation/model_evals/FFNN_basic_metrics.h5`` does not exist"
+     ]
+    }
+   ],
+   "source": [
+    "# LOAD MODEL FROM FILE\n",
+    "save_dir = 'model_evals'\n",
+    "metricDict = 'FFNN_basic_metrics.h5'\n",
+    "info = dd.io.load(osp.join(save_dir,metricDict))"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 3,
+   "id": "8fa7d522-a68a-401a-a426-0c7f9f3f1b1a",
+   "metadata": {},
+   "outputs": [
     {
      "data": {
       "text/plain": [
-       "AttrDict({'batch_size': 100, 'beta1': 0.9, 'beta2': 0.999, 'cross_validate': False, 'data_config': 'penn_dataset.py', 'git_commit': '7416bf730b356aabfe0df644240e40948a8196bb', 'include_coords': False, 'input_size': 39, 'learning_rate': 0.001, 'log_train_values': True, 'log_val_test': True, 'model_config': 'basic_feedforward.py', 'n_repeats': 1, 'report_loss_every': 50, 'rescale': True, 'results_dir': 'checkpoints', 'resume': False, 'run_name': 'plotting', 'save_check_points': 50, 'save_test_predictions': False, 'split_seed': 1, 'total_evaluations': 100, 'train_epochs': 100, 'train_split': 0.8, 'use_mps': False})"
+       "8482"
       ]
      },
      "execution_count": 3,
@@ -49,40 +100,86 @@
     }
    ],
    "source": [
-    "runDir = 'checkpoints/penn_data/feedforward/plotting/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs100_'\n",
-    "info = eval.get_metrics(runDir,n_thresholds = 10000)"
+    "info['params']"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "id": "ff0548de-9fd3-4b6b-b015-d43325c2c3f6",
+   "metadata": {},
+   "source": [
+    "#### Plot training loss"
    ]
   },
   {
    "cell_type": "code",
-   "execution_count": 9,
+   "execution_count": 4,
    "id": "2bd1188b-3032-4e11-bfe1-ff121b7fa28e",
    "metadata": {},
    "outputs": [
     {
      "data": {
+      "image/png": "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q1ar2bNnD/3798fZ2Vmbz8fHh549ez6w/LLs2LEDhULBhAkTdNI//PBDJEli586dANoWjq1bt6LRaMosy9LSkps3b5bq8nuQgQMHoqenx/r167VpFy9e5PLlywwZMkSn/EuXLhEWFlah8h/V33//jUajYfDgwSQnJ2tvjo6O1KxZk/379+vkf1yfrbvFxcUREhLC8OHDsba21qY3atSIF154gR07dpQ65r333tN53L59e1JSUsjMzKzw+QXhYYkASBCqkIuLCwYGBqXSL126xIABA7CwsMDc3Bw7OzvtAOqMjIwHluvu7q7z+HYwlJaWVuFjbx9/+9jExETy8vLw8fEpla+stPK4ceMGzs7OmJmZ6aTXrVtX+zwUB3Zt27blnXfewcHBgVdffZUNGzboBEMfffQRpqamtGzZkpo1azJu3DidLrJ7sbW1pWvXrmzYsEGbtn79evT09Bg4cKA2bfbs2aSnp1OrVi0aNmzIlClTOH/+/ENdd0WEhYUhSRI1a9bEzs5O5xYaGkpiYqJO/sf12brb7femdu3apZ6rW7cuycnJ5OTk6KQ/yudTECqLGAMkCFXozv/Gb0tPT6djx46Ym5sze/ZsvL29USqVnDlzho8++uieLR93utf0ZKkcq148yrGPm5GREYcOHWL//v1s376dgIAA1q9fT5cuXdi1axcKhYK6dety9epVtm3bRkBAAJs2bWLp0qVMnz69zEHOd3r11VcZMWIEISEhNGnShA0bNtC1a1ftWByADh06EBERwdatW9m1axc//fQT33//PcuXL+edd955bNeu0WiQyWTs3LmzzPfo7jE6j+uzVRmq82dMeH6IAEgQqpkDBw6QkpLC33//TYcOHbTpkZGRVVirEvb29iiVSsLDw0s9V1ZaeXh4eLBnzx6ysrJ0WoFud8l4eHho0+RyOV27dqVr16589913fPXVV3z66afs37+fbt26AWBiYsKQIUMYMmQIhYWFDBw4kC+//JJp06bddwp3//79effdd7XdYNeuXWPatGml8llbWzNixAhGjBhBdnY2HTp0YObMmZUSAN1rFp23tzeSJOHl5UWtWrUequyKfLbKO5vv9ntz9erVUs9duXIFW1tbTExMHqq+gvA4iS4wQahmbv93fOd/w4WFhSxdurSqqqRDoVDQrVs3tmzZQmxsrDY9PDxcO1anol566SXU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",
       "text/plain": [
-       "dict_keys(['thresholds', 'config', 'params', 'test_time', 'test_loss', 'train_acc', 'train_prec', 'train_tpr', 'train_fpr', 'train_F1', 'test_acc', 'test_prec', 'test_tpr', 'test_fpr', 'test_F1', 'val_acc', 'val_prec', 'val_tpr', 'val_fpr', 'val_F1'])"
+       "<Figure size 640x480 with 1 Axes>"
       ]
      },
-     "execution_count": 9,
      "metadata": {},
-     "output_type": "execute_result"
+     "output_type": "display_data"
     }
    ],
    "source": [
-    "info.keys()"
+    "eval.plot_train_loss(info)"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "id": "2b7375f8-5b21-45f4-a5c1-45ba2218330a",
+   "metadata": {},
+   "source": [
+    "#### Plot test loss vs. train time"
    ]
   },
   {
    "cell_type": "code",
-   "execution_count": 4,
+   "execution_count": 5,
    "id": "ac815258-7141-4e1c-8ea8-b6598aa6dd27",
+   "metadata": {
+    "scrolled": true
+   },
+   "outputs": [
+    {
+     "data": {
+      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAjcAAAHHCAYAAABDUnkqAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjguMywgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy/H5lhTAAAACXBIWXMAAA9hAAAPYQGoP6dpAAEAAElEQVR4nOx9eXwU5f3/e2Z29sxNSAC5kXCIIqCAoPWiIioVRLFKUZTDWoGKfuEr/aKo/VXQohVLtUqVYFsUrdZajwAqeHDGAypyyJlwhARyZ685f3/MPLMze2U32SSEPu/XK68ku7PPPDs7O8973p/35/NhVFVVQUFBQUFBQUFxjoBt6wlQUFBQUFBQUKQSlNxQUFBQUFBQnFOg5IaCgoKCgoLinAIlNxQUFBQUFBTnFCi5oaCgoKCgoDinQMkNBQUFBQUFxTkFSm4oKCgoKCgozilQckNBQUFBQUFxToGSGwoKCgoKCopzCpTcUFBQYNOmTWAYBps2bWrrqZwzKCwsBMMwOHr0aIvv6/HHHwfDMC2+HwqK9gJKbigoWgkMwyT0kwqC4fP58Pjjj1Oy0gieeuopvPfee209jYRAP1MKisRha+sJUFD8t+Cvf/2r5f/XX38dGzZsiHh8wIABzd6Xz+fDE088AQC46qqrmj3euYqnnnoKt956KyZMmJDysadOnYqf//zncDgcKRkv3me6aNEiPPLIIynZDwXFuQBKbigoWgm/+MUvLP9v27YNGzZsiHic4uyE1+uFx+NJeHuO48BxXAvOKASbzQabjV7OKSgIaFiKguIsgqIoeP7553HBBRfA6XQiPz8f9913H6qrqy3bff311xg7dixyc3PhcrnQq1cv3HvvvQCAo0ePomPHjgCAJ554wgh3Pf7440nP5+2338awYcPgcrmQm5uLX/ziFzhx4oRlm1OnTuGee+5B165d4XA40LlzZ9x8880Wr0m8+cbCTTfdhN69e0d97rLLLsMll1xi/L9hwwZcfvnlyMrKQlpaGvr164ff/OY3ccdnGAZerxerV682jtG0adMAhDwse/bswZ133ons7GxcfvnlAID//Oc/mDZtGnr37g2n04lOnTrh3nvvRWVlpWX8aJ6bnj174qabbsJXX32F4cOHw+l0onfv3nj99dfjzrWxzzSa54ZhGMyePRtvv/02Bg4cCJfLhcsuuwzff/89AODll1/G+eefD6fTiauuuiqqN2j79u24/vrrkZmZCbfbjSuvvBKbN2+OO1cKirMBlOpTUJxFuO+++1BYWIh77rkHc+fOxZEjR7BixQp899132Lx5M3ieR0VFBa677jp07NgRjzzyCLKysnD06FG8++67AICOHTvipZdewv3334+JEyfilltuAQBcdNFFSc2FzOPSSy/FkiVLUF5ejuXLl2Pz5s347rvvkJWVBQCYNGkSfvjhB8yZMwc9e/ZERUUFNmzYgNLSUuP/ePONhdtvvx133XUXiouLcemllxqPl5SUYNu2bfj9738PAPjhhx9w00034aKLLsKTTz4Jh8OBgwcPNroI//Wvf8WMGTMwfPhwzJo1CwDQp08fyza33XYb+vbti6eeegqqqgLQiNThw4dxzz33oFOnTvjhhx/wyiuv4IcffsC2bdsaNfYePHgQt956K6ZPn467774br732GqZNm4Zhw4bhggsuiPqapn6mX375Jd5//3088MADAIAlS5bgpptuwoIFC/Diiy/iV7/6Faqrq/HMM8/g3nvvxWeffWa89rPPPsO4ceMwbNgwLF68GCzLYtWqVbjmmmvw5ZdfYvjw4XH3TUHRplApKCjaBA888IBq/gp++eWXKgD173//u2W7oqIiy+P//Oc/VQBqcXFxzLFPnz6tAlAXL16c0Fw2btyoAlA3btyoqqqqCoKg5uXlqYMGDVL9fr+x3QcffKACUB977DFVVVW1urpaBaD+/ve/jzl2IvONhtraWtXhcKgPP/yw5fFnnnlGZRhGLSkpUVVVVf/whz+oANTTp08nNb6qqqrH41HvvvvuiMcXL16sAlDvuOOOiOd8Pl/EY2+88YYKQP3iiy+Mx1atWqUCUI8cOWI81qNHj4jtKioqor7PcMT7TMl8zQCgOhwOy/5ffvllFYDaqVMnta6uznh84cKFlrkqiqL27dtXHTt2rKooiuW99+rVS/3pT38ad64UFG0NGpaioDhL8PbbbyMzMxM//elPcebMGeNn2LBhSEtLw8aNGwHAUEw++OADiKLYInP5+uuvUVFRgV/96ldwOp3G4zfeeCP69++PDz/8EADgcrlgt9uxadOmiNAZQVPnm5GRgXHjxuGtt94yVBMAWLt2LUaOHInu3btbxv/Xv/4FRVGSeZuN4pe//GXEYy6Xy/g7EAjgzJkzGDlyJADg22+/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PPfcc1i0aBEURcGtt94qLRXkhW9/+9vYsGEDxo4di3HjxuHhhx/GyZMnC/bJGTVqFFpaWrBt2zacddZZiEaj0tJFt912Gy644AKMHDkSl156KVRVxXvvvYe///3vuOuuu6S8BkEQJlQtRRBEQdasWQNN03DGGWdg0KBBBf0z999/P/r164fZs2dj0aJFWLBgAaZMmVLB3erceOON+MY3voHly5dj1qxZiMfjWLBgQcEU0OzZs3HttddiyZIlGDRoEO677z5p+1mwYAFeeuklvP7665g+fTrOPvtsPPDAAzjllFOkvQZBECbUoZggiJonk8lg/PjxWLx4Me68886e3g5BED5DaSmCIGqOjz76CK+//jrmzZuHzs5O/PjHP8ahQ4ewdOnSnt4aQRAVgNJSBEHUHKqqYvPmzZg+fTrmzJmDvXv34s0338T48eN7emsEQVQASksRBEEQBFFTUOSGIAiCIIiagsQNQRAEQRA1BYkbgiAIgiBqChI3BEEQBEHUFCRuCIIgCIKoKUjcEARBEARRU5C4IQiCIAiipiBxQxAEQRBETUHihiAIgiCImuL/A+SggsnRsKmgAAAAAElFTkSuQmCC",
+      "text/plain": [
+       "<Figure size 640x480 with 1 Axes>"
+      ]
+     },
+     "metadata": {},
+     "output_type": "display_data"
+    }
+   ],
+   "source": [
+    "eval.plot_test_loss(info)"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "id": "c5e82793-656c-492a-9a1b-b422b8c1af0f",
+   "metadata": {},
+   "source": [
+    "#### Plot train vs. test loss"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 6,
+   "id": "cdfb8940-95f8-4926-af92-054760b8a7f0",
    "metadata": {},
    "outputs": [
     {
      "data": {
-      "image/png": "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",
+      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAkAAAAHHCAYAAABXx+fLAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjguMywgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy/H5lhTAAAACXBIWXMAAA9hAAAPYQGoP6dpAADi8klEQVR4nOydd3gU5fbHv7M9vTcgEHrvKNLEQrUBcgURLyoKiqAiVq6KeO0N9dq4Iihe5YIiV/0pooAgRYp0kBBKQk/vdev8/pidmXdmZ3dndjckJO/nefKwOzv77ptkyXz3nO85h2FZlgWFQqFQKBRKM0LX0BugUCgUCoVCudRQAUShUCgUCqXZQQUQhUKhUCiUZgcVQBQKhUKhUJodVABRKBQKhUJpdlABRKFQKBQKpdlBBRCFQqFQKJRmBxVAFAqFQqFQmh1UAFEoFAqFQml2UAFEoVAoAZKRkYG77747ZOstXLgQDMOEbD0KheIdKoAolCYOwzCqvjZv3hz0a9XU1GDhwoUhWSsU/PHHH1i4cCHKysoaeisUCqWRYWjoDVAolPrlP//5j+T+F198gfXr13sc79q1a9CvVVNTgxdeeAEAcM011wS9XrD88ccfeOGFF3D33XcjNjY25OtnZWVBp6OfIymUyxEqgCiUJs6dd94pub9z506sX7/e43hzx+VywWazwWKxqH6O2Wyuxx1RKJT6hH50oVAocLlcePfdd9G9e3dYLBakpKTg/vvvR2lpqeS8PXv2YPTo0UhMTERYWBjatm2L6dOnAwBOnz6NpKQkAMALL7wgpNYWLlyo+Jp79uwBwzBYvny5x2O//PILGIbBjz/+CACorKzE3LlzkZGRAbPZjOTkZIwcORL79u3z+j0tXLgQTzzxBACgbdu2wn5Onz4NgEsNzpkzB1999RW6d+8Os9mMdevWAQDeeustDB48GAkJCQgLC0P//v2xevVqj9eQe4A+//xzMAyD7du3Y968eUhKSkJERAQmTJiAwsJCr3v1hcPhwIsvvoj27dvDbDYjIyMD//jHP2C1WiXn+frd8KxcuRL9+/dHVFQUoqOj0bNnT7z33nsB7YtCudyhESAKhYL7778fn3/+Oe655x48/PDDyMnJwQcffID9+/dj+/btMBqNKCgowKhRo5CUlISnn34asbGxOH36NNasWQMASEpKwscff4xZs2ZhwoQJuPXWWwEAvXr1UnzNAQMGoF27dvj6669x1113SR5btWoV4uLiMHr0aADAAw88gNWrV2POnDno1q0biouLsW3bNmRmZqJfv36K69966604fvw4/vvf/+Kdd95BYmKisE+e3377DV9//TXmzJmDxMREZGRkAADee+893HLLLZg6dSpsNhtWrlyJ2267DT/++CNuvPFGvz/Phx56CHFxcXj++edx+vRpvPvuu5gzZw5WrVrl97ly7rvvPixfvhx/+9vf8Nhjj2HXrl149dVXkZmZif/9738A4Pd3AwDr16/HlClTcP311+P1118HAGRmZmL79u145JFHNO+LQrnsYSkUSrNi9uzZLPlff+vWrSwA9quvvpKct27dOsnx//3vfywA9s8///S6dmFhIQuAff7551XtZf78+azRaGRLSkqEY1arlY2NjWWnT58uHIuJiWFnz56tak2SN998kwXA5uTkeDwGgNXpdOxff/3l8VhNTY3kvs1mY3v06MFed911kuNt2rRh77rrLuH+Z599xgJgR4wYwbpcLuH4o48+yur1erasrMznfp9//nnJ7+bAgQMsAPa+++6TnPf444+zANjffvuNZVl1v5tHHnmEjY6OZh0Oh889UCjNBZoCo1CaOd988w1iYmIwcuRIFBUVCV/9+/dHZGQkNm3aBACCifjHH3+E3W4PyWtPnjwZdrtdEqn49ddfUVZWhsmTJwvHYmNjsWvXLly8eDEkr8szfPhwdOvWzeN4WFiYcLu0tBTl5eUYNmyYz5QbycyZMyXl7MOGDYPT6cSZM2c07W/t2rUAgHnz5kmOP/bYYwCAn376CYC6301sbCyqq6uxfv16TXugUJoqVABRKM2cEydOoLy8HMnJyUhKSpJ8VVVVoaCgAAAnFiZOnIgXXngBiYmJGDduHD777DMPL4oWevfujS5dukhSQ6tWrUJiYiKuu+464dgbb7yBI0eOID09HVdeeSUWLlyI7OzswL9pN23btlU8/uOPP+Kqq66CxWJBfHy8kN4rLy9XtW7r1q0l9+Pi4gDAw1PljzNnzkCn06FDhw6S46mpqYiNjRUElZrfzYMPPohOnTph7NixaNWqFaZPny54niiU5ggVQBRKM8flciE5ORnr169X/PrnP/8JgDMNr169Gjt27MCcOXNw4cIFTJ8+Hf3790dVVVXArz958mRs2rQJRUVFsFqt+OGHHzBx4kQYDKJFcdKkScjOzsb777+PFi1a4M0330T37t3x888/B/W9k5Eenq1bt+KWW26BxWLBRx99hLVr12L9+vW44447wLKsqnX1er3icbXPl+OvOaKa301ycjIOHDiAH374Abfccgs2bdqEsWPHevivKJTmAhVAFEozp3379iguLsaQIUMwYsQIj6/evXtLzr/qqqvw8ssvY8+ePfjqq6/w119/YeXKlQD8X6iVmDx5MhwOB7799lv8/PPPqKiowO233+5xXlpaGh588EF89913yMnJQUJCAl5++WWfaweyn2+//RYWiwW//PILpk+fjrFjx2LEiBGa1wkFbdq0gcvlwokTJyTH8/PzUVZWhjZt2kiO+/rdAIDJZMLNN9+Mjz76CKdOncL999+PL774AidPnrwk3w+F0pigAohCaeZMmjQJTqcTL774osdjDodD6KJcWlrqEcHo06cPAAiplvDwcADQ1Hm5a9eu6NmzJ1atWoVVq1YhLS0NV199tfC40+n0SD0lJyejRYsWftNvERERmvej1+vBMAycTqdw7PTp0/juu+9UrxEqbrjhBgDAu+++Kzm+aNEiABAq0tT8boqLiyWP63Q6oUIvmDQmhXK5QsvgKZRmzvDhw3H//ffj1VdfxYEDBzBq1CgYjUacOHEC33zzDd577z387W9/w/Lly/HRRx9hwoQJaN++PSorK7FkyRJER0cLF+qwsDB069YNq1atQqdOnRAfH48ePXqgR48ePvcwefJkLFiwABaLBffee6+ku3JlZSVatWqFv/3tb+jduzciIyOxYcMG/Pnnn3j77bd9rtu/f38AwDPPPIPbb78dRqMRN998syCMlLjxxhuxaNEijBkzBnfccQcKCgrw4YcfokOHDjh06JDaH2tI6N27N+666y588sknKCsrw/Dhw7F7924sX74c48ePx7XXXgsAqn439913H0pKSnDdddehVatWOHPmDN5//3306dMnJF3AKZTLjoYtQqNQKJcaeRk8zyeffML279+fDQsLY6OiotiePXuyTz75JHvx4kWWZVl237597JQpU9jWrVuzZrOZTU5OZm+66SZ2z549knX++OMPtn///qzJZFJdEn/ixAkWAAuA3bZtm+Qxq9XKPvHEE2zv3r3ZqKgoNiIigu3duzf70Ucfqfp+X3zxRbZly5asTqeTlMQD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",
       "text/plain": [
        "<Figure size 640x480 with 1 Axes>"
       ]
@@ -92,29 +189,26 @@
     }
    ],
    "source": [
-    "# # PLOT TEST LOSS VS TIME\n",
-    "# def plot_loss(run_info,**kwargs):\n",
-    "#     times = run_info['test_time']\n",
-    "#     losses = run_info['test_loss']\n",
-    "#     for k in range(len(times)):\n",
-    "#         plt.plot(times[k],losses[k],label = 'fold {} loss'.format(k+1))\n",
-    "#     plt.xlabel(\"training time\")\n",
-    "#     plt.ylabel(\"test loss\")\n",
-    "#     plt.legend()\n",
-    "#     plt.show()\n",
-    "\n",
-    "eval.plot_loss(info)"
+    "eval.plot_train_test_loss(info)"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "id": "5e5db2e0-29bc-4837-b78c-c6a255b89e0b",
+   "metadata": {},
+   "source": [
+    "#### Plot accuracy vs. positive threshold"
    ]
   },
   {
    "cell_type": "code",
-   "execution_count": 5,
+   "execution_count": 7,
    "id": "edb8dbe5-1fe6-4dc3-9aa2-39f44d7939ab",
    "metadata": {},
    "outputs": [
     {
      "data": {
-      "image/png": "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l5WVVaruDh06XHP7SqUSDz30EL777jt5HsiKFSug1+tx3333XXNdtVqNe+65B99//708x2PNmjWwWq0u4aYif0Pu1KRJE5fnAQEBAKTgVdLV+/bSpUvIysrCokWLSv2tOecWOf/WKvOZ/qme06dPQ6lUokWLFi7LhYeHw9/fH6dPny73s54+fRotWrQoFaBbt25d7jpUvzHcUJ3l6+uLyMhI7N+/v8rbmDVrFhISEnDzzTfj888/x4YNG7Bp0ya0b9/e5ZTttm3b4vDhw/jqq6/Qt29frF69Gn379nXpYgwbNgwnTpzA/PnzERkZiXfeeQft27fHjz/+eF2fE4Bcy6RJk7Bp06YyH1d/KZTsbFzL559/jtGjRyMmJgZLlizB+vXrsWnTJtx6662lTluvbna7vczxsj7LU089hTfffBPDhg3D119/jY0bN2LTpk0ICgqqUt0jR45Ebm4uvvvuOwgh8MUXX+DOO++En5/fP657//33IycnR/63/vrrr9GmTRvExsbKy1Tkb8idyuvaCSFcnl+9b5377uGHHy73b61Pnz4AKveZKlrP9XT4iJw4oZjqtDvvvBOLFi1CcnIyevXqVen1V61ahf79+2PJkiUu41lZWQgODnYZ8/LywvDhwzF8+HBYLBbcfffdePPNNzF58mT51NmIiAiMHz8e48ePx8WLF9G1a1e8+eabGDBgQNU/JIDmzZsDkCawxsXFXde2rrZq1So0b94ca9ascfliufoLKiYmBhs2bEBmZma53ZuYmBg4HA4cPHjQZSLy1QICApCVleUyZrFYcOHChUrVPWrUKLz33nvyWGFhYantxsTEVCgAd+jQAV26dMGKFSvQuHFjpKamYv78+RWq5eabb0ZERARWrlyJvn37YvPmzZgyZUqp5SryN1RR1RUCQkJC4OPjA7vdXqG/NXd9pqZNm8LhcODo0aNo27atPJ6eno6srCw0bdr0muvu378fQgiX/XL48OEKvz/VL+zcUJ324osvwsvLC2PHjkV6enqp148fP4558+aVu75KpSr1X47ffPNNqfkrly9fdnmu1WrRrl07CCFgtVpht9tdDoUAQGhoKCIjI91yOmpoaChuueUWfPTRR2UGgLLOrqoo539Rl9wPO3bsQHJyssty99xzD4QQmDFjRqltONcdMmQIlEolZs6cWap7UnL7MTEx+PXXX11e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dNNNOHDggDtqrBNEycNSvIgfERGRx1Q53FitVqxatQoDBw5E06ZNsWHDBnzwwQdIT0/HsWPH0LRpU9x3333urLVWcziKD0splDwJjYiIyFOqNDnkqaeewpdffgkhBEaMGIHZs2ejQ4cO8uteXl549913ERkZ6bZCa7uSE4oZboiIiDynSuHm4MGDmD9/Pu6+++5yb0oZHBzcoE4ZFzxbioiIqFao0rdwyRtdlrthtRr9+vWryubrJNdTwdm5ISIi8pQqfQsnJiZi6dKlpcaXLl2Kt99++7qLqoscdmnOjUIIKHmFYiIiIo+pUrj56KOP0KZNm1Lj7du3x8KFC6+7qLqJc26IiIhqgyp9C6elpSEiIqLUeEhICC5cuHDdRdVFDkfxvaV4WIqIiMhzqvQtHBUVhW3btpUa37ZtW4M6Q6qkkjdXVyoUHqyEiIioYavShOJx48bh2WefhdVqxa233gpAmmT84osv4vnnn3drgXWF3SXceLAQIiKiBq5K4eaFF17A5cuXMX78ePl+Unq9Hi+99BImT57s1gLrCkdRuFEAULBzQ0RE5DFVCjcKhQJvv/02XnvtNaSkpMBgMKBly5blXvOmYRD/vAgRERFVu+u62py3tzduuOEGd9VCREREdN2qHG52796Nr7/+GqmpqfKhKac1a9Zcd2FEREREVVGls6W++uor9O7dGykpKfj2229htVpx4MABbN68GX5+fu6usW7gUSkiIqJaoUrhZtasWXj//ffx3//+F1qtFvPmzcOhQ4cwbNgwNGnSxN011gnObMOpxERERJ5VpXBz/PhxDBo0CACg1WqRl5cHhUKB5557DosWLXJrgXUHWzdERES1QZXCTUBAAHJycgAAjRo1wv79+wEAWVlZyM/Pd191RERERJVUpQnFN998MzZt2oSOHTvivvvuwzPPPIPNmzdj06ZNuO2229xdIxEREVGFVSncfPDBBygsLAQATJkyBRqNBtu3b8c999yDV1991a0F1hUlb79AREREnlPpcGOz2fC///0P8fHxAKSbRL788stuL6yu4oRiIiIiz6r0nBu1Wo0nnnhC7txQEXZuiIiIaoUqTSju0aMH9u3b5+ZSiIiIiK5flebcjB8/HgkJCThz5gy6desGLy8vl9c7derkluKIiIiIKqtK4eb+++8HADz99NPymEKhgBACCoUCdrvdPdXV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UCgUmD59OoDSh05SU1Nx1113wdvbG76+vhg2bBjS09Pl1511LV++HNHR0fDz88P999+PnJycMvfjtd4bkO4i/cgjj8DHxwdNmjTBokWL5NechwpXrlyJfv36Qa/XY8WKFQCAjz/+GG3btoVer0ebNm3w4YcfyutZLBZMnDgRERER0Ov1aNq0KRITE13qysjIwNChQ2E0GtGyZUv88MMPLq//8ssv6NGjh7yvX375ZdhstjI/IwBcvHgRgwcPhsFgQLNmzeQ6ieqVar97FRFV2osvvigCAgLEsmXLxLFjx8Rvv/0mFi9eLIQQ4uTJkwKA+OOPP4QQQlgsFjF16lSxa9cuceLECfH5558Lo9EoVq5cKYSQbhDo5+cnJk2aJI4dOyYOHjwoli1bJt/Ft3379uLhhx8WKSkp4siRI+Lrr78W+/btE0II8cknnwg/Pz8hhBD5+fnip59+EgDEzp07xYULF4TNZhPTpk0TsbGxcu0ffvih0Ov1Yu7cueLw4cNi586d4v3335dff//998XmzZvFyZMnRVJSkmjdurV48sknhRBCmM1mMXfuXOHr61vq7u5NmzaVt2O320Xnzp1F3759xe7du8Xvv/8uunXr5nLDvmnTpglvb29x9913i7///lv8+uuvIjw8XLzyyitl7vN/eu/AwECxYMECcfToUZGYmCiUSqU4dOiQy79JdHS0WL16tThx4oQ4f/68+Pzzz0VERIQ8tnr1ahEYGCiWLVsmhBDinXfeEVFRUeLXX38Vp06dEr/99pv44osv5JoAiMaNG4svvvhCHD16VDz99NPC29tbXL58WQghxNmzZ4XRaBTjx48XKSkp4ttvvxXBwcEuN43t16+feOaZZ+TnAwYMELGxsSI5OVns3r1b9O7dWxgMBpd/I6K6juGGqJYxmUxCp9PJYeZqV4ebskyYMEHcc889QgghLl++LACILVu2lLmsj4+P/GV7tZLhRggh/vjjDwFAnDx5Uh67OtxERkaKKVOmlFvb1b755hsRFBRU7ns6lQw3GzduFCqVSqSmpsqvHzhwQA5ezrqMRqMwmUzyMi+88ILo2bNnubVc670ffvhh+bnD4RChoaHiP//5jxCi+N9k7ty5LuvFxMS4hBUhhHj99ddFr169hBBCPPXUU+LWW28VDoejzHoAiFdffVV+npubKwCIH3/8UQghxCuvvCJa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",
+      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAjcAAAHHCAYAAABDUnkqAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjguMywgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy/H5lhTAAAACXBIWXMAAA9hAAAPYQGoP6dpAAB4G0lEQVR4nO3dd3xV9f3H8de9N8m9udl7QEjYeygoBVQctNRB3eKoA1ctUAfVqnXgqGCtWqy1P+vEWgfWVVuoiiAOQFAQZc9AWEnIInvd+/39cZMLIQFCSO7NTd5PH/dx7z33jM89xPDmO86xGGMMIiIiIh2E1d8FiIiIiLQmhRsRERHpUBRuREREpENRuBEREZEOReFGREREOhSFGxEREelQFG5ERESkQ1G4ERERkQ5F4UZEREQ6FIUb6VQyMjK47rrr/Hb86667joyMjAbLSktLufHGG0lOTsZisXD77bezfft2LBYLs2fP9kudErgeeughLBYLeXl5/i4FaJt6Tj/9dE4//fSjrrdo0SIsFguLFi1qtWNLYFC4kQ5h69at/OpXv6JHjx44HA4iIyMZM2YMzzzzDBUVFf4u74hmzJjB7Nmz+fWvf83rr7/O1Vdf7e+SJADMmDGDDz/80N9liLRLQf4uQOR4zZ07l0svvRS73c4111zDoEGDqK6u5uuvv+auu+5i7dq1vPDCC/4uE4AXX3wRt9vdYNnChQv5yU9+wvTp073LjDFUVFQQHBzs6xIlQMyYMYNLLrmECy64wN+liLQ7CjcS0DIzM7n88stJT09n4cKFpKSkeD+bMmUKW7ZsYe7cuX6ssKGmwkpubi4DBgxosMxiseBwOFrtuGVlZYSFhbXa/vypI32X9sbtdlNdXd2qP3si/qBuKQloTzzxBKWlpbz88ssNgk29Xr16cdtttx12+4KCAu68804GDx5MeHg4kZGRnH322fzwww+N1n322WcZOHAgTqeTmJgYRowYwZtvvun9vKSkhNtvv52MjAzsdjuJiYn89Kc/ZeXKld51Dh5zUz8eIDMzk7lz52KxWLBYLGzfvv2wY242bNjAJZdcQmxsLA6HgxEjRvDRRx81WGf27NlYLBa++OILJk+eTGJiIl27dj3sOaiurubBBx9k+PDhREVFERYWxqmnnsrnn3/eaF23280zzzzD4MGDcTgcJCQk8POf/5zvvvuuwXr//Oc/Ofnkk73n6rTTTuPTTz/1fm6xWHjooYca7f/QMVFH+i47duxg8uTJ9O3bl9DQUOLi4rj00kvZvn17o/0WFRVxxx13eP9sunbtyjXXXENeXh6lpaWEhYU1+XOya9cubDYbM2fObPLc1dTUEBsby6RJkxp9VlxcjMPh4M477/QuO9rPUHNZLBbKysp47bXXvD83h44lKyoq4rrrriM6OpqoqCgmTZpEeXl5o/1MnTqVN954g4EDB2K32/n4448B2L17N9dffz1JSUnY7XYGDhzIK6+80qiW5n6n5tRTW1vLo48+Ss+ePbHb7WRkZPD73/+eqqqqo56TXbt2ccEFFxAWFkZiYiJ33HFHs7aTjkktNxLQ/vOf/9CjRw9Gjx7dou23bdvGhx9+yKWXXkr37t3Jycnh73//O2PHjmXdunWkpqYCnu6kW2+9lUsuuYTbbruNyspKfvzxR5YtW8aVV14JwC233MK7777L1KlTGTBgAPn5+Xz99desX7+eE088sdGx+/fvz+uvv84dd9xB165d+e1vfwtAQkIC+/bta7T+2rVrGTNmDF26dOGee+4hLCyMd955hwsuuID33nuPCy+8sMH6kydPJiEhgQcffJCysrLDnoPi4mJeeuklrrjiCm666SZKSkp4+eWXGT9+PMuXL2fYsGHedW+44QZmz57N2WefzY033khtbS1fffUV33zzDSNGjADg4Ycf5qGHHmL06NE88sgjhISEsGzZMhYuXMjPfvazY/sDOsJ3+fbbb1myZAmXX345Xbt2Zfv27fzf//0fp59+OuvWrcPpdAKeAdunnnoq69ev5/rrr+fEE08kLy+Pjz76iF27djFs2DAuvPBC5syZw9NPP43NZvMe96233sIYw1VXXdVkXcHBwVx44YW8//77/P3vfyckJMT72YcffkhVVRWXX3450LyfoeZ6/fXXufHGGzn55JO5+eabAejZs2eDdS677DK6d+/OzJkzWblyJS+99BKJiYn88Y9/bLDewoULeeedd5g6dSrx8fFkZGSQk5PDT37yE2/4SUhI4H//+x833HADxcXF3H777cf8nZpTz4033shrr73GJZdcwm9/+1uWLVvGzJkzWb9+PR988MFhz0dFRQVnnXUWWVlZ3HrrraSmpvL666+zcOHCYzqv0oEYkQC1f/9+A5jzzz+/2dukp6eba6+91vu+srLSuFyuButkZmYau91uHnnkEe+y888/3wwcOPCI+46KijJTpkw54jrXXnutSU9Pb1TTueee26gGwLz66qveZWeddZYZPHiwqays9C5zu91m9OjRpnfv3t5lr776qgHMKaecYmpra49YjzHG1NbWmqqqqgbLCgsLTVJSkrn++uu9yxYuXGgAc+uttzbah9vtNsYYs3nzZmO1Ws2FF17Y6LzWr2OMMYCZPn16o/0c+udzpO9SXl7eaPulS5cawPzjH//wLnvwwQcNYN5///3D1v3JJ58YwPzvf/9r8PmQIUPM2LFjG213sPpt//Of/zRYfs4555gePXp43zfnZ+hYhIWFNThX9aZPn26ABn92xhhz4YUXmri4uAbLAGO1Ws3atWsbLL/hhhtMSkqKycvLa7D88ssvN1FRUd5z35zv1Nx6Vq1aZQBz4403NljvzjvvNIBZuHChd9nYsWMb/LnMmjXLAOadd97xLisrKzO9evUygPn888+PWKN0POqWkoBVXFwMQERERIv3YbfbsVo9/xu4XC7y8/MJDw+nb9++DbqToqOj2bVrF99+++1h9xUdHc2yZcvYs2dPi+s5nIKCAhYuXMhll11GSUkJeXl55OXlkZ+fz/jx49m8eTO7d+9usM1NN93UoBXicGw2m7fFwe12U1BQQG1tLSNGjGhwDt577z0sFkuDgc/1LBYL4GmtcLvdPPjgg97zeug6LdHUdwkNDfW+rqmpIT8/n169ehEdHd2o7qFDhzZq2Tq4pnHjxpGamsobb7zh/WzNmjX8+OOP/PKXvzxibWeeeSbx8fHMmTPHu6ywsJD58+czceJE77Lm/Ay1pltuuaXB+1NPPZX8/Hzv/zf1xo4d22DMlzGG9957jwkTJmCM8f6s5eXlMX78ePbv3+89v8fynY5Wz7x58wCYNm1ag/XqWzSPNHZu3rx5pKSkcMkll3iXOZ1Ob6uWdD4KNxKwIiMjAc9Yl5Zyu938+c9/pnfv3tjtduLj40lISODHH39k//793vXuvvtuwsPDOfnkk+nduzdTpkxh8eLFDfb1xBNPsGbNGtLS0jj55JN56KGH2LZtW4trO9iWLVswxvDAAw+QkJDQ4FEfNnJzcxts071792bv/7XXXmPIkCE4HA7i4uJISEhg7ty5Dc7B1q1bSU1NJTY29rD72bp1K1artdEA6ePV1HepqKjgwQcfJC0trcGfXVFRUaO6Bw0adMT9W61WrrrqKj788EPvOJA33ngDh8PBpZdeesRtg4KCuPjii/n3v//tHePx/vvvU1NT0yDcNOdnqDV169atwfuYmBjAE7wOdui53bdvH0VFRbzwwguNftbqxxbV/6wdy3c6Wj07duzAarXSq1evBuslJycTHR3Njh07Dvtdd+zYQa9evRoF6L59+x52G+nYFG4kYEVGRpKamsqaNWtavI8ZM2Ywbdo0TjvtNP75z3/yySefMH/+fAYOHNhgynb//v3ZuHEjb7/9Nqeccgrvvfcep5xySoNWjMsuu4xt27bx7LPPkpqayp/+9CcGDhzI//73v+P6noC3ljvvvJP58+c3+Tj0L4WDWzaO5J///CfXXXcdPXv25OWXX+bjjz9m/vz5nHnmmY2mrbc1l8vV5PKmvstvfvMbHnvsMS677DLeeecdPv30U+bPn09cXFyL6r7mmmsoLS3lww8/xBjDm2++yXnnnUdUVNRRt7388sspKSnx/lm/88479OvXj6FDh3rXac7PUGs6XKudMabB+0PPbf25++Uvf3nYn7UxY8YAx/admlvP8bTwidTTgGIJaOeddx4vvPACS5cuZdSoUce8/bvvvssZZ5zByy+/3GB5UVER8fHxDZaFhYUxceJEJk6cSHV1NRdddBGPPfYY9957r3fqbEpKCpMnT2by5Mnk5uZy4okn8thjj3H22We3/EsCPXr0ADwDWMeNG3dc+zrUu+++S48ePXj//fcb/MVy6F9QPXv25JNPPqGgoOCwrTc9e/bE7Xazbt26BgORDxUTE0NRUVGDZdXV1ezdu/eY6r722mt56qmnvMsqKysb7bdnz57NCsCDBg3ihBNO4I033qBr165kZWXx7LPPNquW0047jZSUFObMmcMpp5zCwoULue+++xqt15yfoeZqqxCQkJBAREQELperWT9rrfWd0tPTcbvdbN68mf79+3uX5+TkUFRURHp6+hG3XbNmDcaYBudl48aNzT6+dCxquZGA9rvf/Y6wsDBuvPFGcnJyGn2+detWnnnmmcNub7PZGv3L8V//+lej8Sv5+fkN3oeEhDBgwACMMdTU1OByuRp0hQAkJiaSmpraKtNRExMTOf300/n73//eZABoanZVc9X/i/rg87Bs2TKWLl3aYL2LL74YYwwPP/xwo33Ub3vBBRdgtVp55JFHGrWeHLz/nj178uWXXzb4/IUXXjhsy83h6j70z+7ZZ59ttI+LL76YH374ocnZNoduf/XVV/Ppp58ya9Ys4uLimh1KrVYrl1xyCf/5z394/fXXqa2tbdAlBUf/GQIoLy9nw4YNzbpVQVhYWKMg1xpsNhsXX3wx7733XpOh8OCfteZ8p+Y655xzAJg1a1aD5U8//TQA55577hG33bNnD++++653WXl5ebu5eKf4nlpuJKD17NmTN998k4kTJ9K/f/8GVyhesmQJ//rXv454L6nzzjuPRx55hEmTJjF69GhWr17NG2+84W0pqfezn/2M5ORkxowZQ1JSEuvXr+evf/0r5557LhERERQVFdG1a1cuueQShg4dSnh4OJ999hnffvttg5aF4/Hcc89xyimnMHjwYG666SZ69OhBTk4OS5cuZdeuXU1em6c5zjvvPN5//30uvPBCzj33XDIzM3n++ecZMGAApaWl3vXOOOMMrr76av7yl7+wefNmfv7zn+N2u/nqq68444wzmDp1Kr169eK+++7j0Ucf5dRTT+Wiiy7Cbrfz7bffkpqa6r1ezI033sgtt9zCxRdfzE9/+lN++OEHPvnkk0atZUer+/XXXycqKooBAwawdOlSPvvsM+Li4hqsd9ddd/Huu+9y6aWXcv311zN8+HAKCgr46KOPeP755xt0HV155ZX87ne/44MPPuDXv/71MV0heuLEiTz77LNMnz6dwYMHN2h9gKP/DAEsX76cM844g+nTpzd5HaCDDR8+nM8++4ynn36a1NRUunfvzsiRI5td75E8/vjjfP7554wcOZKbbrqJAQMGUFBQwMqVK/nss88oKCho9ndqrqFDh3LttdfywgsvUFRUxNixY1m+fDmvvfYaF1xwAWecccZht73pppv461//yjXXXMOKFStISUnh9ddf914OQDohn8/PEmkDmzZtMjfddJPJyMgwISEhJiIiwowZM8Y8++yzDaZONzUV/Le//a1JSUkxoaGhZsyYMWbp0qWNppr+/e9/N6eddpqJi4szdrvd9OzZ09x1111m//79xhhjqqqqzF133WWGDh1qIiIiTFhYmBk6dKj529/+1qDO45kKbowxW7duNddcc41JTk42wcHBpkuXLua8884z7777rned+unT3377bbPOndvtNjNmzDDp6enGbrebE044wfz3v/9t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//d2c65g0+nCTUlJCYDuDi4iIhKASkpKiIqKOuI6ne4ifm63mz179hAREYHFYmnVfRcXF5OWlsbOnTt1gcA2pPPsGzrPvqHz7Ds6177RVufZGENJSQmpqakN7lzQlE7XcmO1WunatWubHiMyMlL/4/iAzrNv6Dz7hs6z7+hc+0ZbnOejtdjU04BiERER6VAUbkRERKRDUbhpRXa7nenTp2O32/1dSoem8+wbOs++ofPsOzrXvtEeznOnG1AsIiIiHZtabkRERKRDUbgRERGRDkXhRkRERDoUhRsRERHpUBRujtFzzz1HRkYGDoeDkSNHsnz58iOu/69//Yt+/frhcDgYPHgw8+bN81Glge1YzvOLL77IqaeeSkxMDDExMYwbN+6ofy7icaw/z/XefvttLBYLF1xwQdsW2EEc63kuKipiypQppKSkYLfb6dOnj353NMOxnudZs2bRt29fQkNDSUtL44477qCystJH1QamL7/8kgkTJpCamorFYuHDDz886jaLFi3ixBNPxG6306tXL2bPnt3mdWKk2d5++20TEhJiXnnlFbN27Vpz0003mejoaJOTk9Pk+osXLzY2m8088cQTZt26deb+++83wcHBZvXq1T6uPLAc63m+8sorzXPPPWe+//57s379enPdddeZqKgos2vXLh9XHliO9TzXy8zMNF26dDGnnnqqOf/8831TbAA71vNcVVVlRowYYc455xzz9ddfm8zMTLNo0SKzatUqH1ceWI71PL/xxhvGbrebN954w2RmZppPPvnEpKSkmDvuuMPHlQeWefPmmfvuu8+8//77BjAffPDBEdfftm2bcTqdZtq0aWbdunXm2WefNTabzXz88cdtWqfCzTE4+eSTzZQpU7zvXS6XSU1NNTNnzmxy/csuu8yce+65DZaNHDnS/OpXv2rTOgPdsZ7nQ9XW1pqIiAjz2muvtVWJHUJLznNtba0ZPXq0eemll8y1116rcNMMx3qe/+///s/06NHDVFdX+6rEDuFYz/OUKVPMmWee2WDZtGnTzJgxY9q0zo6kOeHmd7/7nRk4cGCDZRMnTjTjx49vw8qMUbdUM1VXV7NixQrGjRvnXWa1Whk3bhxLly5tcpulS5c2WB9g/Pjxh11fWnaeD1VeXk5NTQ2xsbFtVWbAa+l5fuSRR0hMTOSGG27wRZkBryXn+aOPPmLUqFFMmTKFpKQkBg0axIwZM3C5XL4qO+C05DyPHj2aFStWeLuutm3bxrx58zjnnHN8UnNn4a+/BzvdjTNbKi8vD5fLRVJSUoPlSUlJbNiwocltsrOzm1w/Ozu7zeoMdC05z4e6++67SU1NbfQ/lBzQkvP89ddf8/LLL7Nq1SofVNgxtOQ8b9u2jYULF3LVVVcxb948tmzZwuTJk6mpqWH69Om+KDvgtOQ8X3nlleTl5XHKKadgjKG2tpZbbrmF3//+974oudM43N+DxcXFVFRUEBoa2ibHVcuNdCiPP/44b7/9Nh988AEOh8Pf5XQYJSUlXH311bz44ovEx8f7u5wOze12k5iYyAsvvMDw4cOZOHEi9913H88//7y/S+tQFi1axIwZM/jb3/7GypUref/995k7dy6PPvqov0uTVqCWm2aKj4/HZrORk5PTYHlOTg7JyclNbpOcnHxM60vLznO9J598kscff5zPPvuMIUOGtGWZAe9Yz/PWrVvZvn07EyZM8C5zu90ABAUFsXHjRnr27Nm2RQeglvw8p6SkEBwcjM1m8y7r378/2dnZVFdXExIS0qY1B6KWnOcHHniAq6++mhtvvBGAwYMHU1ZWxs0338x9992H1ap/+7eGw/09GBkZ2WatNqCWm2YLCQlh+PDhLFiwwLvM7XazYMECRo0a1eQ2o0aNarA+wPz58w+7vrTsPAM88cQTPProo3z88ceMGDHCF6UGtGM9z/369WP16tWsWrXK+/jFL37BGWecwapVq0hLS/Nl+QGjJT/PY8aMYcuWLd7wCLBp0yZSUlIUbA6jJee5vLy8UYCpD5RGt1xsNX77e7BNhyt3MG+//bax2+1m9uzZZt26debmm2820dHRJjs72xhjzNVXX23uuece7/qLFy82QUFB5sknnzTr168306dP11TwZjjW8/z444+bkJAQ8+6775q9e/d6HyUlJf76CgHhWM/zoTRbqnmO9TxnZWWZiIgIM3XqVLNx40bz3//+1yQmJpo//OEP/voKAeFYz/P06dNNRESEeeutt8y2bdvMp59+anr27Gkuu+wyf32FgFBSUmK+//578/333xvAPP300+b77783O3bsMMYYc88995irr77au379VPC77rrLrF+/3jz33HOaCt4ePfvss6Zbt24mJCTEnHzyyeabb77xfjZ27Fhz7bXXNlj/nXfeMX369DEhISFm4MCBZu7cuT6uODAdy3lOT083QKPH9OnTfV94gDnWn+eDKdw037Ge5yVLlpiRI0cau91uevToYR577DFTW1vr46oDz7Gc55qaGvPQQw+Znj17GofDYdLS0szkyZNNYWGh7wsPIJ9//nmTv2/rz+21115rxo4d22ibYcOGmZCQENOjRw/z6quvtnmdFmPU/iYiIiIdh8bciIiISIeicCMiIiIdisKNiIiIdCgKNyIiItKhKNyIiIhIh6JwIyIiIh2Kwo2IiIh0KAo3IgFm+/btWCwWn9yde/bs2URHRzdY9sILL5CWlobVamXWrFk89NBDDBs2rM1rycjIYNasWW1+nPZ0bIvFwocffnhc+zj99NO5/fbbj7iOP8+tSFtQuBGRw5o4cSKbNm3yvi8uLmbq1Kncfffd7N69m5tvvpk777yz0b1jjkdTgQrg22+/5eabb2614xzLsUUksOiu4CJyWKGhoQ3u3JuVlUVNTQ3nnnsuKSkp3uXh4eFtXktCQkKbH6M11dTUEBwc7O8yRDoltdyItENut5snnniCXr16Ybfb6datG4899liT67pcLm644Qa6d+9OaGgoffv25ZlnnmmwzqJFizj55JMJCwsjOjqaMWPGsGPHDgB++OEHzjjjDCIiIoiMjGT48OF89913QMOWjNmzZzN48GAAevTogcViYfv27U12S73yyisMHDgQu91OSkoKU6dO9X729NNPM3jwYMLCwkhLS2Py5MmUlpZ665w0aRL79+/HYrFgsVh46KGHgMZdJ1lZWZx//vmEh4cTGRnJZZddRk5Ojvfz+rpef/11MjIyiIqK4vLLL6ekpKTJ83ikY4PnLtLXX389ERERdOvWjRdeeMH7WX1X4Zw5cxg7diwOh4M33ngDgJdeeon+/fvjcDjo168ff/vb37zbVVdXM3XqVFJSUnA4HKSnpzNz5swGdeXl5XHhhRfidDrp3bs3H330UYPPv/jiC04++WTvub7nnnuora1t8jsC5ObmMmHCBEJDQ+nevbu3TpEOpc3vXiUix+x3v/udiYmJMbNnzzZbtmwxX331lXnxxReNMcZkZmYawHz//ffGGGOqq6vNgw8+aL799luzbds2889//tM4nU4zZ84cY4znBoFRUVHmzjvvNFu2bDHr1q0zs2fP9t7Fd+DAgeaXv/ylWb9+vdm0aZN55513zKpVq4wxxrz66qsmKirKGGNMeXm5+eyzzwxgli9fbvbu3Wtqa2vN9OnTzdChQ721/+1vfzMOh8PMmjXLbNy40Sxfvtz8+c9/9n7+5z//2SxcuNBkZmaaBQsWmL59+5pf//rXxhhjqqqqzKxZs0xkZGSju7unp6d79+NyucywYcPMKaecYr777jvzzTffmOHDhze4Yd/06dNNeHi4ueiii8zq1avNl19+aZKTk83vf//7Js/50Y4dGxtrnnvuObN582Yzc+ZMY7VazYYNGxr8mWRkZJj33nvPbNu2zezZs8f885//NCkpKd5l7733nomNjTWzZ882xhjzpz/9yaSlpZkvv/zSbN++3Xz11VfmzTff9NYEmK5du5o333zTbN682dx6660mPDzc5OfnG2OM2bVrl3E6nWby5Mlm/fr15oMPPjDx8fENbho7duxYc9ttt3nfn3322Wbo0KFm6dKl5rvvvjOjR482oaGhDf6MRAKdwo1IO1NcXGzsdrs3zBzq0HDTlClTppiLL77YGGNMfn6+AcyiRYuaXDciIsL7l+2hDg43xhjz/fffG8BkZmZ6lx0ablJTU81999132NoO9a9//cvExcUd9pj1Dg43n376qbHZbCYrK8v7+dq1a73Bq74up9NpiouLvevcddddZuTIkYet5UjH/uUvf+l973a7TWJiovm///s/Y8yBP5NZs2Y12K5nz54Nwooxxjz66KNm1KhRxhhjfvOb35gzzzzTuN3uJusBzP333+99X1paagDzv//9zxhjzO9//3vTt2/fBts/99xzJjw83LhcLmNMw3CzcePGBufIGGPWr19vAIUb6VDULSXSzqxfv56qqirOOuusZm/z3HPPMXz4cBISEggPD+eFF14gKysLgNjYWK677jrGjx/PhAkTeOaZZ9i7d69322nTpnHjjTcybtw4Hn/8cbZu3dri2nNzc9mzZ88Ra//ss88466yz6NKlCxEREVx99dXk5+dTXl7e7OOsX7+etLQ00tLSvMsGDBhAdHQ069ev9y7LyMggIiLC+z4lJYXc3Nxj/FYeQ4YM8b62WCwkJyc32teIESO8r8vKyti6dSs33HAD4eHh3scf/vAH7zm+7rrrWLVqFX379uXWW2/l008/PeJxw8LCiIyM9B53/fr1jBo1CovF4l1nzJgxlJaWsmvXrkb7Wr9+PUFBQQwfPty7rF+/fhpELR2Owo1IO3PwAN7mePvtt7nzzju54YYb+PTTT1m1ahWTJk2iurrau86rr77K0qVLGT16NHPmzKFPnz588803gGdsytq1azn33HNZuHAhAwYM4IMPPmiT2rdv3855553HkCFDeO+991ixYgXPPfccQIN6W8uhA3otFgtut7vN9hUWFuZ9XT+O6MUXX2TVqlXex5o1a7zn/sQTTyQzM5NHH32UiooKLrvsMi655JI2+w4inYXCjUg707t3b0JDQ5s9vXrx4sWMHj2ayZMnc8IJJ9CrV68mW19OOOEE7r33XpYsWcKgQYN48803vZ/16dOHO+64g08//ZSLLrqIV199tUW1R0REkJGRcdjaV6xYgdvt5qmnnuInP/kJffr0Yc+ePQ3WCQkJweVyHfE4/fv3Z+fOnezcudO7bN26dRQVFTFgwIAW1d7cYzdXUlISqampbNu2jV69ejV4dO/e3bteZGQkEydO5MUXX2TOnDm89957FBQUNOsY/fv3Z+nSpRhjvMsWL15MREQEXbt2bbR+v379qK2tZcWKFd5lGzdupKioqOVfVKQdUrgRaWccDgd33303v/vd7/jHP/7B1q1b+eabb3j55ZebXL9379589913fPLJJ2zatIkHHniAb7/91vt5ZmYm9957L0uXLmXHjh18+umnbN68mf79+1NRUcHUqVNZtGgRO3bsYPHixXz77bf079+/xfU/9NBDPPXUU/zlL39h8+bNrFy5kmeffRaAXr16UVNTw7PPPsu2bdt4/fXXef755xtsn5GRQWlpKQsWLCAvL6/J7qpx48YxePBgrrrqKlauXMny5cu55pprGDt2bIOuoWPVnGMfi4cffpiZM2fyl7/8hU2bNrF69WpeffVVnn76acAzc+ytt95iw4YNbNq0iX/9618kJyc3u5to8uTJ7Ny5k9/85jds2LCBf//730yfPp1p06ZhtTb+9d63b19+/vOf86tf/Yply5axYsUKbrzxxmNuLRRp7xRuRNqhBx54gN/+9rc8+OCD9O/fn4kTJx52rMivfvUrLrroIiZOnMjIkSPJz89n8uTJ3s+dTicbNmzg4osvpk+fPtx8881MmTKFX/3qV9hsNvLz87nmmmvo06cPl112GWeffTYPP/xwi2u/9tprmTVrFn/7298YOHAg5513Hps3bwZg6NChPP300/zxj39k0KBBvPHGG42mPo8ePZpbbrmFiRMnkpCQwBNPPNHoGBaLhX//+9/ExMRw2mmnMW7cOHr06MGcOXNaXHdzj30sbrzxRl566SVeffVVBg8ezNixY5k9e7a35SYiIoInnniCESNGcNJJJ7F9+3bmzZvXZDBpSpcuXZg3bx7Lly9n6NCh3HLLLdxwww3cf//9h93m1VdfJTU1lbFjx3LRRRdx8803k5iYeFzfU6S9sZiD2zNFREREApxabkRERKRDUbgRERGRDkXhRkRERDoUhRsRERHpUBRuREREpENRuBEREZEOReFGREREOhSFGxEREelQFG5ERESkQ1G4ERERkQ5F4UZEREQ6FIUbERER6VD+H19A+E6yMeuCAAAAAElFTkSuQmCC",
       "text/plain": [
        "<Figure size 640x480 with 1 Axes>"
       ]
@@ -124,59 +218,56 @@
     }
    ],
    "source": [
-    "# # PLOT ACCURACY VS THRESHOLD\n",
-    "# def plot_accuracy(run_info,**kwargs):\n",
-    "#     ts = run_info['thresholds']\n",
-    "#     subsets = ['train','test','val']\n",
-    "#     for subset in subsets:\n",
-    "#         accs = run_info[subset+'_acc']\n",
-    "#         plt.plot(ts,accs,label = subset,**kwargs)\n",
-    "#     plt.xlabel(\"classification threshold\")\n",
-    "#     plt.ylabel(\"accuracy\")\n",
-    "#     plt.title(\"Classifier accuracy vs. threshold\")\n",
-    "#     plt.legend()\n",
-    "#     plt.show()\n",
-    "\n",
     "eval.plot_accuracy(info)"
    ]
   },
+  {
+   "cell_type": "markdown",
+   "id": "6403e0db-877e-4e0e-b3b3-af74a2130d8e",
+   "metadata": {},
+   "source": [
+    "#### Plot F1 score vs. positive threshold"
+   ]
+  },
   {
    "cell_type": "code",
-   "execution_count": 6,
+   "execution_count": 8,
    "id": "a2782025-287b-4e3e-8e49-8d3a487554cb",
    "metadata": {},
    "outputs": [
     {
      "data": {
-      "image/png": "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",
+      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAkAAAAHHCAYAAABXx+fLAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjguMywgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy/H5lhTAAAACXBIWXMAAA9hAAAPYQGoP6dpAABhVUlEQVR4nO3dd3hUZf428HtmMiU9kB4IhB5KDBokBtSg5DUousZGxEIRRBdQNIoKKhFb1J+6cRFFLOC6siBFdBERBFEXIh2U3gktnWRSJ1Oe94/JHBgyQCZl6v25rrlMzjxz5jsHTG6e8xSZEEKAiIiIyIvInV0AERERkaMxABEREZHXYQAiIiIir8MARERERF6HAYiIiIi8DgMQEREReR0GICIiIvI6DEBERETkdRiAiIiIyOswABERtYJXXnkFMpkMJSUlzi4FQNvUM2TIEAwZMuSK7davXw+ZTIb169e32nsTtTYGICIXMn/+fMhkMpuPF154QWq3evVqjBs3Dv369YNCoUBcXJzzivYyb775JpYvX+7sMoiohXycXQARNfbqq6+iS5cuVsf69esnfb1gwQIsWrQI11xzDWJiYhxdnld78803ce+99yIjI8PZpRBRCzAAEbmgW2+9FQMGDLjk82+++SY+/fRTKJVK3H777di9e7cDq2s5g8EAk8kElUrl7FJcgslkQn19PTQajbNLIfIavAVG5IZiYmKgVCqb/fqFCxciKSkJgYGBCAoKQkJCAj744AOrNuXl5Xj66acRFxcHtVqNjh07YtSoUVZjSoqKijBu3DhERkZCo9EgMTERX375pdV5jh8/DplMhnfffRe5ubno1q0b1Go19u7dCwDYv38/7r33XrRv3x4ajQYDBgzA999/f9n69Xo92rdvj7FjxzZ6TqvVQqPR4Nlnn5WOzZo1C3379oWfnx/atWuHAQMGYMGCBXZfN5lMhurqanz55ZfSrckxY8ZYtSkvL8eYMWMQEhKC4OBgjB07FjU1NY3OM3nyZHz99dfo27cv1Go1Vq1aBQA4ffo0HnnkEURGRkKtVqNv37744osvGtXS1M/UlHoMBgNee+016c8mLi4O06dPh06nu+I1OXXqFDIyMuDv74+IiAg8/fTTTXodkbOxB4jIBVVUVDQavBoWFtYq516zZg1GjhyJoUOH4u233wYA7Nu3Dxs2bMCUKVMAAFVVVbjhhhuwb98+PPLII7jmmmtQUlKC77//HqdOnUJYWBhqa2sxZMgQHD58GJMnT0aXLl2wePFijBkzBuXl5dK5LObNm4e6ujpMmDABarUa7du3x549ezB48GB06NABL7zwAvz9/fHNN98gIyMDS5cuxV133WXzMyiVStx1111YtmwZPvnkE6uepOXLl0On0+H+++8HAHz66ad48sknce+992LKlCmoq6vDn3/+iU2bNuGBBx6w69p99dVXGD9+PAYOHIgJEyYAALp162bVZsSIEejSpQtycnKwfft2fPbZZ4iIiJCutcW6devwzTffYPLkyQgLC0NcXBwKCwtx3XXXSQEpPDwcP/74I8aNGwetVounnnrK7s/UlHrGjx+PL7/8Evfeey+eeeYZbNq0CTk5Odi3bx++/fbbS16P2tpaDB06FPn5+XjyyScRExODr776CuvWrbPruhI5hSAilzFv3jwBwObjUoYPHy46d+7c5PeYMmWKCAoKEgaD4ZJtZsyYIQCIZcuWNXrOZDIJIYTIzc0VAMS///1v6bn6+nqRkpIiAgIChFarFUIIcezYMQFABAUFiaKiIqtzDR06VCQkJIi6ujqr8w8aNEj06NHjsp/jp59+EgDEf//7X6vjt912m+jatav0/Z133in69u172XPZw9/fX4wePbrR8ezsbAFAPPLII1bH77rrLhEaGmp1DICQy+Viz549VsfHjRsnoqOjRUlJidXx+++/XwQHB4uamhohRNM+U1Pr2blzpwAgxo8fb9Xu2WefFQDEunXrpGOpqakiNTVV+t7yd+Cbb76RjlVXV4vu3bsLAOKXX365bI1EzsRbYEQuaPbs2VizZo3Vo7WEhISgurr6sudcunQpEhMTbfbAyGQyAMDKlSsRFRWFkSNHSs8plUo8+eSTqKqqwq+//mr1unvuuQfh4eHS92VlZVi3bh1GjBiByspKlJSUoKSkBKWlpUhPT8ehQ4dw+vTpS9Z48803IywsDIsWLZKOnTt3DmvWrEFmZqbV5z116hS2bNlymavSeh5//HGr72+44QaUlpZCq9VaHU9NTUWfPn2k74UQWLp0Ke644w4IIaTrUVJSgvT0dFRUVGD79u0A7PtMV6pn5cqVAICsrCyrds888wwA4IcffrjkuVeuXIno6Gjce++90jE/Pz+pd4zIlTEAEbmggQMHIi0tzerR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tWIAIiIiIq/DAERERERehwGIiIiI7DZkyBA89dRTrXa+MWPGICMjo9XOdyUMQERErUBnMEII4ewyiKiJGICIiFqoSFuHm/5vPUZ++oezSyFyiDFjxuDXX3/FBx98AJlMBplMhuPHj2P37t249dZbERAQgMjISDz88MMoKSmRXrdkyRIkJCTA19cXoaGhSEtLQ3V1NV555RV8+eWX+O6776TzrV+/vk0/A9cBIiJqoWcW78KZijqcqaiDEIIzeqhFhBCo1Rud8t6+SkWT/v5+8MEHOHjwIPr164dXX30VgHmbioEDB2L8+PH4xz/+gdraWjz//PMYMWIE1q1bh7Nnz2LkyJF45513cNddd6GyshK///47hBB49tlnsW/fPmi1WsybNw8A0L59+zb9rAxAREQtUKStw++Hzv8LV2cwQaNsnb2KyDvV6o3oM+Mnp7z33lfT4ae6cjQIDg6GSqWCn58foqKiAACvv/46rr76arz55ptSuy+++AKxsbE4ePAgqqqqYDAYcPfdd6Nz584AgISEBKmtr68vdDqddL62xltgREQt8O2O01bf19Y751/uRM62a9cu/PLLLwgICJAe8fHxAIAjR44gMTERQ4cORUJCAu677z58+umnOHfunNPqZQ8QEVEzaev0mPPrEatjNXoj2jmpHvIMvkoF9r6a7rT3bq6qqirccccdePvttxs9Fx0dDYVCgTVr1mDjxo1YvXo1Zs2ahRdffBGbNm1Cly5dWlJ2szAAERE105z1R3CuRo/uEQEorKhDpc6A2nqDs8siNyeTyZp0G8rZVCoVjMbzPZ7XXHMNli5diri4OPj42K5fJpNh8ODBGDx4MGbMmIHOnTvj22+/RVZWVqPztTXeAiMiaqIz5bWYsnAHpn/7F+Je+AEfrTf3/jw/LB6BGvMP/Godb4GRd4iLi8OmTZtw/PhxlJSUYNKkSSgrK8PIkSOxZcsWHDlyBD/99BPGjh0Lo9GITZs24c0338TWrVuRn5+PZcuWobi4GL1795bO9+eff+LAgQMoKSlp8V5fV8IARETUBKfLazHorXX4bucZLNiULx2/Nq4d0npHwFdlvnVQwzFA5CWeffZZKBQK9OnTB+Hh4aivr8eGDRtgNBpxyy23ICEhAU899RRCQkIgl8sRFBSE3377Dbfddht69uyJl156Ce+99x5uvfVWAMCjjz6K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",
       "text/plain": [
        "<Figure size 640x480 with 1 Axes>"
       ]
      },
      "metadata": {},
      "output_type": "display_data"
+    },
+    {
+     "name": "stdout",
+     "output_type": "stream",
+     "text": [
+      "F1 score maximized at threshold 0.549\n"
+     ]
     }
    ],
    "source": [
-    "# PLOT F1 SCORE VS THRESHOLD\n",
-    "# def plot_F1(run_info,**kwargs):\n",
-    "#     ts = run_info['thresholds']\n",
-    "#     subsets = ['test']\n",
-    "#     for subset in subsets:\n",
-    "#         accs = run_info[subset+'_F1']\n",
-    "#         plt.plot(ts,accs,label = subset,**kwargs)\n",
-    "#     plt.xlabel(\"classification threshold\")\n",
-    "#     plt.ylabel(\"F1 Score\")\n",
-    "#     plt.title(\"F1 score vs. threshold\")\n",
-    "#     plt.legend()\n",
-    "#     plt.show()\n",
-    "\n",
     "eval.plot_F1(info)"
    ]
   },
+  {
+   "cell_type": "markdown",
+   "id": "72f828e8-8674-4abb-8263-72b649500628",
+   "metadata": {},
+   "source": [
+    "####  Plot ROC curves"
+   ]
+  },
   {
    "cell_type": "code",
-   "execution_count": 22,
+   "execution_count": 9,
    "id": "b5644cf6-3b0f-4ff6-abe4-60dd790fa337",
    "metadata": {
     "scrolled": true
@@ -184,7 +275,7 @@
    "outputs": [
     {
      "data": {
-      "image/png": "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",
+      "image/png": "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",
       "text/plain": [
        "<Figure size 640x480 with 1 Axes>"
       ]
@@ -194,34 +285,26 @@
     }
    ],
    "source": [
-    "# PLOT ROC CURVES\n",
-    "# def plot_ROC(run_info,**kwargs):\n",
-    "#     subsets = ['train','test','val']\n",
-    "#     for subset in subsets:\n",
-    "#         tprs = np.append(run_info[subset+'_tpr'][::-1],1)\n",
-    "#         fprs = np.append(run_info[subset+'_fpr'][::-1],1)\n",
-    "#         auc = np.trapz(tprs,fprs)\n",
-    "#         plt.plot(fprs,tprs,label = subset + \"; AUC = {}\".format(auc),**kwargs)\n",
-    "#     line = np.linspace(0,1,100)\n",
-    "#     plt.plot(line,line,'k--')\n",
-    "#     plt.xlabel(\"False positive rate\")\n",
-    "#     plt.ylabel(\"True positive rate\")\n",
-    "#     plt.title(\"ROC Curves; in/out of sample\")\n",
-    "#     plt.legend()\n",
-    "#     plt.show()\n",
-    "\n",
     "eval.plot_ROC(info)"
    ]
   },
+  {
+   "cell_type": "markdown",
+   "id": "7cffb073-6d1d-4ba1-908c-ac1e8c3e63f0",
+   "metadata": {},
+   "source": [
+    "#### Plot PR curves"
+   ]
+  },
   {
    "cell_type": "code",
-   "execution_count": 21,
+   "execution_count": 10,
    "id": "0668184c-cd7c-4349-aee3-7397605c62b9",
    "metadata": {},
    "outputs": [
     {
      "data": {
-      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAkAAAAHHCAYAAABXx+fLAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjguMywgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy/H5lhTAAAACXBIWXMAAA9hAAAPYQGoP6dpAAByuUlEQVR4nO3deVhU1f8H8PfMAMMOsi+iqOAKQm6Eu4bikkmLolkuqW1aGmmpmdqKVpamFl9brZ9bllmpoYhamuaGayrugsoqwrDINnN/f4wMDAz7zFx03q/nmYeZM+feOXcGnQ/nfM45EkEQBBARERGZEKnYDSAiIiIyNgZAREREZHIYABEREZHJYQBEREREJocBEBEREZkcBkBERERkchgAERERkclhAEREREQmhwEQERERmRwGQER035g4cSJ8fX3FboZojhw5gp49e8LGxgYSiQQnTpwQu0l6ZeqfLxkXAyCievj+++8hkUg0N0tLS7Rt2xbTp09HWlqapt7evXu16slkMri5ueGpp57CuXPn6vWaly9fxgsvvIDWrVvD0tIS9vb26NWrF5YvX467d+/q+xIfeHfu3IGZmRl++ukng5z/7NmzWLRoEa5du6bX85aUlGDUqFHIysrCZ599hh9//BEtW7bU62sQmRIzsRtAdD9699130apVKxQWFmL//v348ssvsX37dpw5cwbW1taaeq+++iq6d++OkpISnDp1CjExMdi7dy/OnDkDDw+PWl9n27ZtGDVqFORyOcaPH4+AgAAUFxdj//79mD17Nv777z+sXr3akJfapHz11VdQqVSNOseOHTsgkUgwePBgPbVK29mzZ/HOO++gf//+eu3NuHz5Mq5fv46vvvoKU6ZM0dt5iUwVAyCiBhg6dCi6desGAJgyZQqcnZ3x6aef4rfffsPYsWM19fr06YOnnnpK87hdu3Z46aWX8MMPP+CNN96o8TWuXr2KMWPGoGXLlti9ezc8PT01z02bNg2XLl3Ctm3b9HI9+fn5sLGx0cu5DMnc3LzR59i+fTt69eoFR0fHxjfIiNLT0wHgvms3UVPFITAiPRg4cCAAddBSkz59+gBQ/zVfm48++gh5eXn45ptvtIKfMn5+fpgxYwYA4Nq1a5BIJPj++++r1JNIJFi0aJHm8aJFiyCRSHD27Fk8/fTTaNasGXr37o1PPvkEEokE169fr3KO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",
+      "image/png": "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3377LVatWoWzZ89i5syZeO6557B//34AwJ07d/Doo49CpVJhz549OHbsGCZOnIjc3FwAQGpqKsaNG4e///4bhw4dQrNmzTBo0CCkpqZKto1EVHV4iI2Iao1t27bBzs4Oubm5yM7Ohlwux+eff47s7GwsWrQIu3fvRlBQEACgcePG+Pvvv/F///d/6NWrF1asWAEHBwds2LAB1tbWAIDmzZsbl923b1+TdX355ZdwdHTE/v378fjjj1ffRhJRtWBAIqJao0+fPli5ciXS09Px8ccfw8rKCsOGDcPZs2eRkZGBxx57zKR+Tk4OOnbsCAA4efIkevbsaQxH5mJjYzFnzhzs27cPcXFx0Ol0yMjIQFRUVJVvFxFVPwYkIqo16tWrh6ZNmwIAvvnmG7Rv3x5ff/01/P39AQDbt2+Hj4+PyXtUKhUAwMbGptRljxs3DomJifjkk0/QsGFDqFQqBAUFIScnpwq2hIikxoBERLWSXC7H22+/jdDQUFy6dAkqlQpRUVHo1atXsfXbtWuHtWvXQqvVFtuLdODAAXzxxRcYNGgQAODWrVtISEio0m0gIulwkDYR1VrPPPMMFAoF/u///g+zZs3CzJkzsXbtWly9ehXHjx/HZ599hrVr1wIApk+fjpSUFDz77LM4evQoLl++jO+++w4XL14EADRr1gzfffcdzp8/j8OHD2PMmDEP7HUiopqLPUhEVGtZWVlh+vTp+OCDD3D9+nW4ubkhLCwM165dg6OjIzp16oS3334bAODi4oI9e/bg9ddfR69evaBQKNChQwd0794dAPD111/jhRdeQKdOneDr64tFixZh1qxZUm4eEVUhmRBCSN0IIiIiIkvCQ2xEREREZhiQiIiIiMwwIBERERGZYUAiIiIiMsOARERERGSGAYmIiIjIDAMSERERkRkGJCIiIiIzDEhEREREZhiQiIiIiMwwIBERERGZYUAiIiIiMvP/JvtujyaByLoAAAAASUVORK5CYII=",
       "text/plain": [
        "<Figure size 640x480 with 1 Axes>"
       ]
@@ -231,21 +314,16 @@
     }
    ],
    "source": [
-    "# PLOT PR CURVES\n",
-    "# def plot_PR(run_info,**kwargs):\n",
-    "#     subsets = ['test','val']\n",
-    "#     for subset in subsets:\n",
-    "#         precs = run_info[subset+'_prec'][::-1]\n",
-    "#         recs = run_info[subset+'_tpr'][::-1]\n",
-    "#         plt.plot(recs,precs,label = subset,**kwargs)\n",
-    "#     plt.xlabel(\"Recall\")\n",
-    "#     plt.ylabel(\"Precision\")\n",
-    "#     plt.title(\"PR Curves; out of sample\")\n",
-    "#     plt.legend()\n",
-    "#     plt.show()\n",
-    "\n",
     "eval.plot_PR(info)"
    ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "id": "907da525-c829-4e2a-ab1f-69090dcb2789",
+   "metadata": {},
+   "outputs": [],
+   "source": []
   }
  ],
  "metadata": {
diff --git a/.ipynb_checkpoints/basic_feedforward-checkpoint.py b/.ipynb_checkpoints/basic_feedforward-checkpoint.py
index 0c4bcd1..9dd3aa7 100644
--- a/.ipynb_checkpoints/basic_feedforward-checkpoint.py
+++ b/.ipynb_checkpoints/basic_feedforward-checkpoint.py
@@ -5,11 +5,11 @@ import numpy as np
 
 from forge import flags
 
-flags.DEFINE_boolean(
-    "model_with_dict",
-    True,
-    "Makes model output predictions in dictionary instead of directly."
-)
+# flags.DEFINE_boolean(
+#     "model_with_dict",
+#     True,
+#     "Makes model output predictions in dictionary instead of directly."
+# )
 
 class PerceptronNN(nn.Module):
     def __init__(self, input_size, num_labels):
@@ -17,24 +17,58 @@ class PerceptronNN(nn.Module):
         # Define the layers
         self.fc1 = nn.Linear(input_size, 128)  # First dense layer
         self.fc2 = nn.Linear(128, 64)         # Second dense layer
+        # self.fc23 = nn.Linear(64,64)
         self.fc3 = nn.Linear(64, 64)          # Third dense layer
         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-        self.softmax = nn.Softmax(dim=1)
+        # self.softmax = nn.Softmax(dim=1)
 
     def forward(self, x):
         # Forward pass through the network
         x = F.relu(self.fc1(x))  # Activation function between layers
         x = F.relu(self.fc2(x))
+        # x = F.relu(self.fc23(x))
         x = F.relu(self.fc3(x))
         x = self.fc4(x)  # No activation, this will be included in the loss function
-        x = self.softmax(x)
+        # x = self.softmax(x)
+        return x
+
+class BasicFFNN(nn.Module):
+    def __init__(self, input_size, num_labels):
+        super(BasicFFNN, self).__init__()
+        # Define the layers
+        self.fc1 = nn.Linear(input_size, 64)  # First dense layer, reduced size
+        self.bn1 = nn.BatchNorm1d(64)  # Batch Normalization for the first layer
+        self.dropout1 = nn.Dropout(0.5)  # Dropout with 50% probability
+        
+        self.fc2 = nn.Linear(64, 32)  # Reduced size for second dense layer
+        self.bn2 = nn.BatchNorm1d(32)  # Batch Normalization for the second layer
+        self.dropout2 = nn.Dropout(0.5)  # Dropout with 50% probability
+
+        self.fc3 = nn.Linear(32,32)
+        self.bn3 = nn.BatchNorm1d(32)
+
+        self.fc4 = nn.Linear(32, num_labels)  # Output layer
+
+    def forward(self, x):
+    	x = x['data']
+        # Forward pass through the network with activations, batch normalization, and dropout
+        x = F.relu(self.bn1(self.fc1(x)))
+        x = self.dropout1(x)
+        x = F.relu(self.bn2(self.fc2(x)))
+        x = self.dropout2(x)
+        x = F.relu(self.bn3(self.fc3(x)))
+        x = self.fc4(x)  # No activation here, use sigmoid or softmax outside if needed for binary classification
         return x
 
 def load(config):
 
     # n_channels = 1
     n_features = config.input_size
+
+    mlp = BasicFFNN(n_features,2)
     
-    mlp = PerceptronNN(n_features,2)
-    
-    return mlp, "feedforward"
\ No newline at end of file
+    return mlp, "gpt_feedforward_halfLs"
+
+
+
+
diff --git a/.ipynb_checkpoints/testing-checkpoint.ipynb b/.ipynb_checkpoints/testing-checkpoint.ipynb
index 8242b04..f789c23 100644
--- a/.ipynb_checkpoints/testing-checkpoint.ipynb
+++ b/.ipynb_checkpoints/testing-checkpoint.ipynb
@@ -2,161 +2,449 @@
  "cells": [
   {
    "cell_type": "code",
-   "execution_count": 37,
+   "execution_count": 1,
    "id": "4dee7ff1-01a4-4038-b493-9729ff3693f7",
    "metadata": {},
    "outputs": [],
    "source": [
     "import torch\n",
+    "import torch.nn as nn\n",
+    "import torch.nn.functional as F\n",
     "import numpy as np\n",
     "from sklearn.model_selection import RepeatedKFold\n",
     "import pandas as pd\n",
-    "from torch.utils.data import Dataset, DataLoader\n",
+    "from torch.utils.data import Dataset, DataLoader, Sampler\n",
     "\n",
     "import matplotlib.pyplot as plt\n",
-    "from os import path as osp"
+    "from os import path as osp\n",
+    "\n",
+    "import forge\n",
+    "from forge import flags\n",
+    "import forge.experiment_tools as fet\n",
+    "\n",
+    "from penn_dataset import PennData,headingSampler"
    ]
   },
   {
    "cell_type": "code",
-   "execution_count": 13,
-   "id": "e1759421-97cf-4ca4-90cf-5509eb48455e",
+   "execution_count": 42,
+   "id": "92bae5ef-5c95-4528-a76d-003bbe09786c",
    "metadata": {},
    "outputs": [],
    "source": [
-    "data_dir = './penn_data'\n",
-    "headings = ['aaa0043','aaa0044','aaa0060','aaa0061','aaa0063','aaa0064','aaa0066','aaa0069','aaa0086','aaa0087','aaa_0051','aaa_0053','aaa_0054','aaa_0059','aaa_0071','aaa_0072'];\n",
-    "\n",
-    "all_ind = np.arange(len(headings))\n",
-    "train_split = 0.8\n",
-    "\n",
-    "kf = RepeatedKFold(n_splits = int(len(headings)/((1-train_split)*len(headings))), n_repeats = 3, random_state = 1)\n",
-    "\n",
-    "# for i, (train_ind, test_ind) in enumerate(kf.split(headings)):\n",
-    "    "
+    "headings = np.array(['aaa0043','aaa0044','aaa0060','aaa0061','aaa0063','aaa0064','aaa0066','aaa0069','aaa0086','aaa0087','aaa_0051','aaa_0053','aaa_0054','aaa_0059','aaa_0071','aaa_0072'])\n",
+    "kinds = None\n",
+    "dat = PennData('./penn_data',headings,include_coords = False,k_inds = kinds)"
    ]
   },
   {
    "cell_type": "code",
-   "execution_count": 17,
-   "id": "432286fa-8df2-4e66-aa06-0a8a9170dedc",
+   "execution_count": 53,
+   "id": "8ecb4309-6ea4-4313-a913-3d832e90fe25",
    "metadata": {},
-   "outputs": [],
+   "outputs": [
+    {
+     "data": {
+      "text/plain": [
+       "torch.Size([10, 1, 39])"
+      ]
+     },
+     "execution_count": 53,
+     "metadata": {},
+     "output_type": "execute_result"
+    }
+   ],
    "source": [
-    "# for i, (train_ind, test_ind) in enumerate(kf.split(headings)):\n",
-    "#     # Import training data\n",
-    "#     # Import spectra\n",
-    "#     df_list = []\n",
-    "#     for ind in train_ind:\n",
-    "#         df_temp = pd.read_csv('./penn_data/kvals_fuse_rotate_'+headings[ind]+'.csv',header=None)\n",
-    "#         df_list.append(df_temp)\n",
-    "#     df = pd.concat(df_list, ignore_index=True)\n",
-    "#     df_std = df.std();\n",
-    "#     df_mean = df.mean();\n",
-    "#     df = (df - df_mean)/df_std\n",
-    "#     # df"
+    "df,bounds = pad_dataframe(dat.df)\n",
+    "loader = DataLoader(dat,batch_size = 10,sampler = None)\n",
+    "example = next(iter(loader))\n",
+    "xx = torch.unsqueeze(example['data'].float(),1)\n",
+    "s = xx.shape\n",
+    "s"
    ]
   },
   {
    "cell_type": "code",
-   "execution_count": 93,
-   "id": "2f94c062-2423-41f1-bf7c-dbc10f8b058a",
+   "execution_count": 60,
+   "id": "c15fbcaf-a7cd-4b52-9b94-81b3b16dee64",
+   "metadata": {},
+   "outputs": [
+    {
+     "data": {
+      "text/plain": [
+       "torch.Size([10, 16, 37])"
+      ]
+     },
+     "execution_count": 60,
+     "metadata": {},
+     "output_type": "execute_result"
+    }
+   ],
+   "source": [
+    "m = nn.Conv1d(s[1],16,3)\n",
+    "m(xx).shape"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 34,
+   "id": "94bb950c-609a-44f2-a6f4-5d50f944cd90",
    "metadata": {},
    "outputs": [],
    "source": [
-    "class PennData(Dataset):\n",
-    "\n",
-    "    def __init__(self,path_to_data,headings,kinds,spectra_prefix = \"kvals_fuse_rotate_\",label_prefix = 'labels_fuse_rotate_'):\n",
-    "        self.data_dir = path_to_data\n",
-    "\n",
-    "        self.headings = headings\n",
-    "\n",
-    "        df_list = []\n",
-    "        label_list = []\n",
-    "        for heading in self.headings: # for each datafile heading,\n",
-    "            data_name = osp.join(self.data_dir,spectra_prefix + heading+'.csv')\n",
-    "            print(data_name)\n",
-    "            df_temp = pd.read_csv(data_name,header=None)\n",
-    "            df_list.append(df_temp)\n",
-    "\n",
-    "            label_name = osp.join(self.data_dir,label_prefix + heading + '.csv')\n",
-    "            label_temp = pd.read_csv(label_name,header=None, names=['label'])\n",
-    "            label_list.append(label_temp)\n",
-    "\n",
-    "        df = pd.concat(df_list, ignore_index=True)\n",
-    "        df_std = df.std();\n",
-    "        df_mean = df.mean();\n",
-    "        df = (df - df_mean)/df_std\n",
-    "\n",
-    "        labels = pd.concat(label_list, ignore_index=True)\n",
-    "        # Append labels to data, and scramble rows\n",
-    "        df = pd.concat([labels, df], axis=\"columns\")\n",
+    "class ConvNN(nn.Module):\n",
+    "    def __init__(self, input_size, dim_hidden, kernel_size,num_classes):\n",
+    "        super(ConvNN, self).__init__()\n",
+    "        # Define the layers\n",
+    "        self.conv1 = nn.Conv1d(input_size,dim_hidden,kernel_size)  # First convolution layer\n",
+    "        self.conv2 = nn.Conv1d(dim_hidden,dim_hidden,kernel_size) # second convolution layer\n",
+    "        \n",
+    "        self.pool1 = nn.MaxPool1d(kernel_size,stride = 2)\n",
+    "        # self.softmax = nn.Softmax(dim=1)\n",
     "\n",
-    "        self.alldata = df\n",
+    "    def forward(self, x):\n",
+    "    \tx = x['data']\n",
+    "    \tx = torch.unsqueeze(x,1) # add a single channel index\n",
     "\n",
+    "        # Forward pass through the network\n",
+    "        x = F.relu(self.conv1(x))  # Activation function between layers\n",
     "        \n",
+    "        x = F.relu(self.conv2(x))\n",
     "\n",
-    "        def __len__(self):\n",
-    "            return len(self.alldata)\n",
+    "        x = self.pool1(x)\n",
+    "        return x\n"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 38,
+   "id": "14013b2d-5847-4e1a-800e-edd273d8d791",
+   "metadata": {},
+   "outputs": [
+    {
+     "data": {
+      "text/plain": [
+       "{'label': tensor([0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),\n",
+       " 'coords': tensor([[ 0., 28., 18.],\n",
+       "         [ 0., 29., 48.],\n",
+       "         [ 0., 27., 25.],\n",
+       "         [ 0., 32., 17.],\n",
+       "         [ 0.,  8., 36.],\n",
+       "         [ 0., 19., 35.],\n",
+       "         [ 0., 33., 45.],\n",
+       "         [ 0.,  7., 25.],\n",
+       "         [ 0.,  6.,  5.],\n",
+       "         [ 0., 36., 35.]], dtype=torch.float64),\n",
+       " 'data': tensor([[-0.4918, -0.5943, -1.0721, -0.9575, -0.6650, -0.7359],\n",
+       "         [-0.6024, -1.1120, -0.5868,  0.0182,  0.7436, -0.2009],\n",
+       "         [-0.8743, -0.2060, -1.3125, -0.3913, -0.3318, -0.1418],\n",
+       "         [ 0.3684, -0.0516, -0.7292, -1.1248, -0.7590, -0.5693],\n",
+       "         [-0.7428, -0.7065, -1.0986, -0.8626, -1.0908, -1.0204],\n",
+       "         [ 0.0483, -0.7283,  1.1701, -0.0736, -1.2278, -0.2546],\n",
+       "         [-0.3632, -1.0483,  1.1965, -0.5309, -1.1567,  1.5961],\n",
+       "         [-1.2088, -0.7159, -0.7503, -0.7777, -0.2693, -0.7245],\n",
+       "         [-0.9576, -0.6151,  0.5618,  1.8565,  3.3299,  2.6075],\n",
+       "         [-0.3988, -0.2353,  0.0685, -1.2082, -0.7855, -1.1990]],\n",
+       "        dtype=torch.float64)}"
+      ]
+     },
+     "execution_count": 38,
+     "metadata": {},
+     "output_type": "execute_result"
+    }
+   ],
+   "source": [
+    "inps"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 33,
+   "id": "158d7836-db5c-4210-9814-43806dd777ad",
+   "metadata": {},
+   "outputs": [
+    {
+     "data": {
+      "text/plain": [
+       "torch.Size([153300, 2])"
+      ]
+     },
+     "execution_count": 33,
+     "metadata": {},
+     "output_type": "execute_result"
+    }
+   ],
+   "source": [
+    "torch.cat(outs,dim = 0).shape"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 24,
+   "id": "68243435-58a8-4717-ae96-bd281fbd64c5",
+   "metadata": {},
+   "outputs": [],
+   "source": [
+    "model = SpectralAttentionNet(len(kinds),16,2)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 25,
+   "id": "0dde6efa-3ce3-4f89-abc6-5893e066f9dc",
+   "metadata": {
+    "scrolled": true
+   },
+   "outputs": [
+    {
+     "data": {
+      "text/plain": [
+       "tensor([[-0.6669,  0.0875],\n",
+       "        [-0.7097,  0.0436],\n",
+       "        [-0.6941,  0.0615],\n",
+       "        [-0.6393,  0.1075],\n",
+       "        [-0.7090,  0.0438],\n",
+       "        [-0.7054,  0.0472],\n",
+       "        [-0.7099,  0.0442],\n",
+       "        [-0.7042,  0.0485],\n",
+       "        [-0.5686,  0.1150],\n",
+       "        [-0.7015,  0.0549]], grad_fn=<AddmmBackward0>)"
+      ]
+     },
+     "execution_count": 25,
+     "metadata": {},
+     "output_type": "execute_result"
+    }
+   ],
+   "source": [
+    "model(inps)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 19,
+   "id": "45e4cc12-5ef6-40ad-ad9e-45988ac7dbc1",
+   "metadata": {},
+   "outputs": [],
+   "source": [
     "\n",
-    "        \n",
     "\n",
-    "    \n",
-    "        \n",
-    "        "
+    "    "
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 18,
+   "id": "81dd05f3-bee8-43a4-8c51-f92e023bae25",
+   "metadata": {},
+   "outputs": [
+    {
+     "data": {
+      "text/html": [
+       "<div>\n",
+       "<style scoped>\n",
+       "    .dataframe tbody tr th:only-of-type {\n",
+       "        vertical-align: middle;\n",
+       "    }\n",
+       "\n",
+       "    .dataframe tbody tr th {\n",
+       "        vertical-align: top;\n",
+       "    }\n",
+       "\n",
+       "    .dataframe thead th {\n",
+       "        text-align: right;\n",
+       "    }\n",
+       "</style>\n",
+       "<table border=\"1\" class=\"dataframe\">\n",
+       "  <thead>\n",
+       "    <tr style=\"text-align: right;\">\n",
+       "      <th></th>\n",
+       "      <th>label</th>\n",
+       "      <th>h_idx</th>\n",
+       "      <th>nslice</th>\n",
+       "      <th>0</th>\n",
+       "      <th>1</th>\n",
+       "      <th>2</th>\n",
+       "      <th>3</th>\n",
+       "      <th>4</th>\n",
+       "      <th>5</th>\n",
+       "      <th>6</th>\n",
+       "      <th>...</th>\n",
+       "      <th>31</th>\n",
+       "      <th>32</th>\n",
+       "      <th>33</th>\n",
+       "      <th>34</th>\n",
+       "      <th>35</th>\n",
+       "      <th>36</th>\n",
+       "      <th>37</th>\n",
+       "      <th>38</th>\n",
+       "      <th>39</th>\n",
+       "      <th>40</th>\n",
+       "    </tr>\n",
+       "  </thead>\n",
+       "  <tbody>\n",
+       "    <tr>\n",
+       "      <th>4</th>\n",
+       "      <td>0</td>\n",
+       "      <td>0</td>\n",
+       "      <td>0</td>\n",
+       "      <td>2</td>\n",
+       "      <td>2</td>\n",
+       "      <td>0.001812</td>\n",
+       "      <td>0.002843</td>\n",
+       "      <td>0.001445</td>\n",
+       "      <td>0.003165</td>\n",
+       "      <td>0.002113</td>\n",
+       "      <td>...</td>\n",
+       "      <td>0.016286</td>\n",
+       "      <td>0.019752</td>\n",
+       "      <td>0.027634</td>\n",
+       "      <td>0.039219</td>\n",
+       "      <td>0.053746</td>\n",
+       "      <td>0.070735</td>\n",
+       "      <td>0.089852</td>\n",
+       "      <td>0.110827</td>\n",
+       "      <td>0.133419</td>\n",
+       "      <td>0.157407</td>\n",
+       "    </tr>\n",
+       "  </tbody>\n",
+       "</table>\n",
+       "<p>1 rows × 44 columns</p>\n",
+       "</div>"
+      ],
+      "text/plain": [
+       "   label  h_idx  nslice  0  1         2         3         4         5  \\\n",
+       "4      0      0       0  2  2  0.001812  0.002843  0.001445  0.003165   \n",
+       "\n",
+       "          6  ...        31        32        33        34        35        36  \\\n",
+       "4  0.002113  ...  0.016286  0.019752  0.027634  0.039219  0.053746  0.070735   \n",
+       "\n",
+       "         37        38        39        40  \n",
+       "4  0.089852  0.110827  0.133419  0.157407  \n",
+       "\n",
+       "[1 rows x 44 columns]"
+      ]
+     },
+     "execution_count": 18,
+     "metadata": {},
+     "output_type": "execute_result"
+    }
+   ],
+   "source": [
+    "# imagemask = (df['h_idx'] == 0)\n",
+    "# coordmask = ((df[0] == 1) and (df[1] == 1))\n",
+    "df[(df['h_idx'] == 0) & ((df[0] == 2) & (df[1] == 2))]"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "id": "52ef379d-ba80-4851-96d7-d9d6ba474406",
+   "metadata": {},
+   "outputs": [],
+   "source": []
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "id": "18686a3f-9652-4889-916e-8e70459381b4",
+   "metadata": {},
+   "outputs": [],
+   "source": []
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "id": "78b89c6b-8a3b-45e7-99a8-b00cfac50d49",
+   "metadata": {},
+   "outputs": [],
+   "source": []
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "id": "fd0a8ff8-df49-4b44-884f-588be5bc2d3c",
+   "metadata": {},
+   "outputs": [],
+   "source": []
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 6,
+   "id": "cad0fdc8-5c35-4610-bba3-b71e60dc1b98",
+   "metadata": {},
+   "outputs": [],
+   "source": [
+    "flags.DEFINE_integer(\"batch_size\", 100, \"Mini-batch size.\")\n",
+    "flags.DEFINE_st\n",
+    "flags.DEFINE_integer(\"input_size\",39,\"Input shape to model\")"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 7,
+   "id": "ce1b936b-8a7c-426e-a3aa-3c1c38f645de",
+   "metadata": {},
+   "outputs": [
+    {
+     "name": "stdout",
+     "output_type": "stream",
+     "text": [
+      "Loading 'penn_dataset' from penn_dataset.py\n"
+     ]
+    }
+   ],
+   "source": [
+    "config = forge.config()\n",
+    "loaddat = fet.load(\"penn_dataset.py\",config) # loaddat[fold][train/test][batch][data]"
    ]
   },
   {
    "cell_type": "code",
-   "execution_count": 104,
-   "id": "3223f768-c908-4065-b93e-27326369b028",
+   "execution_count": 5,
+   "id": "4469cddf-4dac-4468-be88-241d440401c3",
    "metadata": {},
    "outputs": [
     {
      "name": "stdout",
      "output_type": "stream",
      "text": [
-      "./penn_data/kvals_fuse_rotate_aaa0060.csv\n",
-      "./penn_data/kvals_fuse_rotate_aaa0061.csv\n",
-      "./penn_data/kvals_fuse_rotate_aaa0063.csv\n"
+      "Loading 'basic_feedforward' from basic_feedforward.py\n"
      ]
     }
    ],
    "source": [
-    "penn = PennData(data_dir,headings[2:5])"
+    "model,modelname = fet.load(\"basic_feedforward.py\",config)"
    ]
   },
   {
    "cell_type": "code",
-   "execution_count": 106,
-   "id": "3bc22e44-c11e-4a45-abfc-1408e9b5beb6",
+   "execution_count": 13,
+   "id": "7c9a9fe9-f5e8-456a-b964-4be13027725b",
    "metadata": {},
    "outputs": [
     {
      "data": {
       "text/plain": [
-       "24385"
+       "array([114170,    904])"
       ]
      },
-     "execution_count": 106,
+     "execution_count": 13,
      "metadata": {},
      "output_type": "execute_result"
     }
    ],
    "source": [
-    "testdat = penn.alldata\n",
-    "len(testdat)"
+    "np.bincount(loaddat[0]['train'].dataset.all_labels)"
    ]
   },
   {
    "cell_type": "code",
    "execution_count": null,
-   "id": "51f7cd80-7ba7-4782-ad50-778ac7a4bfa0",
+   "id": "c5365067-c017-41b4-9b6b-3752b3d100e8",
    "metadata": {},
    "outputs": [],
-   "source": [
-    "poslocs"
-   ]
+   "source": []
   },
   {
    "cell_type": "code",
diff --git a/.ipynb_checkpoints/todo-checkpoint.txt b/.ipynb_checkpoints/todo-checkpoint.txt
index 0fd9ad1..b151bc9 100644
--- a/.ipynb_checkpoints/todo-checkpoint.txt
+++ b/.ipynb_checkpoints/todo-checkpoint.txt
@@ -1,10 +1,7 @@
 To Do on modeling:
 
-- write results to file with deepdish, then read them to compare models
+- Try new padding scheme
 
-- get code working with a subset of kvals
-
-- get Conv1d working as an architecture
-
-- consider patch-attention based strategy
+- Test and fit selected models more completely
 
+- Extract model predictions for ROC etc from visual models
diff --git a/__pycache__/basic_feedforward.cpython-39.pyc b/__pycache__/basic_feedforward.cpython-39.pyc
index 4a02232..bf9f853 100644
Binary files a/__pycache__/basic_feedforward.cpython-39.pyc and b/__pycache__/basic_feedforward.cpython-39.pyc differ
diff --git a/__pycache__/eval_tools.cpython-39.pyc b/__pycache__/eval_tools.cpython-39.pyc
index cbe6232..b956105 100644
Binary files a/__pycache__/eval_tools.cpython-39.pyc and b/__pycache__/eval_tools.cpython-39.pyc differ
diff --git a/__pycache__/penn_dataset.cpython-39.pyc b/__pycache__/penn_dataset.cpython-39.pyc
index ea4dbe7..4251292 100644
Binary files a/__pycache__/penn_dataset.cpython-39.pyc and b/__pycache__/penn_dataset.cpython-39.pyc differ
diff --git a/analyze_models.ipynb b/analyze_models.ipynb
index e7c8b8b..a701b99 100644
--- a/analyze_models.ipynb
+++ b/analyze_models.ipynb
@@ -10,249 +10,13 @@
     "import numpy as np\n",
     "import matplotlib.pyplot as plt\n",
     "from os import path as osp\n",
-    "import eval_tools as eval"
+    "import eval_tools as eval\n",
+    "import deepdish as dd"
    ]
   },
   {
    "cell_type": "code",
    "execution_count": 2,
-   "id": "53e1a620-38c0-45ed-aebc-5b35dfdd390c",
-   "metadata": {},
-   "outputs": [],
-   "source": [
-    "import torch\n",
-    "import numpy as np\n",
-    "import json\n",
-    "import torch.nn.functional as F\n",
-    "import deepdish as dd\n",
-    "\n",
-    "import torchmetrics\n",
-    "from torchmetrics.classification import BinaryConfusionMatrix\n",
-    "\n",
-    "import matplotlib.pyplot as plt\n",
-    "from os import path as osp\n",
-    "import os\n",
-    "import re\n",
-    "import h5py\n",
-    "\n",
-    "import forge\n",
-    "from forge import flags\n",
-    "import forge.experiment_tools as fet\n",
-    "from forge import load_from_checkpoint\n",
-    "from attrdict import AttrDict\n",
-    "\n",
-    "from train_tools import param_count,nested_to\n",
-    "from scipy.interpolate import interp1d"
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 3,
-   "id": "33eab461-6ffd-465d-8004-048197bf8a96",
-   "metadata": {},
-   "outputs": [],
-   "source": [
-    "def get_acc(arr): # get accuracy of set of confusion matrices\n",
-    "    # arr.shape (n_thresholds,2,2)\n",
-    "    return np.array([(x[1,1] + x[0,0])/(x[0,0] + x[0,1] + x[1,0] + x[1,1]) if (x[0,0] + x[0,1] + x[1,0] + x[1,1]) else 0 for x in arr])\n",
-    "\n",
-    "def get_prec(arr): # get precision of set of confusion matrices\n",
-    "    # arr.shape (n_thresholds,2,2)\n",
-    "    return np.array([(x[1,1])/(x[1,1] + x[0,1]) if (x[1,1] + x[0,1]) > 0 else 0 for x in arr])\n",
-    "\n",
-    "def get_tpr(arr): # get true positive rate/recall of set of confusion matrices\n",
-    "    # arr.shape (n_thresholds,2,2)\n",
-    "    return np.array([(x[1,1])/(x[1,1] + x[1,0]) if (x[1,1] + x[1,0]) > 0 else 0 for x in arr])\n",
-    "\n",
-    "def get_fpr(arr): # get false positive rate of set of confusion matrices\n",
-    "    # arr.shape (n_thresholds,2,2)\n",
-    "    return np.array([(x[0,1])/(x[0,1] + x[0,0]) if (x[0,1] + x[0,0]) > 0 else 0 for x in arr])\n",
-    "\n",
-    "def get_F1(arr): # get F1-score of set of confusion matrices\n",
-    "    # arr.shape (n_thresholds,2,2)\n",
-    "    return np.array([2*x[1,1]/(2*x[1,1] + x[0,1] + x[1,0]) if (2*x[1,1] + x[0,1] + x[1,0]) > 0 else 0 for x in arr])\n"
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 12,
-   "id": "e0dfe2b8-8b27-4bdd-a2d4-8d432ca3cdea",
-   "metadata": {},
-   "outputs": [],
-   "source": [
-    "def get_metrics(run_dir,n_thresholds =100,checkpoint_num = None,softmax = True,nonlin_thresholds = False):\n",
-    "    # run directory should contain folders 1,2,3... \n",
-    "    if nonlin_thresholds:\n",
-    "        num_elements = n_thresholds\n",
-    "\n",
-    "        # Create a non-linear space with more density at lower values\n",
-    "        # Using exponential space for higher resolution at smaller thresholds\n",
-    "        # Adjust the base of the exponential to control the distribution\n",
-    "        non_linear_part = np.exp(np.linspace(-np.log(1000), 0, num_elements // 2))\n",
-    "        \n",
-    "        # Create a linear space for the higher thresholds\n",
-    "        linear_part = np.linspace(0, 1, num_elements // 2)\n",
-    "        \n",
-    "        # Combine both parts\n",
-    "        thresholds = np.unique(np.concatenate([non_linear_part, linear_part]))\n",
-    "        \n",
-    "        # Ensure the thresholds are sorted (necessary if combining different spaces)\n",
-    "        thresholds.sort()\n",
-    "    else:\n",
-    "        thresholds = np.linspace(1e-8,1,n_thresholds)\n",
-    "    BCM = BinaryConfusionMatrix()\n",
-    "    ###########\n",
-    "    # Note: BCM = [[TN,FP],[FN,TP]] \n",
-    "    \n",
-    "    if checkpoint_num is None: # if None, get most recent directory\n",
-    "        checkpoint_num = max([int(x) for x in os.listdir(run_dir) if osp.isdir(os.path.join(run_dir, x))])\n",
-    "\n",
-    "    working_dir = osp.join(run_dir,str(checkpoint_num))\n",
-    "    print(\"Getting metrics from\",working_dir)\n",
-    "    flag_file = osp.join(working_dir,'flags.json')\n",
-    "    with open(flag_file, 'r') as file:\n",
-    "        flag_info = json.load(file)\n",
-    "    config = AttrDict(flag_info)\n",
-    "\n",
-    "    model_config = osp.join(working_dir,config['model_config'])\n",
-    "    data_config = osp.join(working_dir,config['data_config'])\n",
-    "\n",
-    "    # print(model_config)\n",
-    "    # print(data_config)\n",
-    "\n",
-    "    # load model (same for all kfolds)\n",
-    "    model,model_name = fet.load(model_config,config)\n",
-    "\n",
-    "    # load data\n",
-    "    kfold_loaders = fet.load(data_config, config)\n",
-    "    nfolds = len(kfold_loaders)\n",
-    "    print(\"Data is {}-fold partitioned.\".format(nfolds))\n",
-    "\n",
-    "    conf_shape = (nfolds,n_thresholds,2,2)\n",
-    "    # list of confusion matrices (nfolds,n_thresholds)\n",
-    "    conf_mats = {'train':np.zeros(conf_shape),\n",
-    "                 'test':np.zeros(conf_shape),\n",
-    "                 'val':np.zeros(conf_shape)} \n",
-    "\n",
-    "    results = {'thresholds':thresholds,'config':config,'params':param_count(model)}\n",
-    "\n",
-    "    test_times = []\n",
-    "    test_losses = []\n",
-    "    train_iters = []\n",
-    "    train_losses = []\n",
-    "    # val_times = [] # these are mostly redundant for now\n",
-    "    # val_losses = []\n",
-    "\n",
-    "    ###########################################\n",
-    "    # RECORD METRICS, CONFUSION MATRICES FOR ALL THRESHOLDS FOR ALL FOLDS, MODELS\n",
-    "    \n",
-    "    for k,loader_dict in enumerate(kfold_loaders):\n",
-    "        print(\"Evaluating fold {}...\".format(k+1))\n",
-    "        fold_dir = osp.join(working_dir,\"data_fold{}\".format(k+1))\n",
-    "\n",
-    "        # record times and losses from results_dict.h5\n",
-    "        test_reports = dd.io.load(osp.join(fold_dir,'results_dict.h5'))\n",
-    "        test_times.append(test_reports['time']/max(test_reports['time']))\n",
-    "        test_losses.append(test_reports['cross_entropy'])\n",
-    "\n",
-    "        iters,losses = np.array(dd.io.load(osp.join(fold_dir,'results_dict_train.h5'))).T\n",
-    "        train_iters.append(iters)\n",
-    "        train_losses.append(losses)\n",
-    "        # val_reports = dd.io.load(osp.join(fold_dir,'results_dict_val.h5'))\n",
-    "        # val_times.append(val_reports['time'])\n",
-    "        # val_losses.append(val_reports['cross_entropy']\n",
-    "        \n",
-    "        # find and load latest model checkpoint in fold dir\n",
-    "        model_ckpt_name = \"model_fold{}.ckpt-\".format(k+1)\n",
-    "        ckpt_files = [f for f in os.listdir(fold_dir) if f.startswith(model_ckpt_name) and re.search(r'\\d+$', f)]\n",
-    "        latest_ckpt = max(ckpt_files, key=lambda x: int(re.search(r'(\\d+)$', x).group()), default=None)\n",
-    "\n",
-    "        ckpt_file = osp.join(fold_dir, latest_ckpt)\n",
-    "        \n",
-    "        # load model weights from final checkpoint and set to evaluation mode\n",
-    "        model_wts = torch.load(ckpt_file)\n",
-    "\n",
-    "        model.load_state_dict(model_wts['model_state_dict'])\n",
-    "        model.eval()\n",
-    "\n",
-    "        # set up model to make binary int class predictions from logit output\n",
-    "        # def model_preds(x,threshold = 0.5,softmax = True):\n",
-    "        #     if softmax:\n",
-    "        #         probs = np.array(F.softmax(model(x),dim=1))\n",
-    "        #     else:\n",
-    "        #         probs = np.array(model(x))\n",
-    "        #     print(probs[:,1])\n",
-    "        #     preds = np.zeros(len(probs),dtype = int)\n",
-    "        #     preds[probs[:,1] > threshold] = 1 # CONFUSED ABOUT DIRECTION OF THIS INEQ\n",
-    "        #     return torch.tensor(preds)\n",
-    "\n",
-    "        for subset in conf_mats.keys(): # loop over train,test,val data subsets\n",
-    "            print(\"in subset\",subset)\n",
-    "            loader = loader_dict[subset] # specific dataloader\n",
-    "            \n",
-    "            all_labels = torch.tensor(loader.dataset.labels) # all predictions\n",
-    "            # print('truelabels counts',np.bincount(all_labels))\n",
-    "            all_data = torch.tensor(loader.dataset.data).float() # all inputs\n",
-    "\n",
-    "            with torch.no_grad():\n",
-    "                if softmax:\n",
-    "                    probs = np.array(F.softmax(model(all_data),dim=1))\n",
-    "                else:\n",
-    "                    probs = np.array(model(all_data))\n",
-    "\n",
-    "            for ii,t in enumerate(thresholds): # for all classification thresholds,\n",
-    "                 # make binary predicitions at this threshold,\n",
-    "                    # print('threshold',t)\n",
-    "                    # all_preds = model_preds(all_data,threshold = t)\n",
-    "                all_preds = np.zeros(len(probs),dtype = int)\n",
-    "                \n",
-    "                all_preds[probs[:,1] > t] = 1 # as threshold increases, fewer positives (FPR-> 0)\n",
-    "\n",
-    "                all_preds = torch.tensor(all_preds)\n",
-    "\n",
-    "                # compute confusion matrix\n",
-    "                binary_confusion_matrix = np.array(BCM(all_preds,all_labels),dtype = int)\n",
-    "\n",
-    "                # record confusion matrix\n",
-    "                conf_mats[subset][k][ii] = binary_confusion_matrix\n",
-    "\n",
-    "    ##########################################################\n",
-    "    # AGGREGATE PREDICTIONS OVER DATA FOLDS AND RETURN METRICS\n",
-    "\n",
-    "    # collect loss vs. time data from training\n",
-    "    results['test_time'] = test_times\n",
-    "    results['test_loss'] = test_losses\n",
-    "\n",
-    "    results['train_iter'] = train_iters\n",
-    "    results['train_loss'] = train_losses\n",
-    "    \n",
-    "    common_t = np.linspace(0, 1, 100)\n",
-    "    interpolated_y_values = np.array([interp1d(x, y, bounds_error=False, fill_value='extrapolate')(common_t) for x, y in zip(test_times, test_losses)])\n",
-    "    average_loss = np.mean(interpolated_y_values, axis=0)\n",
-    "    \n",
-    "    results['avg_loss'] = (common_t,average_loss)\n",
-    "    \n",
-    "    print(\"Models evaluated. Computing metrics...\")\n",
-    "    for subset in conf_mats.keys(): # for train, test, val\n",
-    "        thresh_mats = np.sum(conf_mats[subset],axis = 0) # sum confusion matrices over data folds\n",
-    "        \n",
-    "        # compute accuracy\n",
-    "        results[subset+'_acc'] = get_acc(thresh_mats)\n",
-    "        # compute precision\n",
-    "        results[subset+'_prec'] = get_prec(thresh_mats)\n",
-    "        # compute TPR\n",
-    "        results[subset+'_tpr'] = get_tpr(thresh_mats)\n",
-    "        # compute FPR\n",
-    "        results[subset+'_fpr'] = get_fpr(thresh_mats)\n",
-    "        # compute F1 score\n",
-    "        results[subset+'_F1'] = get_F1(thresh_mats)\n",
-    "    print(\"Done.\")\n",
-    "    return results"
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 13,
    "id": "14bf950d-a4f6-43a5-a1f1-51fd50ea0a8d",
    "metadata": {
     "scrolled": true
@@ -262,62 +26,409 @@
      "name": "stdout",
      "output_type": "stream",
      "text": [
-      "Getting metrics from checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2\n",
-      "Loading 'basic_feedforward' from checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/basic_feedforward.py\n",
-      "Loading 'penn_dataset' from checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/penn_dataset.py\n",
+      "Getting metrics from checkpoints/penn_data/basicFFNN/demo/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_nrep1_/1\n",
+      "Loading 'basic_feedforward' from checkpoints/penn_data/basicFFNN/demo/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_nrep1_/1/basic_feedforward.py\n",
+      "Loading 'penn_dataset' from checkpoints/penn_data/basicFFNN/demo/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_nrep1_/1/penn_dataset.py\n",
       "Data is 5-fold partitioned.\n",
       "Evaluating fold 1...\n",
-      "in subset train\n",
-      "in subset test\n",
-      "in subset val\n",
+      "in subset train\n"
+     ]
+    },
+    {
+     "name": "stderr",
+     "output_type": "stream",
+     "text": [
+      "100%|█████████████████████████████████████| 1151/1151 [00:00<00:00, 1420.97it/s]\n"
+     ]
+    },
+    {
+     "name": "stdout",
+     "output_type": "stream",
+     "text": [
+      "model evaluated.\n",
+      "in subset test\n"
+     ]
+    },
+    {
+     "name": "stderr",
+     "output_type": "stream",
+     "text": [
+      "100%|█████████████████████████████████████████| 94/94 [00:00<00:00, 1681.84it/s]"
+     ]
+    },
+    {
+     "name": "stdout",
+     "output_type": "stream",
+     "text": [
+      "model evaluated.\n"
+     ]
+    },
+    {
+     "name": "stderr",
+     "output_type": "stream",
+     "text": [
+      "\n"
+     ]
+    },
+    {
+     "name": "stdout",
+     "output_type": "stream",
+     "text": [
+      "in subset val\n"
+     ]
+    },
+    {
+     "name": "stderr",
+     "output_type": "stream",
+     "text": [
+      "100%|███████████████████████████████████████| 289/289 [00:00<00:00, 1456.41it/s]\n"
+     ]
+    },
+    {
+     "name": "stdout",
+     "output_type": "stream",
+     "text": [
+      "model evaluated.\n",
       "Evaluating fold 2...\n",
-      "in subset train\n",
-      "in subset test\n",
-      "in subset val\n",
+      "in subset train\n"
+     ]
+    },
+    {
+     "name": "stderr",
+     "output_type": "stream",
+     "text": [
+      "100%|█████████████████████████████████████| 1213/1213 [00:00<00:00, 1626.16it/s]\n"
+     ]
+    },
+    {
+     "name": "stdout",
+     "output_type": "stream",
+     "text": [
+      "model evaluated.\n",
+      "in subset test\n"
+     ]
+    },
+    {
+     "name": "stderr",
+     "output_type": "stream",
+     "text": [
+      "100%|███████████████████████████████████████| 229/229 [00:00<00:00, 1818.79it/s]"
+     ]
+    },
+    {
+     "name": "stdout",
+     "output_type": "stream",
+     "text": [
+      "model evaluated.\n"
+     ]
+    },
+    {
+     "name": "stderr",
+     "output_type": "stream",
+     "text": [
+      "\n"
+     ]
+    },
+    {
+     "name": "stdout",
+     "output_type": "stream",
+     "text": [
+      "in subset val\n"
+     ]
+    },
+    {
+     "name": "stderr",
+     "output_type": "stream",
+     "text": [
+      "100%|█████████████████████████████████████████| 93/93 [00:00<00:00, 1667.57it/s]"
+     ]
+    },
+    {
+     "name": "stdout",
+     "output_type": "stream",
+     "text": [
+      "model evaluated.\n"
+     ]
+    },
+    {
+     "name": "stderr",
+     "output_type": "stream",
+     "text": [
+      "\n"
+     ]
+    },
+    {
+     "name": "stdout",
+     "output_type": "stream",
+     "text": [
       "Evaluating fold 3...\n",
-      "in subset train\n",
-      "in subset test\n",
-      "in subset val\n",
+      "in subset train\n"
+     ]
+    },
+    {
+     "name": "stderr",
+     "output_type": "stream",
+     "text": [
+      "100%|█████████████████████████████████████| 1275/1275 [00:00<00:00, 1751.81it/s]\n"
+     ]
+    },
+    {
+     "name": "stdout",
+     "output_type": "stream",
+     "text": [
+      "model evaluated.\n",
+      "in subset test\n"
+     ]
+    },
+    {
+     "name": "stderr",
+     "output_type": "stream",
+     "text": [
+      "100%|███████████████████████████████████████| 177/177 [00:00<00:00, 1595.66it/s]"
+     ]
+    },
+    {
+     "name": "stdout",
+     "output_type": "stream",
+     "text": [
+      "model evaluated.\n"
+     ]
+    },
+    {
+     "name": "stderr",
+     "output_type": "stream",
+     "text": [
+      "\n"
+     ]
+    },
+    {
+     "name": "stdout",
+     "output_type": "stream",
+     "text": [
+      "in subset val\n"
+     ]
+    },
+    {
+     "name": "stderr",
+     "output_type": "stream",
+     "text": [
+      "100%|█████████████████████████████████████████| 83/83 [00:00<00:00, 1982.76it/s]"
+     ]
+    },
+    {
+     "name": "stdout",
+     "output_type": "stream",
+     "text": [
+      "model evaluated.\n"
+     ]
+    },
+    {
+     "name": "stderr",
+     "output_type": "stream",
+     "text": [
+      "\n"
+     ]
+    },
+    {
+     "name": "stdout",
+     "output_type": "stream",
+     "text": [
       "Evaluating fold 4...\n",
-      "in subset train\n",
-      "in subset test\n",
-      "in subset val\n",
+      "in subset train\n"
+     ]
+    },
+    {
+     "name": "stderr",
+     "output_type": "stream",
+     "text": [
+      "100%|█████████████████████████████████████| 1272/1272 [00:00<00:00, 1423.73it/s]\n"
+     ]
+    },
+    {
+     "name": "stdout",
+     "output_type": "stream",
+     "text": [
+      "model evaluated.\n",
+      "in subset test\n"
+     ]
+    },
+    {
+     "name": "stderr",
+     "output_type": "stream",
+     "text": [
+      "100%|███████████████████████████████████████| 213/213 [00:00<00:00, 1716.40it/s]"
+     ]
+    },
+    {
+     "name": "stdout",
+     "output_type": "stream",
+     "text": [
+      "model evaluated.\n"
+     ]
+    },
+    {
+     "name": "stderr",
+     "output_type": "stream",
+     "text": [
+      "\n"
+     ]
+    },
+    {
+     "name": "stdout",
+     "output_type": "stream",
+     "text": [
+      "in subset val\n"
+     ]
+    },
+    {
+     "name": "stderr",
+     "output_type": "stream",
+     "text": [
+      "100%|█████████████████████████████████████████| 49/49 [00:00<00:00, 1250.04it/s]"
+     ]
+    },
+    {
+     "name": "stdout",
+     "output_type": "stream",
+     "text": [
+      "model evaluated.\n"
+     ]
+    },
+    {
+     "name": "stderr",
+     "output_type": "stream",
+     "text": [
+      "\n"
+     ]
+    },
+    {
+     "name": "stdout",
+     "output_type": "stream",
+     "text": [
       "Evaluating fold 5...\n",
-      "in subset train\n",
-      "in subset test\n",
-      "in subset val\n",
+      "in subset train\n"
+     ]
+    },
+    {
+     "name": "stderr",
+     "output_type": "stream",
+     "text": [
+      "100%|█████████████████████████████████████| 1224/1224 [00:00<00:00, 1561.67it/s]\n"
+     ]
+    },
+    {
+     "name": "stdout",
+     "output_type": "stream",
+     "text": [
+      "model evaluated.\n",
+      "in subset test\n"
+     ]
+    },
+    {
+     "name": "stderr",
+     "output_type": "stream",
+     "text": [
+      "100%|████████████████████████████████████████| 221/221 [00:00<00:00, 930.23it/s]\n"
+     ]
+    },
+    {
+     "name": "stdout",
+     "output_type": "stream",
+     "text": [
+      "model evaluated.\n",
+      "in subset val\n"
+     ]
+    },
+    {
+     "name": "stderr",
+     "output_type": "stream",
+     "text": [
+      "100%|█████████████████████████████████████████| 90/90 [00:00<00:00, 1253.73it/s]"
+     ]
+    },
+    {
+     "name": "stdout",
+     "output_type": "stream",
+     "text": [
+      "model evaluated.\n"
+     ]
+    },
+    {
+     "name": "stderr",
+     "output_type": "stream",
+     "text": [
+      "\n"
+     ]
+    },
+    {
+     "name": "stdout",
+     "output_type": "stream",
+     "text": [
       "Models evaluated. Computing metrics...\n",
+      "Writing metrics to file checkpoints/penn_data/basicFFNN/demo/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_nrep1_/1/metrics.h5\n",
       "Done.\n"
      ]
     }
    ],
    "source": [
     "general_dir = 'checkpoints/penn_data'\n",
-    "run_name = 'gpt-FCNN/hyperparam_testing'\n",
-    "specific_run = \"bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_\"\n",
+    "run_name = 'basicFFNN/demo'\n",
+    "specific_run = \"bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_nrep1_\"\n",
     "runDir = osp.join(general_dir,run_name,specific_run)\n",
-    "info = get_metrics(runDir,n_thresholds = 1000,nonlin_thresholds = False)"
+    "info = eval.get_metrics(runDir,n_thresholds = 1000,nonlin_thresholds = False)"
    ]
   },
   {
    "cell_type": "code",
-   "execution_count": 14,
-   "id": "2bd1188b-3032-4e11-bfe1-ff121b7fa28e",
+   "execution_count": 24,
+   "id": "6b6f0bf3-ebdf-4bc1-9faa-c53bc3305815",
+   "metadata": {},
+   "outputs": [],
+   "source": [
+    "# # LOAD MODEL FROM FILE\n",
+    "# save_dir = 'model_evals'\n",
+    "# metricDict = 'FFNN_basic_metrics.h5'\n",
+    "# info = dd.io.load('test.h5')"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 3,
+   "id": "8fa7d522-a68a-401a-a426-0c7f9f3f1b1a",
    "metadata": {},
    "outputs": [
     {
      "data": {
       "text/plain": [
-       "[<matplotlib.lines.Line2D at 0x3052a0f10>]"
+       "4898"
       ]
      },
-     "execution_count": 14,
+     "execution_count": 3,
      "metadata": {},
      "output_type": "execute_result"
-    },
+    }
+   ],
+   "source": [
+    "info['params']"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "id": "ff0548de-9fd3-4b6b-b015-d43325c2c3f6",
+   "metadata": {},
+   "source": [
+    "#### Plot training loss"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 4,
+   "id": "2bd1188b-3032-4e11-bfe1-ff121b7fa28e",
+   "metadata": {},
+   "outputs": [
     {
      "data": {
-      "image/png": "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",
+      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAl0AAAHHCAYAAACFl+2TAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjguMywgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy/H5lhTAAAACXBIWXMAAA9hAAAPYQGoP6dpAAEAAElEQVR4nOzdd3iTVfvA8W+SpntDF9BFGZYtIGUP2SIIoqKijBdBEURBEVEEwQEvooALBIXyU3kFQQURygaVPURWGS2FMtrSQfdImjy/PwJpQws0LXTg/bmuXCYn5zzPedpI7p5znvuoFEVREEIIIYQQ95S6ojsghBBCCPFvIEGXEEIIIUQ5kKBLCCGEEKIcSNAlhBBCCFEOJOgSQgghhCgHEnQJIYQQQpQDCbqEEEIIIcqBBF1CCCGEEOVAgi4hhBBCiHIgQZcQ97lhw4YRFBRUqrbvvfceKpXq7naohMrS7/uNSqXivffeq+hulNj58+dRqVSEh4dXdFeEqFQk6BKigqhUqhI9duzYUdFdFZXM7t27ee+990hNTa3Qfixfvpx58+ZVaB+EqEpUsveiEBXj+++/t3j9f//3f2zevJnvvvvOorx79+74+PiU+jx6vR6j0YidnZ3VbfPz88nPz8fe3r7U5y+tYcOGsWPHDs6fP1/u565scnNzsbGxwcbGBoA5c+YwceJEYmJiKnQ08NFHH+X48eNFfkeKopCXl4dWq0Wj0VRM54SohGwqugNC/Fs999xzFq/37t3L5s2bi5TfLDs7G0dHxxKfR6vVlqp/gMUXvag45RX0WvvZuhWVSlUhgboQlZ1MLwpRiXXu3JlGjRpx6NAhOnbsiKOjI2+//TYAa9asoU+fPtSoUQM7OztCQkJ4//33MRgMFse4eW3UjfU2c+bMYdGiRYSEhGBnZ8dDDz3EgQMHLNoWt6ZLpVIxduxYfv31Vxo1aoSdnR0NGzYkIiKiSP937NhBy5Ytsbe3JyQkhK+//rpM68SysrJ4/fXX8ff3x87Ojvr16zNnzhxuHrDfvHkz7du3x93dHWdnZ+rXr2/+ud3w+eef07BhQxwdHfHw8KBly5YsX778ludOSEjAxsaG6dOnF3nv9OnTqFQqvvjiC8A0ujh9+nTq1q2Lvb091apVo3379mzevLlU1114Tdd7773HxIkTAQgODjZPQxcebfr+++9p0aIFDg4OeHp68vTTT3Px4kWLY5b1s9W5c2d+//13Lly4YO7Djc/ZrdZ0bdu2jQ4dOuDk5IS7uzuPPfYYkZGRFnVufD6ioqIYNmwY7u7uuLm5MXz4cLKzs0v18xOispA/YYWo5JKTk+nduzdPP/00zz33nHmqMTw8HGdnZyZMmICzszPbtm1j6tSppKen8/HHH9/xuMuXLycjI4MXX3wRlUrF7Nmzefzxxzl37twdR8f++usvfv75Z15++WVcXFz47LPPGDhwILGxsVSrVg2Av//+m169euHn58f06dMxGAzMmDEDLy+vUv0cFEWhX79+bN++nREjRtCsWTM2btzIxIkTuXz5MnPnzgXgxIkTPProozRp0oQZM2ZgZ2dHVFQUu3btMh9r8eLFjBs3jieeeIJXX32V3Nxcjh49yr59+3j22WeLPb+Pjw+dOnVi5cqVTJs2zeK9FStWoNFoePLJJwFT4DBz5kxeeOEFWrVqRXp6OgcPHuTw4cN07969VNd/w+OPP86ZM2f43//+x9y5c6levTqA+ef64Ycf8u677/LUU0/xwgsvkJiYyOeff07Hjh35+++/cXd3Nx+rLJ+td955h7S0NC5dumT+2Ts7O9+y31u2bKF3797Url2b9957j5ycHD7//HPatWvH4cOHi0yTPvXUUwQHBzNz5kwOHz7MN998g7e3N//973/L9PMTokIpQohKYcyYMcrN/0t26tRJAZSFCxcWqZ+dnV2k7MUXX1QcHR2V3Nxcc9nQoUOVwMBA8+uYmBgFUKpVq6akpKSYy9esWaMAym+//WYumzZtWpE+AYqtra0SFRVlLvvnn38UQPn888/NZX379lUcHR2Vy5cvm8vOnj2r2NjYFDlmcW7u96+//qoAygcffGBR74knnlBUKpW5P3PnzlUAJTEx8ZbHfuyxx5SGDRvesQ83+/rrrxVAOXbsmEV5gwYNlIcfftj8umnTpkqfPn2sPv6tAMq0adPMrz/++GMFUGJiYizqnT9/XtFoNMqHH35oUX7s2DHFxsbGovxufLb69Olj8Tu64cZnbOnSpeayZs2aKd7e3kpycrK57J9//lHUarUyZMgQc9mNz9x//vMfi2MOGDBAqVatWpFzCVGVyPSiEJWcnZ0dw4cPL1Lu4OBgfp6RkUFSUhIdOnQgOzubU6dO3fG4gwYNwsPDw/y6Q4cOAJw7d+6Obbt160ZISIj5dZMmTXB1dTW3NRgMbNmyhf79+1OjRg1zvTp16tC7d+87Hr8469evR6PRMG7cOIvy119/HUVR2LBhA4B5JGfNmjUYjcZij+Xu7s6lS5eKTKfeyeOPP46NjQ0rVqwwlx0/fpyTJ08yaNAgi+OfOHGCs2fPWnX8svr5558xGo089dRTJCUlmR++vr7UrVuX7du3W9S/V5+tm8XFxXHkyBGGDRuGp6enubxJkyZ0796d9evXF2nz0ksvWbzu0KEDycnJpKenW31+ISoLCbqEqORq1qyJra1tkfITJ04wYMAA3NzccHV1xcvLy7wIPy0t7Y7HDQgIsHh9IwC7du2a1W1vtL/R9urVq+Tk5FCnTp0i9YorK4kLFy5Qo0YNXFxcLMpDQ0PN74MpmGzXrh0vvPACPj4+PP3006xcudIiAJs0aRLOzs60atWKunXrMmbMGIvpx1upXr06Xbt2ZeXKleayFStWYGNjw+OPP24umzFjBqmpqdSrV4/GjRszceJEjh49WqrrtsbZs2dRFIW6devi5eVl8YiMjOTq1asW9e/VZ+tmN3439evXL/JeaGgoSUlJZGVlWZSX5fMpRGUla7qEqOQKjzrckJqaSqdOnXB1dWXGjBmEhIRgb2/P4cOHmTRp0i1HeAq71a38SgmyyJSl7b3m4ODAH3/8wfbt2/n999+JiIhgxYoVPPzww2zatAmNRkNoaCinT59m3bp1REREsHr1ar766iumTp1a7EL5wp5++mmGDx/OkSNHaNasGStXrqRr167mtVUAHTt2JDo6mjVr1rBp0ya++eYb5s6dy8KFC3nhhRfu2bUbjUZUKhUbNmwo9nd085qre/XZuhsq82dMiNKSoEuIKmjHjh0kJyfz888/07FjR3N5TExMBfaqgLe3N/b29kRFRRV5r7iykggMDGTLli1kZGRYjHbdmO4KDAw0l6nVarp27UrXrl359NNP+eijj3jnnXfYvn073bp1A8DJyYlBgwYxaNAgdDodjz/+OB9++CGTJ0++bbqD/v378+KLL5qnGM+cOcPkyZOL1PP09GT48OEMHz6czMxMOnbsyHvvvXdXgq5b3f0ZEhKCoigEBwdTr169Uh3bms9WSe9CvfG7OX36dJH3Tp06RfXq1XFycipVf4WoSmR6UYgq6MYoQOG/+nU6HV999VVFdcmCRqOhW7du/Prrr1y5csVcHhUVZV57Za1HHnkEg8FgTstww9y5c1GpVOa1YikpKUXaNmvWDIC8vDzAdNdeYba2tjRo0ABFUdDr9bfth7u7Oz179mTlypX8+OOP2Nra0r9/f4s6Nx/f2dmZOnXqmM8Ppmm6U6dOlWq67kaAcnNG+scffxyNRsP06dOLjAgpilKkX8Wx5rPl5ORUov77+fnRrFkzli1bZtHn48ePs2nTJh555JE7HkOI+4GMdAlRBbVt2xYPDw+GDh3KuHHjUKlUfPfdd5Vq6uW9995j06ZNtGvXjtGjR5sDpkaNGnHkyBGrj9e3b1+6dOnCO++8w/nz52natCmbNm1izZo1vPbaa+aF/TNmzOCPP/6gT58+BAYGcvXqVb766itq1apF+/btAejRowe+vr60a9cOHx8fIiMj+eKLL+jTp0+RNWPFGTRoEM899xxfffUVPXv2tEjDANCgQQM6d+5MixYt8PT05ODBg6xatYqxY8ea6/zyyy8MHz6cpUuXMmzYMKt+Fi1atABMaRuefvpptFotffv2JSQkhA8++IDJkydz/vx5+vfvj4uLCzExMfzyyy+MGjWKN95447bHtuaz1aJFC1asWMGECRN46KGHcHZ2pm/fvsUe9+OPP6Z37960adOGESNGmFNGuLm5Val9JYUoCwm6hKiCqlWrxrp163j99deZMmUKHh4ePPfcc3Tt2pWePXtWdPcA0xfyhg0beOONN3j33Xfx9/dnxowZREZGluoOOLVazdq1a5k6dSorVqxg6dKlBAUF8fHHH/P666+b6/Xr14/z58+zZMkSkpKSqF69Op06dWL69Om4ubkB8OKLL/LDDz/w6aefkpmZSa1atRg3bhxTpkwpUV/69euHg4MDGRkZFnct3jBu3DjWrl3Lpk2byMvLIzAwkA8++MCc1LSsHnroId5//30WLlxIREQERqORmJgYnJyceOutt6hXrx5z5841r0/z9/enR48e9OvX747Htuaz9fLLL3PkyBGWLl3K3LlzCQwMvGXQ1a1bNyIiIpg2bRpTp05Fq9XSqVMn/vvf/xIcHFz2H4oQVYDsvSiEKFf9+/evkHQKQghR0WRNlxDinsnJybF4ffbsWdavX0/nzp0rpkNCCFGBZKRLCHHP+Pn5MWzYMGrXrs2FCxdYsGABeXl5/P3339StW7eiuyeEEOVK1nQJIe6ZXr168b///Y/4+Hjs7Oxo06YNH330kQRcQoh/JRnpEkIIIYQoB7KmSwghhBCiHEjQJYQQQghRDmRNVykZjUauXLmCi4tLibfCEEIIIUTFUhSFjIwMatSogVpdvmNPEnSV0pUrV/D396/obgghhBCiFC5evEitWrXK9ZwSdJXSja1CLl68iKurawX3RgghhBAlkZ6ejr+/f4m2/LrbJOgqpRtTiq6urhJ0CSGEEFVMRSwNkoX0QgghhBDlQIIuIYQQQohyIEGXEEIIIUQ5kDVdQgghhJUMBgN6vb6iuyGKodVq0Wg0Fd2NYknQJYQQQpSQoijEx8eTmppa0V0Rt+Hu7o6vr2+ly6MpQZcQQghRQjcCLm9vbxwdHSvdl/q/naIoZGdnc/XqVQD8/PwquEeWJOgSQgghSsBgMJgDrmrVqlV0d8QtODg4AHD16lW8vb0r1VSjLKQXQgghSuDGGi5HR8cK7om4kxu/o8q27k6CLiGEEMIKMqVY+VXW35EEXUIIIYQQ5UCCLiGEEOI+pygKo0aNwtPTE5VKxZEjR+7YZseOHahUqtveqRkeHo67u/td6+f9ToIuIYQQ4j4XERFBeHg469atIy4ujkaNGpXbuT/88EPatm2Lo6Pjvz5Ak6CrElIUhYT0XC4kZ1V0V4QQQtwHoqOj8fPzo23btvj6+mJjU37JC3Q6HU8++SSjR48ut3NWVhJ0VUIrD14k7KOtTF1zoqK7IoQQooobNmwYr7zyCrGxsahUKoKCggDIy8tj3LhxeHt7Y29vT/v27Tlw4MBtjxUeHk5AQACOjo4MGDCA5OTkO55/+vTpjB8/nsaNG9+Ny6nSJE9XJeTvabrVNTYlu4J7IoQQ4nYURSFHbyj38zpoNSW+Q2/+/PmEhISwaNEiDhw4YM5b9eabb7J69WqWLVtGYGAgs2fPpmfPnkRFReHp6VnkOPv27WPEiBHMnDmT/v37ExERwbRp0+7qdd3vJOiqhIKqOQFwMSWbfIMRG40MSAohRGWUozfQYOrGcj/vyRk9cbQt2Ve4m5sbLi4uaDQafH19AcjKymLBggWEh4fTu3dvABYvXszmzZv59ttvmThxYpHjzJ8/n169evHmm28CUK9ePXbv3k1ERMRduqr7n3ybV0K+rvbY2qjJNyrEpeVWdHeEEELcZ6Kjo9Hr9bRr185cptVqadWqFZGRkcW2iYyMJCwszKKsTZs297Sf9xsZ6aqE1GoVAZ6ORF3N5Hxylnm6UQghROXioNVwckbPCjmvqHok6KqkbgRdF1NyKrorQgghbkGlUpV4mq8yCQkJwdbWll27dhEYGAiYtsw5cOAAr732WrFtQkND2bdvn0XZ3r1773VX7ytV75PyL+HnZg9AfLpMLwohhLi7nJycGD16NBMnTsTT05OAgABmz55NdnY2I0aMKLbNuHHjaNeuHXPmzOGxxx5j48aNJVrPFRsbS0pKCrGxsRgMBnNi1jp16uDs7Hw3L6vSkzVdlZQ56EqTkS4hhBB336xZsxg4cCDPP/88zZs3Jyoqio0bN+Lh4VFs/datW7N48WLmz59P06ZN2bRpE1OmTLnjeaZOncqDDz7ItGnTyMzM5MEHH+TBBx/k4MGDd/uSKj2VoihKRXeiKkpPT8fNzY20tDRcXV3v+vFXHbrEGz/9Q4e61fluRNidGwghhLincnNziYmJITg4GHt7+4rujriN2/2u7vX39+3ISFcldWOkS+5eFEIIIe4PEnRVUjeCrkvXssnRlX/iPSGEEELcXRJ0VVJB1ZwI8HQkV2/k92NxFd0dIYQQQpSRBF2VlFqtom9TPwAOxKRUcG+EEEIIUVYSdFViIV6mW2llD0YhhBCi6pOgqxILkI2vhRBCiPuGBF2VWEA1U9B1JS0HXb6xgnsjhBBCiLKQoKsS83K2w0GrQVHgcqokSRVCCCGqMgm6KjGVSlUoX5cEXUIIIURVJkFXJed7PehKkD0YhRBClJKiKIwaNQpPT09UKpV5/8Pb2bFjByqVitTU1FvWCQ8Px93d/a71835XKYKuL7/8kqCgIOzt7QkLC2P//v23rNu5c2dUKlWRR58+fcx1FEVh6tSp+Pn54eDgQLdu3Th79qzFcVJSUhg8eDCurq64u7szYsQIMjMz79k1lpav6409GPMquCdCCCGqqoiICMLDw1m3bh1xcXE0atSoXM57/vx5RowYQXBwMA4ODoSEhDBt2jR0Ol25nL+yqfCga8WKFUyYMIFp06Zx+PBhmjZtSs+ePbl69Wqx9X/++Wfi4uLMj+PHj6PRaHjyySfNdWbPns1nn33GwoUL2bdvH05OTvTs2ZPc3ILRosGDB3PixAk2b97MunXr+OOPPxg1atQ9v15r+chIlxBCiDKKjo7Gz8+Ptm3b4uvri42NTbmc99SpUxiNRr7++mtOnDjB3LlzWbhwIW+//Xa5nL/SUSpYq1atlDFjxphfGwwGpUaNGsrMmTNL1H7u3LmKi4uLkpmZqSiKohiNRsXX11f5+OOPzXVSU1MVOzs75X//+5+iKIpy8uRJBVAOHDhgrrNhwwZFpVIply9fLtF509LSFEBJS0srUf3SWrY7RgmctE4Z9X8H7lxZCCHEPZOTk6OcPHlSycnJqeiuWGXo0KEKYH4EBgYqiqIoubm5yiuvvKJ4eXkpdnZ2Srt27ZT9+/eb223fvl0BlGvXrpnLli5dqvj7+ysODg5K//79lTlz5ihubm5W9Wf27NlKcHDwXbiyW7vd76q8vr+LU6EjXTqdjkOHDtGtWzdzmVqtplu3buzZs6dEx/j22295+umncXJyAiAmJob4+HiLY7q5uREWFmY+5p49e3B3d6dly5bmOt26dUOtVrNv3767cWl3jb+HKW3EucSsCu6JEEKIIhQFdFnl/1CUEndx/vz5zJgxg1q1ahEXF8eBAwcAePPNN1m9ejXLli3j8OHD1KlTh549e5KSUvwuKPv27WPEiBGMHTuWI0eO0KVLFz744AOrf2RpaWl4enpa3e5+UD7ji7eQlJSEwWDAx8fHotzHx4dTp07dsf3+/fs5fvw43377rbksPj7efIybj3njvfj4eLy9vS3et7GxwdPT01znZnl5eeTlFayrSk9Pv2P/7oaGNV0BiE7MJFuXj6Nthf7KhBBCFKbPho9qlP95374Ctk4lqurm5oaLiwsajQZfX18AsrKyWLBgAeHh4fTu3RuAxYsXs3nzZr799lsmTpxY5Djz58+nV69evPnmmwDUq1eP3bt3ExERUeJuR0VF8fnnnzNnzpwSt7mfVPiarrL49ttvady4Ma1atbrn55o5cyZubm7mh7+//z0/J4C3iz0+rnYYFTh5pXwCPSGEEPe36Oho9Ho97dq1M5dptVpatWpFZGRksW0iIyMJCwuzKGvTpk2Jz3n58mV69erFk08+yciRI0vX8SquQodNqlevjkajISEhwaI8ISHBHI3fSlZWFj/++CMzZsywKL/RLiEhAT8/P4tjNmvWzFzn5oX6+fn5pKSk3PK8kydPZsKECebX6enp5RZ4Na7pRkL6VY5dTqNl0L9zSFYIISolraNp1KkizluFXLlyhS5dutC2bVsWLVpU0d2pMBU60mVra0uLFi3YunWrucxoNLJ169Y7Rs8//fQTeXl5PPfccxblwcHB+Pr6WhwzPT2dffv2mY/Zpk0bUlNTOXTokLnOtm3bMBqNRaL4G+zs7HB1dbV4lJdGNd0AOHY5rdzOKYQQogRUKtM0X3k/VKoydTskJARbW1t27dplLtPr9Rw4cIAGDRoU2yY0NLTIuue9e/fe8VyXL1+mc+fOtGjRgqVLl6JWV+lJtjKp8AVCEyZMYOjQobRs2ZJWrVoxb948srKyGD58OABDhgyhZs2azJw506Ldt99+S//+/alWrZpFuUql4rXXXuODDz6gbt26BAcH8+6771KjRg369+8PmD44vXr1YuTIkSxcuBC9Xs/YsWN5+umnqVGjAubm76BRDVPQdVyCLiGEEHeBk5MTo0ePZuLEiXh6ehIQEMDs2bPJzs5mxIgRxbYZN24c7dq1Y86cOTz22GNs3Ljxjuu5bgRcgYGBzJkzh8TERPN7d5rRuh9VeNA1aNAgEhMTmTp1KvHx8TRr1oyIiAjzQvjY2NgiUfHp06f566+/2LRpU7HHfPPNN8nKymLUqFGkpqbSvn17IiIisLe3N9f54YcfGDt2LF27dkWtVjNw4EA+++yze3ehZfCAnwsA55OyMRoV1Oqy/YUjhBBCzJo1C6PRyPPPP09GRgYtW7Zk48aNeHh4FFu/devWLF68mGnTpjF16lS6devGlClTeP/99295js2bNxMVFUVUVBS1atWyeE+x4g7M+4VK+Tde9V2Qnp6Om5sbaWlp93yqUW8wUm/KBhQFDrzTDS8Xu3t6PiGEEEXl5uYSExNDcHCwxR/xovK53e+qPL+/b/bvnVitQrQaNd7XA634NMlML4QQQlRFEnRVEb5uDgBcScup4J4IIYQQojQk6KqkdLGx5BXapLuG242Nr2WkSwghhKiKJOiqhFK+/4HoHj25Om++uczv+kjXpWvZFdUtIYQQQpSBBF2VkONDDwGQ9eefGDIzAQj2Mm33EC17MAohhBBVkgRdlZBdvbrYBgWh6HQkXL8Vt46XMwBRVzMrsmtCCCGEKCUJuiohlUqF1/jxAKSt/Q1DRgZ1vE1B18Vr2eTqDRXZPSGEEEKUggRdlZRrzx5oa9UCRSH32DGqO9vi7qhFUeCcTDEKIYQQVY4EXZWYQ5MmAOQcPYpKpSqYYkyUKUYhhBCiqpGgqxKzbxAKQF5UNIB5ilHWdQkhhLCGoiiMGjUKT09PVCoVR44cuWObHTt2oFKpSE1NvWWd8PBw3N3d71o/73cSdFVi2sBAAHTnzwMFQdfWyATyDcaK6pYQQogqJiIigvDwcNatW0dcXByNGjUqt3P369ePgIAA7O3t8fPz4/nnn+fKlSvldv7KRIKuSsz2RtB14QKKotDlAW/UKjhxJZ1d0ckV3DshhBBVRXR0NH5+frRt2xZfX19sbGzK7dxdunRh5cqVnD59mtWrVxMdHc0TTzxRbuevTCToqsRsAwJApcKYkYEhJYUQL2c61vMC4EqqbAckhBDizoYNG8Yrr7xCbGwsKpWKoKAgAPLy8hg3bhze3t7Y29vTvn17Dhw4cNtjhYeHExAQgKOjIwMGDCA5+c4DAOPHj6d169YEBgbStm1b3nrrLfbu3Yter78bl1ellF+oK6ymtrfHxtub/IQE9JcvY1Otmnnj65QsXQX3TgghhKIo5OSX/x/BDjYOqFSqEtWdP38+ISEhLFq0iAMHDqDRaAB48803Wb16NcuWLSMwMJDZs2fTs2dPoqKi8PT0LHKcffv2MWLECGbOnEn//v2JiIhg2rRpVvU7JSWFH374gbZt26LVaq1qez+QoKuS0/r6moKuuHgcmjTBw8kWgORMCbqEEKKi5eTnELY8rNzPu+/ZfThqHUtU183NDRcXFzQaDb6+vgBkZWWxYMECwsPD6d27NwCLFy9m8+bNfPvtt0ycOLHIcebPn0+vXr148803AahXrx67d+8mIiLijn2YNGkSX3zxBdnZ2bRu3Zp169aV9FLvKzK9WMnZ+PkBkB8fB0C160FXSlZehfVJCCFE1RYdHY1er6ddu3bmMq1WS6tWrYiMjCy2TWRkJGFhlgFmmzZtSnS+iRMn8vfff7Np0yY0Gg1DhgxBUZTSX0AVJSNdlZz2+l8l+rh4ADydrk8vZv/75sKFEKKycbBxYN+z+yrkvFVJ9erVqV69OvXq1SM0NBR/f3/27t1b4qDtfiFBVyWnrWEa6dLHmUa6PJ1Mc+Ay0iWEEBVPpVKVeJqvMgkJCcHW1pZdu3YReP1Oeb1ez4EDB3jttdeKbRMaGsq+fZYB5t69e60+t9FoSnmUl/fv+x6ToKuS09byB0B3zpQg9cZIV2LGv+/DKoQQ4u5wcnJi9OjRTJw4EU9PTwICApg9ezbZ2dmMGDGi2Dbjxo2jXbt2zJkzh8cee4yNGzfecT3Xvn37OHDgAO3bt8fDw4Po6GjeffddQkJC/nWjXCBruio9h8amBHZ5UdEYMrOo7eWEVqMiIT1PMtMLIYQotVmzZjFw4ECef/55mjdvTlRUFBs3bsTDw6PY+q1bt2bx4sXMnz+fpk2bsmnTJqZMmXLbczg6OvLzzz/TtWtX6tevz4gRI2jSpAk7d+7Ezs7uXlxWpaZS/o0r2e6C9PR03NzcSEtLw9XV9Z6e6+zDD5N/JY6A8HCcWocxZMl+/jiTyJQ+obzQofY9PbcQQgiT3NxcYmJiCA4Oxt7evqK7I27jdr+r8vz+vpmMdFUB9g9c34Px+hRjcDXT+oH0HFlML4QQQlQVEnRVAbb+pnVd+tiLFdwTIYQQQpSWBF1VgPZ60KW7KEGXEEIIUVVJ0FUF2AZcH+mSoEsIIYSosiToqoRef/11WrZsyeeffw4UGum6dOlfmcFXCCGEuB9Inq5KKCYmhkOHDnHo0CH69u1LYM2aoFKhZGdjSEqq6O4JIYQQohRkpKsS+vXXX83P165di8rWFhs/03ZAuouXKqhXQgghhCgLCboqoaNHj5qf3wjAbP0DANBfjK2ILgkhhBCijCToqoQaNmxISEgIAH/88QcpKSnmxfR5589XYM+EEEIIUVoSdFVCKpWKxx57DACDwcD69euxb9QYgOy9BZuNypJ6IYQQJaEoCqNGjcLT0xOVSsWRI0fu2GbHjh2oVCpSU1NvWSc8PBx3d/e71s/7nQRdldSNoAvg999/x7ljBwBy/vkH+8y0iuqWEEKIKigiIoLw8HDWrVtHXFwcjRo1Kvc+5OXl0axZsxIHffcjCboqqbZt25r/eti8eTM2vr7YN2kCRiPBB7dXbOeEEEJUKdHR0fj5+dG2bVt8fX2xsSn/5AVvvvkmNWrUKPfzViYSdFVSNjY2dOhgGt1KTk7m9OnTuD8xEIAakYcqsmtCCCGqkGHDhvHKK68QGxuLSqUiKCgIMI08jRs3Dm9vb+zt7Wnfvj0HDhy47bHCw8MJCAjA0dGRAQMGkJycXKI+bNiwgU2bNjFnzpyyXk6VJnm6KqGTyScJPxGObW1bc9mxY8cIatIEANeESyBJUoUQosIpioKSk1Pu51U5OKBSqUpUd/78+YSEhLBo0SIOHDiARqMBTCNPq1evZtmyZQQGBjJ79mx69uxJVFQUnp6eRY6zb98+RowYwcyZM+nfvz8RERFMmzbtjudPSEhg5MiR/Prrrzg6Olp3ofcZCboqoejUaDbEbMC1ritrf1tL+3bt8fDwwJiXB2o1djmZeORlVHQ3hRDiX0/JyeF08xblft76hw+hKmEA4+bmhouLCxqNBl9fU87HrKwsFixYQHh4OL179wZg8eLFbN68mW+//ZaJEycWOc78+fPp1asXb775JgD16tVj9+7dRERE3PLciqIwbNgwXnrpJVq2bMn5f/kd+DK9WAn1COqBu5076c7ppIek4+HhAYDazg7b61sCBWYkVGQXhRBCVGHR0dHo9XratWtnLtNqtbRq1YrIyMhi20RGRhIWFmZR1qZNm9ue5/PPPycjI4PJkyeXvdP3ARnpqoTsNHa80PgF5hycw7xD8+gb0hdXW1cAbOvWQXfhAgHp8RXcSyGEECoHB+ofLv91tioHh3I/Z2ls27aNPXv2YGdnZ1HesmVLBg8ezLJlyyqoZxWjwke6vvzyS4KCgrC3tycsLIz9+/fftn5qaipjxozBz88POzs76tWrx/r1683vBwUFoVKpijzGjBljrtO5c+ci77/00kv37BpLY0iDIYS4hZBryGXDuQ3mcrs6dQAZ6RJCiMpApVKhdnQs90dJ13PdSkhICLa2tuzatctcptfrOXDgAA0aNCi2TWhoKPv27bMo27t3723P89lnn/HPP/9w5MgRjhw5Yv6+XrFiBR9++GGZrqEqqtCRrhUrVjBhwgQWLlxIWFgY8+bNo2fPnpw+fRpvb+8i9XU6Hd27d8fb25tVq1ZRs2ZNLly4YJGY7cCBAxgMBvPr48eP0717d5588kmLY40cOZIZM2aYX1e2xX0qlYp+dfrxye5PWLR0ERsSNlCnTh1eadoMgICMBGRDICGEEKXh5OTE6NGjmThxIp6engQEBDB79myys7MZMWJEsW3GjRtHu3btmDNnDo899hgbN2687XougICAAIvXzs7OgCnoq1Wr1t25mCqkQoOuTz/9lJEjRzJ8+HAAFi5cyO+//86SJUt46623itRfsmQJKSkp7N69G61WC2C+9fUGLy8vi9ezZs0iJCSETp06WZQ7OjqaFxRWVm382qAYFLZ9vA0UeOihh3hjoClthH9GAhfkBkYhhBClNGvWLIxGI88//zwZGRm0bNmSjRs3mtcR36x169YsXryYadOmMXXqVLp168aUKVN4//33y7nnVZdKUSom94BOp8PR0ZFVq1bRv39/c/nQoUNJTU1lzZo1Rdo88sgjeHp64ujoyJo1a/Dy8uLZZ59l0qRJ5ltgbz5HjRo1mDBhAm+//ba5vHPnzpw4cQJFUfD19aVv3768++67tx3tysvLIy8vz/w6PT0df39/0tLScHV1LeVP4faMipGOKzpy4LUD6BJ02Nvbk3rlCufatAVgw8crmNC3yT05txBCCEu5ubnExMQQHByMvb19RXdH3Mbtflfp6em4ubnd0+/vW6mwka6kpCQMBgM+Pj4W5T4+Ppw6darYNufOnWPbtm0MHjyY9evXExUVxcsvv4xery82V8ivv/5Kamoqw4YNsyh/9tlnCQwMpEaNGhw9epRJkyZx+vRpfv7551v2d+bMmUyfPt36Cy0DtUpNK99WHPM/hi5BR25uLmcvX8Zg74htbjYO15LKtT9CCCGEKL0qdfei0WjE29ubRYsWodFoaNGiBZcvX+bjjz8uNuj69ttv6d27d5FtB0aNGmV+3rhxY/z8/OjatSvR0dGEhIQUe+7JkyczYcIE8+sbI133WivfVvwv5H+kH0wHTBuQtnCvjm18LA7XEu/5+YUQQghxd1TY3YvVq1dHo9GQkGB5F15CQsIt11r5+flRr149i6nE0NBQ4uPj0el0FnUvXLjAli1beOGFF+7Ylxt5R6Kiom5Zx87ODldXV4tHeegR1APPRgWZgbdt20a2WzUACbqEEEKIKqTCgi5bW1tatGjB1q1bzWVGo5GtW7feMtlau3btiIqKwmg0msvOnDmDn58ftra2FnWXLl2Kt7c3ffr0uWNfbux27ufnV4orubc87T3p0bYHGidToLl9+3YyXE1BmL1MLwohhBBVRoXm6ZowYQKLFy9m2bJlREZGMnr0aLKyssx3Mw4ZMsQii+3o0aNJSUnh1Vdf5cyZM/z+++989NFHFjm4wBS8LV26lKFDhxbZST06Opr333+fQ4cOcf78edauXcuQIUPo2LEjTZpUzkXpQe5BOIU6AaY8ZUfzcgEZ6RJCCCGqkgpd0zVo0CASExOZOnUq8fHxNGvWjIiICPPi+tjYWNTqgrjQ39+fjRs3Mn78eJo0aULNmjV59dVXmTRpksVxt2zZQmxsLP/5z3+KnNPW1pYtW7Ywb948srKy8Pf3Z+DAgUyZMuXeXmwZBLgE4NLUxbyua2v0KZ5Egi4hhBCiKqmwlBFVXXnecnoo4RDPrXqOM2+cwZhrRKPRsCe4NiqfWrT8a9s9PbcQQggTSRlRdVTWlBEVvg2QKEZOKqwbDydNucpCPUNxcXfBZ6APD49+mAkfhuOs0WCfmoRSaH2bEEIIISovCboqowOL4eASWP8m5KbjqHVkTqc5VOteDTqDa/3GGFChydeTnySL6YUQQoiqQIKuyqjNWPAIhsx482hXmF8YtmpbruZcJbCWnquOpjsY887FVGRPhRBCVAGKojBq1Cg8PT1RqVTmu/ZvZ8eOHahUKlJTU29ZJzw83GL/Y3F7EnRVRloHaNDP9PzyIQDsNHbU86gHgIdHIpdcTTcbJBwvPnu/EEIIcUNERATh4eGsW7eOuLg4GjVqVG7nDgoKQqVSWTxmzZpVbuevTKpURvp/lRrNTf+9cthcVN+zPv9c+oeILb9zITkOL52OWmdvndBVCCGEAFO6JD8/P9q2bVsh558xYwYjR440v3ZxcamQflQ0GemqrGq1NP03/hhkmLL2h3qGkrorlS9f+pJ1x/fwW3oa+ouXKrCTQgghKrthw4bxyiuvEBsbi0qlIigoCIC8vDzGjRuHt7c39vb2tG/fngMHDtz2WOHh4QQEBODo6MiAAQNITk4uUR9cXFzw9fU1P5ycnMp6WVWSBF2VlVstqPUQKEY4vhqApt5NcW1RcHvr9sxMjBnpFdVDIYT411MUBX2eodwf1mR7mj9/PjNmzKBWrVrExcWZA6s333yT1atXs2zZMg4fPkydOnXo2bMnKSkpxR5n3759jBgxgrFjx3LkyBG6dOnCBx98UKI+zJo1i2rVqvHggw/y8ccfk5+fX+L+309kerEyazgALh2Ac9uhzcvUda+Lh7cHNm425Kflk2owoGRmVHQvhRDiXytfZ2TRqzvL/byj5ndCa6e5c0XAzc0NFxcXNBqNeW/jrKwsFixYQHh4OL179wZg8eLFbN68mW+//ZaJEycWOc78+fPp1asXb775JgD16tVj9+7dRERE3Pb848aNo3nz5nh6erJ7924mT55MXFwcn376qTWXfF+QoKsyC7w+9x67D4xGNGoNnf07c9jhMKRBltGIOiurYvsohBCiyomOjkav19OuXTtzmVarpVWrVkRGRhbbJjIykgEDBliUtWnT5o5B14QJE8zPmzRpgq2tLS+++CIzZ87Ezs6uDFdR9UjQVZn5NAZbZ8hLg6snwbcRU1pP4UunL9GhI9NoxCYrHUVRUKlUFd1bIYT417GxVTNqfqcKOW9VFRYWRn5+PufPn6d+/foV3Z1yVXV/a/8GGhvTui6A2D0AOGmd8PE0pYtQAL0+D2O6rOsSQoiKoFKp0Nppyv1R1j+0Q0JCsLW1ZdeuXeYyvV7PgQMHaNCgQbFtQkND2bdvn0XZ3r17rT73kSNHUKvVeHt7W922qpORrsousK1pTdeF3dDKdLutl6cXUZhSRWQajOji4nBwc6vIXgohhKhCnJycGD16NBMnTsTT05OAgABmz55NdnY2I0aMKLbNuHHjaNeuHXPmzOGxxx5j48aNd5xa3LNnD/v27aNLly64uLiwZ88exo8fz3PPPYeHh8e9uLRKTUa6KruaLUz/TThuLvL19DU/zzQaSTkvaSOEEEJYZ9asWQwcOJDnn3+e5s2bExUVxcaNG28ZDLVu3ZrFixczf/58mjZtyqZNm5gyZcptz2FnZ8ePP/5Ip06daNiwIR9++CHjx49n0aJF9+KSKj2VYs19p8Ks3HYpT78Cn4aCSgPvxIONLWPHjeXLz78E4H8BgdR9cyotxvzn3vVBCCEEubm5xMTEEBwcjL29fUV3R9zG7X5X5fb9XQwZ6arsXPzAzhUUA6REA+Dj5YOLjwuB1RzQqlRkxl6u4E4KIYQQ4k4k6KrsVCrwun53R+xe2DyNdweFsffEXl7oF0QDe3tyU2UhvRBCCFHZSdBVFfg1M/133Wuwax4sf5KaWdcwqk2/vqSs2IrqmRBCCCFKSIKuquDGPoyFuF05iqdjIAA5usTy7pEQQgghrCRBV1UQ0LpoWeJpPJxN+brQ/zv3sBJCCCGqEgm6qgKPIHh4iukOxjrdMRgVHp2ynJn/28i0+DgwGCq6h0IIIYS4A0mOWlV0nAhtX4XESDRRm9l0PBG9EYx2dvQ0GMk3GLHRSAwthBBCVFbyLV1JGQ1GdLk3TRva2IJvEwjuhLOtqSjbaMTGYCAlW1f+nRRCCCFEiUnQVQmdP5bED+/t48C6mKJvqlQQ9hJOtqZ9t3IUBRujQnKmBF1CCCFEZSZBVyWkUqlIT8zh+M7LpCZkF60Q2Abn60FXttGIjdFISpYEXUIIISqXYcOG0b9//4ruRqUha7oqoYCGnngHunD1QgarZh/Ey9+FmvU9aNEr0LSzvIMHTrYawEi20YjaYCApM6+iuy2EEEKI25CRrkpIpVLRfURDAPKy8rl06hr71pwj6uBVcx1ne1O8bAQUg1GmF4UQQohKToKuSsrd2xHvQBeLsiNbL2IwGAFwtteay/V6AwnpueXaPyGEEFVHREQE7du3x93dnWrVqvHoo48SHR1tfr9t27ZMmjTJok1iYiJarZY//vgDgLi4OPr06YODgwPBwcEsX76coKAg5s2bV+J+5OXlMW7cOLy9vbG3t6d9+/YcOHDA/P61a9cYPHgwXl5eODg4ULduXZYuXQqATqdj7Nix+Pn5YW9vT2BgIDNnzizDT6X8SdBVifnUdrN4ffV8Osd3mDa3dioUdOXrDVxILmbtlxBCiHLx6aefUqtWrTs++vXrV6Rtv379StT2008/LXX/srKymDBhAgcPHmTr1q2o1WoGDBiA0Wj6Q37w4MH8+OOPKIpibrNixQpq1KhBhw4dABgyZAhXrlxhx44drF69mkWLFnH16tViz3crb775JqtXr2bZsmUcPnyYOnXq0LNnT1JSUgB49913OXnyJBs2bCAyMpIFCxZQvXp1AD777DPWrl3LypUrOX36ND/88ANBQUGl/plUBFnTVYk16VyLY9svoVKrqNPci7MHr5Jw3rS5tbNDQdCly8/nQooEXUIIUVHS09O5fPnyHev5+/sXKUtMTCxR2/T09FL1DWDgwIEWr5csWYKXlxcnT56kUaNGPPXUU7z22mv89ddf5iBr+fLlPPPMM6hUKk6dOsWWLVs4cOAALVuatqb75ptvqFu3bon7kJWVxYIFCwgPD6d3794ALF68mM2bN/Ptt98yceJEYmNjefDBB83nKBxUxcbGUrduXdq3b49KpSIwMLDUP4+KIkFXJebu48iz74WRm5VPdnoeZw9e5eyBBJp186ddXU9ystIJuuKMl1rDheQsFEUxLbQXQghRrlxdXalZs+Yd63l5eRVbVpK2rq6upeobwNmzZ5k6dSr79u0jKSnJPMIVGxtLo0aN8PLyokePHvzwww906NCBmJgY9uzZw9dffw3A6dOnsbGxoXnz5uZj1qlTBw8PjxL3ITo6Gr1eT7t27cxlWq2WVq1aERkZCcDo0aMZOHAghw8fpkePHvTv35+2bdsCpjshu3fvTv369enVqxePPvooPXr0KPXPpCJI0FXJefg6AZB0KdNc9ttn/zCiUzBhHsmo13uQqFGTrTOQlKnDy8WuoroqhBD/WhMmTGDChAmlart27dq73Jui+vbtS2BgIIsXL6ZGjRoYjUYaNWqETldwE9bgwYMZN24cn3/+OcuXL6dx48Y0btz4nvetsN69e3PhwgXWr1/P5s2b6dq1K2PGjGHOnDk0b96cmJgYNmzYwJYtW3jqqafo1q0bq1atKtc+loWs6aoi3LwczM9zs/QY1bZoVKa5dxuj6b+JGZI2QgghhKXk5GROnz7NlClT6Nq1K6GhoVy7dq1Ivccee4zc3FwiIiJYvnw5gwcPNr9Xv3598vPz+fvvv81lUVFRxR7nVkJCQrC1tWXXrl3mMr1ez4EDB2jQoIG5zMvLi6FDh/L9998zb948Fi1aZH7P1dWVQYMGsXjxYlasWMHq1avN68GqAhnpqiK0dhpCmnsRfTgRgJ+PPcEDnEQD2Fzf7zpRcnUJIYS4iYeHB9WqVWPRokX4+fkRGxvLW2+9VaSek5MT/fv359133yUyMpJnnnnG/N4DDzxAt27dGDVqFAsWLECr1fL666/j4OBQ4mUtTk5OjB49mokTJ+Lp6UlAQACzZ88mOzubESNGADB16lRatGhBw4YNycvLY926dYSGhgKmmxX8/Px48MEHUavV/PTTT/j6+uLu7l72H1I5kZGuKqTXqMbUqOsOQEKGL0dzXuRafj7xuaZgS0a6hBBC3EytVvPjjz9y6NAhGjVqxPjx4/n444+LrTt48GD++ecfOnToQEBAgMV7//d//4ePjw8dO3ZkwIABjBw5EhcXF+zt7Uvcl1mzZjFw4ECef/55mjdvTlRUFBs3bjSvDbO1tWXy5Mk0adKEjh07otFo+PHHHwFwcXFh9uzZtGzZkoceeojz58+zfv161OqqE8qolML3h4oSS09Px83NjbS0tDItbrTWwQ3n2bfmHABvLXuczNw0Amy1qMb/wqReDzC6c0i59UUIIf5NcnNziYmJITg42KpA43516dIl/P392bJlC127dq3o7li43e+qor6/QUa6qpz6Yb5wfSTX0c6UPDU53wAoMtIlhBDintm2bRtr164lJiaG3bt38/TTTxMUFETHjh0rumtVhgRdVYyLpz3D/9serUaPq6MnAFlGI4ouS9Z0CSGEuGf0ej1vv/02DRs2ZMCAAXh5ebFjxw60Wu2dGwtAFtJXSY6utrg6ZePi4G4uU2WnkJghWwEJIYS4N3r27EnPnj0ruhtVWoWPdH355ZcEBQVhb29PWFgY+/fvv2391NRUxowZg5+fH3Z2dtSrV4/169eb33/vvfdQqVQWjwceeMDiGLm5uYwZM4Zq1arh7OzMwIEDSUhIuCfXd6842umx1zqaX6vzMmR6UQghhKjEKjToWrFiBRMmTGDatGkcPnyYpk2b0rNnz1vu5aTT6ejevTvnz59n1apVnD59msWLFxfJ5NuwYUPi4uLMj7/++svi/fHjx/Pbb7/x008/sXPnTq5cucLjjz9+z67zXtBqjdgVCrpUunSSMnW3aSGEEOJukPvPKr/K+juq0OnFTz/9lJEjRzJ8+HAAFi5cyO+//86SJUuKzSGyZMkSUlJS2L17t3kOubjNLm1sbPD19S32nGlpaXz77bcsX76chx9+GIClS5cSGhrK3r17ad269V26untLrVFhb1so6MrLIi1HT16+ATsbTQX2TAgh7k83vneys7NxcHC4Q21RkbKzTfsRV7b1ZhUWdOl0Og4dOsTkyZPNZWq1mm7durFnz55i26xdu5Y2bdowZswY1qxZg5eXF88++yyTJk1CoykINM6ePUuNGjWwt7enTZs2zJw505xv5NChQ+j1erp162au/8ADDxAQEMCePXtuGXTl5eWRl1cwfVeWjUfvBo1GhZ224DZYjT6LfCApU0dNd/nHQAgh7jaNRoO7u7t5NsbR0VH2u61kFEUhOzubq1ev4u7ubhEbVAYVFnQlJSVhMBjw8fGxKPfx8eHUqVPFtjl37hzbtm1j8ODBrF+/nqioKF5++WX0ej3Tpk0DICwsjPDwcOrXr09cXBzTp0+nQ4cOHD9+HBcXF+Lj47G1tS2SwdbHx4f4+Phb9nfmzJlMnz69bBd9F6k1WEwvOih55GFKkFrSoOtA/AGC3YKp7lD9HvVSCCHuLzdmUW61DEZUDu7u7rec8apIVeruRaPRiLe3N4sWLUKj0dCiRQsuX77Mxx9/bA66evfuba7fpEkTwsLCCAwMZOXKleZtBkpj8uTJFpuZpqen4+/vX/qLKSONRm2xkN7eaBpKjUvNoZm/+x3bf3fyO2YfmE1n/858/vDn96qbQghxX1GpVPj5+eHt7Y1er6/o7ohiaLXaSjfCdUOFBV3Vq1dHo9EUuWswISHhltGpn59fkR9maGgo8fHx6HQ6bG1ti7Rxd3enXr16REVFAaa/UnQ6HampqRajXbc7L4CdnR12dnbWXOI9pbZREer/EDM6P0ez87v4s1EgK4Hzydklaj/7wGwAdlzccc/6KIQQ9yuNRlNpv9hF5VVhdy/a2trSokULtm7dai4zGo1s3bqVNm3aFNumXbt2REVFYTQazWVnzpzBz8+v2IALIDMzk+joaPz8/ABo0aIFWq3W4rynT58mNjb2luetjDQaNS4O7tSpGUQdOzvc808DEJOUWcE9E0IIIURxKjRlxIQJE1i8eDHLli0jMjKS0aNHk5WVZb6bcciQIRYL7UePHk1KSgqvvvoqZ86c4ffff+ejjz5izJgx5jpvvPEGO3fu5Pz58+zevZsBAwag0WjMu6W7ubkxYsQIJkyYwPbt2zl06BDDhw+nTZs2VebORQC1xvSrc7g++maTHAsYOJ9UspEuIYQQQpSvCl3TNWjQIBITE5k6dSrx8fE0a9aMiIgI8+L62NhYi93D/f392bhxI+PHj6dJkybUrFmTV199lUmTJpnrXLp0iWeeeYbk5GS8vLxo3749e/fuxcvLy1xn7ty5qNVqBg4cSF5eHj179uSrr74qvwu/C9Q2pp+Lva3pdljPVD32zVZxJulxFEWRO2qEEEKISkalVNYMYpVcRe5SDnAo/Hf27nXANnMj8Vv+j780ucS+7YtKE8yWp1dRw93xtu0bL2tsfn5s6LF73V0hhBCiUqjI7+8yTy+mp6fz66+/EhkZeTf6I0pIrTUt4NwQuY+pCfFsupJK1oksNA4X2RR1uIJ7J4QQQoibWR10PfXUU3zxxRcA5OTk0LJlS5566imaNGnC6tWr73oHRfE017PONw8ONZflnM4C4GCcjFwJIYQQlY3VQdcff/xBhw4dAPjll19QFIXU1FQ+++wzPvjgg7veQVE89fWgq16NoILCaNM6rvMZZyqgR0IIIYS4HauDrrS0NDw9PQGIiIhg4MCBODo60qdPH86ePXvXOyiKp9Ga7oFwtHOmtpMTAKmXUzHqjVzRHSRDl1HiY8myPiGEEOLeszro8vf3Z8+ePWRlZREREUGPHj0AuHbtGvb29ndoLe4Wtb0p0DLq82l2PQdZfr6BnHN26FWp/Hz251u2vTnIMiiGe9dRIYQQQgClCLpee+01Bg8eTK1atahRowadO3cGTNOOjRs3vn1jcdeoPWoAYDCoaOHjZC5P2W6advw16leirkWhNxbdpsKoGC1eF1dHCCGEEHeX1UHXyy+/zJ49e1iyZAl//fWXOY9W7dq1ZU1XOboxvWjEhserxeNwPS9X+uETGHVGolKjGLB2AB/u/bBIWwm6hBBCiPJXquSoLVu2pGXLlgAYDAaOHTtG27Zt8fDwuKudE7em1piCLINiQ41qCj1cXFiTno6iyyHtsBMerXMA+Pvq30XaGhQDteMURm0wsP4hNfqnJOgSQggh7rVSTS9+++23gCng6tSpE82bN8ff358dO3bc7f6JW9Bcz0hv9KiDtuWj9HQpSPCWtltDNTvTOq8rmVeKrOEyKkZmhRuonQCP7zLKSJcQQghRDqwOulatWkXTpk0B+O2334iJieHUqVOMHz+ed9555653UBRPY2Ma6TJqHLEd8hntq3swwNWN6WE+uLR4Fq+0KahQkWvIJTk3mYSsBPKN+YDlwnkHnUwvCiGEEOXB6qArKSkJX19fANavX8+TTz5JvXr1+M9//sOxY5KUs7zc2PDakG9E4+yEzzPP8KGfHyOr29LGR8+BmAwUTCNcXVZ2oduqbkzbPQ2wXNOl05Yu6JI0E0IIIYR1rA66fHx8OHnyJAaDgYiICLp37w5AdnY2Go3mrndQFM88vWgwBT82NQNQAH2ulqc0OwHIzw6yaLM2ei2x6bHmES8AtRH0BuuCrp/P/kzY8jBe3/F66S9ACCGE+JexOugaPnw4Tz31FI0aNUKlUtGtWzcA9u3bxwMPPHDXOyiKd2Mhfea1PLJS87Dx9OBo49FsDvwvDxOJEznkJTxSpN1fl//CaCyYXlQr1o90rTy9kpz8HDZd2FS2ixBCCCH+RawOut577z2++eYbRo0axa5du7CzswNAo9Hw1ltv3fUOiuLdCLoA1n52BNw8SK7WiFTFnvBTbQk8sxxjbgCvNJpu0e5E8gkM+oIgS2Ms25oug1ESqwohhBAlUaqUEU888USRsqFDh5a5M6LkbkwvAqRcySIppzqKks17/3uezNxUAJrX388235lQKJPHH5f+ZEidZ8yvSzO9qEGNyqigqFXojXo0aplWFkIIIe7E6pEugJ07d9K3b1/q1KlDnTp16NevH3/++efd7pu4jcJBF8CGVUmoVCoCvOqayw6fvszBeZPQ6PxRjFoURU1q3jUG//a0uU5pphd7/XqZZZ8a6H5Y0k0IIYQQJWV10PX999/TrVs3HB0dGTduHOPGjcPBwYGuXbuyfPnye9FHUQwndzse7B6Ag4vWorx9g74Wr6MvxBG/ow2ZZ6aQc3EYYAq0bihN0NVkfxL2ehi5UYIuIYQQoqSsDro+/PBDZs+ezYoVK8xB14oVK5g1axbvv//+veijuIW2A+vw7LTWuFYv2Gi8SVA7Rvf+CD/PIHNZ/u7loNhhyKqHIb0ZaiPoFIVLOh0qg2J14GSrK0g5Ye3UpBBCCPFvZXXQde7cOfr27VukvF+/fsTExNyVTomSs3fW8vwHbXnirZY0tj9F06Nf0jAgjLcGLqKaiykrffL5U+TEmLYD0mcHojIqPB97gR4x51iedA2dQVfq85dmpMuoGMkz5JX6nEIIIURVZHXQ5e/vz9atW4uUb9myBX9//7vSKWE9nyBXmnTwwTPlJL6GWDRqDY8+NNz8fvbeVQAYsgMxpOVzLDcXgE8SrvLmtjetOpex0KemNEHXyE0j6bGqB5m6TKvbCiGEEFWV1Xcvvv7664wbN44jR47Qtm1bAHbt2kV4eDjz58+/6x0UJaetWRMV0DRuNR2/Ws6LZ/ez/oAHiRnXyLkciZKvx4gvhkIZ6QH08Xkk5SRR3aF6ic5jUKtQG00Lw6wNumLSYtgfv9/8vLFXY6vaCyGEEFWV1UHX6NGj8fX15ZNPPmHlypUAhIaGsmLFCh577LG73kFRcjbVTUGTMTERrwAXSKvDoCZeHE/rTIO6DTnsbk9cpgF9ck0gqqBhlpGz186WOOhSClKEoc+3bmryj0t/mJ+rVKrb1BRCCCHuL6XK0zVgwAAGDBhwt/siyuhG0GVISyP39Bmuzl3HxLpO/GY3FhtVLnmaS8ThR97lh4Cd5naqLAOjNo9ifpf5PBzw8B3PY1Sr4Pq+jnpdrlV9TMtLMz+XOx+FEEL8m5QqT5eonNRubqA1pZCIHTqUrN37yNyTiy1ZZOQZ6PT3XJqfnEtOYqxFOyXLNN346vZXOZl88o7nMRTKharPy7aqj0peHoEJ1wM2ufNRCCHEv0iJRro8PDxKPBWUkpJSpg6J0lOpVNhUr05+XByG1FRTGQpelw8TY1+TiatOAidxcnRklq8fP6Wl4qxWk+Ko4Ubqrj8v/UmDag1ue57C04v5udaNdIWsPkiPdQbWhKnQd7M+6Prm2Df8eOpHwnuFU8ulltXthRBCiIpSoqBr3rx597gb4m65EXQV5pX4Ny71GppfZ2Vns0Gl4ruAQADG1NGQeP29Rf+E073GM9T2cr3lOQrlViXfyunFGnuiAXhsn0KC3rq2semxzD9sulnjj0t/8Gzos1a1F0IIISpSiYIu2Vex6nBo3JjcY8cAsGsQimuPHuR//jVOdpZB1M6sLDINBpw1GpSU5ihuR1CpFHRKJi9ueoUpHf+Dr5Mv9T3rFzmHqlDUlZ+XY1X/0mq645CcZWqba13b09dOm59rNdrb1BRCCCEqH1nTdZ9x6dHd/Fzj7IJD8+bYGHJxNaQWqatXTNGTMbEjmadnYMj1BSA+/zBjt43lxc0vYrwpvQRgThcB1o90WU5NWhd0GRSD+bmsBxNCCFHVSNB1n3F86CHzc5vq1bELDgbA+/Jei3pza9TAw+b6QGduFihasmNeIzehj7lOcm4yH+37CIPRYNG28EiXQWddZnmLoMvKgK1wP+TORyGEEFWNBF33GZVGQ9CqVTh360r1sWPRVK+OxtMT/0vbearlUFQqNQ08A+jh7MK78XF0i45i38r3iHitAx8NaIw+pT3ZF4egwQmAFadX8MKmF7iYcbHgHIWDrjzrAieMBSNn1gZshUfdJOgSQghR1UjQdR9yaNQQ/y++wK52MCqVCvsGDbAx5PKqJoVP//M7Y574hmwnXy7p9VzJzycvK5WcuGgeaewLqDBkNiArvpv5eAcTDjJw7UCScpIAyMs38E9ODnpFsTpwsgi6rAzYZHpRCCFEVSZB17+Ac8cOAHiknkWtS0BRabjg352eLi7mOs2bN+eDqW+jXF/npb/Wmnr6aeb3c/Jz+OnMTyiKwn9iLjDu8mXySxF0qQwFw2QVMdKVkJVgvkYhhBCiPFmdkX7AgAHF5uxSqVTY29tTp04dnn32WerXL3rXm6gY7k8+iSE9g1eueOCakEtTIN6vDWHB/+B4dTXZ14OZTz75hCde8+CAXTNAxaEoB1xCC45zLvUcGRkZRObm8byHB/9LvUZYRY10lSLo+ubYN8w/PJ/32rzHwHoDrW4vhBBClIXVI11ubm5s27aNw4cPo1KpUKlU/P3332zbto38/HxWrFhB06ZN2bVr173orygFtYMDXmPHEO/hxz/uvubymKYvMayWZXC8ftFHLOhbw/w6L6mz+XnE+QiGrRkGwHfXrvFPTg5Ga4OuQqNMRr11+zYajaUf6co35ptzfH138jur2gohhBB3g9VBl6+vL88++yznzp1j9erVrF69mujoaJ577jlCQkKIjIxk6NChTJo06V70V5TRNRsFXaH0pg16f8aqNo/TuVNHALKzs1kw+z3z+7rEXmRFjze/PnHpmPm5o1ptdeCkKsNC+rKs6UrITjA/b1S9kVVthRBCiLvB6qDr22+/5bXXXkOtLmiqVqt55ZVXWLRoESqVirFjx3L8+PG72lFRdnqDgk4FS1zzCHuqLk6uGlCpSWj0Et/0a4ufnx8AERs2oE2/Ym5n1FczP1dyCoImR7Wa5PSCYKZECuX4UnTWBWyFgy6d0bq2+cZ8q+oLIYQQd5vVQVd+fj6nTp0qUn7q1CkMBtOXor29fYn3ahTlR2cwBUwZaoWG7WswZGYHPDKiUdQajm/T8lpd016Go/7zH35I2MbwUxHU93HBkJ2DgzEIACW3IOj6X2oq6/78y3xXY0kUHukyWhl0lWUhfVnXgwkhhBBlZfVC+ueff54RI0bw9ttv89D1RJwHDhzgo48+YsiQIQDs3LmThg0b3u4wogLo8guCFlsbNWq1iqCMg1xzCeFSrc64p/rToG4uo5u3QP3ppzwFBHdpxvBv3oAR7+NUZx+OeeeA8+bjXD6fxR8xRyG3HgMerFkk2DYYDSgo2KhNHzVVoZEua4Mug2KgepqCRwboA60LnMqyHkwIIYS4G6we6Zo7dy6vvfYas2fPpmPHjnTs2JHZs2czfvx4Pv30UwB69OjBjz/+WKLjffnllwQFBWFvb09YWBj79++/bf3U1FTGjBmDn58fdnZ21KtXj/Xr15vfnzlzJg899BAuLi54e3vTv39/Tp8+bXGMzp07m28CuPF46aWXrPxJVD16Q0HgoVGbgiP3+GPY5Geb3ncP4cVOH2N73LQpdY7RyLfzPsSYnUrGoV3kXnmapOhWFsfMycrn7c3LmLzzA34/YRoBzTfmm4ItRWFIxBC6/tSVI1ePmBoUCrrQWxf8aONT+OorA+9/b8A2JcOqtpLjSwghREWzOujSaDS88847xMXFkZqaSmpqKnFxcbz99ttoNBoAAgICqFWr1h2PtWLFCiZMmMC0adM4fPgwTZs2pWfPnly9erXY+jqdju7du3P+/HlWrVrF6dOnWbx4MTVr1jTX2blzJ2PGjGHv3r1s3rwZvV5Pjx49yMrKsjjWyJEjiYuLMz9mz55t7Y+iyik80nVDzXcm0fTkIurn7kJl1KPRaNmc15V9Ld/mYFA//jgfA0DGgV9RcrNQbtq6Jy1Nh9b9MLaeu/i/01+jM+h4fv3zNPuuGWHLwziaeJSU3BQ++/szwHKkS7Ey6Kr2VyQAagVsr2XdobalwlOT1q4HA8jSZzH7wGwOJxy2uq0QQggBpZheLMzV1bVMJ//0008ZOXIkw4cPB2DhwoX8/vvvLFmyhLfeeqtI/SVLlpCSksLu3bvRarUABAUFWdSJiIiweB0eHo63tzeHDh2iY8eO5nJHR0d8fX35N8k3Fk0K6vbYY4Q9+igY83F6eBBHHngJo8aWLOea4FyTB2vv5+9zf2DU5zLw6F8oJ35hXqH2qdd0eCsKKpWKyMyt9P/lGS5mnQFMCVVvuJB2AQBDvpEfr12jhlaLRmdd0KXKK6ivWNm2rIlVX9/xOruu7GJjzEa2PrXV6vZCCCGE1SNdCQkJPP/889SoUQMbGxs0Go3Fo6R0Oh2HDh2iW7eC7WbUajXdunVjz549xbZZu3Ytbdq0YcyYMfj4+NCoUSM++ugj8wL+4qSlpQHg6elpUf7DDz9QvXp1GjVqxOTJk8nOzr5tf/Py8khPT7d43C9UGg0qrR01Ahx56NAsfOL343fVtEF2oHdBdtS52z9HH/AwYYVyfemNCnl7Cn4WNwKum13NuUqnFZ1YfekKM64mMPryJa5evWZdRwtvvG3lKJnFnY8G60e6dl0x5Z27mlP8KKwQQghxJ1aPdA0bNozY2Fjeffdd/Pz8Sn2XYlJSEgaDAR8fH4tyHx+fYu+OBDh37hzbtm1j8ODBrF+/nqioKF5++WX0ej3Tpk0rUt9oNPLaa6/Rrl07GjUqyM307LPPEhgYSI0aNTh69CiTJk3i9OnT/Pzzz7fs78yZM5k+fXqprrWqcAxrjdOhBTQ8tQyHajoSgs5zNj/Noo5dzTY8Uu9R9i0fbC7L2p2GfVu3Yo/Z1Ksp/yT+A0BKbgpfxphSTCjA0cjLVvVPKbQY3tqpybu1WbaL1uXOlYQQQohiWB10/fXXX/z55580a9bsHnTn9oxGI97e3ixatAiNRkOLFi24fPkyH3/8cbFB15gxYzh+/Dh//fWXRfmoUaPMzxs3boyfnx9du3YlOjqakJCQYs89efJkJkyYYH6dnp6Ov7//XbqyysHj+ee5tvx/GFJTcfTRE+a6gphcR+YXquPnGYSDrRPzXohg8v89QY4uk7jj6eR/kIX7qO7YVj+Iw5nH6RB9hT/9HuL7+cMYuWkke+P2FjmfSim6xux2CgddWDm9eLdSRhQ+jhBCCGENq6cX/f3978qGwdWrV0ej0ZCQYJlcMyEh4ZZrrfz8/KhXr57FNGZoaCjx8fHobko/MHbsWNatW8f27dvvuKg/LCwMgKioqFvWsbOzw9XV1eJR1Xz+zIMAdKznVez7Nh4eBK/5laCffsJr9QV4Yil1qheMZAY72vCc13RU5GOj0VK/5oPm9wZm5qFPepS8k+/w7u9r6HJgA8siZnHpiwWMaDzCVElR+Lh+QaB6OTmRi+kXb9nfbH02Z64Vmq4sNI2s6K1LdmpUjLhnKjSNNpJvZRb9m48jhBBClIbVQde8efN46623OH/+fJlObGtrS4sWLdi6tWBRstFoZOvWrbRp06bYNu3atSMqKsoi59KZM2fw8/PD1tYWAEVRGDt2LL/88gvbtm0jODj4jn05cuQIgDkj+/2qb9MabHi1A/MHNbtlHa2PDw6NG5mmjRs9jlv/d3mtuhftHZ348tFgfDt04AXvIQz1GsGjoV1RqzV4OnrQ0VbLt3Vz8I/9hyEnDtHvfAwvXrpEUvgSwnxa8cPFR/hurkK9vILB1czMfLZf3G5x/rPXzvJD5A8YFSOT/pzEwLUD+fSgKRVJ4c2yrV3TZUy5xqLPDbyz0khgtHXpJgrLVySzvRBCiNKxenpx0KBBZGdnExISgqOjo/kuwhtSUlJKfKwJEyYwdOhQWrZsSatWrZg3bx5ZWVnmuxmHDBlCzZo1mTlzJgCjR4/miy++4NVXX+WVV17h7NmzfPTRR4wbN858zDFjxrB8+XLWrFmDi4sL8fHxgGmjbgcHB6Kjo1m+fDmPPPII1apV4+jRo4wfP56OHTvSpEkTa38cVU6on3UjdCovL0ZVq8aoatUYEfoxvR99FNveH2O7/CnGXF1JXv/PSc9MpN6Flbj/tISc6EukXQ+O/srO4vsLFwhauxbt92sB8LIpFHRl5/PxwY/58fSPPBf6HE8/8DSPr30cAA87D3Zc3AHA0hNLGdd8HBTKM6aycqRLfeiE+blTqnV7PhYe2ZWRLiGEEKVlddA1b968u3byQYMGkZiYyNSpU4mPj6dZs2ZERESYF9fHxsZa7PHo7+/Pxo0bGT9+PE2aNKFmzZq8+uqrFptrL1iwADAlQC1s6dKlDBs2DFtbW7Zs2WIO8Pz9/Rk4cCBTpky5a9d1P9F06caGpb9ytHoI2DlcL7SBJ5fik9aT0BPVyfaqz/6AVrieWU094xkKr976OT2NEdNnmF+7qtWoMC2kz80zYAdczLjIzP0z8bQvuMN00p+WG6YPjxhO96xEal9/nZWTxrXca3jYe5ToOoyFE6LmW7cuq3CgJUGXEEKI0rI66Bo6dOhd7cDYsWMZO3Zsse/t2LGjSFmbNm3Yu7foouwb7rTezN/fn507d1rVx38zlVbLJy2eASDIptBstL0bqsErCJ35CYfS+2PU2BJXuy82UTtwUqvJuj7aFaPT8dCJSN7wdKetoyO/pqdx4zeUnWeg8D2PE/+YeMt+HEk8wkO5BcGSNh++OfYNEx+6dZvCCi/Ct3aUrKyL5/VGPZ8c/ITabrV5qv5TZTqWEEKIqqtEa7oK56S6OVfV/Zq7ShRla3PTx8UjkLDODjzuORlXXSwrd33OkitRNHRyJ9i/vrmaq4sf0xPiGZKUyILkZHN5HSc7q86vLhRP2xhh84XNJW5rNBQEWiorR7oMigGHPAWNoXQ3kCw+upjfDn7P+3tm3LlyMSLORxB+PLxUbYUQQlQeJRrp8vDwIC4uDm9vb9zd3YvNzaVcz0p+u0SlomrTaorG6Ko2o/E7sIgWed8z9OG3ebbj62htbFm0cSpg2vMyLsW0lVBCRsEC9je9fRjm4cGYVAV7/wBGNh5JZEokSTlJRKVGkanLJCU3ha4BXdl0YRMAaiP8k5ODi1qNNt8Btark94EohT6Xar3B/HktCX3qNRZ8aSDPBj54RmNVW4C0H/7Hot8M/NRBDcNK3AyAPEMeE3eaRvO6BnbF3+X+SlMihBD/JiUKurZt22bO6L59+/Y71Bb3qyIjXQAeQdB3Pv4LJ2KjzwStMwAuDu63PZZLrUDISuc5m3b07DGVms41GcAAizppeWk4a515Pul5LmZcZOs3rzI/9gK2KhUvX6vN5czLjN06lqZeTRnZZCQpuSk42DjgYONQ5HyFgy4bg2lTbq1GW6RecXSXLuGYB455EHZKQW/UY6uxLVFbxWCg/29JAHQ8brQ6YItMjjQ/l426hRCiaitR0NWpU6din4t/F9tiRroAaD4E+6cyafr2QlI8QvHIiaJ6s3M8HWTPAtvn8dbW48y2r7hyfcQL4JJXXyJrKvS198fL2bRh+fZTV4lOzGRE+2BUKhVudqYVX828m9HMuxnvx4wGQKcobN6fiKpvADsv7WTnpZ20q9mOYRHDcLBxYGmvpdR2q23RxcJrumwMpsCppEGXMb8g2NEarAy6CuWPS3ZRYVAM2KhKvpTyRjZ/KFtSVyGEEBWvVBtep6amsn//fq5evWqRMwtMaR7E/anYka7rbDoOxy39c9zSY7Bv1JCA1rWomXKZDL2ab/NDGVN9EadPb2XTkf/hX60ODQLCOKvLZOn06YyJiaLXBx8wPPwAYEpr0a5O9SLn0Ba6k/Vyci6FU94OWjcIMG2yvfL0Sl5v+Tqnkk8R4BqAm50bSqE1XTYG0/6LjlrHEl23wVi0rZPWqURtlUJpLtSKKWCzUZf8fzuHX7fz1m4Da1qrJegSQogqzuqg67fffmPw4MFkZmbi6upqMVWiUqkk6LrPFJ4Ju+VIF6CydaD6yy+T+ddf1Jo/j/1//EDNlH1M1v6PQ8a6fOfyAH4PduSRRl1I1hjZeuhH1v65BIB1H/7DB4oLbaIdiTn7B/NS/qT5/Gk4OFhOE3rY2ZufG26zqD06NZpvjn3DV0e+wtPek6U9l5KryzG/rzXAhYwLuNu7l+hnYDRY3jVpVfBTaJNutdEUsBU3/XkroSsOYqNTqHPFgG5U6TPpCyGEqHhWZ6R//fXX+c9//kNmZiapqalcu3bN/LAmMaqoem430gXgNe4VgleuQOvnR7RfH2KNpu2GVtnNoJPNfs5pjZxwjGew05c8W+cUjjYFQdSUj97ix1Xj2PfPKlYt/i8tPatz4LXxFsdPyy0InAqvivq6+9cWOb72xu3lqyNfAaZNth9b8xjbLmwxv681wOQ/J5f4ugtPL9pcD5xK3rhgpEtjtH6K0EZnCtpcc2R6UQghqjqrg67Lly8zbtw4HB1LNjUj7h93CroKM2jsGaCbQZpi+px8Zfc5zVVn+Mb2E560+YNBAcdZ1vPWa6pO5mbT+bPPOHB9myglP5/U3Fzz+5M6mPbLbO7dnLY12vLLY78wp9OcWx7PIt2EwZSQ9XDCYfbF7bvztRSamrR2pKvwWjKNYlrAX1oSdAkhRNVmddDVs2dPDh48eC/6Iiq5200vFicZN57VvUOG2hW1YuBnu/dopD5vfv+Jlipi+9aktm3xi9KzFSOtunXj7UGD2NuwESE6HY3t7Wlsb8+QBs35v97/x+ddPwfA096TnkE9GVBnQLHHMuqNLExOYllKCmq9KQIbGjGUkZtGEpkcSXRqNM+se4bfon8r0lbJt1zTZVXwYyg6vVhaZWkrhBCi4lm9pqtPnz5MnDiRkydP0rhx4yJ7L/br1++udU5ULlorRrpuTP+dUIL53vctRl952/zeNe8wPrj0IENsNuEcnMUy/wBmXk3goC6L0e5eTE9IsDjWzJUrmQkE29qysGYt/G1tUXR6HvR+sMh5Z7SbwbQ201h0dBF1PepS3aE6p1JO8eOy11mTZErd8Fy0Ezc++goKT60ryBL//t73ebT2o2w8v5Hk3GSeeeAZi5EuG4N1qRsUY8EQm9XrwW5SmrZnrp0hLjOOjrU6WpWqQgghxN1nddA1cuRIAGbMKJpdW5Kj3t+sHem64axbO2g6Gza8CdXr4/5SBK0PX2b6/n7E6GJZEjKLOTamtBHHc3NQA8XtcBij07EkJYVpvr4o+lsHIBq1htHNRptfN/NuRoRxLnAFgO+PxdCIRsW2zcnPYU30Gt7d9S4As/bPon2sIze2VLd6pKvQQnqbUqzpKszatkeuHuH5Dc8DsLjHYlr7tS71uYUQQpSd1UHXzSkixP3NzkZjfh7gWbp1fLY2amg1Clxrgk8DVGo1T7b0JzlLx6zYVH5w7s4Ifgegkb0Dl5725TvVJFLy7Nl7ZhNHz+/iWuZVnu8yieeNV8m68he7oqNps307we7uOD5YdMTrZi5a12LLuwV0Y0vsFouyGwHXDdl5mebnWoN103yFU0ZYO0p2M2vbxmbEmp9fy71W6vMKIYS4O0qVp0v8e/i62TOlTyhOdjY81bJ0W9DY2qhNuSdCH7UofzYsgF1RSZxP8LUoV7vb0M55P0cyXsDfqx5PthuLwWhAo9aw8eQvzD97lvyzZ3ny77+Z7utLyMYIbAMDb9uHjJyCOx9HN2xI7QZDqelSk2ceeIZ3/nqHtdFrb9m28KTcjcSqJWa0TDehM5Z+XZa1I12GQueW9WBCCFHxShR0ffbZZ4waNQp7e3s+++yz29YdN27cbd8XVc8LHWrfudJt3Gpa0tVey3cjwvjR3x72fGsuf8z+AxI1HvTMv0h3JYY+NRYQcySQLTVn4RnYEeWvBaAY+CktlZ/SUunUty+fhofTvHnzW/YhM6fgzsenAoPo/NAb5tfT2kyjR2AP9sbt5fvI74u0VRca3LWxcqSrcMqIMk8v6vOsqm9UCs4tdz4KIUTFK1HQNXfuXAYPHoy9vT1z5869ZT2VSiVBlyjiTgvwn+7RlMhCr+NtqwEq1levznqq0aPVf+DcL7imnQO32vQNe4Ff935trr/z2DE6tG/PychIAm8x4pVRKMfXzZOkthpbOvl3opN/J1558BU6r+yMjdqGr7p+xdrotcSeWmGua2OAcdvHcWzosVtej86gQ6VSoVVrLbcfyofsskwv6nLvXKkQg1Iw0iVBlxBCVLwSBV0xMTHFPheiJEqyAN9jyPNc++57fn5sLJYTeioa7mqPtkZrRp5ZQyPn03Rt8iS5uiwiDheMSmXn5DB37lx69uxJ586dC7LZG/JBY0NmoRxfzsqts9k7ah1Z238tBsVATeeaNPNuxpJ9F4DdgGlNF8Cnhz6lf53+5j0e8435aFQaknOT6fdrP5p7N+eLrl9YpIwwjZJZN1pVmKEMQZdMLwohRMWTNV3initJUlWfiROpNmIEZ36/AGcSi7yv19jwVehANCojq73WYpv/BA83eYIjMX+yfOcnAMyfP5/58+cD8NOMoTzhfAjSL0G9XmTmZJmPtTchAfWpUzzwwAPF9sXXyXKNWd+gR0hiN3lGI3aKKafY0uNLWXp8KceGHmNv3F4m7pyIp70n59LOAbDz0k4upl/Eq1DKCDWgzy9L0CXTi0IIUZWVKui6dOkSa9euJTY2Fp3O8i/oTz/99K50TFRthXNC2ZUg6FJptWh9fIAL5rI+jf3IyMvnj0JBmEFR0/9qD4YGZuJ9xYu2DzzCnyfWcjHprMXxnpy6jMdDbajnqSYv4mdeCfTidL4XcxITGXH4EH3ffJNBgwbRrVs3fHx8bts3W5UNHyTE82NqKmPyagAFWw7tuLiDabunkZqXSmpeqkW7jRc28pxNO4uy/NySj1YpN43IGaxoC2DIz2fgX0aSXEHfTIIuIYSoaFYHXVu3bqVfv37Url2bU6dO0ahRI86fP4+iKLddyCz+vazZPqhw/s6uod483rwWxy+nkZyl4721J4hJMo1YLct2prVjKg/m5dA0sHWRoAvg50hTUlMvRxVzG+bS19WDTxITUTBt3P7bb79Ro0YNjh07hm1kJInzP6PayBdw7d7d4jhXU1JYnpoKwOexV2hUKOh6Zdsrt7yWjec3Mji4jUVZvjVThDflvDNYuZDea/1+HvrTNNq1ebAEXUIIUdGsznY5efJk3njjDY4dO4a9vT2rV6/m4sWLdOrUiSeffPJe9FFUcaVNqnojWGtU041O9by4kJxl8f5eWzu+dnbltbyz9PQKMpc396lvXhXm5enLj6++RNNazcgMeZQBNUMtjnHlyhVmvTaUlP++Re7Ro1x+ZRz51yxzWu385x+L1zePQN3M29EbgFMppxixYZjFe4ZCC/pvSNelk5JbdLN45aaceIY864Kuan+cND/Xy5ouIYSocFZ/G0ZGRjJkyBAAbGxsyMnJwdnZmRkzZvDf//73rndQVH3WjHRZtLspWBtZTOoKo0qNrUahn62eDtUDcbRzYUC36Uzo/zkP1u5IqF9rdl3owE7vt4kJ7kuH3p/yQK2WFsf436oNZEcXTGHmHj1q8X58SkFA1NDBAW4fc7H1ya2EepqCu1y9ZZCVf9O6rHOp53jk50fo92s/svXZlge6aaRLsXJNV+GO5usl6BJCiIpm9fSik5OTeR2Xn58f0dHRNGzYEICk63vbCVFYaYMuO63G4vW4rnVpXMuNX/++wpbIgv0Zk+1d6eLsQmdnFcfajyZda4uHTwNGdJ9W5JhajS1j+5j+OPjopxe4khJDfK6Rgxk5XMnX08vFlYsvvkTd3bvQuLuTuW0b1y5fNrd/1dubtn1XkKZLo22Ntnzx9xdcybxCfc/6fHLwEz572JTHbmSTkUzYMQH1TQHazYvhlxxfQlpeGgDn0s7RqHqh7YluGukyWhk4GdUFc7X5eUVH2IQQQpQvq4Ou1q1b89dffxEaGsojjzzC66+/zrFjx/j5559p3Vr2dhNFaUs7vXhTOyc7Gx5tUoPO9b25kprDzPWRbD+dSLKDG6ReRIXCWX0Ma11q8OWuL4jzDcMr6SgJ3g/hlXgY97QodnabRPDpQwRc3MICjZYrQL6i8PxF05Y5B7KzmeHrx7Xvvyc/KZnUlSu5WmgDbhcFGniGolKb+jb2wbEA6OPieOa5Z7DVmO5u7B7YnfBe4fx30VCLa/junyUM6voqGrUpoDyedNz8XkxaDBExEVzIuMBrzV8jSONt0fbgpX0oilLijauVQkGXUWf9SNe13Gv8dfkvugZ0xVFbui2ghBBCFLA66Pr000/JzDTtRTd9+nQyMzNZsWIFdevWlTsXRbFKPb14i3bOdjbU83HhnT4NOB2/j5AHgiDOFLycda9FkoM7dtkJ1I3+BYCaTWuQdfYMAHPtXVkbuwkAnbMD3JSdYlVaGu4aDcb3pmNA4T+e1cgotJ2Oi1qNPjaWzD/+wO3xgWicncjYto1LL4/B49ln8J061Vy3hU8LfB28gThzmY0BDiUcop5HPSb+MZHotGjze2//9XZBPZUNcx60HKkz6vLYeWknnf07l+jnpxSaXjTkWXfno96gp+OKjgC83uJ1hjUaZlX7stp9eTe+Tr7Udi/bbghCCFGZWBV0GQwGLl26RJMmTQDTVOPChQvvScdE1RbqV7DBtI+LfamOcadUE3W8ndk9uSvZB924sH0dBlREegZiVKlJdnDFN9u0IH5qvf48ZuvDxjwX9Botr3V8BWd9DtlGGwIyviT2pjsfvym0hivDaCS90DRfPgqHuvfAXaMhJXwZgf9bTupPqwC4tvx/2AYG4vHcc6g0ppGsVj4PAQX7OmoNMP/wfI4mWa4bu1l0WnSRBfs2BtPdko8EP8L4FuNRq9QsOrqIjrU60rFWx6IHKZQjzGjlerDz6efNz5NyynfZwMrTK3l/7/vUca/DL4/9Uq7nFkKIe8mqoEuj0dCjRw8iIyNxd3e/R10S94NWwZ7snNiZpMw8GtRwvXODYpR0hMyxZUtGd5mAmy6Lq46mdA6bAx7i2dNb2FarOTuSFHY4twZnU/3TnqatgmyAaV3Hk+ESQnLqBWJ1PxO+NsLi2G+MfYVXPv3E/Lr/+fO8VK0a46p7ob9yhbhJb6KPLtgSKGHmLPLOn8d36lQSP/uMDkeuUnh5vEemwv5CAddLTV+iU61OfHPsG7bGbjWXx6TF8NuZNRRO32pzPfZbH7Oe9THrzeUrTq/g18d+JcQ9xPIHUyhYtHY9WOFs9oWfl4cvj3wJQFRqlNVtFUXhYsZF/F38SzwNK4QQ5cXqeZ9GjRpx7ty5e9EXcZ8JrOZEi0DPO1cspPDXpDWpJs671eAfr7oALPtPK5Y/0INH+/2XT1s8XaSug1ZDiJcTXi52/OakxzMjBu9qIbzw3Dw+f6IBznYFQaKxeV1m+voxrVAC1YXJyRzKNoVSWXv3o0u0XKSe+r8fORXagOQFC8ncvYcEvR799VGr3gcLAqH/dvgvY5qNoVH1RszrMo+3Wr1lcZy5B+ZYvNbm3/r6jyUVsxdkoaBLsXJNV0VuIZRvvM2F3sGyE8vo80sfxu8Yfxd7JIQQd4fVa7o++OAD3njjDd5//31atGiBk5OTxfuurqUb1RDiZqVdCxZczYlFz7dg1HeHLMpb1/bkiRb+9Gjog6u9lvfWniA8I49OjV2wOZXPqb1X0fp+zqxhpvrp2SnYxV2h+c+rqXM1gek9e5mPNfLSRdYEBeNva3vbvqQaDHQ5Z1q31dvFhQ9sa4Ki0LB6Ix6p/YhF3WcfeJYn6z3JqM2juHbkIHWuFJ1evJUrmVeKlKkKTS8qeuuSoxoLBWw6Y/kGXRqV5s6VbiEm3bQ37NbYrSTlJFHdofrd6pYQQpSZ1d9qjzzyCP/88w/9+vWjVq1aeHh44OHhgbu7Ox4eHveij+JfpFCcUKLtg4pja6OmdUg1Qv1caV27YKStQ10vnmhRC1d7LQA13U2bYl9wM92Zl5ulJ79QbOLq6Mm+Y41YujCZw79F4uXkYH4vV1H4RZcMQLxezzZPNXkt49mnpJFVKGBJMhSM2mzIyOBMWg4DdisMqTWgSL9VKhW2GltmtJrGrHADL2yyTBlxY3oxzC+MPwb9YfFedGo0RRQOusow0lWafRtj0mJY8M8Coq5ZP0WoVhX83u+UiPZ28sqwubgQQtwLVo90bd++/V70QwgA9IaCQKPU+b1s1Ljaa9nwagcAHv38T45fTqdnQ8uNrP3cTQv8L+bm0TbYlYSYdAD6vtKUWh5X+GXmn8TrH0BBRby+CaMe+YI/j//MH5G/A3BZlc/69HTeiLsC54A9AKnUtk3mx4BA6ndM4/Ahy3VFf+fkMOwPB9yqH4Vmg4rtf7VTcWQVUz46cDD5NS8y8aGJeNh7sG7AOn6N+pVvjn3Dpgub+OzwZzjbOtPCpwVNvZqiKrymS2dd4FTW6cV+v/YD4ETSCb7o+oVVbQuPdOmNenMajpIoPDVZmn7n5ueSkJ1AoGug1W2FEOJOrA66goOD8fcvukhVURQuXrx41zom/p10+WUPum5u98MLrUnN1hFYzXIq3MnO9PHPzVdo/2Rdti6LpE5Lb/wbeKJSVaPPNF/+/n4judeSUWNEo27MgHZjzUHXX6nwWzHTeud0OhbjykK/qxiC86DQLkKp17PMp/38M75T3gG1mvj338fxwQdxGzAAlT6Tayt/Kva6XE5fYcG4BebXga6BdPHvwjfHvgFg8bHF5ve8Hb15KzcNtxsF1k4vKgW/h9KMdN1wMcP6fxNu5DC7cW5rgq7C/bY26NIb9fRf05/LmZdZ89gaSVchhLjrShV0xcXF4e1tmbgxJSWF4OBgDIbyvdNJ3F+ydAWfn7Lu2XiDm4MWNwftbds4+DrSeXxTaro7oDcY+XpnFC2DPGnz2nPmOm1y8ok+nozz925k5qZxLbO48SiTGi1fIyHkNAn7PrYoT3csSDJ6cdSLuD0xkLTVP5O2+mfipryLd9N0Mv4xrYtUFIWjublcDQok8dRpBu7bR62bkqM2rt6Ysc3G8sURy9Gkq9lXLbLhX027bFVi1cIjRnqDdUFX4SnBwkFQSRWeXtQZdDhpnW5T21LhETprF+Rvj93O5UzT7gMxaTESdAkh7jqrv9Vu9Q93ZmYm9valy8ckxA3VnApGNUp7y7+N2rp2xy6n0XTGJjp/vJ2E9FwijsczZ9MZnl60l1H/d5C/zpryVNk62DDn+AXsnKsB0Kpudx4LG0mAV30eatwB9fURGpVKzdHzf/FP7gDicy2DPX1YK9yffAKA6LRq/LpRzdmQx81pTK9eD7hsXfXYNU/mmdgLvPrHH3xwNYGElBQMhXKImc6l4sWmLzKj7Ywi16UqFHRpDAo/nSl+BK04RsWIxmA6gLUjXYUDrdKkmygctFk7WmUolMjW2hsAruUWbHRe3mkyhBD/DiUe6ZowYQJg+kf+3XffxbHQX+wGg4F9+/bRrFmzu95B8e8ytG0QCkqxm1uXVGmDNb1B4dCFaxy6UPDlu+lkAptOJrD7rYep4e7A1tOJ6PxD6VavE481GoxKpaJ7M1NaiufC8tFobAho7E7ssVQuns5gZ4ILkGk+XlLUYbxbnuKSUw0iazwKipprfu2xv3YW/5SCtA92bvmkeVimokgzGEhbsxb3xweguSlPXv86/QlwDSAvP48Xt7wIYDHSpc2H9/e+z1P1nyrRz8Jm216+m2Ng/UMqjg+ycs/HQkFXaUa6yrKIvyzTixbr2Mr5js2yisuMw83OTbZrEqKSK3HQ9ffffwOmv0KPHTuGbaFb5W1tbWnatClvvPHG3e+h+Ffp3sCH7g187lzxHnn5h8PFlh+/nEaN63c7enQdSa67M8PHtEdRFM4evMru1VFoNKb/ndoNqM+VMwfZsP9HDp2NszjOgZMxHL3gzcc0pu61CySnx/HN5unYqFTM9fWhs7Mpg6vdo6+RaDgGLDG3TTMauDp7NukbIwj68UeL4FKlUtHCpwUA4b3CAchdMBQwBRI37nzM0meZp+u2XtjKZ39/xqwOswitFmrRT82xs9gYod8+hbM9s7FGvlIwrVeaESOLwMnK4OduBWzWTqlWpP1x+xmxaQRta7Tl6+5fV3R3hBC3UeKg68Zdi8OHD2f+/PmSj0tUSvcqCfmo7w4xrG2Q6RwaGy5m5OLoZotKpeLB7gGkJ+Zw/I/LuFa3x8PXkXotvbkY9xC/YLlNVrYemi+8CvwIh380lzcL6YKmlifEnwDA9oFQYuPcsQi6rt/ZmfvPUdJ++RX3x4umnQDMwdcZ++oYMG3WfSOx6tlrZ2nm3Yzc/Fxe2/EaAEuPL2V2p9mWByk0xafOtm7fRqNixDFXwTkHDA7WB10WgZOVwU9Z7rosa5qMijLxj4kA7L6yu4J7IoS4E6sX0i9duvRe9EOIu6K0i++L80H/Rvx8+BKHY1MBCN993uL9K2m55lxfnZ6tT9Ou/qZATK2iy/OhxJ5MYWyf2ew7s4mMnGucunSI4qhQUbNaCPoHnmFn7Sy+/uVFTvXvT26uZbCTVugmlYSZM3F7rB/GrCxUtraoi1lPqSqUfqOuczCbucDzG57n+0e+J1NXMOWZaygaVCmF1kYpVqabyD0VyeLPDGgM8P4Y63NllSX4KcsU4d26Y7O8peSm3LmSEKJSuHvfUEJUAqVNM1Gc51oHMr1fIzS3WJh/9GKqxWt3H0ds7Qv+jgluUp0HarVg6MOTaVW3+y3Po6DQrn07AAy2Tnj4NisScAHkV8+mzkt+YGODMSOD3JMniereg6iu3cg7e7ZIfaVQni5HpWA5wOs7Xudk8knz6/iseAxGg8XG1oXbWptuIvfIUbQG0z8uninWb+ljsRjeytGqwpn0y3OUTAghSqLCg64vv/ySoKAg7O3tCQsLY//+/betn5qaypgxY/Dz88POzo569eqxfv16izp3OmZubi5jxoyhWrVqODs7M3DgQBISEu76tYnyZ00W+8KhVE13Bx5p7MvjzWtiZ6Pm82ceBKBxLTcOT+nOky1qFWl/OiHjtsdv2ScYJzdTsFPN1c/ivcYhdRjg6kaIrS1LJkxg4pyhPPlmMwCCarYo9ni5bvloUw9hV8OUfeva9z9gTEvDkJxM8pKiI9A5ej2jLl7kudgLeKkK1sklZCewNnqt+XVkSiTdV3Wny8oubDy/EQClcOoXK0e6jIWy8KvzSxF03aWRLqvbGqvm9GJZtk0S/x5l2d2hImToMlgTtaaiu3HXWT29eDetWLGCCRMmsHDhQsLCwpg3bx49e/bk9OnTRfKAAeh0Orp37463tzerVq2iZs2aXLhwAfdCd3KV5Jjjx4/n999/56effsLNzY2xY8fy+OOPs2vXrvK6dHGPlHZ60d1Ry1eDTcHOp081s3jPzVFLq2BPfjp0yaLcYLz9P2KOrrY8+15r8nLy2bzEjaeGRVGjvjsqxxxs9LmkD3oaRaej7vTpqFQqvGt7EvZYbVgDLo4ehG/9kPTsgqmjFPcmQCR2jhnkAWlrCv5BSvvlF2y8vPAa9wop//cd+clJfHnhAn9lm3KJbT4QzccvfMzbf72N3qjnfPp5i74m5iQC8MbON6jnUQ8KTy9am1i1UNCFvowL6ctyB6K1o2RlOG9FUqvUkuJC3Nb+mBSGLNnHhO71GNUxpKK7c0eXMi4xZMMQEnMS8XHyobVf64ru0l1ToUHXp59+ysiRIxk+fDgACxcu5Pfff2fJkiW89dZbReovWbKElJQUdu/ejVZryn8UFBRk1THT0tL49ttvWb58OQ8//DBgWqcWGhrK3r17ad36/vnl/hvdrSz2N2sV7Fmk7PNtUXSu70WLwKLvmY/rYIOtgw2Pv1F09Mrzp5WoNBo01+9YBGjRMxA7Bxv4EaY9/X84BeTx0nsDAUjBHTS22NkmAUVvZEletAjUKpIXmu5g+y0l2fze/uho5gb34kD8AVaeWQnAYyGP0bZGWyb9OcniOO/vfZ9RhtJPLxYeJVPp861Kygply7VVlnVZZV1Ivy12G1GpUTzzwDO42LpY3b60NCoNekz9NSpGi+SyQgB88+c5cvVGPlp/im6hPtT2cr5zowqSb8xn1v5ZJOYk4mHngVZ9+8TWVU2F/d+p0+k4dOgQ3bp1K+iMWk23bt3Ys2dPsW3Wrl1LmzZtGDNmDD4+PjRq1IiPPvrInAW/JMc8dOgQer3eos4DDzxAQEDALc8LkJeXR3p6usVDVD5l2a/xdgI8HWlc0w1PJ1u61Pcylw9csIdT8aX7LNjVro1toOUefyq1isada9H7pcbYaR3Iu+yCo4Mj/v7+eHr5QIvh7MrIIqtQYKKxL3h+I+ACSCw0ted3/Y+Ul5u9zNthb7Om/xpmtJvBI7Uf4Z2wdyz6cCD+ACcTjxf0ycrRqsIjXTYGxepRmLs1RVieo2QX0i/w6vZX+fzvz8t9SuTmbZOEuFl0YsGNM+eTb72TRmWw+Nhidl7aCcCkVpPMd2PfLyos6EpKSsJgMODjY5mTycfHh/j4+GLbnDt3jlWrVmEwGFi/fj3vvvsun3zyCR988EGJjxkfH4+tra3FlOSdzgswc+ZM3NzczA9/f39rL1mUg9IHXbdfF6NSqfj55bb8+WaXIns49pr3Z6nOeTvBTatT3d8ZjVrDJ//5nUO7TrBs2TKigwYzcFM6fWNiuJqv53x+HifqXcK2ZtF/SL+uVfAZTbtyhfykJKo5VOOZB56htltt84jIE/WeYGTjkXzW5TOeeeAZwDJwujFaVVLG/MJBl3UBjFExYqsz8mCUEbVRKdti+HLM8ZWal2p+nq6zPgiPTY/ljZ1vcDD+oNVtb942SYjCMnL1RCea/n3YMqETDz9QcXkQS2J77Hbz87Y12lZgT+6NKjUObTQa8fb2ZtGiRbRo0YJBgwbxzjvvsHDhwjs3LqPJkyeTlpZmfsjm3pWTh2PJN0curCQL8LUatXmT7JvlGywzr+foDHdc83U7KpWKvq80o0Zddwz5RjZ9cwKD3shHn3yGwagQn59P5+ho+kTH8PhPOfQ/cpX469OArn37onZ2poWDg/l41/LzyYuKKvZcNmobxjUfR5eALrwd9jb1PepbZrM3WLePYeF0E1qDdQFMvjGf+V8bmPyTkdanlDKty7I2YLO487EcM+ErikKfX/qw8fxGFv5j/b9lhYMuGekSN4tJMgVcXi521PGuvNOKYBqpvrHe9ONOH+Nh71GxHboHKizoql69OhqNpshdgwkJCfj6+hbbxs/Pj3r16qHRFIxKhIaGEh8fj06nK9ExfX190el0pKamlvi8AHZ2dri6ulo8ROXTqZ7XnSsVo6ypJpKzdMQkZfHh7yc5dOEarWduZcwtstuXlKOrLb1fbIyjqy2pCdls+z6SXp36W9S5ERsdT8ljYtwVjIqC56DH0Hh6YqdW43j9C/mawYAuNrZE5+0b0hd1oRhSa8C8DqwkCq/pssm3LhDIPXkSz+szIYFXFauDiMLZ8Mu0psvaEbYy3PlYuM8J2dbfRV1VbwAQ5eNG0BVcveQbx1eUmLQYcvJzcLRxpEdgj4ruzj1RYUGXra0tLVq0YOvWreYyo9HI1q1badOmTbFt2rVrR1RUlMVfpGfOnMHPzw9bW9sSHbNFixZotVqLOqdPnyY2NvaW5xWVX4iXE1qNiieKSe1wK4UXd99pevFOEtJz+Wh9JIv/jGHggt2k5eiJOBFf5tu07Z21tH3cdLfRmX0JXN3txOAnhxdb91BODlMM53DY8gzVGupQFIUbA38J+fnEvTuV/GvXim1bWGf/zhYjXTb5MGv/rBL32Wgx0lXyKcLlkcv5bOdM8+s8rYpPDn5i3dSmsfQBSEVtP1Q4YHO1s/6PubKM7p1KOcXg9YN5ZesrVS6lgCiZc9enFmtXgaDrRLJpR44G1RrctzeEVOhVTZgwgcWLF7Ns2TIiIyMZPXo0WVlZ5jsPhwwZwuTJk831R48eTUpKCq+++ipnzpzh999/56OPPmLMmDElPqabmxsjRoxgwoQJbN++nUOHDjF8+HDatGkjdy5WYWvGtufglO64l3Z6UVu2/xX6fbGLzSeLjlKkZJV95KFemC9h/Qo2AP9Pv9dZvnw533//PTqdjh07dpjfG99Biz4rlV/O7aXhmdMk5Zm+kEPt7MhRFK79sPyO5wt0DSwy0gXwx6U/SM4x3RF5Mf0ir2x9hb1xe4u0V25e01WCAEZv1DNz/0xOJhUs4LcxKOQacolJjzGXpeWlMeWvKczcZwrOErMTLTKylyX4cbyUzJT/GWh3wliuiVULB02FA7ASn7sMo2zfnfyOo4lH2XFpBxn62+edE1XTuSoy0pWTn8OUXVMAaFitYQX35t6p0JQRgwYNIjExkalTpxIfH0+zZs2IiIgwL4SPjY1FrS74MvT392fjxo2MHz+eJk2aULNmTV599VUmTZpU4mMCzJ07F7VazcCBA8nLy6Nnz5589dVX5Xfh4q5zvsVaq5KyJqmqNS5ey6Gas12ZjqFSqWj5SBAu1ezZsvQk8VEZPPveM+b3O3XqxIwZM/jxh2W0D0gkLtuGEWsLvkD7h2j5yMZ0l2TSwgU4d+qEQ+NGtz1ns2qNIfooUBB0jdk6BhdbFzY/sZlB6waRoc9gb9xe3mr1FseSjjGg7gCaejVFMRjMiWe1xSykz9Rl8u6ud2np25LBoYP54u8v+Pqo6a7Lm9eSAZxIOkFtN1PQ+dnhz1gTbbo7MF2Xzrpz67DT2NE9sDvHE4/x2HfncMiDZd3U/HnZuhscerzzOwAemQq/9KiYVBWFj1Oa9taO0BXua1Xa5FuUXEySab6+MqeJAFh5umAJQ8PqEnTdM2PHjmXs2LHFvlf4L/gb2rRpw969Rf+6LukxAezt7fnyyy/58ssvreqruH+VdXrxVs4kZNCkphsvfX8IowKLnm+B+hbbCt1JdX/TP5rX4rPZsvQkzXsF4uHriEql4t1332XixImoruzHx6EazCkIqtxDGhDcKJGYDS6Qb+D8k09S968/sale/ZbnctE4MTMxkRSDgQ6qJoBpNClDl0Hr5QUjwrmGXN7b8x4Aq8+uZssTWzAaDdz4ad5Y03U86Th/X/2bwaGDWfDPArbEbmFL7BbS8tLMARdgMcJmc33A7PeY3zmWdIyXmr7E4asF6+TWnVsHQJ4hj3Xn1uGWpdAu0hS1JRwysrRaPLsv76ZtTevugKqZXL7Z7C1GukqR5LQs04uFpxRlEf79R1EUYhKrxkjXnjhTyiaNSkO3wG53qF11VXjQJURlUNqF9M+GBeDpaMvh2GscPH8NZ3sbiynFGb+dxEGrYdP1qcfDsddoGeTJtSwdbg5aqwIwT18ngppU5/zRJE7vi+f0vnhCmnvRa1RjwPTHxFVNMzZ8fsyinXO9Dth/PA+//HZciEjFVqUi7+h+rm7ZRX5CArW++hK1neVo3IbzMXx9PbmqzdFkaFOyfr6+83WeTM6m3vXXWgMsPrqYLbFbALiSecW81RDAgn8WWLTv4d8N2ARAO+8wlnGQXZd3sYtdbDq/ieTcZG6lcMBmf/1XsPLMStrUaGNev6c36NEZdThpb/0FlGNbtn0brbnT8+b61rZVFKXC0mSIyi8xI48snQG1ypRrsLLSG/QcTjD9QbXi0RX3XULUwu7PlWpCWKm004vB1Zx4o2d9lgx7iF1vPcyql9oQ4uXEW70fwMfVjsy8fCau+sdcf9PJBDafTODB9zezZFfMbY5clEqtos/LTeg5shFqG1MQEX04kVN74jBeT1lx4PfzZKbkWbRzc3MDtYbNAe3ofzGaa/n5ZC2aQNrPP5O1axcZERFFzvXbuXPm5+v+LrqZ9q38k/gPZ5JPmV/bGDAHXADfR35v3nLohteav8a+Z/cR3iuc3oG9zOWuKgeLesUFXPO6zDOv/yhuHdrW2K0MWjeInPwcAMbvGE+XlV24lHHp5kOZaYylWA/2YwSfLcjHP9H6NBf5qam8u9zA5BUG8q1Nc3HTdGSZUmxI0HXfiYw3LTMI8HQs8x3a99KxpGPk5OfgYedBXY+6Fd2de0pGuoSg9EHXjQX49loN9loNXi52bH29MwBhwZ4M+Go3ufqCL7bDF66x6A9TQPPB75G80KF2kWPeSZ0W3gQ1qcYP0/aSmZLH1mWRXDp1Dc+aTpw/mgRAbZ+GnEsw3QnUPqwzq1ev5uk352E0Ghl/5QqfH/XjSFYe1TQ2MOktDKmpeA4daj5Htr5gxMVZa8eLTV6kjkcdugZ0RWfQEZ8Vz9LjS9kWu42pbaeSlJ3Efw/8Fyh+XdbN2tVsR2232vQJ7mNev9HCpwXp10e5AJyU4m+KqO1Wm3Np5+ji34WuAV1p6dOSjec38s2mDwHTCR/27chnmPZSjUyJZNWZVbSt0dac6Xrj+Y10qtWJCxkXeNj/YYs7WdVG05dAtj4bR23JRgfclvyGG/DJNwbmfW5d8JK19DsaXzD90FZk5VrV9ubpyDJNi8qarvvO7mjTvwctg269VVllsC9uHwCt/Frdt3ct3iBBl/jXsi8UaNlpS7em63YbbDes4YatRo2uUOLUgxcsUza888sx3uhRHw8n6+66tNFqCG5cnWM7LwNwep/lbgpjR73O+3PfonFgGwKrN8At0JQb7+rVq+zPySYsMhoADbDEP4CHZs7Cw+MfjHX7k34snmxdwYiJvVbL2AcL1khq1VpC3EN4v937TGszDa1Gi6IoBUGXEfZmZRGXr8dP725u17FWRxpWa4i/iz+9gnsVP4VQKAiwKRRPuNq60jekLx52HgxvNJxjScdoXN00repm58ZT9Z+ig1KH1C8Hm/potJwOXXZiGb9G/Wp+vefKHlacXkFcVhxT20zlyXpPmt/TXP91fXzwY6a1mVbcj78IRa1GdT1dhdVrupIL7r5U8ko/PQhlmxaVka77z95zps9WuzrVKrgnt3fjLugwv7AK7sm9J0GX+NdqEejB2C51OHThGp3vQVJVWxs1DWu68nds6i3r/LAvlj/OJtIiwINZA5tgb0Xw1+KRINRaNecOJ5KRUjBCEtrOjy7PdSGsaQf+3hzLH/87Q/OegaxetZq+j/QmNbNgHzYDMC8xkR8CA0ndFM6l//6CTbI93TRq9l+vk3uLDa9VKhVajdb8fEG3BXyw9wOS06N449JFjMCoixrAlFX67bC3qelc87bXpBTKs6Xo9fSp3YfN5zezrNcy6njUKbj2YvZj87T1IPXGC51l8JKQnWCReHRf/D7z8y/+/gJXrQsB119rro/UrTqziixdFq+3fB0fJx90Bh1atbbYzbsVOy2q/2fvrOOrrv4//ry97mLB2BiM7u4uAxAUEVFRUVTs9mvHDwsLAwtUFEFBQEVKurtjwFh3992tz++Pu91YsN2BG3Gej8cej93P55zP55x773Zf951lZreuwxXpbYrJonPcvehdJJHnBshklxTEL0TXtYXRJBFT0Re2S9iVW9k9X5vPsSxzpnSfoGu/bNO1bccTCC6CUiHnmdHR/PpAH8IcCDK1/cytK+uxb2Td3zCTcstYeSSV73fEkWcThC9JEquOpJCcV1rjPFdPDQMmtyK6j7WTwoBbWzFseltkMhkdh4bi5q3BoDOx7684pNQAFn78cbXrdHV2RpIkXt9STpdd8czPyWGatw/tKoLrM4uLKS+rW0gMCBnA2klrScnSUPlR/s3xFN7s9yb/6/2/OgUXACYTGXo9S/PziMvO4s1+b/Lvrf/aCa5asREQkq7m9XYL6MaEqAl2x3K1uTy75Zkax6+JX8Oda+4koySDwUsHM3PDTLSG6i5AySYhwlHxYie69PUPpC8zlJG59i++/tzIS0tNIEmXFkgv3IvXFEm5pWj1JjRK+RUdRD/34FwMkoEIzwhC3etf3PpqRYgugeASqCs49ZZuoaiVcnpH+BDue/F/fB+si2HAe5s4mpQPwJ9HU3l8yRFGfrTtovNa9QrEP9ydyC7+tO3fjFVHUuj5zr+cLSpl6mu9GTjFHJh6bHMyEeHD6WHTk/F/Tz7OO/dNQZIruU0XipNczmfZWSxv8yBuXuH4qZ0I94vgm2f/payolg/003/Dn4/CmuchYRchbvbttCa2msjtbW6/6B4qyS8s5JaEeN7IyOCOf/5BKVPWu/+arXgx6XV8OPhDglyDeLzb48zuMpsDdx7gx7E/8ma/N6vNlVcpxu7vbLV8ppekszpuNcX6Yvam7eWvC39Vv7eNm1nvqKXLxqUqGeo/d9aGWfz451sAdImTaJEh3IsCKzEZ5iD6qAA3FA0sU/NfI0kS25LN/9+e6fFMjVbkaw0hugSCS6CuAPyoADd2PDeUhTN6YvvvZETbQII8nKqNL9EZmbPmNCsPp7Dngjlbr0xvpKS8dgvIO9vO83JJNm0nR6J2UvL4kiNkFZUz6avdqJ2UdBoaRkhrLwB2LI/j2b73Mye8NYva9eWtDz8i1nckWwfOZZM6FF8Xc8Dtq6uexDWgI6/e8xdP3fItcoMTcYu/hm+GQE6s9ebJB2HpNDj0E9Ke+ZR+MJGigtrLOtTF8fOx5FWIp5SSErKzs+s/2dY1qdMzusVoNkzewP0d7+fBzg+iUZgtdzKZjB/H/IiH2gNPjSdgn/kI4Kywf20+Pmi1EO5N28vetL0sPbPU4kqUbIo4G2txx9a6bBuxqNBLFy0bkVWaxc0rb+bF7S9yKPMQks2byqVc4vXdrztU1f5S6osBnMg+wdIzS0ULoSuQyp6LV2qTa6PJyOS/Jls6SlwP8VwgYroEgkuiPmnYATWIqyk9w3hiRCtunLej2rk9F3LZcyHXzo15MCGPQTXEnaXml7H8kLn8wd/HUpk9zD7dWqs34qRS0PPGCFI+OgxAVqsJuLeaQAGwe8UFjsR7ghwuBPUl6eQmy1wfmYRWV4qLxvxPe/Ph9rh7/8aRt/6k9dj+RI/oBscrqkg7eZIf7036Fh3J6fF2ayg7vQFnqRTaja/zuSooKbZ7nJqaSkBAQJ3zwN7SVZt7sZJugd3YOXUneqOeuMI4misCiPvQ2ntVbqxdRKyLX2epNXYi5wTP9HgGSWF9seq6dzWM9skDepMepdz6rzmrNIuHNz7MsObDcFI4EVcQR1yBudxITWUyEooSLBX86+JSYrokSWLqanNnhEivSHoG9XRovuC/JTXfXCYl1Nu5jpFNw98X/uZs3lkAQt1CLV+KrnWEpUsguAQaWmpCpZDRoo4K0bbGg/ickhrHbImx1rxKLTDHGvnYZEKeTDUH0oa09uaR+cMYcFsrlCqrQDi8IdHyu6eLffzZ8mN/UHzhe5xLMykszSUm5TArsl8hUduZf1cUY3wzAPbONw+++XPysyIAzGUobEiffwv8dhesmGW2jF2Ecd26M8vXuo60tLSLjrfDVHdMV1VUChWtvVujktnH5t0XfRcAI8NH8vWIr2uaCsDK8ysZsGQA+QZr2yXJwWB4qUqD8KqB+HMPzuVM7hm+PPIlZ3LP2J2T27xJKrM9D2ccZnPi5noVWr2UmK7YfKvFs0gn+jZeaVSKrmCvK1N0VZZvAXiu53NNuJLGRVi6BIJLoKEFB9VKOW4aJVufHYJCLmPAe5svOj69wD54u0irZ9JXuzibYbUMLd6bSFZRuV1F/MOJeXQPt8ZEdR4WRtt+zdCXG9nx+znOH8i0nBt8dhGf2txjQL9+PHLfLSS+/So9z5kLpAb7RPDojR+gN+h472Rz7o5OJKRTOHrvbmhPvQDAk/7+3OrpiQT4KZUEGnMwlBtQHv0Vjv4Kt/4I4f3ArboFSzIZCVBa/y2lpqZe9HmxwwFL18XmAowLG0WLZm1p7d0aF5ULayet5WzuWV7b9Rp55Xm1XMSMSe9o9qLJ2qvSUN3itC9tn+X3f+L+sfwe7hFORx8XwNyBoJ9fTw5y0NKW6fW+rzOp9aSL3vtSYroOZlgFdENqK+Vr8zmXf47ugd0dnv/Zoc/IL8/n4S4P4+dcezur65mUfPP/jGDPK1N0Hc82v28Xjl5Ij6AeTbyaxkOILoHgEmhoz8ZKC1m4r9na9c307izak8CTI1tTpjNyMCGPzzaew2AyWzLSC7SU6gyk5muJ8HNl+7lsO8FVyYZTGXaPT1VYumxROylROykZcU87clNLyE0tITTShQGzFqDo0QNjhQD5cv584k+coO85a0X61Nw4Xlp0G1KFW+qzg56sn/wpoZu3sSAnm45OzgQplYSqrKUVEv71pwgj8h4ZdG8pIfu9ogjr5AXQwUYUGPVgtBddSSvfhjFdzWLNLQAGPVvrcyqZTOglif2lpbQvKcGRuta2pSoAZHojXQK7WB6HuIUQ4hZCR/+OrIlbw/v737cbbxeIX0NMV7mxnOVnlzO6xWhMkonPj3zO9LbTzVmZtu5Fk73FKb0kvVoF/x6BPfhk6CeoFWqKLnxJToXoCtEE2o3bm7aXSa0nYTQZkcvkNQYp27oXHc181BqtXwQcFWyZpZmMWjYKo2Tk3YHvckPkDfWeW6ov5dvj3wJm0fhGvzccujfAoYxDhLiFEOgaWPfgq5Qr2dJ1Ouc06SXpyGVy2vm2a+rlNCpCdAkEDtK1uTcLd8YDDXcvqhX2Ym1U+yBGtbdm/fWP8uPufi3482gqr6w8QXqhltmLD7PpTCYKuQyjyT7myN9dQ1aRffsfwK4wa1UUSjmTX+hBTnIxPsGuqJ2UvPbaa/z666/ce++9dOzYkdLwcFq4unKhxOrelGw+qCPD+/HPr1noM3fwYZZVHDwT1pwX33qFjDlzOVBayl1JiRADHw5wZVYHZ/LOueLv9jWa1mPgwlZwC4Sfb0GKcaG5yuoePRufDN8OtS66MBXGfgCKGv51GY38WVjAWxkZBGZmcMFgQKms57+4KpYuqRZrlZ+zH9PbTWdSq0lISKw6v4o5++bYxVZJNYiur458xfcnvmfF+RVEe0ezKnYVf5z7g+N3H7cTfEqDvfjZmbKz2rW+HfWtJear0Ob1beEcbDduTfwahoUP48sjX+Kp9uSnsT9VE16X4l606/noYMZmfEG8ZX5maWYdo+2xFXgNcWv+FvMbb+15iz7N+vDtqG8dmqsz6ojJjaGDX4crOtNuzfE0Csr0qBSyKy6m63DmYWasnQFAv+B+9e76cK0gRJdA4CA3dmzGljOZ5JbqCHHgW6TtP+n6uCU9nVW09DdbwpLzykjMNdfrqiq4AOZN7UpibinPLTtmd/zvY2l4Oh/nnYkdLccyC7X4umlQyGWo1AqCIj0t51555RVeeeUVy2MXDw92njjBJ/fcw7Ldu4mt4rbrETWcjPwkPllr37haPnECbjdOJPb/5vJhlvVD9aXdZexO8GZzajLt92Tz9H5/wr3l7Esxsvy0nvWxRmzlaExhlef3wALzz40fQ/cZdkXTpOzzJOn0RGs0pOj1JCQk0LJly5qe2mpUtXTV5Z6s/KC4o+0drE9Yj1yyFltFr6dEX2LXVPvvC38DcCb3jF1c1opzKwjTl1I5UmWEYn0xr+96neXnlle77yt9XrELsrcVi4EqX6gSxvXsVqtlMK0kjWA3e2F2KdmLtnMdFV2XIths5zqSqVnJW3vMZTYqq6A7wtwDc1l8ZjHP9XyO6e2mOzy/Mcgt0fFsxf+B+wdG4qq5cj7mdUYdr+x8BaNkxM/Zj5d6vdTUS2p0RCC9QOAgcrmMj6Z04YcZvZA3sP5NfWPBAtzNGT2Vgqs2gj2dmdQtFGXFegbbZDr+sjeRqd/swWSS+PdUBr3+byNfb4ut7VLVCGrRgjkbN/Jnyyi+CgnFr6Jo6oxmwcx2OYKvunpK+snYWH5dsY53vPtzTGt1Q+mMJpYnJZNrNLK9pIRfNqro8U0JD/6tZX2s+QO08mO0k4sLP/+zG2bthMePQb/HiMsz8dHuctJ+fRzW2ATfFqXDqscwSBLHtVpyjUbi4hxoKF7V0uVATFj3wO7IbHSw0gjv7XvPboxCVrMb+tVdr5KQZ20urjLC7X/fXk1wrZ64mp/H/WzXrgjsMzZlegPP9HiG/sH9eXfgu9XuVZkpZsulZC9eSjzYpbg1L7XMxaWw+MxigGru5SuJw4l5FJcbCPFy5skRrZt6OXb8cPIHEgoT8HP2488JfxLmEdbUS2p0rhwJLBBcR6gU9RNrCvnFxdkTI1phMkk0ryi8uu7JQZxOKySzsJytZ63uvt0Xcoh8yRqE/f7aGKb1CsfdSVkv4ShTKAh47DEGf/IJ29zc0JlMBN55JwHPP8fwXsN4xWbsgO4jUEpOOBU3Y3jn2wnyjgC3o3y97Pdq1z1doqOm6gyRajU/h4YRHRUFFSLPNOR/jJ0xj5jUYj7fp+O45mtcQ3qAXAG7v0CSZASrrP0c41e+B7mLoM/D0PziNYActXTZMiFqAmmmLy2PlQZYcX4F93S4h2DXYM7kniG1xJwQ0C2gG4cyDwEgQ4aEZBcPpqwh4fDrEV/T3KM5zS2NimywLayq03N3+5nc3d4cM5dSnMK8w/Ms5x/d9CghbiFMbTOVu9vfjUmr5eZVmehLjfw4XN6oLYQuRbDZWckcFGyXSqBLoKWdlEkyXZHNmSvrc3UO82xwos9/QUF5Ad8eM7tzn+nxDO5q9yZeUdMgRJdA0EjYFpC8XP8Mn6jyTbalvxst/d1YuLNuK0/nN9fTKdSTVY/0RyaTkZJfRm6xjo6hnjWOV7doYf1dLsepQwfkGg0dv3gfBg6wnLut23PI5Qqyz0jIZXI6hvdlzJ1Tyd6wnuUFBbRQqflu5EjSk5P4xCZIf7ibGxFqNRd0Op7xD0ApkxHToydyjQZN+/bMd3EmJrUAgLh8iRVn9Ny54gHrAiUNIbai68h28NPAqZXQ9mZw9Qf3ZhA5GMJ62W/OaCRNrydWV06G3sD0jAzC63wGzYS5h1GkcAbMgcvKCi0yfuV4ZMgsjb1vjLyROQPnEJMbg0ahodxYzuS/JtdYa6uSx7s9Tr+QfrXeWzLWXibjjjZ3cDL7JCnFKcTkxQBmIfbhgQ8Z3nw4XocvMGCPOdHiRLiEvqdj4se2JIXDLkKjAZkkIclkl1ZFv5FbF4W4hVhEl96kd7i2VJmhDL1Jj4fa479YHmAtL9PC9+IlaRqb/en70Rq1tPBowbiIcU29nCbjypHBAsE1jsEmFkujaFjW45DohjXmro1jyQV8uSWWXbHZTPxiJxO+3Mn5zJqDk9WREXaPndq3N//Sszc//bSIju06c9+oV5HLq+9t7c/xjBr/Nd9FdWZZixa079uX27dvJ9Ng/uBWAnObBfOUfwCfh4TSQl0RTK/Xk5KXx82/LeW9+fPtrrkxyf6D6/fS9nxsE8wfb/CHypZEp/+EA9/D5rfh+5FwYKFlnC72NGVrFvBLXh4PJCfzSkY6J8/Y18OqC4VNaXiVwfo6S5j7Ibb2bs0LvcwlNaJ9omnh3pxon2jWTVpnb+myEV3Lb17O/R3vv/iN7Sxd9sLHTe3Gp8M+5dcbfq3mllwXvw6TjdvXSUe96nrZ3drWReig6PJ66XPmfmvEP796XbI672syIav4W3J07qWisHlvO9zYXJK4a81djPh9hKUK+39BfLY5FMG2DuDvZ39nxbkVDeocYJJM7ErdRXaZA90hqrAzZSdPbnkSgD7N+lzRSQj/NcLSJRA0EjqD9UOqoZauj27rgkmSeGH5MW7vWYO7qQF8sC7G7vHfx9J4YkR1078m0r7KuaZlJLklOga/v5kuzVtx7OQRSgt1GHRGCjLLOLsvHZMkkR5bQGG2Fr2zP+o+z+J04F2UzZqxOzGXgoqYpM7OzpwOakPnzOpxR/5KJcYaPix+OJBJEc14b0I4a06E88aqP8nWWTM4E2ShMGsVbJkD2ecg+QAYzNYo1r0ELYchOfmQcNskDCUSgSrrv8OU9PT6P4HYuycjnUM5hn19sZf7vIynTgtb3oe9X4OTJ8zcRLB3OBkuwVAx/r7W09ntvB6ZUUeLv54zV/FvNdKc3alQUZWLWboqUSlUvNr3VXK1uWxM3AjAJ4c+gYJeVNrQKivhO0JD47IkScLp4GlCgXs3mDjbw7H76o+d4Ot5RvZFy9g+tXEtXXIbO4Wjz9fJnJOWJIrzeefp1axXHTPskSSJQl2hpXVVbVS6FyMqRFdBeQFv7rb2G53YaqJD9/3fjv/x94W/GRQ6iC+Gf+HQXDCLeduEjgEhAy4y+tpHiC6BoJHQGy9ddFUWVf3u7ou3XKnre6RMZl/x3pZtZ7OquS0BZFXKL8iUSrYcS6ao3MD2c9nojSZcPMwWKg8/Z8Lamfs4GnRGks/kse7LQ5S4NuN0mzs5cN6fRadOs2jc7RiP7yLRyYNv243j8wrR9VXH8Tx0fBUAUqs2fKDXcXdSEoVGIzqbhS8/kMbyA2lA9Uy0k6dPI7n6I7vR3DdRkiRKduyAdS/jKh1BtngK5d4jMZSYrxektIqaxPPnib9jGt5TbsNzfN3ti2wD8UNtWhmNLypmeGkZXY//BUeXQqG5ZROl2bDpLbjlWzxVHpRXiC6Xg4tZXpKIDFCbJLhQUTS38x0w4UtzB4DTf8Okb8Ej2KGCsG/1f4uxEWN5duuzSEjsS9ljEV2qBoiuyGX7eTDOyO8D5I65+WzW7F4qORyXVf7gs3gZYdRhiY1TLs3SJUmSQ1YXEzZxbA66Nvem7a170EV4Y/cbLD+3nEVjF9EloEuNY7R6I6kF5i8Wle5FrcFq0TyaddRh0VWZeVvZmNpRzuWdo0hvtp7f3/F+BoUOatB1rhWEe1EgaCRsLV2KBmY9NqQuWFSAG819XOjZwhtnlYJfZ/ZhzeMD6dbcy25clzDz4/OZxbW6IfyfeAKAZnPmAPbCrbYMS6VaQYtOfvSIMscPZQT2pDjPlYklGs6F3MOBHnfwzbiXifUM4Y+Wg1jcegR/Rlq/DS9StyRCrWFNRARbWkbZtQm6GHkFBdxxxx2UFRYiSRL5S38jaeYDJC3LpDivGWSdpuSv781jDQaeS7Nap86vX0/ZoUOkPv8CxmKz5aBw/XpSnnoaXWJitXslabU8npLMgtwcumalmPeNjLezcxlaWgbb55oFl2dz8w/A8d9h/3f2wqkkD0+ThEfVsiBHF8MbXrD2BUjYAV/2hbRjdha22mqLVeKudmd0i9HM6jwLqNK30QBLY5ZSqr94lmwluuRkolceYfhRiRFHTI4JNps1K0wNcBHaPF+X6l68pDIZDopF23s5Oje+IN6S0bo7bXet45LzSpEkcNMo8XMzfwG6lKSFy8H+9P0A9A/pz+PdHr+uXYsgRJdA0GhcrFBpbdj+e5LJsJSEcISOIZ5se24ov8/qx6k3R9O3pS9tgjzssgaPvz6KJQ/0QSaDQq2BBxcdJDaresV73/vvI/Kff/CcYLb+ZNoUZL2QVXN/SDBbFAKnDkFrsK+Qr0FBM7/hBMrcQCbj2443s6jdGJDJeLfHNP6M6M8fUYMxubrhKlfgpVDw3JixbJ88GY+KzM5wlYrbvbyY4e3D0/7+zAsOsTxvnZ1d2NO3Hxlz5nDgo7m0izlDr3Nn+XZZEQXJPmSfNLtR0w0Gym0UZLpNgdPY0aMpv3CBlMcep/Cff8j7dUm1/X2RmcmG4mI+zMqiLLmIz8pdWHbzH/DECesgFz94YAs8eRz6P2E+tuE1pPwk6/NklEFgR/O8V/PMCQA1oc2H70dBWYF1bj0zLh/u8jD/3PIPLnJrI3ZlxZthc9LF21FZ7lVWZvndudwx8SNVEV2XIgQaEkgvs/mrcjie7DJlbDp638Qiq9B3UdZeTPRokvn9EO7rYhE3l3LfSyW+IJ7vT5i/2AwMGdio975SEaJLIGgk9DXVRnAAjbLmVi51oVZY/8xt5w+MMvesa+HrgruTCieVwlK9ev2pDIbP3WppJWKZr1SiiYywXCej0Oq6qCrSTCaJ6d/vZcrXu3lpxXEGzNvLEm81Z1VGLijt0/SGlal4dkRrFBK01snpoVUSfNNNfNV5Ika5ghTfUMvYRSXe+H/2Hft79+FUdBvWRLbknSFDeTYggPt8fBnu7s7bQUHIgQ9/+pGM4mLOL1jIz+fPA1BsMvF0WioJ2zWYdHKU/v7oxo61W0+6wRpUbszJofiPBZbH2j0bIG675bEkSawqtIqf9Uk6hnabRUvvKPAKg6lLoNUomDgfXCusdENfMgf560tAa01cMJmAMXPM8+RymLIInouDSd9Dn0fAvy30exSadQFDGVLMOutcB8pchLmHMaWVNbi+8uXYnbqbtGJrk/EjmUdYeX5ltfm2wklldNByY2OpkpsuLQOxISUjbGumXVKpC0ezLi9TIdra5hpNEh9tMLvnO4V6WY47JBSLsyD3wsXHOMBnhz8jV5uLm8qNW1rdctmuezUjRJdAcJVgK54cQaOqed7DQ1vy2k3tWPFwf8ux5j7236KfWHqk2rzYrGLKdBUtXIqsoutMmr0VK61Qy/Zz2eyNy+XXfWZrTpZCYpWrjuVuOj7wKmOJazkmJLxMcliWxFMFzowv1TBUq2JosZLHhps7KB5UWpsaH/aO4O1/zuDSyxqI7P/Iw3iMG4umbVuitm5hoqcXS8LDucXTCz+lgqX5+fyUZ21U3dHJCZVMhkGS+MpoYOp8+4r6tqILoPCPXy2/l51NQvpxIhSmIZlMSDZZgADnSxTQ6TbrgeixMO13c0B8JUoNDHwaAMkm85GosRBRxSLg4gMdJ8OY/4NH9sCot2H0/5nP2eh4R5t8t/K0VusfFmS+56rYVYxaPooFJxZQqCtk+prpvLLzFU7lnLKfbCOcVMZLs3RdSq0tR8WLpNcTmNMwy48kSbjkN7zf5KVke9Zn7oWsYlLyy1DKZTw3OtpyvN6dAwpS4Ms+8GU/KDKXxSjcsIHJ203Ia+iCUR8q3dUzO83EWXlltSNqKkQgvUBwlaBRNazMRG1izUWtZEZ/+zIQyirFWPfF5bLrfDYBHhqL6+Lp349ya/dQpvZuTlKu1RJ2qorois2s7p6sSpLKxDpnPWPL1NXOndufgfsFDYPLlJSEjiVGEYyiLJMSrzYU5ZTidetkSvfsQRncDNd+/XAfMcK6tx496HDgAD169ER74gTjPT35PMea8j6qa1fIzWN7STHfJMRXu3e+0UiuwUCQnwpdvoQ217o+ySgj87AzgR+1JSV+OPkHz6LE2oEnWeYD6nrUSOo1E4K7wvYXoNgcT1Z8+BTG4hIUbtb5uuRkUl94AffhI/CdcY/5YEWdMduYOqnEam2rFzbubn+lt92pXSm77GpQxebH2jUmts2aVBkcFCA2gk1xqZYuB8VLxodz+fhHPX/3lPHTCIVDgq/w7795+q3T/D5Axu8DFY1aTNYg1V0T7UhSPgDdwr3xdrW+X+sd03V4kTnBAyBxF7SfSMqjj3EboFfKWdXXcSt75b0DXa7dxuKOIkSXQHCVcLktXfXlju+qZ139fjCZ3w8m2x07n1lMZqGWLWezGN8luMaYsJo4qTbSEwiRKxk5oz3ezVxYOfcwRbladDnl9EIFci9SQgYDML4UjBdMlE7pSOs9NQcVB380l7KDB3EfPZrkhx/Bf7N9rFL3wYNhxUoi1BpKyqs3CgdIu3MaYYlJ6HbtshzzbVdEzil38i+44BaipWjPKRTA0dbRtD9rLr2RnFG/ekYFf/1FzvcL0KdYA/iNWdnk/boYdWgoMrUat2HDSHrgQXQXLlB24CDlZ07T7N13ATmlQfcgyTeSayjnbHk5gwocq6Mk2VhANCb798je9L12bYOSi5PJKMkgvzyfaJ9ou/pgKqNjwulSLV2SXI6s4hoGg86hDMTirVsBuHG/xE/DJYfWnbvwBwBu3SGxbIBjc3VJSQx59Beyu5j4q4/80ixdtTxfJ1LMortzleLGhsJCpm02sqmTHF3ARe5blm/9PfkAtLdmOY7bb2JVX8f/j1SKrtraYF2PCPeiQNDIOBIMb/tZ0lDxpFH+t//w/Nwq2vRIcOf3e3lu2TE+XBfDqdTCamOjA93pH2WffSjJYH+EkhnvDSC8gy8evs4MuLUVEZ39aNe/GRoX63fDrIqUOwUylr17gLTYmq07qoAAPMaORSaXo2ndmrzAHnbnb3jhBZq9/RY/tW1T4/wbx41j8uuvowoJsRyTqVT4L41DCgjAoJORuttqHZLJZERXtCtKLSpCl31xASTpdKQ+9zzlMdYaabJ27UjS6cia+xEpTz5F8iOzyfv1V3QXrDE2Bav+RHvyFNlffkXiJ+vJTzRwR2IC9yYn8enRimbnkgT/vg7vt4Qjv0JJTs2LsK3xpdfzQKcH7E7nlVvdsV8e+ZIRy0Zw+9+3cyH/gp2lS2loeEyX0kHXJAA2Xz4crS+m8PVp8FznLl0svwfmObbnonXrcM4rZfpmk7lMhoN7rk/1/6Q8s9U50t++F6r02KuM3yPxyN/Gi+/XaPPlI9G+BItrzd9L6qTStXkltktqKoSlSyBoJEa1C2RzTCY/3utYUcRKHLF02X7z/6/7r/Vt6ctfR83WmrMZZuvWt9urtyF6f3InJnULJTW/jA2nMvB31/Dor4cr1qhAYbPOyK7+RHY1V98fOr0t23cm8djK4+QpJHpqlQzRqpAkOL0zlWYtL14sstC/DSfbdWZcqZK1hxbxxJNP4OHpCZMnM3/kSD4tL+fw4cP89ddfPPPMM2zYsIGePc110LK8PFmcm8sJrZZPBwxAZzIx8vBhdGWlDHZzI0CppMhoorVGQ5i3NzHp6RiAPRMm0n/tGhRu5g9AY34+pYcO4dKzJwp3dwo3bLCsb0l+Hm9mZEDMGZTAodbRKCtev5yvv6m2n4IVK8j75RcAzpWXk1iRaTkvLo25n4xE1Wkw7DDXJmPlLEAGdy6DlsNh09sQs8YcjJ+XYLmmpNPxUOeHmNxqMqOWj6r1uTRIBv6+8Df3m6ytiS4lpktldLwSPnJ70aUz6lArqrun65rr6LplNsVzNXrHrHsKLy/L722SHa9NVh/XZGXSS7CXNXZKkiRkMWbR3iKjDpFpsFlTykFzUH0FleVFDCYDSnn9ZUPluoWly4oQXQJBI/HltG4UlOnxdXOsX1slDY3pakhtL0e4pVuIRXTVxNReYRSXGxnfJRiFXEaYjwv3Dohgc0ymzRovvrfuPZuR95fZkrPfyUCGwsSUEg2xR7JoPyyUU1tT8PR3ptOQUEoKyvH0d8FkNJGbVsq+GDdAz7ged3HzgGlMfdFcA6y0UIezxhVPT09Gjx7N6NGjAZg5c6blvrMWLWJ3lnmdr/j50lKjwd/bi6PFRSwvsLeyPTBtGvMyMwk+ew6vrCxOvfY6HT78AKm8nLjJt6JPTsZz0i0Ev/MOuYt/Jc9gIKhHDz6xaQRuANL0esIq2iAZMswBzQEvPI/C3Z20/71M/vLllvEJVYLns9bFYFh5HkOZP6EDcpGrTaTu8kZ96hmCPvgStn9oHrhyFtIZV8AsWCWdDqVcSTO3Znw85GN+P/s7qcWpOCudOZ172u4e3x7/lpiM5cyueKw0ShzIOEBBeUGd1dKBS7d02XyhqClzMk+bx/PbnmdsxNhqhUAlGyuz0sGsSzvrnoNWMtu5agcFG9QvkD6lQnSFeFlLgZiKrS7+M2Gyiz/XBtuEEInEXctYV1SIp1xBrtFIxnI9ujt0DRNdNbQGu14RoksgaCSUCnmDBReApoExXQ21dHm5qMgvtf9w6B/ly87zVnfVI0NbMqT1xftBvjC2LZ7O1VvY2DpZ61qji1rJnX2ak5BTSrnexP64XHBTois2sOzt/ZZxu/+IBaDj0FCOb06udh2DVsHPr+7BxV1FSYEOpUbBpGe74xfqVm0sQLfevdl99CgAU9atY8mePRxNSqpx7De//MLuWQ/hmZhEsk7HJ99+g9/q1Xz6f/+HPtm8loLlf1AyaBA3L1/OmXItHpkZFNqIEIBEvZ42I4ZTss1alkITGYnc3VxTzDZb8rxN26PPgkMoiLMG4Bd534U2KZuSjIOUZJTjP38cdv2ZbbImbTMfR4SPYES4NSlhd+puVp5fyePdHmfK31PIL88n16YPn7rCUDXv8Dxe7vOy5fi5vHOsjV/LvR3uxVXlikkyIZfJOZpxhMpV1haEn1WaxQ8nf2BK9BSae5iLyZYZypj+z3ReNpRTuQ1lDfFkcw/MZXfabnan7a4uumwyDxwWfCZ7sehYQdgqQtNBS5c8KY1bdppY161m4VSo1VOkNb8QdpYumyxck6yONRvtfYiTH3ub/ak2X6b+gqSUJKJbRFNfKhMAhHvRingmBIKrhMaO6Xrj5vYcedVa5iDSz5Vf7u/DiLYBgLm+17Oj21QLYr6tRyhtgqy9G2sSXFWpjzB8e0JHFt3XmzAfFyQZLJdK0FNzKrut4PIJdsXvxlDcO3nj4qFGMkmUFJg/uAzlRg5vSKjxGgDNmlv7WyZkZlJYWMjTDz9c63jDqJGc8/ZiVNwF/ikq4qeYM0x85BE+y86ivMKt9vNdd3Om3CycCouqNxdP0unwusW+ppE6IgJNRES1sedtkgCiNPaCXm/ypSzO6iIqSqmwgAx/DW7/Faml9bW9WLmJvsF9eW/QewS7BfN6v9dxU7nZVbOvrPF1Lu+c3bzJf03mm2Pf8PWxr5l/dD79f+3P23ve5oUtz1nGKCTQG6oHDD277Vl+OvUTz2x9xnLsSOYRYvJi7BqEq4zw5p43SSpM4lzeORILE9mVak180Bv1/HjyR2JyzbFzktEx4SRJksVaY5exaXQsLst+rmNiz1hUROuH53H7NhODTtTsmkyrKGXh5aLCRW1jS7ERmXVW/690LzbrTE6pif0x1a3Xp8+crnbsYgj3YnWEpUsguEpocPaiA5YuW/2kVsjxclFzb/8ItpzN5JlR5m+4/zexI5O65dG3Zc3teGb0j6B1oDsfro+hs02Rxsu1RjeN+R/4BZWJLzy1ROjlpCpNyJDhbZQxUqvGx2jeSLsBwXS5qQVd55gbPR9+dSSbvzpOWmwBaicFOq2Rs3szkMtlDLo9muzkYrKTijAZJSK7+hMUFGR374iICP7v449pHRlJ19696TlgALGxsTz22GO0bNmS/hMmIJs40e6J3JKeRnNvb1RRLfnz8BHeysy46P5+VSrY+MYbxMae51n/APaWlrK6bVvCwsJ4VKlgqMGIpnVrvCZP4nyFK9RJoyFMVSFulUowGCg/exa9TcuitH3euPXpirLLHeAeBEFnAHNmqqmsfpmmw5sPp8+tfXjord6WY6oKY0qO1j5gv/IDd/nZ5RTqzEkVS2OW0qyKTi4tLeBC/gUivawN1Q9mHASwc22ezDkJUE3wbUveVmtfwL6/9qXcWI6byo3dd+y2y9isK+uyzFDGbX/dhq+zL/NHzLfP2HS0TEaVuY6IrvKKor4A7mUShTWsubJeXpCHk/0JoxGtycSs5GSSkwz4dFfArdWmV4ytEL/BXTm552CNQ06fOc2EMRPqvXaT0fzmEO5FK0J0CQRXMLYtSxpq6bqU5toAr97Ujlex1mgK8HBibMdmtc7TKOUo5DKeH1NzZuClrtHWsqaXwVl15aewRJFcYpFSS4ReQVQnPx65sw3nbeqFnc0sYuxDHTmzO502fYLYtfw8Z/akc2a3+ceWg2vjce3iYXesefPmSAYZLgX9SNqjpkV4EZERkaxevdpu3JgxY1i7dq3l8U95eSRkZfHF669x8Pnn8VIomfj4Yzy2aBHnbT5UAc6lpnKuwq3ztE0/yDNnzvAIsO399xnwxBOUlJeTOGMGAG3atEHj7gFKJQFPP03qM89QeuBAteeurO1zuLubhaQkt1rGpJx4OP0XtL3JfoIkwYnlkBsH3e4C90BcVa4VhVXNJSX8lJ5ACYmFiZTqS3FRudj1cKwUXJXIq4gulQHGrxrPnW3v5O72d9vVlVLIFOiNetYnrGfZ2WXmYzbzqzQ2qEZ5hZAo1heTVJhULZ4stzzXbnypvpTZm2YT7BpMG582xBfGE18Yz21/38b0xAI6VM51sH1RVUtXTXNztbmczjlNv+B+9tbjepTYyCw079Pf3d7aKZlMrC8qYl+Z+fVIn3sK/q+WRVZYuqSwPgz+4bMah5w9c7bG4zWR9eWX/O+bs3x8s7B02SLciwLBVYIjli43jfX7VENFV0Pdkg0J+L+cwf46GcSojaw+k4HOYCLTplXR6bRCnN3UdB3ZHGd3NcPubkvb/vYCUllhSSsr0pN2yPqBFxUVhUaj4ey+DAoyy0g7X8Bv7+znl9f3cGqnvSsmLCzM7vFsXz+WfPstET168EZQM57092fwjTdx9OhRFi9ezK5du4iMjKQ+HHV2RqZScfjwYW69zVz5/sjRoww6d5Zzjz+Oc+dOduNd+/fH4yazmCqPicGQlUXSI7MpWmdtISSVFsHSOyEv3v5mBxfC8vtg89vw7VD440GIWcPI0OGWISoD+Dn7ISExeOlgFp9eTFxh9ezVdr7tGBgyEKVk746uFE4/n/6ZkctGMmb5GMs5Z6Uz847M44XtL5BSnEKAxq/GufXh77i/7dyLKgO8uftNu4rt84/OZ3/6flbFruK9/e9ZjscVxJFTYnXVKg0OBsPXw9J179p7mfXvLNYlrLM7XnXNNc3NKq4QXVVjRo1Gi+ACMOlMFNXg0jaPNV9jycbDdoc/Dg62/H7m9Jma59ZA3q+/4qw18dJvJuQN6Dt7rSJEl0BwleCICBrbMYhIP1fkMmjpV3OQeF00XKw5Pu+/qiXW+uU1fL3NWufqTLr9B45MJmPY9Lbc8IhZqDi7q7j/w4FMe6MPSrUcVbEfE0bcQae23Xnn8fms++4E25dav+3LFTIKMsvYujiGkgJrbFKPHta6YM/5B/Cwnx/+Ua1Q2wgrTasoXFxcmDp1Kn379mXhwoWWc2PGjKF169Z211NVuA+ffvppzp07x44dO9i0aZNlTHpGBvmlJaiCgkBhfT410dE4tTG7hot37ODcwEEUb9xI+TlrDJZkqhBCiyZCTiyU5sK6/8HfT1qfrMIUOLYEfr2ddgprlqLSKNHc3Rz7pjVqmbNvDrf/fbvd8zy93XQWj1vMlyO+5JcxP9udU11EOBXri1l4wvy8+Dj5sOyG3+3O+yrcaenZkn7B/Vg3aR2tva3P2ePdHmfH7Tt4s9+bAHxz9BuyS6wZs8oKHdDzl57MPTCXD/d/yMKTC6mNqm7Nhlq6lEap2lyTZCK2wJwEsj5+PVVOWn6tLR4sq6LxvL+HvejKzc3ln0KrpTHoNnt3uR0VhWa/+d16/0ClkuFu7pbm8nu27eHcuXO1XcEOVZD1y4zyWP3mXA8I96JAcJXgiAhyUStZ+8Qgckt0BHk61T3hEu9nS0NEV0PvdUu3EEa1C+K3A0lsOpNZ45itZ60WiqS80hrHtOjox/gnu+LioUahkuMV6EKrHoGc3pXGiJb3QUvIOgFZmO8R0dmPkfe2x2gwsfj1PZQV6dn3VxwDp7RCqVJwzz33UHriBPLlfzDczQ2Zi0tFax9XQj6aC3IFCnd3uzXYCrXi4mIOHz7M1q1b6dSpEyEhIej1erZv346LiwtRUVE4OTlhqNojsrAQmUqFKigIfUoKm4qL+OXHHxg3eAi3SBJlB+xjdbIMBjYWFdFVUhMF5mbH87rZPzlOnhDQ3twappJN7wBmYSfp9AS6XrzNy30d7rPE9airfOx4F8H4PUY2d5JzoZlZ/HU/ZyLZV0aGj9Uq9tGQj/BUuWHrBP5kwFzc+1lrhs0fMZ8vjnzB3e3vJsLTnHgwLnIc8w7PI6ssi/yyXCpL2ioNEiBDb9Lzw8kfal17z6Ce7E/fXy2Av8ExXTUIp/iCeMvvTooqf6/1yJq0iK4qlq4Tp0+jrQimH+3nQco4P5xd7Xsgbtq0ic8//5x+UgJPd4IFH7zElKc/JDc1jickDUqZjBs9PFicnw/AggULmDNnTp1bltkIf+X2AzD2zjrnXA8I0SUQXCW4ahz7c1Ur5Q0WXHApgfv1s1rZxq001L3o7aJmTIcg+kf5klVUzowf9pOQU7OwAkjOK6v1XGi0ff/BbqPDSTyVS0m+1YLl7K5i6J1tiOhsLpOh0igYcGsrNiw4xakdqcQdy6b/pCha9wrkwQceJH69uQiqyiYg32PcuBrv7+LiwuzZs/H19aV9+/a4uLgwduxYy3mVSsWwYcMsj5988kmefPJJ/vjjDyZNmgTA4cNm15DS35/TFy7wREoKhpQUdp86xbtyOVtbRuFSYbUwSRLTExNI1OtxzpZzYegCgg7PhXybbE7fVnDfeigvhLUvQexGMGiRygoAc3V3qVzL7E6zyCrNYmKrifxvx/8s0+cNm4ePkw++zjZJFyZ709ZTW9zwTSpg8HEjz/8vmKedb6L5sq8xyWVMf0qOXmV+n0R7R4Pefq5Mby9A/F38eb3f63bHNAoNT/d4mhe2v2BnrQpS+3ES+5guW0LcQvh+9PeEuIVgkkxs3XgTYLaaOlwQtqqLsCIuS2/So5KrOJZ9zHI+uTi5ylz7Ppc13Tc5rxSZohg/NzUHMw7y/v73eaHXC2w5s8UyJkKjIQUo0ZawZcMWOnTogMlkYty4cZSXl7MC+H6HnF/76tm3bx8paacoHGp+X83y9WNxQT5I8O6773Ly5EmWL1+OXCHn08Of0sKjBbe0ss+4tS2CK9u2H8lkQiYXzjUhugSCKxh/dw2+rmrkchlTe4XVPeEy0lDrk0rheGPcS83MdHdS4e6kYt7Urtz29W6eGRVNmyAPHvrloKV+EZirdhtNEop6tGLyCnRh+jt9MehMaJyVGPRG5HIZ8iprbdktgAP/xJOXXkpZoY5/F55i7l+neWRqBJV10tUtWtRrP/PmzavXOFs8Pa2uvkrRpc/M5N/iIruCGiUmE0+kpnCPtw9jp0/n3G9LLdXsy0wm9uR5MuHetbD/O9CVQqdbIbAjKNXg4gNTF5uP/zQe4o9bL2ySCPtiCAsnfQUtb6Czf2fe3/8+93a4l+6B3autV6pSl8y3opG6kx5+OjsYuZtEDiA3Sfzm9BjfhV8g1C0UN7UbxnJ797DpIqUubLkh8gbGRYxjw7fWhJCxISPZKC2tNjbcI5xBoYO4q91dBLmaxbJcJqelRwQlFaJLacTiDqyLpKIkdsdvomPFY5URdqTsYPWF1by9521ubnmznfXqcOZhNiRsYGR4RUmPqlYyk47U4lT2pe/jpsibOJ5SxPHCdbi1XsG/2aPYeszsHrxrzV2YjlozSn3lCiSTxOOPPs6PC36sca05pRItWjTHJJmY+OdtfK9wQmnU4qdU4t/dk6wDBUS1jGTWffegUqlYF7/O4v4d33K8fZaizessy85Fn5hY77+Da5krQnZ+8cUXtGjRAicnJ3r37s2+fftqHfvDDz8gk8nsfpyc7L/NVz1f+fPBBx9YxrRo0aLa+Xffffc/26NA0BCc1Qq2PTeU3S8MI9zXte4Jl5GGWp/q23zYlssV7N8p1Iszb43l/oGRDGjlx63d7YWq3ihZ0uvrg0IhR+Ns/m6qVCmqCS4AhVLOrS/15L65A4nobA707pwtseHLWIpdzXEttm1gLje2okupVLJ582YCnnyCQKUSqcprsaOkhHVFhXjcMI6UKlai4xs2gEcwDH8Vxr4LId3NgssWtQu6EV9jDLe31kllhbDkDojbTrhHOF8M/4J2WU7k/vKLXUFSXXw8ybMfrXUv+cuWU7rX2mBds+soc/q9w+yus9FnZqI9XaVOlL7+Lj6ZTIa/xmpx6+XXlbY+bXFSOPFQ54d4f9D7LBq7iB/H/MhzPZ+zCC7LfJvYKqURtiRtMWdE2nAm9wzbk7fbHXvo34c4m2Ndd2WJjRe2v0CxvpjFZxbz+1n7WLU1cWssv1ethK8z6nh116u8svMV5h6cy6GEHJyarQBga6p9PJi+2Cp8fOQKtIla9u6p3sAe4MsJPuy81wUvH3/SStLokTyBbQPnUuBhdtO2ndSMUd2c+KhnGuPOvwTaAru92lrrwGzp2lVSwvi4OKYkxPPPipV274XrlSYXXUuXLuWpp57itdde49ChQ3Tu3JnRo0eTmVlzfAaAh4cHaWlplp+EBPvihrbn0tLSWLBgATKZzGKCr+TNN9+0G/foo7X/MxAImgpXjRJlAy1BjuJIlfjLSUMFXl1rDLQJLK40bk3+ajevrTpBci3xXQ1BpVbg5Kpi1P3tya3wYTkbZezr+TI7+7yNtsdoti6OIfVcHrGHM9n71wX+mneE3+fs59+FpygrcrAVjg2hoaGW33fv3k1paSnZ7drxsU5Hz169iImJYeDAgZYxHYcPpywigpyWLbGVrCe224uFmtAlJhI77iYylu62Oy6FDzH/8uejkHoESZKInzyZjLfepqiidIYkScRNmowxp3oDbnWPbigDApB0OsoqOgAAFG/aRPb8+UiSROKMe0m86267efW1dFXirrR+cZEbjPw49kfWTlrLw10eZmzEWLoEdLF3hdpSxUUIsCN1hyX7MSY3hlv/upWHNz5MQmECqy+s5r1975FQmGAXD1ZbxqWbyo0PBpkNAxsSNnDLn7eQVpxWLfMxV5vL3jSzcFp0ahEHsjfXul99sdXK6y9TosvSceZU9QzEWbNm8VAPDS18FfyYsIZ18eton2V2ZZ+LMn9uOqsUzLjDh5uiVVCUBieWcybXeq271tzFTStu4p8L/5gPGAx8lp3FOV05x7VaJj71JJGRkSxZsuS6Fl9NLro++ugjZs6cyYwZM2jXrh3z58/HxcWFBQsW1DpHJpMRFBRk+QkMtA/itD0XFBTEqlWrGDp0aLWUbHd3d7txrq6Na0kQCK40DDbf5hvq8msIXi71bFhchbrEmtzG0hPm4wKYe9T9uDuBzzedr20aAGU6Iy+tOM7O89kXHWeLUqXgZ7dy/nG2ioFyJ2/WrDdwYlsKK+YeZu3XJziwOp7Ek7lkJhQRszedTYvMH16p5/PZtvQsKTF59b5n1QKuHTt2pGXLlqRnZrJnzx5at25tsfKr1WoWHDqEysWF1N698fG3tnA6n25fp6wmCv7+21I3Si9JLMrLZX1RIaZ+T5sH5MXBN4PRbf7FMqfsgNlzoYuNxVRSUuN13SKCcOlZ3RUJkD3vc7THjqGLre7Oy/q05npSFGXAqT/tKrIDYGM1knQ6nJXOtYusKtjGKCkr/k7+b+//MfXPyexL22dXYmJP6h5e2P4CP582Z2raxpLVlq3549gfGRhqFcfn8s7xwYEP+ObwfOt9a5i7veBTu8fOSmde7fsqoW6h3DJtCBsiW/J7eAvaqTR49vCgzedtSEhIYPr06YwbN47Vq1fz5ZdfgrGc3zzc+PDUAj4++LHlelqNt+Xe7/j5IAWYXbRSzDrOHDlD4eFCTOXmDcYXxvP89ufRG/Vo9XpOae2tyvHx8XzyySdotfW3Nl9rNKno0ul0HDx4kBEjrH2+5HI5I0aMYPfu3bXOKy4uJjw8nLCwMMaPH8/JkydrHZuRkcHq1au57777qp1799138fX1pWvXrnzwwQfVMoFsKS8vp7Cw0O5HILjW0BlsGvM2qPRD/eeU6ax/b93DvS8y8iL3q6Ng7PiuwXg4KZnYNYSqTs+9cbUHUQPM23SOxXsTmfZdze6Y2iiXw0mNkcVu5fiF1Vyuo1mUJy06+lrckfHHs0k9l8fGH05xfHMyf352hMyEQrYvPcvJ7Sl13nPlypV4e3szY8YMmjdvjtFo4vSONM4fzESSJHr37s0HH3xAjx49WLRoEV5eXly4cIGsLHNmp4dcjr9Wi6EGK5Td3s7EWH7/PDubOZmZPJGays5PF5GZNxqD1vx6FH/9vGVc7i9LyP/xKwpWrrS7lved0/C9qQeuzbR4lSzEKWOF5ZzS3x9NG2tx3eQnn6QmDGlplOzaZV73kV/NWZXlRfD73fDbdDj0k91424r0kgOuScDO0jUOq1A7XXCe+9bfx/50aw/Qt/e+bTfV1tLVwcO+d+GQsCFsvm0zrb1b46pypa1PW8u5DQkbiLF1TRprthBJRuuXllf6vMKtrW9lzaQ1vN7vFUJUKto7OeEil6M0gtJNSUBwAD/99BOrV69m3LhxyCSJbJmJHzw9ql1bp/Ey37vizzV3iLmN0zvL93DytZMkfppI7BuxGMusz8/BzIOcyMvF9hNVDgzs1Yt///0XZ2f7DMrriSYNpM/OzsZoNFazVAUGBnLmTM1F2KKjo1mwYAGdOnWioKCADz/8kH79+nHy5Ek7M3slP/74I+7u7txSpZfZY489Rrdu3fDx8WHXrl28+OKLpKWl8dFHH9V43zlz5vDGG280cKcCwdWBzth4oktv8wES6t2wf8J1ZUoGuDtx4OWRqBQyhn64xe5cXZFntjW9DEZTvVy8tm6TFKWJN8tzmdrWB7/zpRj15udWpVFw02NdUKnNa1/7zQliD2WyYq61KKXJKPH7HGtF+bz0UmQy6DA4BE9/l2r3HT9+PDk5OZZ4uuObk9m5zGzJ6zcpitA23jzzzDM884y1l+HixYv54IMP8DSaSK3IkkyYdicRq1Yir+jjaMjLQyovp+z4cdDrKdpgzsbMMRj4Ntcq0Lb/+ReBXl7kEESrqTqKUu3FQdocq0XKyUeHxktPgPZD5K4SDK54jkuLAXN8rjrInfDfVxB/60TKjp/BkJqGzNkZp/btKDtwEGVQIIZ0czulxHvvQxPoRMSQC+buS6dWQnZFLbW/HofoseAWYHbT6awWFmn/TzBhLDh7VXs+a8LW0uWXnQB41j64goEhA/li+Bf8e+QO4AgAcr0BD7UHhbpCvDRezBtmnzzx8dCPuX/d/ZYsRlsrmbOkghr6jRaffZOxg/ciKTPxyfLhRNkJOnTogLLKu1xpBIMSbvnzFl7r+xq9m1W0czKW85qfL+nK2iVBpYVuv6EATTa8ssLaYqo8tZysd7MIeCkAuUbOzPUziYi3ZmG+HhjERE9P3O++Gzc38xeRzMxM/v77b/r160cbG4F9rdPk7kVH6du3L3fddRddunRh8ODB/PHHH/j7+/P111/XOH7BggVMmzatWrD9U089xZAhQ+jUqROzZs1i7ty5zJs3j3KbBrK2vPjiixQUFFh+kpKSahwnEFzNlOttXCj1yPCriiPV6Ee2C+SuvuF8d1ePBgXfQ/2EoVopr/H6aQXai8aWlJRbv6fHX6QMhSRJaCtKGZTo7P0/JToj36Vl0WpWG2Z+MogBt7Vi3EMdLYILYPg9bQnvYO/iUlSx4B3dmMSRf5P448NDtcZ/Ve7RZDRxfIv1A2/X8vP89s5+zu5LR6pwi+nLjWRcKMRV4UOZ5IVO5YaEjLLEFAr/Nrc0yl69mpfatuPh9u05/8hsUp562uKu21pi36sx3ia2Kj25H2XZZstLSH97a6LaQ0+LEdkE9ypArrR57qf8gmbsQ5aHrvIT8Ps9OJVbhWdAdx3N33iIgPdn86r2Aq+mp2GoWE95hpa0vV7mgZWCCwDJXFE/5RB8EIVUbHUVSynH4L1wWDAW0o5SKzs/g+9HQbrVo1KTm8/baOQtlza83uslJkZNpKNfR+7veD8ymYxor1bW58AoZ+GYhXTx78InQz+pdp0QtxDWTFrDDZE3APZWMl+FB0PDhloeD28+HI9cs1XxvrZPMH/kfJ56/Cm6du3Kc889h7bM3o3XwdMsbpKKkrh//f0kFSWRcPRnOi7uxTYXZ5SSxNKxPzOz40zkKuv/Aq3Gm44e5rnPHp7LYz2b4zXQy+7a2QnZuP3shtwkx1hm5K/MfMu5Tk5OqGQynLPtXfX33Xcfbdu2pWfPnrz99tssX76cvDyza/1ajftqUkuXn58fCoWCjAz7BrAZGRnV4hRqQ6VS0bVr12r9ywC2b99OTEwMS5dWTwuuSu/evTEYDMTHxxMdHV3tvEajQaPR1DBTILh2OJVmdZs3RAg5YulyUil4c3yHugdepvtVpUxvpLDMQFaxlpR8LSFezvy4K557+rcg0s+VsxlWS9eZ9EKiAqq7Ckt1Bu5ZsJ9jKfmsfXxQraUo7lt0kJNvjKbzsOplP1RqBWMe6MC6706SHJPHgMlRBLfyIvVcPt5BrhzdlETK2TzKSwyUFujY91ccg25vTWZiEX6hbiiUcpLP5HJ4QyIl+TpyUmpuXr1hwSnOH8zE3ceJE9tTMBmsH2qawe+gKMymWK7BfcFP3H3LRF5+9VW+zjDHebnLFcz09UUvScj+9xIT3vk/ejm7MCrOXEIhzkZ0Fe06DJIMmVKB+5Nf4XzmWcpyzCLMM7wMWWg3GPs+nN9gtkD1uA9kMpRtbyQg3gnTwd/xbZEKJ1eg8bBa9byCkpEvGsfX28tZstf85biviytjPcwusYJ4FwLf+wLdv9+R9lcaAQ9Px+30qxC3De0HIylOdcJksLrhLJ7GxF3w91Mwc6P5oG3ZA70WNr4BJgNSsS9g/gyQNL58Mvh9fjr9M4cyDwHwaUYWXRPXQ1YykzrdBmlZ8Mt0CGyHqsjavshFUhHh3ZpF4xbV+DpV8lrf14jwiOD4MauV0Nmk4uU+L5Neks4NkTdwV7u76LB5HWDEz03D119/bcn+/+eff3h18mS7a/Yp0XPAZnvj/7iRfqUluOPEmIMmMtrqaeffiXYBnVm4eCulFV8msvw6E1AlGC1kRggBEwLon9afhR+ay0bs276PyPRIXG53wU0hp9hoQqaQ0f29Nyh5bQ7l561xeQEBAXTr1o1Dhw5x4MABDlT0CnVycsLV1RVJkkhJSalmMLnaaVLRpVar6d69Oxs3bmTChAkAmEwmNm7cyOzZs+t1DaPRyPHjxxlXQ8HB77//nu7du9O5c+c6r3PkyBHkcjkBAQEO7UEguJaI9HflQlYJg1v71z24Bi5nD8XasNWCl3q/U2mFTP12j92xMr2Rx4a1Iq/UGvMTl1WC3mgio1BLqLcLBqOJ55Yd42BinqUY60srjnMxnbovPpce4d64O6lIyi1l9fE0BrXyp12wB0q1ghsetu+Z6B1kTuwJbuUFQMKJHP7+/CgntqUQszcdffnFGw8OnNIaXZmB41uSKS00i6K4ozUnBZQblOASxNnkg/y+ZRvaF17k60OHLOeDVSqKjUamZmcTe/fd9G7XjhVvvYl6+nR0Oh0pRgOBL79MxttvW2KflM2CkbW5AaXPG5Bjvr/zrK8xDR3HyJEj2bx5M97e3rzwQh7PPvssAL6PvwTpN8PXA0Ey4dnBg9LsclwDSy2Wsd3JRrt1yV1cQKnAVFiEThFB0h/ZGHMKSXr1C/xumYy/8wrSD7hTll2lGXS/JyEqwRz3lXIAXvcEZDDyTXMPSpkcitPBVGHxlGRkGQxsKy7mBp8xDG8xkuEtRnIk8wgpR36ia9z3ZkNgxilk/75uvVFhMlxobr2vrmZvSlWclc482PlBjnUohdXfAKA2QoBLAL/d9BtgrkRfojMik8Hfv/3Eo488bJl/++23V3Oht4w7AFE+lsd6TOSla/h+qfk5LT8DPG2eZbQR5Vl+nQhzSrO7lkwuY8XAJ2jX8yFcta58/vnnAFw4d4E3VW8yptvvGPO0vDpFjnPraEqAsiNH0Kemoqro5zhr1ixeeeUVO8OLVqu1BNqvW7eO8ePH1+v5ulpo8uKoTz31FHfffTc9evSgV69efPLJJ5SUlDBjxgwA7rrrLkJCQixtB95880369OlDVFQU+fn5fPDBByQkJHD//ffbXbewsJDff/+duXPnVrvn7t272bt3L0OHDsXd3Z3du3fz5JNPcuedd+Lt3bCAXoHgWuDzqd1YcyKNh4dENWj+f9VD8XLfz0klR6s3VRNcAMsOJrPsoH1V8LicEl5Yfpzlh5LxcFJSqK2edLMr9uJB6DMW7qdtMw9u6BjE+lMZHEsu4N01Zzj/zth6xYuFtPay/F6T4NK4KFEo5UiSRJcRzek4JASZTEb7QcHs/P08/s3dyU4uQjJBeEdforoFkJ1czIYFJ8lLL2XL8T9YtusLAB56/z27a0978AH0Awcy8KefuPDTT+w9dYoV2dmEhYURGxtLulqNz53TyP7yS4y5ZpeiKjAQlBpMft3gnPl5dhk0mrXr1ll6Rubm5vLcc88xcOBAevbsiUKhgKAOMHkh5JxD3vN+QmakgaEMji6Bfd9QYlRCRYh2j2eeIXzKbaQ88SRlhw6hi4uzK0mR/cd2/P5aQtkv9l/iTZKEZJTg5nmgcoW9X1WckWDDK9Wf/OGvYdy1mkdSdnFCq2XN2n/ZWXGqS0AXuozqQtHOU6T+EYeLv47QgbnI/FqZa50dW4KkLQDMItpS5qI4E5L3m2ujFaVDWG9zEdoqhLmGWFofVQ3+j80yWzWDNEbeeO1Vy3EfH29mTRwMBfbv09ByAzJJQpLJGF9UzJ+urjy73OpG1GQr0SUnY8wvwKAzUBmBVOAVRQ8nd6iSexByNI4L70zk9eefo6CggEWLzNa7qVOnovvnb2QKPXf0mIJf554Ud+yI9vhx8pb+RsCTTwBYKhcsXryYxMRETp8+zc6dO0lISMDV1ZXkZPu/w2uBJhddU6ZMISsri1dffZX09HS6dOnC2rVrLcH1iYmJyG1aB+Tl5TFz5kzS09Px9vame/fu7Nq1i3bt2tldt7IWyNSpU6vdU6PRsGTJEl5//XXKy8uJiIjgySef5KmnnvpvNysQXOG0C/agXXD1DKb60sKvepD3f4kjwf627tIHBrXks431b8Ibn13CocR8gBoFV1V6Rfiwr4bsyNNphZy2ceGCObasspzFxVCqFUT3DiL2UCbdx4bj4qmhOFeLxkWFq5eGqO41W+md3dSMmNGuxnP+zd25cXZnjm1JpudNT7L+tiUUltqLx0fve5TD/hMY2CWa2Z6ebNm6lfj4eE6cOEF4eDixsbEUFhaSkJCAU5toSnaZM8+VFSEivg88QMnuPfjOehCZSsXBgwerraNv375Et2zH5/M/ZejQYeR5jsCv/YSKDVR8EQ7qBB1v5fT8mwAtvr6+RD1qFlPqsDDKDh2i6N9/q1077ilrSYVMg57pieYA8EVJyQQCjJkDUSPgwmY4/jsU24e7GKKnkbOtlLWnYjih1RKkVDI6NARDXh6Ff/2N68ABaCIiyNwLJr2c4lQnsuQPEfDou0iSRPm5WCSj+b1WZDTinZ0AC28wW9cMNjFXkUPgrlXVXySbAH6pSl2y85nFSEY9F355jWybeKn9L3bH7/cbKU7XgE2mpad2HEvf3YPOQ6J13yIueLugqfJ2jh1hroRvHDwPZKDSFaFXu1NwSsvjhnByS7Jw6R9Ci8TdpC74C4DCjz7mp99/o0uXLrz00kuUl5ejkuQYgantpyGTy/GcMB7t8eOUnz1rdz+lUsldd91VZcsmjEajpcn7tUSTiy6A2bNn1+pO3LJli93jjz/+mI8//rjGsbY88MADPPDAAzWe69atG3v2VP+GKxAIGsZ9AyJIziu95BgtR2moe3Fk20CKtHoW7oy/6LiHhrTkqy2xFsFVF9N6NyfS3w0Z1Ci6aiIpr7ReogvMQfeDprZG7XT5/nV7+DkzYLI50Pulu9/kpfmPYpLMH/QuShXNTcOJO5aDXnea7pMDiY+PB+Crr75CWZHtJpfLOXXqFD26d7eIrn0lxRx/803Gjx9P+107UXh5sXr1al55pQZLEhATe4qRI0cyddBT9G97A/+c+5x/Nq2gX79+rFy5En9/f1LkIaRnmAtnd+nSxTJX1dwcK1e0bl2165afs4rrX/LySaqwFj284HtOfPgBMrUaWo0w//R+ENOSGchLUsxuRu8WZH79JwXLfuGHCgteusGAW2IS5wYMBKMRZWAgLZb8ii7Bms2X8+sqPKc/SPm5c6QsTAFcmJedxVc5OUz28uTXMxkonU3g4gelFWLpwhZIPw5nVkPMGrj5M2jW2a5tklQl0Wt3bA5FR9aSd95cDd7Hx4ejuzcTurii3leVWPT89ebPPXWhjPTEAfQyZgJ5XIhypXufieT9bK4rZpLJze5VIESWTDxtiTtTTP8T5pgsb1kUXjIdcRXX1R4/TtbnX/Dkk0/y+OOPI5fLOVspFisaX2uizO+x8hrir6sil8vtjC3XEtfmrgQCQaPyyo3t+Hp6D/zcGjfZxKmOOl21oVbKeXx4K/zcNIT51FyuYvlDfZnSo/79Ll3VCl67qT33DYigtsTPGzo2q3YsObf2JtxVkclkl1VwVWXA4KE8O/ELOrXoT/+2N/LaLXNwVrsDkHwmj32/28f1eHt74+fnx6dzP2fM6DG49OiJJEksyc/jlvnzee211+jZsyeDbrwR/4AAbrzxxjrX8Ne+BegM5fyzyVy3a9euXURHRxMVFWVXFmjjxo1MnjyZuXPnogyyf159H5qF9x132B2L/OtPdrlYX+tTJSUc7NCBpEdmWzLlCnYe5+xXOZxd5kNJaXO0JR4ULFsOYBFrHnI5Y9zdLbFrhowMsj6bB5KEMiDAYuEr3rKFovXmtjySJPFVhdtzWX4Bifox8MBWePY8vJoH7StKGn03ArbMgbQjsOoR87EqBV0r15qaX8bq42mUntpqOf/nh7MJXWYu/5Eb40p+fkdqQ3s6hnFF5hY/bW6ajvcddyCvKOdgklstTN1fNHuLcnzao1OZ3wv5W45TkmH/t579+edma+PKlSTNmoWpopalzCK6WgKgT07GVFb/9/y1xhVh6RIIBIL6Umzj3mtoTJdaKcfLRc2/T5kzDu/8fh9Hk/KZe2tnjCaJbuHeRAW4EZ9dcwX1SuZN7YpJkmgd6I6vq7pGd6eXi4r8Uj139G7O/03syIPJ+dz+zR5KK8pLVLYj2hyTSXx2CTP6RzRoT5eDtoOac2Z9IO363keRR3i182kx9g2ne3UaxIResyg/I+fLhzcT3MqLn7068sfZZZYxer2+xmLXbk6eaFTO5BSlM773/eQWZRIU2Iwxw8dzfJ99nca8vDxLKQFbli9fzvLly/kmPJx5cgVhanN2onPHThiysyzjvO+ajqZVKx59+WVmzZplOX6kTEv/jRvRJySgCgkh9WlzHTNjeTmJ98xAVuHeitfpyKgont3czb1aZm/BCrNAdGrXDte+fciY8y7Fmzejq7AK/l+VtnZbT+XRwretuWOCTAZ9H4GTf9i7G3MuQFFGtQbh6PWgVhOfU4KhKIfyVPNz1SHUg/4JnwCgzVOScdgTSDWvqyKeqhKFvx/GrGyMe83JEs2690cTGUHrfXvBaCR350FYYn5fBkR6416cRJFbGDk+bWmWexhJp6cwofqXlbJjx8l8zz4esNLSpfDxQe7ujqmoCH1qKpqWLavNvx4QoksgEFxVFNvUzwr2amhRVbM4qmw/9NOMXhxNzmdgK7+LlspoH+zByHaBfPKv2WV1U+fgOu81tkMQ9w+MJLzChdgp1Iu9Lw1n6f4k3l59ms82nSfUx4XnlpldRN3DvekU6tWgfV0qPs1cGWH8k9JDe0gP6M6pdvcCEBjhgbO7muI8LZ6uvhSUmK028iIvynPNz6XRZOSzH95m68ka4pJqYNbY/8PPvRm5xRmE+bXigU8HW6x4p3Z2IjM/mcXbzMWqZTI5w4YOZeOmjQB4uHui05dbstzOJiQwQ6nk2YAAYsrLedTVBVddBEVuYbgXJ+FZYWF78MEHUavV3HuveV+x5eX0d3UldsxYwr6eX3WJSHo9u0pKuD/ZWpfxRGEBP2k0+CmV3NyhPblx8bjJ5chlMlShoThVxBeX7q+oUC+TYXJ3h3yraDxy8CB9+/SlxS8/m8eH9qC47Ttg1OE2dhJ82gn0JTC3NWTaW6tyf/oJ3/vvJ6uonOZuRp57ZDTn1u0iSKbEZDAiV0oUl7UFrLF5ldYmMFf7d+rQgeLNmy3rc2prroIvk8tBLkfTuSss2YlcLkMulxHYJpCiZJANn4B6Tza6CxfQ5pn/dsIG51Aa+Rg5C3+pLrgqr4nZSqsKCqS8qAh9evp1K7qEe1EgEFxVPDi4JX0iffjj4X611sWqCdtii1UtUp4uKga19q+zNtnX07sza3BL7h8QwcpH+tfrvhqlgpb+bnYZiu5OKm61cV1WCi4wB9Y3Jerm5vIGQZkHGTLUiY5DQxn/ZFdueLgTU/7XiyXLfiYgIBAPF1+6tzQX6mwW5YlCrkAmkyNVxIOF+bXmwyd/YWLfB+jcpicdW/ew3OPZme8w8c5RuDl70ty/NcPuamvnNm3bL5jPl77JkMFDAJAkE22cRnFTr/sY2WUqj475iP89OgdPT2tV+FSDgSdTU5mfk0P7Pn2Y89k63paH0i02FpfOnenXrx/btm2jbVtrm535uTlkV1iwdsydyxfZ2fxdWECZSSItsBf5HpGohwyp9hy9m5XJorxcHsnLo8/5czyaksIvRWUM/PxzRj/+OMkVbsCvsrOZ6eTK/63bZ9fuLrZch1RWRtrrb2DSainZu4+k174g6c1vyfxxJVLUSJCZhZKUE2d378wP5/JTyyge7RfJ8O0Pc2feUR5WhHCLPIB874eQXsunMN2+2K46PJyAZ58BlYqQTz9F09Lah1gdGYm8St9hY0U7sMoivYF9zEJSGxiFOtzeAqp0NqJ2v0hyia3gCzAnyBkyMmsbfc0jLF0CgeCqokuYF0se6OvwvEvtKwkQ5OGEUiHn5RtrzgasxFa81dYf0tNZxYqH+zHxy112x9ObWHTJ1NYCou0m9UJWpTXMmDFjSE9PY8OPJzm3J5Mh06JpPzCEolwtmreV3H37g1CupDhDglIY3mkKw5mCwagnq3MK+ObxwIu30rx5c0KivclJLia6j30xbJlMhneQKwGB1ozMAK9Q2oZZhRuFMP+5tcTFxvPZyudIz7Vao9ycvMjMT+Gv/Qstx3bv3s3gwYM5ZFN/LN9oJFGnQy9JTF69mpKK4O+Hbr+B9p5TKdeX8c7vM2p8no5qtVBR0HNzSTGbK6r0n89IZxQwwNWVHSUl3Bh5M6s/PcmNLZ5hk3wzJpOReFcXZGo12mPHyP99GWWHrWvKmT8f159+xPXOZRQt/57kHR9wV0I8T4X50FtuzixekJFOuFxFQLET+enW1yvj25WUF2mqZQi6jx2D+5Ah+MyYgUwuR3fBWqTUqX3193JlyypFxd9JZc24/IzSaqJL5WzEpLP25PS67TbKjh6lPMZ8TGYTEK8MqhRddTdXv1YRoksgEFwX6Gx6ParrURerKgq5rF71tKpysbizrs296dbcyy47MrWgDK3eyEcbzjK8TQC9I31rnf9f4HP3XRStX4/3tGnVBFclMpmMoXe0pfOQ5gS2MAsBdx8n7nmvP3K5DG2JgYXP7bCMd3JVoS2BsVMG0X+StQZceHtfwtvXvj9fX+u5diN96NmjM4ERHhzdmMSBf+LJSSzFQxXA/SPeYP7alykozcHL1Y9Q35as2F3dXejn50dISAi3jxvHkn/+AeChzAwCJckiuAC+WvIdI7sUc3Ov+3lg1NsEBPnj17OUopIC1q9fz6pVdbtQd5SY4wE1KidKy4tw0bjj7xFMRn4Ssfn5lM16g7hDWZQfT8fjnH1GX9nhI8gUCpL/9yGbi4o4rtUy41wqLwYYmO7tQ4JOT6Jex4ETpQzp1QIl1tjD/CXmDixuQ4bgdfsU9ImJuA02N7isFEDqCGvcoLLPYE7vSiW0jQ/uPubq71UtXV6BZjd+QWYZqv5W0SVTKZCrJZxz/8Gz/whUXYbiN/sR0l973Sq6nK2ZuapAs7jWp9uX5bieEKJLIBBcF+gM1oDkhpSaaGh5irrmDW8baCe60gu0zN8ayzfbLvDNtgvEv3tDg+7bUNRhYbTatrXOcSq1wiK4KlFW9N508VAz6PbW7F4Ryw2PdKJZS09KC3W4eTvW0sVoE0Su9NJaelT2vjmSwAgPzu5N58LRbIK8w3l96iIkSULtpOTPXQs5fGGbZe4No8azev0qsrOzWbp0KYv//ptZi3/ln4MHyD5xghkX4vgoK4sVhQWWOWeSD/LwHU8ik0WBASJcOzDg7lZER0fXS3RVcj79CDPveYjzBzMJ8gontyiD1q2i+TfeF5dmUaQVQnMKCFKmE3LTCApWrEB74rilPMQ5mzIRgUoVkiSRbtBjwlyRX5lvFlze06eTt8jaWsipQwfcbVyj5aV6jm5KpkVHX3xbtQKVCkmvZ/0hLwqzz+DsrmLK/3rh6qWxii6l2WLr5u0EMrMYMwZaq+srg4KRDbsLjiwm+MXvLc3D/R55GKW/P86dOqJws7oulYGVli4hugQCgeCaRmeTel/fvpK2wxrqkqxLdN3aPZSvtsRaEgQSckpJzK29wfbVQschoXQcYi3x4KjgAhg3bhzffGNugeNaJe6oRUc/WnT0Q1dmYNUnh8lMKMLDz5lJz3YnZC2snvojADOGv0yftiP4+KOPWfnPMnr16oVMJmPwtDsYPO0OSg8dIuGOabwdFGQnukJ9W9Ljpii6GiT+/vwoR/9NIuF4DiaTC4nxyRzdHsuhNcl4u/ojk8kZ2TOXZXtLKcwt47v1r5NbnEGofySfffIl/Ua3xT/cndLyZ3FSOSO36e9Yri/jxWMbKCjN433ZKNpoNsOGfyna8C8GhRMH1IFUBsXL295ObvwqtBXxicEV2ZUKLy+C/vcS+qQkiitqW9q6DUsKyln82h50WiPJZ3K55ZnuhC5dRmaGicKl5gzHsiI9i1/fg0qjwFTRGF1RIaIVSjmunhpK8svRuQVarqsMCIDBz0G/R0FlTWpRBQbi/2j12ptKf3MPSkNu/WrYXYsI0SUQCK4Lym1iuhpCgy1dqouXtQjwcGL9k4PIKNQy8ctdHEnKtzuv1RtxquMa1yo333wzK1euxM3NjeHDh9c4Ru2sZOIz3TiyIZFmUV64emm44fbBbA3eSm5OHsbzIaTHFrJ+XhxTHr2X5lXcmZbMPZmMVhonzpWbY+o6RvUmoIUHKo2CkGhvUmLyyM8wi+E/58SgUMnxdTe7y0bc05boPs14fJKWkgIdc5o/wLlz54iKijK3NgK6jQqnIKuMU9tTLffWGcr5fOVs4nLjGdJhIrm5JhLcW3EicwML8otJMejRGayWrk9Pric23eqKbF4hulQhIQC49u1D8ZYtqIKDce3VC4DSQh0/PL/TMiftfAEJJ3PY9FMmpQX2Fe51WiM6rdW6aNRbf3f3caIkv5xSmVX8eow11wSzFVwXQ+ljbnNk26rpekOILoFAcF0gSXWPuRgNrQmmqUccWLCXM8FezrQKcONcZrHdubQCLT6uauKzS+gc5tWgNVytyGSyejU8VqoU9BhnX99s0KBBAKTFFvDHB+bWQ5t/PkOrnoEknc5lwK2tKM4rx9PfGZNMTqlzIDcPupnPNn9KuH8bZj52lyWjsvvYcFJi7OuEGfUmFEo597zXHydXs/hx83ayWPSio6OrrbP9gGBO70xDMkmsPPQF/+7/w3KuSFuA3qhD5+LHZzl5ZOmrN8aOTT9u97iTk1nsVIou76lTUbdogXO3bpaMxPjj1Zuc/z3vqN1jjasSjbOSwmz7JA7bx+6+TqRfKKAor5yojz9Cl5SM9x3V2+xdDEVFjJ6wdAkEAoHgojjW59H6e23ZizUR4u1cTXSl5JXx/tozrDmRzotj21CmNzKqXRA6o4nOoZ5o9SZUioYF+V8PNGvpybC72rLpp9MU55VzeL25Xc/Kjw5bxmhGfEa5XkYE8GmbkYy9vwstOvlZzodGezPsrja4eGg4tTOVC4fNhVe7jw23CK76EBDuwfS3++LspiLupX/4d7/1XJtAV1QKNcWtRnKzyZXvN75tN/f+++9n58YDnI47YjnW2dledMnUanSte2Aql+NhLh5PwnGzVanTsFASjudQkGWuBh/cyovC7DKK88qJ6h5Iv4ktyYgvRKGUU1JQzuZFZ+gwOMRyL59mZhGXdr6Abg+Prfeebam0dEllZZhKSqqVqrgeEKJLIBAI6sF/FUhfF3d+v9fy+5w15urjlcVZ7+nXgj+PptI51JOFM3o5dF2D0XTdCLW2/ZohSRKbF52p8Xy53qySvZu5MvbBDpYSCZXIZDLa9jMXwvUMcMaoN9F1VHNCWns7vJbKDMGgIPsyGXfcOJG4eCgzamgf3pcZNz/FqCm92Ll7B7m5ubzyyitk31vEoGH9KNEW0iWyP+Eqs6BSh5uD2zPiC/nj/YNIksSIe9vh4qHhwhGzQIzuHYRklDi+NQWZDAbd3hpndzWndqTQYXAoamclYW19LOuJ7OJvKRkBENHZj71/XiDpVC46raFB7ahkLi7InJyQtFoMubmohegSCASCa5NK111tvRbrouGiq2FuyZ4tvNkfX731jS0/7IoHYHNMFpIk1TtBYOvZLB746QBv3Nye23s1r3vCNUDbfs0w6ExkJRWhUiuI2ZOGs7uaUfe3Z8WHh5Ar5dzwcCc8/S/+/vAKcOHG2Z0veT2BgYF2j7vcMJy4L8zxWk4aZz765i28Al24/Y4pljHNm8OubXv57H9L6Bjel6LDc3ErTqKs4xDWv7OP7CSrlXTD96csv7t4qvEPc8d3shtuPk54+DnjG2Lus1jVLVuJosr73SfYFQ8/JwqztSSdyqVlt4Aa510MmUyG0tcXfUqKOa4rrP69Ta8VhOgSCATXBW/c3J598blM6129p2B9aKh4cm9gg+rhbQNp6e/Gkv1JdQ8Gckp09W44fveCfQC88Mfx60Z0yWQyOg21ZlP2m9QSmUyGQinn9ld7I1fILFaoxqBDhw6W32/u0YNmHcLoPKIchUJOVPcAvAJdapzXqWcbOvceiTyrnP09XjAfnGcVWB7+zhjKjZQWmoPklWo5fca3RCaXoZDL6Da6Ye9/mUxGZBd/jvybxJk96Q0SXQAKP7Po0qdn0LCvP1c3QnQJBILrgn5RfvSL8qt7oA0yrJYjR2K6Csv0lt9bBbo7dE/L/RRynhrZut6iKy1fW6PoKtUZeOCng/Rt6csjQ6NqmHl9orTJCK3LuvVf0LVrV7755htSU1N55plnkMlkDJjcql5zdW3ccMqyD7TXuCq56dEu+Ie5kZ9ZxpZfzhAa7U2PGyKQO9Au62K06duMo5uSiT+WTdKZXMLa+NQ9qQqaqCi0R4+hjTmDx5jRl2VdVxNCdAkEAkE9cMS9eCa9yPK7p3P9A63t7qeS4++uwc9NQ3Zx9Uy27uHe5JXouJBtLo6ZVlBGx1DPauO2xmSx43w2O85nM75LMO5O1vU4ORDkL7j8zJw5s0Hzyr3V/OFWzoToQDqYVHgHudBxcCiuXmbR7dPMlVue6X45lwqAb4gb7QcGc2JrCsc3JzdIdDm1bUcBf1B+uub4umsdIboEAoGgHtRVb8uWYK9Lt5yoFXJkMhl/PdqfYq2B+JxSnlx6hAcHRaJQyLi3fwROKgWzFh1k7cn0WhtlZxZZBdvaE+l2ljeDUcJkki6bJUTQOOgMJlKUJmjuwtjRbRr13h0GhXBiawoJJ3IaFFDv1Na8Xu0ZIboEAoFAUAuO9Gt8ZEgUMhlM6BJS92AbbKVPpchr5ukMnmY35Yk3qrtjgjzNcUjphdVF16/7Enntz5OWx2+vPm133mCSyCnR4e9ev1gwwZWBvqK7gqoJsk9tA+qTz+QR2cXfofmali0BMKSnYywusWsTdD0gbMsCgUBQDxypt+XpouLFsW1p28yj7sG1UF+RVymYsorsXZC5JTpe/ON4TVPsePGPY/y0O97h9QmajqYUXTKZjPAO5tjIxJOOV5ZXeHlZiqTq4uMv59KuCoToEggEgnrgiKXrclBfkVeT6JIkiV2x1SuRV+KiVjCotdlC8e/pTF5ddZLcEl21cekFWs5mFFU7Lmha9EZze4XGfk9WUtl4POFEDlIDWj1oIsxlKsrPnbus67oaEKJLIBAIakHC+oHSIaR6kPp/SX0D9wNsRJfeaOJESgH3LNzP7MXWiuttgqxxXM08nfjj4X5M6BJsdx1bNySYsx77zNnIjZ/tqGZFEzQtOoulq2li8UJaeyGTyyjOK6ckv7pYrwtNRYuknG+/RdLr6xh9bSFEl0AgENRCkKcTYT7OdGvuVU2k/NfUV3RVWrqS8kp5ftkxbpy3g61nsyznP57SmVWz++PrqkYhl/Hn7AG0CfLAx1Vtd52/jqZyzsaqtfxQCmD+gI/PKbnU7VyzxGeXkF/quPC4FPQVzdtVl9jtoKEo1Qqc3cxZsNoaLKR14TvzfuSuruguXKD08OG6J1xDiEB6gUAgqAWNUsHWZ4ZikqRGb5lT32KslaKrSGvgj8Mp1c73CPdBo1Tw16MD7MbXRFJeqSW78byNAMupoWTFtUZGoZaCMj2tHairllZQxpAPtxDooWHvSyP+w9XZ05QxXZU4uakoLdRRVuy4pUoVFIT7iOEUrPqT4q1bce3lWAurqxlh6RIIBIKLIJc3TTPp+hZj9XW9eOZhqLe5fEWwl3OdpSwyC80uyq+2xLLtnDUmLKvYbM0o1Oo5lVpYr3VdLWyOySS9QMvEL3Yy6uNtJDhg1ats05RRWE6htvHcZE0d0wVYLV0NEF0AboMHA1C8detlW9PVgLB0CQQCwRWCbe/E+roXFbXU2HprQge6Nfeqdz9GMMeFLd2fxHtr7WsoZVfEdL284gR/Hk3ly2nd8HVV0ybIA0+XhhV/rQtJkvjrWBrdw70JuQx1z2riUGIeMxbutzu2+Uwm9/SvuR9hVcp0BsvvZ9KK6BXheLHQhqC7QixdAGVFDRNdrv37g0KB7nwsuuRk1KGhdU+6BhCWLoFAILgCcaTtUFX+fnQA0/uE0z7YseD/zKJyjiTlVzteWRH/z6OpADz8yyGmfLOHyfN3NXiNlXy55Tz3/7ifMp3R7viaE+k89uthhn6w5ZLvURvHatjriYtY8tILtMRmWZtK2xakPZlacFnXdjH0TRxID+DkZo4J1BY3LJ5N4emJS48eAOQvX37Z1nWlI0SXQCAQXCGYbNLvG9pgu7mPS4MzLTOLtBhN1UsA/LI3kY83nK12/FxmMU8tPVLndVPyy0jOK612XJIk3l8bw7+nM1l20L7H5MEEs+tOZzRRUHb5XXerjqTwy97EasdPpFQXTzvOZfP8smOM/2IHw+dutZTRSLcRXQcqXI22fLzhLHP+Od2gsgoXwyK6miiQHi7dvQjgPXUqAAWrVl2WNV0NCNElEAgEVwi6iqw0aLila+GMng2+/7qTGayoIRgf4NONNddU+uNwCgajqcZzAFq9kbGfbGPoh1soKTfYncuyCdCPqVIPzNaGs/eC40U4L8ahxDweX3KEc5nF1c7FZZdgqiI87/x+L0sPJJFRaF7v/C2xgL2la/eFHPJKdPy8JwGt3khBqZ5PN57j620XWHMinQ/XxVBcZf8NRW9o+pguJ1ez6CptoHsRwHXAAJDJMKSmYci5vK/xlYqI6RIIBIIrhHIb0eVIg21b6jvPNtarc5gXWYVaUmvo3/j48Fa1Cq5KUvLLCPc1t3NZdSSFf09n8tK4NuSV6CnU6inUmsXGngs5DG8baJkXl2UNWl91OBWdwcT9AyNpHehuJ2jOZhQxqn1QvfZVHxbXYOGqpNxg4n8rj1NSbmRku0DWn8qoNuZYhTXM1tKVW6Ljps93kJxXxoWsEiZ3t8YoPfzLIQBkMnh6VHSD151dXM6p1MIrIqbLp5n59U46lYNBb0TpQG/SShRurqhbtEAXF4f25EncBg263Mu84hCiSyAQCK4QbD/ElQ1sQt0Qt6Sfq5pv7+pOr3c2Vjv35MjWQO2WLjBbh+QyGYv3JfLLngQKtQb+qoj/smX7uWw70WVb/6uo3MBvB5IBeH9yZ9IKyiznzmYUU24w2u0tPrsEV42yQX0jU/LKqh3rEOKBVm/ifGYxv+4zuzr/rGEPABeyiskqKrdbI0ByxXUX7Iwjs6i6gE3Iqe5idYQJX+y03AOaNqYrJNoLZ3cVZUV61n93knEPdWrQdZzatzeLrlOnrwvRJdyLAoFAcIXQo4U3AJH+rg5lHdriSI/IStRKOQHuTrQKcAPMFpmf7+vNn7P7A9Cvpe9F5/+yN5HHlhzmqy2xFqtWTWw7l2WJR5IkieM1xE8l55WRXqDlWLL13J9HU+n1zkbiss0iLaNQy7C5Wxj32fZq8VIl5QY2x2RWcxHaklNidhP6ual5cWwbYt4ewx8P9a93lqRJgp7v/HvRvf59LK3aMecGWINsSa4iFpvS0iVXyBlwaysA4o5loy1pmJtRE2VugK2Li7tsa7uSEaJLIBAIrhCeGRXN2xM68HdFIdOG0JA4n0qX5Od3dKNnC2+WzerLgFZ+dAr1AqBLcy/L2OY+LtXmbziVweHE/DrvcyGrhFb/W8OeCznMXX+Wn/dUd/Ptis2hz5yNGKqIpoIyPUM/3MKJlAL2xeVikswlLqrGgr266iQzFu7nk4tY5nIqMu4W3debBwe3RKNUoFbKqc24qJDLcNPU7Bhy1yiprz7OvYTK9TXFg11KhuvloHWvILyDXECC0zuri8z6oG5R0YcxXogugUAgEDQiYT4u3NknHBd1wyM/GhILVum2iw5y5/dZ/ege7lPt/C/39+bjKZ0Z1ibAcvyRoS25u294ve7hZVPP6/Zv9vD55vOWxyPaBtQ0hYX3VE8K+OtoKom5VjfdmE+288ehZMvj5RW/f1aD6DqWnE/fORvJqWhd4+umrjamKo8Oi2LT04PZ/78RfHtXD/a+NJwHB0dazjvi3qypqXhtGE0SBxPyLNmktvFvlTSlpauSiC7mxun7VsdRXuZ4ooA6ogUAurj4y57leSXS9K+YQCAQCC4bDXFL1sdi0j/Kj4ld7QtYOqsUjOnQrM65vVr44O1Ss8AZ2MqPz+/oxqe3d7E7/uSI1kT6u1Ybb5IkzlfJOnzqt6McraHmliRJ7I/PZc6a07y75gyL9ybaBej71LImgNlDo/jj4X48PSqacF9XnNUKRrYLJNDDiWdtguHDarD82XJT52BLfN75zGJi0ouISS/ili93sv1cVo1zynRGFu6MY9JXu/hoQwyApUxFJS5qhaXZeVPS64YI5AoZhnIjeWmO9+hUh4eDQoGpsJDycxdP2LgWEIH0AoFAcJ3T0ExJtVJeLQ5KKZdhkiRMEswcGMHUXs3xddMw4Yud1ea/flM7S/X3zhWuzErGdaw5WzE1X1tjza9dsTkEejjZHft2+wX+758z1cZa1noRS5Gvm5puzb1rnbf+yUH8vCeBiV1D2GYjnr6a1o398Xks2Gl2l829tTOPDYti5MfbKCjTM/bTbVR6Tqd/v4/4d2+wu/b5zGLGfbbdUj7ki82x/HM83RLPVsmEriG41uLybEwUKjnNojxJicknI76QwBYeyBxIApE7OeE+bBhFGzaQ/9vvBL38v/9wtU1P079iAoFAIGh0bD8WGxJ8D2a3Y6Cn1dri7qTk8Csj0RslTqYW0D3cu1bLm0YpZ1xHq5XMq0o7IX93TY1FUVcfrzl26L21Z6q1L7qY4KqLurJAWwe68+b4DtWOt23mwaDW/hxLzqdXhA9qpRxvV6tF7SLx/QBsOpNhV68NqCa4ADyd/5v2Sw3BK8CFlJh8dvx2jtSz+Yyd1dGh+R4330TRhg2U7Nn9H63wykGILoFAILhGaGixTLWi/ll1thpKo5TbiZNIfzeUCjlKBfRoUXsfwq+mdWNMhyA7QebuZC8iPJ1V/0kleoCpvcK4oWPwRcc4Yv2TAZVaSqOS46pRsuyhfpbzvq5qnFUKyvTGGufnFJdTUKYn0t+N02lFNY4Bs2WxUpBpa7lWU+DdzOoGTjlbvTJ/Xbh07w6A7nwsxvx8FF5el2tpVxwipksgEAiuERqazdZgS1fFvM5hXgDMGhR5kdFWPF1U1SxgVRt3Vz2vVsoZ28He5ThvaleGRvtXu35dpR/+b2JHBrTyu+gYR55LW+tVTRYymUzG348NsEtCsMw1Sdzw2Q6Gzd1KUm6ppQ3Rwnt6cqtNgVVPZxU7nx9meRxfg/WrqWjTJ4g2fc2vTXmpAaO+9g4FNaH08UHd0lw6omTfvsu+viuJK0J0ffHFF7Ro0QInJyd69+7Nvos86T/88AMymczux8nJ3o9/zz33VBszZswYuzG5ublMmzYNDw8PvLy8uO+++ygurt4SQiAQCK4WGiy6GhrTVWEh+3Z6d5Y+0IexHesOqjffr2bLWq8K61gL3+rB6S5qBV/d2d0uuP6mzsF8Ma0bnUM9uaVbCP2jfHFWKRjV3lqAtUuYF0se6GN57KxS1OrytD1+uTsCtPR3Y0EN2Zhbz2WRXmgO7n955QlLa6L2IR525TmeHR1tlykZW0M2Y1OhcVExbHpb5BXFWkuLHC+N4TbAXBOueNu2y7q2K40mdy8uXbqUp556ivnz59O7d28++eQTRo8eTUxMDAEBNacRe3h4EBMTY3lc0x/QmDFjWLhwoeWxRmOf5TFt2jTS0tLYsGEDer2eGTNm8MADD7B48eLLtDOBQCBoXBwRCrahRX5uDcuCq7xfgIcTAVWC2KtiF0NWyzq/v6cHn/57jmEVJSRkVBdBH9/Whcnzd3HfALNVzUWtZNVsc10zSZIoN5hYut/aPNtJJadPpC8PD2nJl1ti+eDW+lVO1zSwkKmjYm3Gwv2W37eeNQfkK+QyAtydaNPMw3JuVDuzkFQpZOiNEkGeF3++GxuZXIaLh5rivHJKC3W4+zi2PtdBg8j98SdKtm5DkqQGFwe+0mly0fXRRx8xc+ZMZsyYAcD8+fNZvXo1CxYs4IUXXqhxjkwmIyjo4n24NBpNrWNOnz7N2rVr2b9/Pz169ABg3rx5jBs3jg8//JDg4Iv7+gUCgeBKxJEP/EKbeKkhNbjo6nW/BrolnWqZ5+6k4uUb29V4rtKK1znMi6OvjcKpFjeeUxWxVGlVe2JEayZ1D6Wlv1u91tjQ+LiLZUQC/HRvL77dfoGsonLOpNccv1VZYmJYmwD+b2JH+kT6WETtP48N5KutsTw2rFWD1vdfYhFdBeV1D646t2dPZC4uGLKy0J46hXP79v/BCpueJnUv6nQ6Dh48yIgRIyzH5HI5I0aMYPfu2rMYiouLCQ8PJywsjPHjx3Py5MlqY7Zs2UJAQADR0dE89NBD5Nh0MN+9ezdeXl4WwQUwYsQI5HI5e/furfGe5eXlFBYW2v0IBALBlYQj7sX+UX60CXLnseGtqgWx15eG9Hls6DzbOS5qJfJ6liWoFKJqpbzeggsaLijrYlBrfxbd15ubu9T+5f69SWZrnEIu447ezYm0WXerQHc+uq0LLfyq1zBralwqMllLChx3L8rValz79jXP37Xrsq7rSqJJRVd2djZGo5HAwEC744GBgaSnp9c4Jzo6mgULFrBq1Sp+/vlnTCYT/fr1IznZWpF4zJgx/PTTT2zcuJH33nuPrVu3MnbsWIxGc7ZHenp6NdelUqnEx8en1vvOmTMHT09Py09YWNilbF0gEAguO46IGR9XNWufGMRTFQ2t64uty88RkWfrzmyIoGlwjFUjuQkdpW2Qh91jN42SKT3CiJszjgldQ/7Te/9X+DQzx6Cd3ZveoOryLl27AKA9eepyLuuKosndi47St29f+laoYYB+/frRtm1bvv76a9566y0Abr/9dsv5jh070qlTJ1q2bMmWLVsYPnx4g+774osv8tRTT1keFxYWCuElEAiuKMZfxHryX+CIMKlsdG2e57gQckTgVS1r0RAaMs+BmqB2lrpADw27XhiOjIZ1FLhS6DQ0jGObkkmLLSAjvpCgCE+H5ju1M7uWtTV4r64VmlR0+fn5oVAoyMjIsDuekZFRZ8xWJSqViq5du3L+/Plax0RGRuLn58f58+cZPnw4QUFBZGZm2o0xGAzk5ubWel+NRlMtGF8gEAiuBObf2Y3sYh3Tejdv1Ps6IkzKDbaiqxEtXQ7W27LO+2+FoS0apaJayYyrEVcvDQNvb413kKvDggusokuflISxoACFp+PXuNJpUveiWq2me/fubNy40XLMZDKxceNGO2vWxTAajRw/fpxmzWpPVU5OTiYnJ8cypm/fvuTn53Pw4EHLmE2bNmEymejdu3cDdyMQCARNw5gOzbizT3ijWEmKtNYAfA8HqqLrLlF0qRshfszOBXoJjcMdn3dFVG+6LLTrH0yzlg0TSwovL1Sh5tpk2tOnL+eyrhia/JV+6qmn+Pbbb/nxxx85ffo0Dz30ECUlJZZsxrvuuosXX3zRMv7NN99k/fr1XLhwgUOHDnHnnXeSkJDA/fffD5iD7J999ln27NlDfHw8GzduZPz48URFRTF69GgA2rZty5gxY5g5cyb79u1j586dzJ49m9tvv11kLgoEAsFF2Befa/ndkVIT5QZrBfWGiMOGx3TVf57BpsppQ6xWjbHGa51Ka1fizAfQp6Y28WouP00e0zVlyhSysrJ49dVXSU9Pp0uXLqxdu9YSXJ+YmIhcbn1D5uXlMXPmTNLT0/H29qZ79+7s2rWLdhUvlEKh4NixY/z444/k5+cTHBzMqFGjeOutt+zcg7/88guzZ89m+PDhyOVyJk2axGeffda4mxcIBIKrjGBPZxJySqv1SqyLcoNjVcrBPjarMQq/6myEYYMyLBsonhpanuJaxLlzJ4rWrwe9Hn1qKqprzBDS5KILYPbs2cyePbvGc1u2bLF7/PHHH/Pxxx/Xei1nZ2fWrVtX5z19fHxEIVSBQCBwkHcmduCbbRd4eEiUQ/MakMxmR8NjuuovnmyFYUNEXmGZweE50HC35LWI1223YSwqQtKWo/RvWP24K5krQnQJBAKB4Oog0t+NdyfVr6r75aQxAukPJ+ZbfncksF0hl2E0SQTX0fPRFrugfeFetKBwdyfgiSeaehn/GeKVFggEAsEVjyPWoIYKmspWOyPaBtYx0p4tzwxhXMcgXhrXxqF5lVxLgfSCiyMsXQKBQCD4z7mtRyhrTqTz5bRuDZofWEdvx9pwRKy9cmM7hkQHMLl7qEP3CPNx4ctp3R1dmgXhXrx+EKJLIBAIBP85703qxNsTOjoUK2W0ySbs19K3Qfd1xIoU5uPCHY1c6wwaniQguPoQoksgEAgE/zkymQy10rFSEZ42dcDaB3tcZGTtXA2uu6thjYLLgxBdAoFAILgi8XZVs/KR/ng4KVE6UFbBdN7VKQAAFoVJREFU1kLm1MDei42JcC9ePwjRJRAIBIIrli5hXg7PKdRaSzd0ae74/MZGZC9ePwjRJRAIBIJrilu6hbD1bBb3DYjAw8mxIq6NhV3hV1Ec9bpBiC6BQCAQXFOEeruw/KF+Tb2MeiMsXdcP4pUWCAQCgaAJETFd1w9CdAkEAoFA0IR4OAmn0/WCEF0CgUAgEDQyBqM1w7IhyQKCqxMhugQCgUAgaGQyi7SW31v6uzXhSgSNiRBdAoFAIBA0MqPaBdEqwI3HhrdC7kBzbcHVjXAkCwQCgUDQyHi7qtnw1OCmXoagkRGWLoFAIBAIBIJGQIgugUAgEAgEgkZAiC6BQCAQCASCRkCILoFAIBAIBIJGQIgugUAgEAgEgkZAiC6BQCAQCASCRkCILoFAIBAIBIJGQIgugUAgEAgEgkZAiC6BQCAQCASCRkCILoFAIBAIBIJGQIgugUAgEAgEgkZAiC6BQCAQCASCRkCILoFAIBAIBIJGQIgugUAgEAgEgkZA2dQLuFqRJAmAwsLCJl6JQCAQCASC+lL5uV35Od6YCNHVQIqKigAICwtr4pUIBAKBQCBwlKKiIjw9PRv1njKpKaTeNYDJZCI1NRV3d3dkMlmDr1NYWEhYWBhJSUl4eHhcxhVeeVxPe4Xra7/X015B7Pda5nraK1xf+63ca2JiIjKZjODgYOTyxo2yEpauBiKXywkNDb1s1/Pw8Ljm3/CVXE97hetrv9fTXkHs91rmetorXF/79fT0bLK9ikB6gUAgEAgEgkZAiC6BQCAQCASCRkCIriZGo9Hw2muvodFomnop/znX017h+trv9bRXEPu9lrme9grX136vhL2KQHqBQCAQCASCRkBYugQCgUAgEAgaASG6BAKBQCAQCBoBIboEAoFAIBAIGgEhugQCgUAgEAgaASG6mpAvvviCFi1a4OTkRO/evdm3b19TL6lOXn/9dWQymd1PmzZtLOe1Wi2PPPIIvr6+uLm5MWnSJDIyMuyukZiYyA033ICLiwsBAQE8++yzGAwGuzFbtmyhW7duaDQaoqKi+OGHHxpje2zbto2bbrqJ4OBgZDIZK1eutDsvSRKvvvoqzZo1w9nZmREjRnDu3Dm7Mbm5uUybNg0PDw+8vLy47777KC4uthtz7NgxBg4ciJOTE2FhYbz//vvV1vL777/Tpk0bnJyc6NixI//880+j7vWee+6p9lqPGTPmqtzrnDlz6NmzJ+7u7gQEBDBhwgRiYmLsxjTme/e//tuvz36HDBlS7fWdNWvWVbffr776ik6dOlmKe/bt25c1a9ZYzl9Lr2t99nutvK418e677yKTyXjiiScsx66611cSNAlLliyR1Gq1tGDBAunkyZPSzJkzJS8vLykjI6Opl3ZRXnvtNal9+/ZSWlqa5ScrK8tyftasWVJYWJi0ceNG6cCBA1KfPn2kfv36Wc4bDAapQ4cO0ogRI6TDhw9L//zzj+Tn5ye9+OKLljEXLlyQXFxcpKeeeko6deqUNG/ePEmhUEhr1679z/f3zz//SP/73/+kP/74QwKkFStW2J1/9913JU9PT2nlypXS0aNHpZtvvlmKiIiQysrKLGPGjBkjde7cWdqzZ4+0fft2KSoqSpo6darlfEFBgRQYGChNmzZNOnHihPTrr79Kzs7O0tdff20Zs3PnTkmhUEjvv/++dOrUKenll1+WVCqVdPz48Ubb69133y2NGTPG7rXOzc21G3O17HX06NHSwoULpRMnTkhHjhyRxo0bJzVv3lwqLi62jGms925j/O3XZ7+DBw+WZs6caff6FhQUXHX7/fPPP6XVq1dLZ8+elWJiYqSXXnpJUqlU0okTJyRJurZe1/rs91p5Xauyb98+qUWLFlKnTp2kxx9/3HL8ant9hehqInr16iU98sgjlsdGo1EKDg6W5syZ04SrqpvXXntN6ty5c43n8vPzJZVKJf3++++WY6dPn5YAaffu3ZIkmT/o5XK5lJ6ebhnz1VdfSR4eHlJ5ebkkSZL03HPPSe3bt7e79pQpU6TRo0df5t1cnKpCxGQySUFBQdIHH3xgOZafny9pNBrp119/lSRJkk6dOiUB0v79+y1j1qxZI8lkMiklJUWSJEn68ssvJW9vb8t+JUmSnn/+eSk6Otry+LbbbpNuuOEGu/X07t1bevDBBy/rHiupTXSNHz++1jlX614lSZIyMzMlQNq6daskSY373m2Kv/2q+5Uk84ez7YdXVa7m/Xp7e0vffffdNf+6VlK5X0m6Nl/XoqIiqVWrVtKGDRvs9nc1vr7CvdgE6HQ6Dh48yIgRIyzH5HI5I0aMYPfu3U24svpx7tw5goODiYyMZNq0aSQmJgJw8OBB9Hq93b7atGlD8+bNLfvavXs3HTt2JDAw0DJm9OjRFBYWcvLkScsY22tUjmnq5yYuLo709HS7tXl6etK7d2+7/Xl5edGjRw/LmBEjRiCXy9m7d69lzKBBg1Cr1ZYxo0ePJiYmhry8PMuYK+E52LJlCwEBAURHR/PQQw+Rk5NjOXc177WgoAAAHx8foPHeu031t191v5X88ssv+Pn50aFDB1588UVKS0st567G/RqNRpYsWUJJSQl9+/a95l/Xqvut5Fp7XR955BFuuOGGamu6Gl9f0fC6CcjOzsZoNNq9CQACAwM5c+ZME62qfvTu3ZsffviB6Oho0tLSeOONNxg4cCAnTpwgPT0dtVqNl5eX3ZzAwEDS09MBSE9Pr3HflecuNqawsJCysjKcnZ3/o91dnMr11bQ227UHBATYnVcqlfj4+NiNiYiIqHaNynPe3t61PgeV12gMxowZwy233EJERASxsbG89NJLjB07lt27d6NQKK7avZpMJp544gn69+9Phw4dLGtpjPduXl5eo//t17RfgDvuuIPw8HCCg4M5duwYzz//PDExMfzxxx8X3UvluYuNaez9Hj9+nL59+6LVanFzc2PFihW0a9eOI0eOXJOva237hWvrdQVYsmQJhw4dYv/+/dXOXY1/t0J0CRxi7Nixlt87depE7969CQ8P57fffmsyMST4b7j99tstv3fs2JFOnTrRsmVLtmzZwvDhw5twZZfGI488wokTJ9ixY0dTL6VRqG2/DzzwgOX3jh070qxZM4YPH05sbCwtW7Zs7GVeEtHR0Rw5coSCggKWLVvG3XffzdatW5t6Wf8Zte23Xbt219TrmpSUxOOPP86GDRtwcnJq6uVcFoR7sQnw8/NDoVBUy7DIyMggKCioiVbVMLy8vGjdujXnz58nKCgInU5Hfn6+3RjbfQUFBdW478pzFxvj4eHRpMKucn0Xe92CgoLIzMy0O28wGMjNzb0sz0FTvj8iIyPx8/Pj/PnzwNW519mzZ/P333+zefNmQkNDLccb673b2H/7te23Jnr37g1g9/peLftVq9VERUXRvXt35syZQ+fOnfn000+v2de1tv3WxNX8uh48eJDMzEy6deuGUqlEqVSydetWPvvsM5RKJYGBgVfd6ytEVxOgVqvp3r07GzdutBwzmUxs3LjRzi9/NVBcXExsbCzNmjWje/fuqFQqu33FxMSQmJho2Vffvn05fvy43Yf1hg0b8PDwsJjH+/bta3eNyjFN/dxEREQQFBRkt7bCwkL27t1rt7/8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",
       "text/plain": [
        "<Figure size 640x480 with 1 Axes>"
       ]
@@ -327,10 +438,7 @@
     }
    ],
    "source": [
-    "ts,ls = info['avg_loss']\n",
-    "plt.plot(ts,ls)\n",
-    "# plt.xscale('log')\n",
-    "# plt.yscale('log')"
+    "eval.plot_train_loss(info)"
    ]
   },
   {
@@ -343,13 +451,44 @@
   },
   {
    "cell_type": "code",
-   "execution_count": 15,
+   "execution_count": 5,
    "id": "ac815258-7141-4e1c-8ea8-b6598aa6dd27",
+   "metadata": {
+    "scrolled": true
+   },
+   "outputs": [
+    {
+     "data": {
+      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAkAAAAHHCAYAAABXx+fLAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjguMywgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy/H5lhTAAAACXBIWXMAAA9hAAAPYQGoP6dpAAEAAElEQVR4nOydd5hU5d2/7zO9bK8svTdBRRRQiBUFoiiIHQtKMcYSxeAb8xpRk58aNUaMLRIDmFciGmssFAsWBEQUlCp1l7KwvU2fOef3x3POmZkt7FJ30ee+rr3YPfWZ2WXPZz/fpmiapiGRSCQSiUTyM8LS2guQSCQSiUQiOdZIASSRSCQSieRnhxRAEolEIpFIfnZIASSRSCQSieRnhxRAEolEIpFIfnZIASSRSCQSieRnhxRAEolEIpFIfnZIASSRSCQSieRnhxRAEolEIpFIfnZIASSRSFrE0qVLURSFpUuXtvZSfjLMnTsXRVHYuXPnUb/XAw88gKIoR/0+EsnxghRAEkkbQlGUFn0cCRHi9/t54IEHpKBphocffpi33367tZfRIuT3VCJpObbWXoBEIonzr3/9K+nrl19+mSVLljTY3q9fv8O+l9/v58EHHwTg7LPPPuzr/VR5+OGHueyyyxg3btwRv/Z1113HVVddhdPpPCLXO9D39L777uN3v/vdEbmPRPJTQAogiaQNce211yZ9vWLFCpYsWdJgu6Rt4vP58Hq9LT7earVitVqP4ori2Gw2bDb5K18iMZAhMInkOENVVZ566ilOOOEEXC4X+fn53HzzzVRWViYd98033zBq1ChycnJwu91069aNm266CYCdO3eSm5sLwIMPPmiG1h544IGDXs/rr7/O4MGDcbvd5OTkcO2117Jnz56kY/bt28eNN95Ix44dcTqdFBQUcMkllyTlvhxovU1x0UUX0b1790b3nX766Zx66qnm10uWLGHEiBFkZGSQkpJCnz59+P3vf3/A6yuKgs/nY968eeZ7NGnSJCCeU7NhwwauueYaMjMzGTFiBADff/89kyZNonv37rhcLtq1a8dNN91EeXl50vUbywHq2rUrF110EV9++SVDhgzB5XLRvXt3Xn755QOutbnvaWM5QIqicNttt/H666/Tv39/3G43p59+Oj/88AMAf//73+nZsycul4uzzz670VyllStXMnr0aNLT0/F4PJx11lksW7bsgGuVSNoC8s8BieQ44+abb2bu3LnceOON3HHHHezYsYNnnnmG7777jmXLlmG32ykpKeGCCy4gNzeX3/3ud2RkZLBz507efPNNAHJzc3n++ee55ZZbGD9+PJdeeikAJ5544kGtxVjHaaedxiOPPML+/fuZNWsWy5Yt47vvviMjIwOACRMmsH79em6//Xa6du1KSUkJS5YsoaioyPz6QOttiiuvvJLrr7+eVatWcdppp5nbCwsLWbFiBY8//jgA69ev56KLLuLEE0/koYcewul0snXr1mYf1P/617+YMmUKQ4YMYdq0aQD06NEj6ZjLL7+cXr168fDDD6NpGiDE1vbt27nxxhtp164d69ev58UXX2T9+vWsWLGi2WTkrVu3ctlllzF58mRuuOEG/vnPfzJp0iQGDx7MCSec0Og5h/o9/eKLL3j33Xe59dZbAXjkkUe46KKLuOeee3juuef49a9/TWVlJY899hg33XQTn3zyiXnuJ598wpgxYxg8eDAzZ87EYrEwZ84czj33XL744guGDBlywHtLJK2KJpFI2iy33nqrlvjf9IsvvtAA7ZVXXkk6buHChUnb33rrLQ3QVq1a1eS1S0tLNUCbOXNmi9by6aefaoD26aefapqmaeFwWMvLy9MGDBigBQIB87j33ntPA7T7779f0zRNq6ys1ADt8ccfb/LaLVlvY1RXV2tOp1O7++67k7Y/9thjmqIoWmFhoaZpmvbXv/5VA7TS0tKDur6maZrX69VuuOGGBttnzpypAdrVV1/dYJ/f72+w7d///rcGaJ9//rm5bc6cORqg7dixw9zWpUuXBseVlJQ0+jrrc6DvqbHeRADN6XQm3f/vf/+7Bmjt2rXTampqzO333ntv0lpVVdV69eqljRo1SlNVNem1d+vWTTv//PMPuFaJpLWRITCJ5Dji9ddfJz09nfPPP5+ysjLzY/DgwaSkpPDpp58CmM7Le++9RyQSOSpr+eabbygpKeHXv/41LpfL3H7hhRfSt29f3n//fQDcbjcOh4OlS5c2CNMZHOp609LSGDNmDK+99prpvgAsWLCAYcOG0blz56Trv/POO6iqejAvs1l+9atfNdjmdrvNz4PBIGVlZQwbNgyAb7/9ttlr9u/fn1/84hfm17m5ufTp04ft27cfgRUnc95559G1a1fz66FDhwLCtUtNTW2w3VjD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",
+      "text/plain": [
+       "<Figure size 640x480 with 1 Axes>"
+      ]
+     },
+     "metadata": {},
+     "output_type": "display_data"
+    }
+   ],
+   "source": [
+    "eval.plot_test_loss(info)"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "id": "c5e82793-656c-492a-9a1b-b422b8c1af0f",
+   "metadata": {},
+   "source": [
+    "#### Plot train vs. test loss"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 6,
+   "id": "cdfb8940-95f8-4926-af92-054760b8a7f0",
    "metadata": {},
    "outputs": [
     {
      "data": {
-      "image/png": "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",
+      "image/png": "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YNq4cWOle7V3j5KSEtObb75pat26tcnNzc0UGRlpmjVrlqmwsFCd48jvZvny5aYRI0aYQkNDTe7u7qaWLVuannzySVNKSkqlexKEKxWdyVTNqDxBEARBEIRGisQACYIgCIJw1SECSBAEQRCEqw4RQIIgCIIgXHWIABIEQRAE4apDBJAgCIIgCFcdIoAEQRAEQbjqkEKIdjAajZw7dw5fX99qldIXBEEQBOHyYzKZuHjxIhEREVYFVe0hAsgO586dIzIysr63IQiCIAhCNUhOTqZFixaVzhEBZAdfX19A+QH6+fnV824EQRAEQXCE3NxcIiMj1c/xyhABZAez28vPz08EkCAIgiA0MhwJX5EgaEEQBEEQrjpEAAmCIAiCcNUhAkgQBEEQhKsOiQESBEEQ6g2j0UhxcXF9b0NoJLi5ueHi4lIr1xIBJAiCINQLxcXFJCQkYDQa63srQiMiICCAZs2a1bhOX4MQQJ9++invv/8+qamp9OzZk08++YS+ffvanXvDDTfw559/lhu/5ZZbWLVqFaAUQnr99ddZsGAB2dnZDBo0iM8//5z27dvX6esQBEEQHMNkMpGSkoKLiwuRkZFVFq0TBJPJREFBAefPnwcgPDy8RterdwG0bNkyZs6cyfz58+nXrx/z5s1j5MiRxMbGEhoaWm7+Tz/9ZGUuvXDhAj179uTee+9Vx9577z3++c9/smjRIlq3bs2rr77KyJEjOXbsGJ6enpfldQmCIAgVU1paSkFBAREREXh7e9f3doRGgpeXFwDnz58nNDS0Ru6wepfcc+fOZeLEiUyYMIEuXbowf/58vL29Wbhwod35gYGBNGvWTH2sW7cOb29vVQCZTCbmzZvHK6+8wujRo+nRowfffPMN586d45dffrmMr0wQBEGoCIPBAIC7u3s970RobJgFc0lJSY2uU68CqLi4mL179zJs2DB1TK/XM2zYMLZv3+7QNb788kvuu+8+fHx8AEhISCA1NdXqmv7+/vTr18/hawqCIAiXB+m3KDhLbb1n6tUFlpGRgcFgICwszGo8LCyM48ePV7l+165dHDlyhC+//FIdS01NVa9he03zOVuKioooKipSn+fm5jr8GgRBEARBaHzUuwusJnz55Zd07969woBpR5kzZw7+/v7qQxqhCoIgCILCo48+yp133lnf26h16lUABQcH4+LiQlpamtV4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WbduHQsODraKkpq4evUqA8C+/fZb67kVK1YwACwzM7PasZWVlSwoKIht3ryZMcbYl19+yYxGI8vKylK9fsWKFSwkJMThvFwAbd++nZlMJpadnW19/fDhwwwA++mnnxhjXAAFBgYq3uOMGTNYSkqKyFsmCK+FXGAEQSjo06cPDAaD9bhv3744ceIEKisrred69uypGHP06FH0799fca5///7WcVlZWfDx8UH37t2trycmJiIsLMxhfvt7//LLL5g3bx6aNm1qfaSnpyMnJwc3btzAPffcg+LiYiQkJCA9PR0bNmywusduu+02xMXFISEhAWPHjsWaNWtw48YNzXvi5+eHrl27Ks7l5eUhPT0dbdu2RUhICIKDg1FUVITs7GwAQGZmJlq1aoV27dppnk/i6NGjiI2NRWxsrPVcx44dERoaiqNHj1rPxcfHK4K1o6OjcenSJZfnJQhvgAQQQRCaadKkidvuXVRUhOeffx6ZmZnWx6FDh3DixAmYzWbExsYiKysLb731FgICAjBlyhQMHDgQ5eXlCAoKwoEDB/DRRx8hOjoas2fPRrdu3Rwyr2oiICBAIQoBYPz48cjMzMQbb7yB3bt3IzMzE82bN0dZWZl1jLuwDxQ3GAywWCxum58gPBESQARBKPjxxx8Vx3v37kXbtm1hMpmcjklKSsKuXbsU53bt2oV27drBZDKhffv2qKiowMGDB62vnzx5ElevXq1xPd27d0dWVhYSExMdHlImVkBAAO666y7861//QkZGBvbs2YNDhw4BAHx8fJCWloYFCxbg119/xdmzZ/HNN98I74czdu3ahUcffRTDhw+3Bn9fuXLF+nrXrl1x4cIFHD9+XHW8n5+fwqqmRlJSEs6fP4/z589bzx05cgT5+fno2LGj7vdAEN4MpcETBKEgOzsb06dPx6RJk3DgwAEsWbLEIaPLnieffBK9evXCCy+8gDFjxmDPnj1488038dZbbwEAOnTogLS0NEycOBFvv/02fH198eSTT6paVuyZPXs27rzzTrRu3RqjR4+G0WjEL7/8gt9++w0vvvgiVq5cicrKSqSkpCAwMBCrV69GQEAA4uLi8MUXX+D06dMYOHAgwsLCsHXrVlgsFrRv3173PrVt2xarVq1Cz549UVBQgBkzZiisPqmpqRg4cCD+9re/YeHChUhMTMSxY8dgMBgwbNgwxMfHo6ioCDt27EC3bt0QGBjoUPsnLS0NXbp0wQMPPIDFixejoqICU6ZMQWpqqoOrkCAIbZAFiCAIBePGjUNxcTF69+6NqVOn4rHHHrOmujuje/fu+OSTT7B27Vp07twZs2fPxrx58/Dggw9ar/nggw8QFRWFgQMHYtSoUUhPT0dQUBDMZnO19x46dCi++OILbN++Hb169UKfPn2waNEixMXFAQBCQ0Px7rvvon///ujatSu+/vprbN68Gc2bN0doaCjWr1+PwYMHIykpCcuWLcNHH32ETp066d6n9957D1evXkX37t0xduxYPProo4iMjFRcs27dOvTq1Qv33XcfOnbsiKeeespq9enXrx8mT56MMWPGICIiAgsWLHCYw2AwYOPGjQgLC8PAgQORlpaGhIQEfPzxx7rXTxDeDlWCJgjCyqBBg5CcnOyWVgwXLlxAbGwsvv76awwZMqTO5yMIgpBDLjCCINzCN998g6KiInTp0gU5OTl46qmnEB8fj4EDB9b30giC8EJIABEE4RbKy8sxc+ZMnD59GkFBQejXrx/WrFnj1lYXBEEQEuQCIwiCIAjC66AgaIIgCIIgvA4SQARBEARBeB0kgAiCIAiC8DpIABEEQRAE4XWQACIIgiAIwusgAUQQBEEQhNdBAoggCIIgCK+DBBBBEARBEF4HCSCCIAiCILyO/w9XhFQQkVDkIgAAAABJRU5ErkJggg==",
       "text/plain": [
        "<Figure size 640x480 with 1 Axes>"
       ]
@@ -359,7 +498,7 @@
     }
    ],
    "source": [
-    "eval.plot_loss(info)"
+    "eval.plot_train_test_loss(info)"
    ]
   },
   {
@@ -372,13 +511,13 @@
   },
   {
    "cell_type": "code",
-   "execution_count": 16,
+   "execution_count": 7,
    "id": "edb8dbe5-1fe6-4dc3-9aa2-39f44d7939ab",
    "metadata": {},
    "outputs": [
     {
      "data": {
-      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAjcAAAHHCAYAAABDUnkqAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjguMywgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy/H5lhTAAAACXBIWXMAAA9hAAAPYQGoP6dpAAB7e0lEQVR4nO3dd3xV9f3H8de9GTd77xAIew8FoQxFFMVF68ZRRVy1QB3UuhVHBbUOrLW1TqzViiL6swVRBHEgMkXZMyGsJGTvde/398dNrlySQAhJbsb7+fB67/2e7znnc09C8sl3HYsxxiAiIiLSTlg9HYCIiIhIU1JyIyIiIu2KkhsRERFpV5TciIiISLui5EZERETaFSU3IiIi0q4ouREREZF2RcmNiIiItCtKbkRERKRdUXIjHUpycjI33HCDx85/ww03kJyc7FZWVFTEzTffTFxcHBaLhTvvvJPU1FQsFgtz5871SJzSdj366KNYLBaysrI8HQrQPPGceeaZnHnmmcett3z5ciwWC8uXL2+yc0vboORG2oXdu3fzu9/9jm7duuHn50dISAijR4/mxRdfpLS01NPhHdOsWbOYO3cuv//973nnnXe47rrrPB2StAGzZs3ik08+8XQYIq2St6cDEDlZCxcu5IorrsBms3H99dczYMAAKioq+O677/jTn/7E5s2befXVVz0dJgCvvfYaDofDrWzZsmX86le/YubMma4yYwylpaX4+Pi0dIjSRsyaNYvLL7+ciy++2NOhiLQ6Sm6kTUtJSeGqq66iS5cuLFu2jPj4eNe2adOmsWvXLhYuXOjBCN3VlaxkZmbSr18/tzKLxYKfn1+Tnbe4uJjAwMAmO54ntafP0to4HA4qKiqa9HtPxBPULSVt2jPPPENRURFvvPGGW2JTo0ePHtxxxx317p+Tk8Pdd9/NwIEDCQoKIiQkhPPPP5+ffvqpVt2XXnqJ/v37ExAQQHh4OMOGDeO9995zbS8sLOTOO+8kOTkZm81GTEwM55xzDuvXr3fVOXLMTc14gJSUFBYuXIjFYsFisZCamlrvmJtt27Zx+eWXExERgZ+fH8OGDePTTz91qzN37lwsFgtff/01U6dOJSYmhk6dOtV7DSoqKnjkkUcYOnQooaGhBAYGcvrpp/PVV1/VqutwOHjxxRcZOHAgfn5+REdHc95557F27Vq3ev/+978ZPny461qdccYZfPHFF67tFouFRx99tNbxjx4TdazPsnfvXqZOnUrv3r3x9/cnMjKSK664gtTU1FrHzcvL46677nJ9bTp16sT1119PVlYWRUVFBAYG1vl9sn//fry8vJg9e3ad166yspKIiAimTJlSa1tBQQF+fn7cfffdrrLjfQ81lMViobi4mLffftv1fXP0WLK8vDxuuOEGwsLCCA0NZcqUKZSUlNQ6zvTp03n33Xfp378/NpuNxYsXA3DgwAFuvPFGYmNjsdls9O/fnzfffLNWLA39TA2Jp6qqiieeeILu3btjs9lITk7mgQceoLy8/LjXZP/+/Vx88cUEBgYSExPDXXfd1aD9pH1Sy420af/973/p1q0bo0aNatT+e/bs4ZNPPuGKK66ga9euZGRk8M9//pOxY8eyZcsWEhISAGd30u23387ll1/OHXfcQVlZGT///DOrVq3immuuAeC2225j/vz5TJ8+nX79+pGdnc13333H1q1bOfXUU2udu2/fvrzzzjvcdddddOrUiT/+8Y8AREdHc/jw4Vr1N2/ezOjRo0lMTOS+++4jMDCQDz74gIsvvpiPPvqISy65xK3+1KlTiY6O5pFHHqG4uLjea1BQUMDrr7/O1VdfzS233EJhYSFvvPEGEyZMYPXq1QwZMsRV96abbmLu3Lmcf/753HzzzVRVVfHtt9/yww8/MGzYMAAee+wxHn30UUaNGsXjjz+Or68vq1atYtmyZZx77rkn9gU6xmdZs2YN33//PVdddRWdOnUiNTWVf/zjH5x55pls2bKFgIAAwDlg+/TTT2fr1q3ceOONnHrqqWRlZfHpp5+yf/9+hgwZwiWXXMK8efN4/vnn8fLycp33P//5D8YYrr322jrj8vHx4ZJLLmHBggX885//xNfX17Xtk08+oby8nKuuugpo2PdQQ73zzjvcfPPNDB8+nFtvvRWA7t27u9W58sor6dq1K7Nnz2b9+vW8/vrrxMTE8PTTT7vVW7ZsGR988AHTp08nKiqK5ORkMjIy+NWvfuVKfqKjo/nss8+46aabKCgo4M477zzhz9SQeG6++WbefvttLr/8cv74xz+yatUqZs+ezdatW/n444/rvR6lpaWcffbZpKWlcfvtt5OQkMA777zDsmXLTui6SjtiRNqo/Px8A5jf/OY3Dd6nS5cuZvLkya73ZWVlxm63u9VJSUkxNpvNPP74466y3/zmN6Z///7HPHZoaKiZNm3aMetMnjzZdOnSpVZMF154Ya0YAPPWW2+5ys4++2wzcOBAU1ZW5ipzOBxm1KhRpmfPnq6yt956ywBmzJgxpqqq6pjxGGNMVVWVKS8vdyvLzc01sbGx5sYbb3SVLVu2zADm9ttvr3UMh8NhjDFm586dxmq1mksuuaTWda2pY4wxgJk5c2at4xz99TnWZykpKam1/8qVKw1g/vWvf7nKHnnkEQOYBQsW1Bv3559/bgDz2WefuW0fNGiQGTt2bK39jlSz73//+1+38gsuuMB069bN9b4h30MnIjAw0O1a1Zg5c6YB3L52xhhzySWXmMjISLcywFitVrN582a38ptuusnEx8ebrKwst/KrrrrKhIaGuq59Qz5TQ+PZsGGDAczNN9/sVu/uu+82gFm2bJmrbOzYsW5flzlz5hjAfPDBB66y4uJi06NHDwOYr7766pgxSvujbilpswoKCgAIDg5u9DFsNhtWq/Ofgd1uJzs7m6CgIHr37u3WnRQWFsb+/ftZs2ZNvccKCwtj1apVHDx4sNHx1CcnJ4dly5Zx5ZVXUlhYSFZWFllZWWRnZzNhwgR27tzJgQMH3Pa55ZZb3Foh6uPl5eVqcXA4HOTk5FBVVcWwYcPcrsFHH32ExWJxG/hcw2KxAM7WCofDwSOPPOK6rkfXaYy6Pou/v7/rdWVlJdnZ2fTo0YOwsLBacQ8ePLhWy9aRMY0fP56EhATeffdd17ZNmzbx888/89vf/vaYsZ111llERUUxb948V1lubi5Llixh0qRJrrKGfA81pdtuu83t/emnn052drbr302NsWPHuo35Msbw0UcfMXHiRIwxru+1rKwsJkyYQH5+vuv6nshnOl48ixYtAmDGjBlu9WpaNI81dm7RokXEx8dz+eWXu8oCAgJcrVrS8Si5kTYrJCQEcI51aSyHw8ELL7xAz549sdlsREVFER0dzc8//0x+fr6r3r333ktQUBDDhw+nZ8+eTJs2jRUrVrgd65lnnmHTpk0kJSUxfPhwHn30Ufbs2dPo2I60a9cujDE8/PDDREdHuz1qko3MzEy3fbp27drg47/99tsMGjQIPz8/IiMjiY6OZuHChW7XYPfu3SQkJBAREVHvcXbv3o3Vaq01QPpk1fVZSktLeeSRR0hKSnL72uXl5dWKe8CAAcc8vtVq5dprr+WTTz5xjQN599138fPz44orrjjmvt7e3lx22WX83//9n2uMx4IFC6isrHRLbhryPdSUOnfu7PY+PDwccCZeRzr62h4+fJi8vDxeffXVWt9rNWOLar7XTuQzHS+evXv3YrVa6dGjh1u9uLg4wsLC2Lt3b72fde/evfTo0aNWAt27d+9695H2TcmNtFkhISEkJCSwadOmRh9j1qxZzJgxgzPOOIN///vffP755yxZsoT+/fu7Tdnu27cv27dv5/3332fMmDF89NFHjBkzxq0V48orr2TPnj289NJLJCQk8Je//IX+/fvz2WefndTnBFyx3H333SxZsqTOx9G/FI5s2TiWf//739xwww10796dN954g8WLF7NkyRLOOuusWtPWm5vdbq+zvK7P8oc//IEnn3ySK6+8kg8++IAvvviCJUuWEBkZ2ai4r7/+eoqKivjkk08wxvDee+9x0UUXERoaetx9r7rqKgoLC11f6w8++IA+ffowePBgV52GfA81pfpa7Ywxbu+PvrY11+63v/1tvd9ro0ePBk7sMzU0npNp4ROpoQHF0qZddNFFvPrqq6xcuZKRI0ee8P7z589n3LhxvPHGG27leXl5REVFuZUFBgYyadIkJk2aREVFBZdeeilPPvkk999/v2vqbHx8PFOnTmXq1KlkZmZy6qmn8uSTT3L++ec3/kMC3bp1A5wDWMePH39Sxzra/Pnz6datGwsWLHD7xXL0L6ju3bvz+eefk5OTU2/rTffu3XE4HGzZssVtIPLRwsPDycvLcyurqKjg0KFDJxT35MmTee6551xlZWVltY7bvXv3BiXAAwYM4JRTTuHdd9+lU6dOpKWl8dJLLzUoljPOOIP4+HjmzZvHmDFjWLZsGQ8++GCteg35Hmqo5koCoqOjCQ4Oxm63N+h7rak+U5cuXXA4HOzcuZO+ffu6yjMyMsjLy6NLly7H3HfTpk0YY9yuy/bt2xt8fmlf1HIjbdo999xDYGAgN998MxkZGbW27969mxdffLHe/b28vGr95fjhhx/WGr+SnZ3t9t7X15d+/fphjKGyshK73e7WFQIQExNDQkJCk0xHjYmJ4cwzz+Sf//xnnQlAXbOrGqrmL+ojr8OqVatYuXKlW73LLrsMYwyPPfZYrWPU7HvxxRdjtVp5/PHHa7WeHHn87t27880337htf/XVV+ttuakv7qO/di+99FKtY1x22WX89NNPdc62OXr/6667ji+++II5c+YQGRnZ4KTUarVy+eWX89///pd33nmHqqoqty4pOP73EEBJSQnbtm1r0K0KAgMDayVyTcHLy4vLLruMjz76qM6k8MjvtYZ8poa64IILAJgzZ45b+fPPPw/AhRdeeMx9Dx48yPz5811lJSUlrWbxTml5armRNq179+689957TJo0ib59+7qtUPz999/z4YcfHvNeUhdddBGPP/44U6ZMYdSoUWzcuJF3333X1VJS49xzzyUuLo7Ro0cTGxvL1q1b+dvf/saFF15IcHAweXl5dOrUicsvv5zBgwcTFBTEl19+yZo1a9xaFk7Gyy+/zJgxYxg4cCC33HIL3bp1IyMjg5UrV7J///461+ZpiIsuuogFCxZwySWXcOGFF5KSksIrr7xCv379KCoqctUbN24c1113HX/961/ZuXMn5513Hg6Hg2+//ZZx48Yxffp0evTowYMPPsgTTzzB6aefzqWXXorNZmPNmjUkJCS41ou5+eabue2227jssss455xz+Omnn/j8889rtZYdL+533nmH0NBQ+vXrx8qVK/nyyy+JjIx0q/enP/2J+fPnc8UVV3DjjTcydOhQcnJy+PTTT3nllVfcuo6uueYa7rnnHj7++GN+//vfn9AK0ZMmTeKll15i5syZDBw40K31AY7/PQSwevVqxo0bx8yZM+tcB+hIQ4cO5csvv+T5558nISGBrl27MmLEiAbHeyxPPfUUX331FSNGjOCWW26hX79+5OTksH79er788ktycnIa/JkaavDgwUyePJlXX32VvLw8xo4dy+rVq3n77be5+OKLGTduXL373nLLLfztb3/j+uuvZ926dcTHx/POO++4lgOQDqjF52eJNIMdO3aYW265xSQnJxtfX18THBxsRo8ebV566SW3qdN1TQX/4x//aOLj442/v78ZPXq0WblyZa2ppv/85z/NGWecYSIjI43NZjPdu3c3f/rTn0x+fr4xxpjy8nLzpz/9yQwePNgEBwebwMBAM3jwYPP3v//dLc6TmQpujDG7d+82119/vYmLizM+Pj4mMTHRXHTRRWb+/PmuOjXTp9esWdOga+dwOMysWbNMly5djM1mM6eccor53//+V2esVVVV5i9/+Yvp06eP8fX1NdHR0eb8888369atc6v3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pIwxfF2zvk0zjbeBX1puEoMSm+0cInLylNyISNuSvtH5HDfQVbQnq5iD+WX4eln5VdfIZjt1TcuNuqVEWjclNyLSdjgccHib83XsAFfxdzud95IalhyOv69Xs52+JrlRy41I6+bx5Obll18mOTkZPz8/RowYwerVq49ZPy8vj2nTphEfH4/NZqNXr14sWrSohaIVEY/KT4OKIvDyhYjuruLvqm+UObpH8yzcV8PVchOklhuR1szbkyefN28eM2bM4JVXXmHEiBHMmTOHCRMmsH37dmJiavebV1RUcM455xATE8P8+fNJTExk7969hIWFtXzwItLyaqaAR/UGL+ePryq7gx92ZwNwejOtSgxQVlVGdpnzPGq5EWndPJrcPP/889xyyy1MmTIFgFdeeYWFCxfy5ptvct9999Wq/+abb5KTk8P333+Pj49z9dHk5OSWDFlEPClzi/M5pq+r6Kf9+RSWVxHq70P/hNBmO/Wh4kMABHgHEOLb9HcbF5Gm47FuqYqKCtatW8f48eN/CcZqZfz48axcubLOfT799FNGjhzJtGnTiI2NZcCAAcyaNQu73d5SYYuIJ9W03ByR3NSMtxndIxKvZrgLeI0jp4E311RzEWkaHmu5ycrKwm63Exsb61YeGxvLtm3b6txnz549LFu2jGuvvZZFixaxa9cupk6dSmVlJTNnzqxzn/LycsrLy13vCwoKmu5DiEjLciU3/VxFK1povM2BogOAuqRE2gKPDyg+EQ6Hg5iYGF599VWGDh3KpEmTePDBB3nllVfq3Wf27NmEhoa6HklJSS0YsYg0GXslHN7ufF3dclNUXsX6tFwAxrTUYGJNAxdp9TyW3ERFReHl5UVGRoZbeUZGBnFxcXXuEx8fT69evfDy+mWqZ9++fUlPT6eioqLOfe6//37y8/Ndj3379jXdhxCRlpOTAo5K8AmEUOcfKatTsqlyGJIi/OkSGdisp99X6PzZkRSsP5BEWjuPJTe+vr4MHTqUpUuXusocDgdLly5l5MiRde4zevRodu3ahcPhcJXt2LGD+Ph4fH1969zHZrMREhLi9hCRNih7l/M5sjtYnT+6vtvpnL3U3K028Ety0yWkS7OfS0ROjke7pWbMmMFrr73G22+/zdatW/n9739PcXGxa/bU9ddfz/333++q//vf/56cnBzuuOMOduzYwcKFC5k1axbTpk3z1EcQkZbiSm56uIrWpDrvAv6rbs23KjE4b++wt2AvAEkharkRae08OhV80qRJHD58mEceeYT09HSGDBnC4sWLXYOM09LSsFp/yb+SkpL4/PPPueuuuxg0aBCJiYnccccd3HvvvZ76CCLSUo5KborLq9hyyDlB4LTkiOY9dVk2JVUlWLDQKahTs55LRE5eo5Kbr776inHjxjVJANOnT2f69Ol1blu+fHmtspEjR/LDDz80yblFpA3J3u18rk5uNuzLw+4wJIb5kxDm36ynrumSig+Mx9er7i5wEWk9GtUtdd5559G9e3f+/Oc/a4CuiLSMo1puarqkhiWHN/up0wrSAHVJibQVjUpuDhw4wPTp05k/fz7dunVjwoQJfPDBB/XOWBIROSnlhVCU7nwd2Q2AtanOKeDDmrlLCmB3nrPVKDkkudnPJSInr1HJTVRUFHfddRcbNmxg1apV9OrVi6lTp5KQkMDtt9/OTz/91NRxikhHVtMlFRAF/uFU2R2u9W1Oa4GWmx15OwDoFd6r2c8lIifvpGdLnXrqqdx///1Mnz6doqIi3nzzTYYOHcrpp5/O5s2bmyJGEenoarqkonoCsPVQISUVdoL9vOkVE9zsp9+ZsxNQciPSVjQ6uamsrGT+/PlccMEFdOnShc8//5y//e1vZGRksGvXLrp06cIVV1zRlLGKSEflGkzcHThivE2XcKzNeD8pgLyyPDJLMwHoEdbjOLVFpDVo1GypP/zhD/znP//BGMN1113HM888w4ABA1zbAwMDefbZZ0lISGiyQEWkAztqMPHavTWDiZt/vM3OPGerTWJQIkG+Qc1+PhE5eY1KbrZs2cJLL73EpZdeis1mq7NOVFQUX3311UkFJyIC1Epu1u2tHkzcpQXG2+Q6x9v0DO/Z7OcSkabRqOTmyFsm1Htgb2/Gjh3bmMOLiLjLqe6WiuhORkEZGQXlWC0wsFNos596Z67G24i0NY0aczN79mzefPPNWuVvvvkmTz/99EkHJSLiUpoHZfnO1+Fd+Hm/83XPmGACfJt/kfXtOc47kavlRqTtaFRy889//pM+ffrUKu/fvz+vvPLKSQclIuKSX71QaEAU+AaycX8e0DKtNpX2Sle3VP+I/s1+PhFpGo1KbtLT04mPj69VHh0dzaFDh046KBERlzzn6sCEdQbgp+qWm8EtkNzsyttFhaOCYN9gOgXrnlIibUWjkpukpCRWrFhRq3zFihWaISUiTeuI5MYYw8YDzuRmYKewZj/15mznWl39I/tjsTTvlHMRaTqN6rC+5ZZbuPPOO6msrOSss84CnIOM77nnHv74xz82aYAi0sEdkdzszy0lp7gCHy8LfeObf/G+TVmbAGdyIyJtR6OSmz/96U9kZ2czdepU1/2k/Pz8uPfee7n//vubNEAR6eCOSG5qWm16xwVj8/Zq9lNvyd4CQP8oJTcibUmjkhuLxcLTTz/Nww8/zNatW/H396dnz571rnkjItJoeXudz2Fd+Hm3M7kZ1AJdUuX2ctc08AGRA45TW0Rak5OaRxkUFMRpp53WVLGIiNR2RMvN5oPO5GZAQvMPJt6UtYkqU0WEXwRxgXHNfj4RaTqNTm7Wrl3LBx98QFpamqtrqsaCBQtOOjAREbc1bsKS2J6+H4A+LTDeZnX6agBOiztNg4lF2phGzZZ6//33GTVqFFu3buXjjz+msrKSzZs3s2zZMkJDm/8vKhHpIGpabQKjya30IbOwHIBesc2f3KxJXwPA8LjhzX4uEWlajUpuZs2axQsvvMB///tffH19efHFF9m2bRtXXnklnTt3buoYRaSjyne21BDaiW3phQAkRfgTZGvelYlLKkv4KfMnwNlyIyJtS6OSm927d3PhhRcC4OvrS3FxMRaLhbvuuotXX321SQMUkQ6s4IDzOSSRHRnO5KZ3C7TarDi4ggpHBYlBiSSHJDf7+USkaTUquQkPD6ew0PmDJjExkU2bnGtB5OXlUVJS0nTRiUjHVpPcHNFy0zuu+ZObJalLADinyzkabyPSBjWqbfeMM85gyZIlDBw4kCuuuII77riDZcuWsWTJEs4+++ymjlFEOqqCg87nkAS2pxQA0DsupFlPWW4v5+v9XwMwvsv4Zj2XiDSPRiU3f/vb3ygrKwPgwQcfxMfHh++//57LLruMhx56qEkDFJEOrDq5McEJ7MgoAqBPM7fcfH/ge0qqSogNiGVg1MBmPZeINI8TTm6qqqr43//+x4QJEwCwWq3cd999TR6YiEhNt9RhayRF5aX4eFnoGhXYrKf8Mu1LwNlqY7U0qudeRDzshP/lent7c9ttt7labkREmoUxrpabXWXOrqju0UH4eDVfwlFpr+SrfV8BML6zuqRE2qpG/ZQYPnw4GzZsaOJQRESOUJoLVc4/ojYWOFtrmnt9m1XpqyisKCTCL4JTYk5p1nOJSPNp1JibqVOnMmPGDPbt28fQoUMJDHRvJh40aFCTBCciHVjNGjeB0ezOca6C3iMmqFlPuWSvc5bU+M7j8bI2/405RaR5NCq5ueqqqwC4/fbbXWUWiwVjDBaLBbvd3jTRiUjH5Zoplciew8UAzTrepqSyhM9TPwdgQvKEZjuPiDS/RiU3KSkpTR2HiIi7IxbwS9nV/MnNopRFFFcW0yWkC8PihjXbeUSk+TUquenSpUtTxyEi4q665aY8II7sYme3VHMlN8YY3t36LgBX9LpCs6RE2rhGJTf/+te/jrn9+uuvb1QwIiIu1clNtlcUALEhNgKb6Z5SKw6uYFfeLgK8A7ik5yXNcg4RaTmN+klxxx13uL2vrKykpKQEX19fAgIClNyIyMmr7pY66AgHmrdLau6muQBc3utyQnybdwVkEWl+jWp7zc3NdXsUFRWxfft2xowZw3/+85+mjlFEOqLq5GZPeSjQfMnNpqxNrEpfhbfFm9/2/W2znENEWlaTdSz37NmTp556qlarjojICTtiAb8txc61bZoruXl94+sAXNDtAuKD4pvlHCLSspp01Jy3tzcHDx5sykOKSEdUlgeVJQBsyA8AoGtU069xsztvN0vTlmLBwk0Dbmry44uIZzRqzM2nn37q9t4Yw6FDh/jb3/7G6NGjmyQwEenAam6YGRDJjuxKoHlabt7c9CYAZ3c+m25h3Zr8+CLiGY1Kbi6++GK39xaLhejoaM466yyee+65pohLRDqy6uSmKjCekhw7Vgt0jgho0lMcKDrAwj0LAbh54M1NemwR8axGJTcOh6Op4xAR+UX1YOJC3xgAOoUH4OvdtGvPvLXpLezGzsj4kfSP6t+kxxYRz9JKVSLS+uQ7k5uc6jVuukQ2batNVmkWn+z6BFCrjUh71Kjk5rLLLuPpp5+uVf7MM89wxRVXnHRQItLBVXdLHTIRACQ1cZfUv7f8m3J7OYOiBnFa3GlNemwR8bxGJTfffPMNF1xwQa3y888/n2+++eakgxKRDq66W2pvlXMBv6Ycb1NYUci87fMAuGngTVgsliY7toi0Do1KboqKivD19a1V7uPjQ0FBwUkHJSIdXHXLzY5S5xo3SeFNl9zM2z6Posoiuod258ykM5vsuCLSejQquRk4cCDz5s2rVf7+++/Tr1+/kw5KRDq46uRmc1F1chPh3ySHLaks4V+bnffGu2ngTbpBpkg71ajZUg8//DCXXnopu3fv5qyzzgJg6dKl/Oc//+HDDz9s0gBFpIMpK4CKQgC2FDnXtmmqlpsPd3xIbnkuScFJnN/1/CY5poi0Po1KbiZOnMgnn3zCrFmzmD9/Pv7+/gwaNIgvv/ySsWPHNnWMItKRVLfa2G2hlJb5EWTzJizA56QPW24vZ+7muYBzhpS3tXnuMC4intfof90XXnghF154YVPGIiICBfsBKPWLg3znTKmmGPT7v93/I6s0i9iAWCZ2m3jSxxOR1qtRHc5r1qxh1apVtcpXrVrF2rVrTzooEenAqltu8nyiAUgKP/nxNnaH3dVqc12/6/DxOvmWIBFpvRqV3EybNo19+/bVKj9w4ADTpk076aBEpAOrTm4yiQSaZo2b5fuWk1qQSrBvMJf3uvykjycirVujkpstW7Zw6qmn1io/5ZRT2LJly0kHJSIdWPUaN/vszjVuTrblxhjjukHmVb2vItCn6W/AKSKtS6OSG5vNRkZGRq3yQ4cO4e2tQXoichKqW252l4cCJ99ysz5zPT9n/Yyv1Zdr+l5z0uGJSOvXqOTm3HPP5f777yc/P99VlpeXxwMPPMA555zTZMGJSAdUndxsK3aucXOyqxPXjLX5dY9fE+UfdVLHEpG2oVHNLM8++yxnnHEGXbp04ZRTTgFgw4YNxMbG8s477zRpgCLSwVTfNHN3hbPlptNJrHGTkp/C1/u+BuD6fteffGwi0iY0KrlJTEzk559/5t133+Wnn37C39+fKVOmcPXVV+Pjo1kIItJI5YVQ7mwRTjcRRAXZ8Pf1avTh3t78NgbDmZ3OpGto16aKUkRauUYPkAkMDGTMmDF07tyZiooKAD777DMAfv3rXzdNdCLSsRQcAqDSO4hi/Ol1ErddyCzJ5NPdnwJw48AbmyQ8EWkbGpXc7Nmzh0suuYSNGzdisVgwxrgtsmW325ssQBHpQKpnShXaYqHo5MbbvLPlHSodlZwacyqnxJzSVBGKSBvQqAHFd9xxB127diUzM5OAgAA2bdrE119/zbBhw1i+fHkThygiHUb1YOIsq3ONm06NnAZeUFHAB9s/AJw3yBSRjqVRLTcrV65k2bJlREVFYbVa8fLyYsyYMcyePZvbb7+dH3/8sanjFJGOoDq5STfO5CYxrHEtNx9s/4CSqhJ6hPXg9MTTmyw8EWkbGtVyY7fbCQ52TtOMiori4EHnD6QuXbqwffv2potORDqW6vtK7a0MAyCxES03lfZK3tv6HgBTBkxpkvtSiUjb0qjkZsCAAfz0008AjBgxgmeeeYYVK1bw+OOP061btxM+3ssvv0xycjJ+fn6MGDGC1atXN2i/999/H4vFwsUXX3zC5xSRVqi65WZXWQgAiWF+J3yIxamLOVx6mGj/aM5PPr9JwxORtqFRyc1DDz2Ew+EA4PHHHyclJYXTTz+dRYsW8de//vWEjjVv3jxmzJjBzJkzWb9+PYMHD2bChAlkZmYec7/U1FTuvvtuTj9dTc4i7UZ1cpNa3XKTEHbiLTf/2fYfAK7qc5VukCnSQTUquZkwYQKXXnopAD169GDbtm1kZWWRmZnJWWeddULHev7557nllluYMmUK/fr145VXXiEgIIA333yz3n3sdjvXXnstjz32WKNaikSklaqeLXXIRBAR6EuA74kNC9yUtYmNWRvxsfroBpkiHVijkpu6REREnHDfdkVFBevWrWP8+PG/BGS1Mn78eFauXFnvfo8//jgxMTHcdNPxZ0GUl5dTUFDg9hCRVqiiBEpzAThkIkloRJdUTavNhOQJRPhFNGl4ItJ2NFly0xhZWVnY7XZiY2PdymNjY0lPT69zn++++4433niD1157rUHnmD17NqGhoa5HUlLSScctIs2gsHoBP68ACvEn8QS7pHLLclmcshhwdkmJSMfl0eTmRBUWFnLdddfx2muvERXVsBvg1dzgs+axb9++Zo5SRBqluksq3ycasJzwNPCPd31MhaOCvhF9GRQ1qBkCFJG2otG3X2gKUVFReHl5kZGR4VaekZFBXFxcrfq7d+8mNTWViRMnuspqBjZ7e3uzfft2unfv7raPzWbDZrM1Q/Qi0qSqb5h52Or8w+VEuqXsDrtr0b6r+1yt6d8iHZxHW258fX0ZOnQoS5cudZU5HA6WLl3KyJEja9Xv06cPGzduZMOGDa7Hr3/9a8aNG8eGDRvU5STSllW33By0hwMntjrxtwe+5UDRAUJtoZzfVdO/RTo6j7bcAMyYMYPJkyczbNgwhg8fzpw5cyguLmbKlCkAXH/99SQmJjJ79mz8/PwYMGCA2/5hYWEAtcpFpI05ahr4iXRLvb/tfQAu6XEJft4nPhBZRNoXjyc3kyZN4vDhwzzyyCOkp6czZMgQFi9e7BpknJaWhtXapoYGiUhjVCc3u8tDgYZ3S6UVpLHi4AosWLiy95XNFp6ItB0eT24Apk+fzvTp0+vcdrwbcc6dO7fpAxKRllfTLWUi8POxEhHo26DdPt39KQCjEkaRFKyuaRFpY7OlRKQdO+KmmYlh/g0aFOwwDv63538A/Lr7r5s1PBFpO5TciIjnVZZBSRbgXJ24obdd+DHzRw4UHSDQJ5Bxncc1Z4Qi0oYouRERzyt0ttpUWm3kE9jgmVL/3f1fAM7pcg7+3id+HyoRaZ+U3IiI51V3SeV51yzgd/xEpayqjC9SvwDUJSUi7pTciIjnVSc3mUQCDbsb+PL9yymsLCQ+MJ6hsUObNTwRaVuU3IiI51XPlNrvcC7g15CWm//tdg4kvqjbRVgt+lEmIr/QTwQR8bzqlps95WEAJB5nzE12aTbfHfgOgIu6X9SsoYlI26PkRkQ8r/q+Ugcc4VgtEBty7AX8luxdgt3Y6R/Zn26h3VoiQhFpQ5TciIjnVXdLHTIRxIb44eN17B9N3x74FoDxXcY3e2gi0vYouRERzztqAb9jKbeXs/rQagBOTzy92UMTkbZHyY2IeFZVBRRnAs6Wm+ONt1mXsY4yexnR/tH0Cu/VEhGKSBuj5EZEPKvwEACVFl9yCD5uy03NQOLRiaMbdIsGEel4lNyIiGdVd0nlekUBluO23NQkN2MSxzR3ZCLSRim5ERHPqh5MnG4igGMv4Heg6AAp+Sl4WbwYmTCyRcITkbZHyY2IeFZ1cpNmDwOg0zGSm+/2O1ttBkcPJsQ3pNlDE5G2ScmNiHhWdbfUvirn6sTHarlRl5SINISSGxHxrCPWuAkL8CHQ5l1ntQp7BavSVwHOwcQiIvVRciMinuVa4ybimDOlfjr8E6VVpUT4RdAnok9LRScibZCSGxHxrOrk5tBxFvBbeXAlACMTRupGmSJyTPoJISKeU1UBhemAM7k51nibHw79AMCv4n/VIqGJSNul5EZEPKfgAGCosPiSRQid6lnjpqiiiM3ZmwElNyJyfEpuRMRz8vcBcNgaDVjq7ZbamLURh3GQGJRIXGBcCwYoIm2RkhsR8Zw8Z3Kz3xEF1D8N/KfDPwEwKHpQy8QlIm2akhsR8ZzqlpuUKufqxPXdemHD4Q2Ac/E+EZHjUXIjIp5zRMuNn4+VyEDfWlUcxsHPh38GYEjMkJaMTkTaKCU3IuI5+WkAHDBRJIT513mX79T8VAorCvHz8qNXeK+WjlBE2iAlNyLiOdUtNwdNVL2DiWvG2/SP6o+P1afFQhORtkvJjYh4hsPhuvXCAepPbjTeRkROlJIbEfGM4kywV+DASroJr7/lJtPZcjMkekgLBicibZmSGxHxjOouqRyvSKrwrnMaeEFFAbvzdwOaBi4iDafkRkQ8I28v4BxvA3VPA994eCMAScFJRPpHtlxsItKmKbkREc+oTm52V0UD1NktpfE2ItIYSm5ExDNyUwFItUdjtUBcqF+tKhpvIyKNoeRGRDyjOrnZZ6KJDfHDx8v9x5HDONiY5eyWGhyjlhsRaTglNyLiGbnObqk0E1Nnl9TuvN0UVRbh7+1Pj7AeLR2diLRhSm5EpOXZqyB/PwD7TEydg4k3ZW0CYEDUALyt3i0anoi0bUpuRKTlFewHY6fS4ksmYXSJCKhVpaZLakDkgJaOTkTaOCU3ItLyqsfbZHrFYrDSOTKwVpUjW25ERE6EkhsRaXk1420czmngnY9quSmrKmNH7g4ABkYNbNnYRKTNU3IjIi2vuuVmZ6VzAb8uke7Jzfbc7diNnQi/COIC41o6OhFp45TciEjLq05u0hzR2LytxATb3DZvztoMQP/I/lgslpaOTkTaOCU3ItLyqlcn3mdi6BwRUCuB2ZxdndxE9W/x0ESk7VNyIyIt74gF/I7ukgLYkr0FgH4R/VoyKhFpJ5TciEjLKi+EkmygpuXGfaZUSWUJe/L3AGq5EZHGUXIjIi2reqZUkTWEQgLoHOG+gN/23O04jINo/2hiAmI8EaGItHFKbkSkZVWPtzloiQWgy1Fr3NR0SfWPVKuNiDSOkhsRaVnV4212VzmngScdtcZNzUypfpEabyMijaPkRkRaVk4KAKn2KCwWSDqqW0ozpUTkZCm5EZGWlb0TgD0mnvgQP2zeXq5NxZXFpOQ7kx+13IhIYym5EZGWleVMbnY7EugWHeS2aVvONgyG2IBYovyjPBGdiLQDSm5EpOWUF0HBAQB2mwR6xLgnNxpvIyJNQcmNiLSc7F0AFFjDyCeI7tHuM6Vc4200U0pEToKSGxFpOdVdUikkAND9qG4p1zRwDSYWkZOg5EZEWk71YOJtlc41brof0S1VVFFEakEqoG4pETk5Sm5EpOVk7QBgpyOBIJu3293At+ZsBSA+MJ4IvwiPhCci7YOSGxFpOVnOMTd7TDzdowPd7gZeM5hY421E5GQpuRGRllFV4Wq52WUS3bqkQONtRKTptIrk5uWXXyY5ORk/Pz9GjBjB6tWr66372muvcfrppxMeHk54eDjjx48/Zn0RaSUObwV7OSXWINJMTK1p4D9n/Qyo5UZETp7Hk5t58+YxY8YMZs6cyfr16xk8eDATJkwgMzOzzvrLly/n6quv5quvvmLlypUkJSVx7rnncuDAgRaOXEROyMEfAdhq6QZY6Bsf4tqUU5bDgSLnv+EBUQM8EZ2ItCMeT26ef/55brnlFqZMmUK/fv145ZVXCAgI4M0336yz/rvvvsvUqVMZMmQIffr04fXXX8fhcLB06dIWjlxETsjBDQCsKe8CQP8jkptNWZsA6BralWDf4BYPTUTaF48mNxUVFaxbt47x48e7yqxWK+PHj2flypUNOkZJSQmVlZVERGh2hUirVt1y87OjK5GBvkQfMVPq58POLqmBUQM9EpqItC/enjx5VlYWdrud2NhYt/LY2Fi2bdvWoGPce++9JCQkuCVIRyovL6e8vNz1vqCgoPEBi0jjVJVDhnM21M+mG33jQ9xmSm3M2gjAoKhBHglPRNoXj3dLnYynnnqK999/n48//hg/P78668yePZvQ0FDXIykpqYWjFBEyNoOjkhKvYPabaPol/NIl5TAOV3IzIFrjbUTk5Hk0uYmKisLLy4uMjAy38oyMDOLi4o6577PPPstTTz3FF198waBB9f+1d//995Ofn+967Nu3r0liF5ETsG8VANu9euMcTPzLuJq9BXsprCjE5mWjV3gvDwUoIu2JR5MbX19fhg4d6jYYuGZw8MiRI+vd75lnnuGJJ55g8eLFDBs27JjnsNlshISEuD1EpIWlfgfA8rKeAPSLD3VtqhlM3DeiLz5Wn5aPTUTaHY+OuQGYMWMGkydPZtiwYQwfPpw5c+ZQXFzMlClTALj++utJTExk9uzZADz99NM88sgjvPfeeyQnJ5Oeng5AUFAQQUFB9Z5HRDzEGNj7PQDfVvYm2ObttsaNazBxtAYTi0jT8HhyM2nSJA4fPswjjzxCeno6Q4YMYfHixa5BxmlpaVitvzQw/eMf/6CiooLLL7/c7TgzZ87k0UcfbcnQRaQhDm+H0hyqrH5sNN34VecwvKy1BxNrppSINBWPJzcA06dPZ/r06XVuW758udv71NTU5g9IRJrOXmeX1G6/flSWeDOsyy/LNpTby9meux1QciMiTadNz5YSkTYg5RsAvqnoDcDQLuGuTdtytlHlqCLCL4LEoESPhCci7Y+SGxFpPlUVsGsZAP8t7ofVAkM6h7k2bzz8S5fUkeveiIicDCU3ItJ89q6AikLKbFFsNF3pGx9CkO2X3vCam2XqflIi0pSU3IhI89nxOQA/+Y/AYGV0jyi3zTUzpbQysYg0JSU3ItI8jIEdnwGwoMjZMjPmiOTmYNFBDhQdwMvixeCYwR4JUUTaJyU3ItI8snZAbioOLxv/LeqNr7eV4V1/mSm1Jn0NAP0j+xPoE+ipKEWkHVJyIyLNY8unAOwLOZUS/BjdPRI/Hy/X5prk5rS40zwSnoi0X0puRKTpORzw4zsAfFjuvJXK+QPi3aoouRGR5qLkRkSaXuq3kLcXh28wr+cMxMtqYXy/WNfmA0UHOFh8EG+LN6fEnOLBQEWkPVJyIyJN78d/A7A18lzKsDGiawQRgb6uzasPrQacU8ADfAI8EqKItF9KbkSkaZXmwVbneJu/5v4KgF8PTnCrsjZjLaAuKRFpHkpuRKRpbfwQqsooDuvN53kJBNm8mXhEcmOMYXW6s+VGyY2INAclNyLSdBx2WP0qAJ95jwcsXHxKAoFHrEqcWpBKenE63lZvBkdrfRsRaXpKbkSk6Wz9FLJ24PAL488HTwXgmuFd3KosS3Pea2pE3AiNtxGRZqHkRkSahsMB3zwLwA9Rl5Pn8GdIUhj9EkLcqi3b50xuzup8VouHKCIdg5IbEWkam+ZDxiaMbxB/2jcKgNvGdnOrkl6c7rqf1JlJZ7Z0hCLSQSi5EZGTV1kGSx8HYGX89Rwo96NnTBDn9otzq/Z5qvNGmqfGnEpMQEyLhykiHYOSGxE5ectnQ/4+7EEJ/CHFOf17+lk9sFotbtU+S3HeSPP8rue3eIgi0nEouRGRk7NtIax4EYB/h08lu8KbwUlhTBzkvrbN9pztbM7ejLfFm3O6nOOJSEWkg1ByIyKNt38dzL8JMGT1u55HdznH2Myc2K9Wq838HfMBGNd5HJH+kS0dqYh0IEpuRKRxclLgvSuhqhR793P47f5LMAYuHpLAqZ3D3aqWVpXyvz3/A+CKXld4IloR6UCU3IjIiSvJgXcvh5IsiB/MM8H3sS2zlKggGw9f1K9W9cUpiymqLKJTUCdGxI/wQMAi0pEouRGRE1Oc7UxssndBaBLfnvYy//whA4C/XD6IyCCbW3VjDO9tew+Ay3pdhtWiHzsi0ry8j19FRKRabir8+zJnYuMXRtr5c/n9fw4CMHlkF8b1qT29+6t9X7EtZxsB3gFc3vPyFg5YRDoi/QklIg2z80t4fbyrxSbtkk+4YkEeReVVDO8awYMX1u6OchgHr/z0CgDX9L2GML+wFg5aRDoitdyIyLFVlMCXM103xCR2ICnnvcWV7+3lcGE5vWOD+ce1p+LrXftvpXnb57E1ZysB3gFc3+/6Fg5cRDoqJTciUjdjYPtnzsQma4ezbMTvWdl1Or9/Zwt5JZX0iQvm3ZtH1BpnA7C/cD8vrHsBgDuH3km4X3itOiIizUHJjYi4MwZ2fgFfzYJDG5xlQXGYi//OW+ndePJfP2N3GAZ3CuWtKcOJCPStdYhKRyUPr3iY0qpShsYOZVLvSS37GUSkQ1NyIyJOlWWw5RP44e9w6CdnmU8gjPgdGQNv5eHPD/DFli0AXHpKIrMuHYifj1etwziMgyd/eJK1GWvx9/bnsVGPaYaUiLQoJTciHVlZPuxcAlv/C7u+hIoiZ7lPAAy/haJhU3l1bQGv/e0nSivteFst3Hd+H24a0xWLxVLrcFWOKh5e8TD/2/M/LFiYffpsuoR0aeEPJSIdnZIbkY7EYYfMrbB3BexYDCnfgqPyl+0hnWDYFDJ6Xc38raW89fImsorKATi1cxhPXjKQvvEhdR66rKqMe7+5l2X7luFt8ebJMU9yduezW+JTiYi4UXIj0l45HJCXChmbYf9aOLAODqyHymL3elG9oc+FVPW+kC/zEvlg3X6Wf7YBh3FuTo4M4J7z+nD+gLg6W2sAVh9azRM/PEFqQSq+Vl+eP/N5xiaNbd7PJyJSDyU3Iu1BcRZkbIKMLZC52ZnQZG6DqtLadX2DIfFU6DGe3KSz+TY3nBU7s1j6dgZZRRmuaqclhzPptM78enBCndO8Afbk7eH5dc/z9f6vAYj2j+bpM57mtLjTmuVjiog0hJIbkbaioth5s8qcPZCz27mYXnb1c/HhuvfxskFUL0g8hfK4oaTY+rKxPJYtGcWsWpvDlv+mAqmu6lFBNi4bmsiVw5LoHh1UbyhZpVn8fcPfWbBzAXZjx8vixRW9ruAPp/6BEN+6u61ERFqKkhuR1sIYKMqEvDTI2wu5KUckMylQlH6MnS0Q0RVi+mGP7keGfze2OjqzoSiMrRml7NhWSNr3JUBW9eMXfeKCGdMjijE9oxjdIwofr/pnNh0qOsSCXQt4e/PblFa3Co1LGsddQ++ia2jXk78GIiJNQMmNSEsxxtnCkpfmvEdTXpr7I38fVJUd+xj+ERDRDSK6UR7alcO+SeyzxvNzWSybD1ex/VAhezYWUWk3QF714xdRQTZ6xwXRKzaYwZ3CGN0jiujg2gvwHSmzJJOlaUtZnLKY9ZnrXeUDIgfwx2F/ZFjcsMZcDRGRZqPkRqSpHJm85O2tnbzkpR0/ecECIYkQ1pnKkCTy/DuT7hVPqiOW7RVR7Cz0Zn9uKfs3lZJfWjPLqRxIcztKkM2bXrFB9I4LpndsML2qn+taSfholfZKNhzewLcHvmXFgRXsyN1xRHQW16J85yafq/VrRKRVUnIj0lDGOAfu1kpeal7vq3sAr5tfkpeqkE7k2+LJ9IplnyOKXRWRbC0JIjW3iv37S8gtqTxq3+xaR4sI9KVTuD/do52tMb3jgugdF0JCqF+9M5uOVFRRxN7CvezI2cHm7M3sztvNluwtlFSVHBGxhYHRA5nQZQLnJp9LXGBcAy6WiIjnKLkRqVFv8nJky0tDkpcETFhnKoM7UeiXwGGvWPaZaHZVRLC1JJi9eVUcOFhC1o6Ko/Ytr378IizAh07h/nQKCyApwp9O4QF0CvcnKSKAxDB/Am3H/ydcVFFEWmEaaQVppBWmsbdgr+t1TllOnftE+EUwOmE0oxNHMyphlO4LJSJtipIb6Thquo3y9zlbWfL2Qu7eE255MSEJVAV3osg/gVyfeDKs0ex1RLO7MoJtJSEcKLCTnlpGSYX9qH1rJy/BNm86RQSQFO6euHQK96dTuD/Bfj4N+FiG/PJ8DhYfPKEEpkakXyRdQ7syIGoAvcJ70TO8J73Ce6nLSUTaLCU30n5UlkLhIcjf73zk7XMmMjXJTMGB4455MVhwBMVRGpBAns3Z6nLARLPHHsn20nA2FQVzMNtOZaap5wgFbu9C/X2ID/WrTlYC3J6TIgII9T928lJhryCzJNP1yCjJ4HDJYdfrzJJMDpceptxefszjRPpF0jmkM52DOzufa14HdybIt/4p3yIibZGSG2kbKsucyUle2i/JS8EBZzJTcAgKD0Jp7nEPY7BQERBLkS2ObJ9YDlliSbVHsaMiks0lYWwpDqai7Fj/LKoAsFggOshGXKgfcSF+xIf6ERvqfI4L8XeV+/vWvrEkOFtb8srz2J5Td8JS88gtP/5nqhHhF0GXkC4kBSfRJaSLEhgR6bCU3IjnGQMl2c5kJf+Ae2tL/j5nInPEyrnHYvfyo9gvjlyfWDIsUexzRLGnIpytpaHsKA8nw0RQeczkBXy8LMTWJCzVz3Gh/sSF+BFXncBEB9tqrQdjd9jJK88jrzyPrLIcNu/P4EDhAfLK88gvzye/Ip+88jyyS7M5XHKYCsfRY27q5mv1JSYghpiAGGIDYokJiCE6INr1uubh6+XboOOJiLR3Sm6k+TnsUJh+1ODcIwbsFhwA+/F/0Vd5+VPkF0+Odwzplmj228NIrQhjR0kQaVVhpJtwCgiE4vpnCQX4epHk1sJiIy7Un/jqxCUu1I+IAF+sVgsO4yC3LJfssmyyS9PJLctlW0ku3+fkkFuWS25ZLjllOeSWO1/nl+djqK+7qm4RfhFuCUqMf4zb+9iAWEJtoQ2a+SQiIk5KbuTkORzO1XPrSlxqBuo6jp7WXFuJbyR53tFkWKLZ74hkd0U428vC2eeI4ICJIpfgYyYu4QE+9A31Jy6kOmGp7hqqaW2JDfXD3wdn60lZNlmlWRwu2UNWaRarCjLJzswmvzzflazkluViN0cPCj6+UFso4bZwovyj6BTciQi/CMJsYYTaQgm1hboSmmj/aLW2iIg0AyU30jBlBdX3M9p9xOq6e38ZA3OclhcHXuT5xpBhjWW/iWJ3ZSQ7ysLZb6I5SBQZJrze7iKrBWJC/Bgc6ufWwuLsHvIhwK8Mq08RhZXO1pOiykMUVBSQXZrN2pJssnOyySnLIbs0m7zyvBNuXQmzhRHpF0m4XzjhfuFE+EW4P9siXNvCbGF4W/XPSkTEk/RTWJwqSpxJS84e5z2Nalpc8vc7x72U5R1zdzteZHtFc4BoUu2RpFRGsd9Esd9Es99Ek0E49rLag2t9vazEhfpxyhEtLJHBXgQHlOJrK8bqU0SlKSCv4gC5ZbkUVBSQUZbD5oIsDqcfJrc8F4dxnNBHtVqshNnCiPKPIto/2vkc4HwOtzkTlHC/cCL9nQmNj/X407FFRKT1UHLTkZTl/3IjxtwjbsiYk+KcbXQcedZwUk0cu6qi2edwJi37jkxecE9egm3exIb60T3Uj1HBNsJDKvH3L8LX15m0OCwFFNtzyS7NJqssi9TSLNblZ1NwuKCeCOpmwUK4n7MbKMwWRpBPEMG+wUT6RxLhF0GkfySRfpGu5zBbGF7WumcxiYhI26fkpr2xVzkTl8PbIWs7HN7h7E7K2eOckXQMRZZA9po49tij2WdiOGCiOGAiOWCiOWgiKcbfVdfXy0p8uB8JYTaGhVYSGlSGv38Jvr4lGK9CqiggvzKHjOIMMkoy2FKcQUVGw2YHAXhbvV0JSZR/lDMp8QsjzBbm1uoSHRCtriAREXGj3whtlcMBeamQvhEytsDhrZC5zZnEHGPwbpYJJdXEstfEkupwPu81saSaOPKpWQvFEOxnJyaigoiQcpICSunhvx8v7yLs1gLKTR4FFTlklWaxpTwXR6kDjrewb7UIvwii/KNcj0j/SKL8jnrvH0WIb4hmCImISKMouWkLirPg0E+Q/nN1i8wOzOEdWCoK66xeYmzsNvHsNJ3Y5Uhgj0kgzcSw18RQ4mXH4lVKWHAlESEVBAUW4WNLp4fXVirIo9SeS35FDmX2MjKBTHAmLsdIXqwWKxF+Ec4uoOrWlpokJjYgltjAWNeaLJodJCIizU3JTWtTmgv718GBtXDoZ8yhDVgKDtSqZgHKjQ/bTSe2OTqzzSSyzRLDbq8gsn0MvrZCQoNLsPkXYPHeQiXf4WPPIcg4V9itBDKADAf1Ji6BPoFE+0e7WlPqe4TbwjWGRUREWg0lN57kcEDWDti/GvatpmrvKrxzdrhVqemY2e2IY60liQ3WGPZ4B7PPy5dcXwcBQfl423KptKyn0pQAuEbGFFU/qu8YUH08C8G+wc61WPzCiQuIIy4wjvjAeGIDY13JTKRfJAE+Ac18AURERJqekpuWZK+CfT/A3u+p2vsD7F+Dd8UvM4MMsN/bix+t0az1jmerdyAHvL0ospWDLReHJQNne4uTN1BR/ahZuiXCL4LYgFhXwhIXGOd6xAfGE+UfpcG3IiLSrum3XHOzV8He76j4eQFs/S8+5Tlke1lJ8fEhxebDrsBINvqEkObjRYFPxS9NNWRXP9xF+kW67i2UFJzkeiQGJZIQlIC/t3+tfURERDoSJTfNxOxdyeEVc8nYt4TdXmVs8fVlS4Qvu3w7UWy1HlXbXv0Am5fN1fJy5N2duwR3oVNwJ/y8/Vr8s4iIiLQlSm6aWOaulXyz+F42mX18HeBPVlwgEOhWx4KV+MAEuod1pWtoV5JDk+ka4nyO9IvUFGgREZGToOSmiWzN3srsRXezrSqV0mArVK8Z4218SAjoxanxg/hV4mB6hfeiS0gXTYkWERFpJkf3j3jEyy+/THJyMn5+fowYMYLVq1cfs/6HH35Inz598PPzY+DAgSxatKiFIq3fijXf86MjjVKrlTC7lV+FnMmLY//O6utWsfDK93ni9Ae4sNuF9AzvqcRGRESkGXk8uZk3bx4zZsxg5syZrF+/nsGDBzNhwgQyMzPrrP/9999z9dVXc9NNN/Hjjz9y8cUXc/HFF7Np06YWjtzdpK5duTGvgmeL4lk+eR2vXfISZyWfjo+XbrooIiLSkizGGOPJAEaMGMFpp53G3/72NwAcDgdJSUn84Q9/4L777qtVf9KkSRQXF/O///3PVfarX/2KIUOG8Morrxz3fAUFBYSGhpKfn09ISEjTfRCgvDAbm9VAYFSTHldERKSjO5Hf3x5tuamoqGDdunWMHz/eVWa1Whk/fjwrV66sc5+VK1e61QeYMGFCvfXLy8spKChwezQXW3CkEhsREREP82hyk5WVhd1uJzY21q08NjaW9PT0OvdJT08/ofqzZ88mNDTU9UhKSmqa4EVERKRV8viYm+Z2//33k5+f73rs27fP0yGJiIhIM/LoVPCoqCi8vLzIyMhwK8/IyCAuLq7OfeLi4k6ovs1mw2azNU3AIiIi0up5tOXG19eXoUOHsnTpUleZw+Fg6dKljBw5ss59Ro4c6VYfYMmSJfXWFxERkY7F44v4zZgxg8mTJzNs2DCGDx/OnDlzKC4uZsqUKQBcf/31JCYmMnv2bADuuOMOxo4dy3PPPceFF17I+++/z9q1a3n11Vc9+TFERESklfB4cjNp0iQOHz7MI488Qnp6OkOGDGHx4sWuQcNpaWlYj7gX06hRo3jvvfd46KGHeOCBB+jZsyeffPIJAwYM8NRHEBERkVbE4+vctLTmXOdGREREmkebWedGREREpKkpuREREZF2RcmNiIiItCtKbkRERKRdUXIjIiIi7YqSGxEREWlXPL7OTUurmfnenHcHFxERkaZV83u7ISvYdLjkprCwEEB3BxcREWmDCgsLCQ0NPWadDreIn8Ph4ODBgwQHB2OxWJr02AUFBSQlJbFv3z4tENiMdJ1bhq5zy9B1bjm61i2jua6zMYbCwkISEhLc7lxQlw7XcmO1WunUqVOzniMkJET/cFqArnPL0HVuGbrOLUfXumU0x3U+XotNDQ0oFhERkXZFyY2IiIi0K0pumpDNZmPmzJnYbDZPh9Ku6Tq3DF3nlqHr3HJ0rVtGa7jOHW5AsYiIiLRvarkRERGRdkXJjYiIiLQrSm5ERESkXVFyIyIiIu2KkpsT9PLLL5OcnIyfnx8jRoxg9erVx6z/4Ycf0qdPH/z8/Bg4cCCLFi1qoUjbthO5zq+99hqnn3464eHhhIeHM378+ON+XcTpRL+fa7z//vtYLBYuvvji5g2wnTjR65yXl8e0adOIj4/HZrPRq1cv/exogBO9znPmzKF37974+/uTlJTEXXfdRVlZWQtF2zZ98803TJw4kYSEBCwWC5988slx91m+fDmnnnoqNpuNHj16MHfu3GaPEyMN9v777xtfX1/z5ptvms2bN5tbbrnFhIWFmYyMjDrrr1ixwnh5eZlnnnnGbNmyxTz00EPGx8fHbNy4sYUjb1tO9Dpfc8015uWXXzY//vij2bp1q7nhhhtMaGio2b9/fwtH3rac6HWukZKSYhITE83pp59ufvOb37RMsG3YiV7n8vJyM2zYMHPBBReY7777zqSkpJjly5ebDRs2tHDkbcuJXud3333X2Gw28+6775qUlBTz+eefm/j4eHPXXXe1cORty6JFi8yDDz5oFixYYADz8ccfH7P+nj17TEBAgJkxY4bZsmWLeemll4yXl5dZvHhxs8ap5OYEDB8+3EybNs313m63m4SEBDN79uw661955ZXmwgsvdCsbMWKE+d3vftescbZ1J3qdj1ZVVWWCg4PN22+/3VwhtguNuc5VVVVm1KhR5vXXXzeTJ09WctMAJ3qd//GPf5hu3bqZioqKlgqxXTjR6zxt2jRz1llnuZXNmDHDjB49ulnjbE8aktzcc889pn///m5lkyZNMhMmTGjGyIxRt1QDVVRUsG7dOsaPH+8qs1qtjB8/npUrV9a5z8qVK93qA0yYMKHe+tK463y0kpISKisriYiIaK4w27zGXufHH3+cmJgYbrrpppYIs81rzHX+9NNPGTlyJNOmTSM2NpYBAwYwa9Ys7HZ7S4Xd5jTmOo8aNYp169a5uq727NnDokWLuOCCC1ok5o7CU78HO9yNMxsrKysLu91ObGysW3lsbCzbtm2rc5/09PQ666enpzdbnG1dY67z0e69914SEhJq/YOSXzTmOn/33Xe88cYbbNiwoQUibB8ac5337NnDsmXLuPbaa1m0aBG7du1i6tSpVFZWMnPmzJYIu81pzHW+5ppryMrKYsyYMRhjqKqq4rbbbuOBBx5oiZA7jPp+DxYUFFBaWoq/v3+znFctN9KuPPXUU7z//vt8/PHH+Pn5eTqcdqOwsJDrrruO1157jaioKE+H0645HA5iYmJ49dVXGTp0KJMmTeLBBx/klVde8XRo7cry5cuZNWsWf//731m/fj0LFixg4cKFPPHEE54OTZqAWm4aKCoqCi8vLzIyMtzKMzIyiIuLq3OfuLi4E6ovjbvONZ599lmeeuopvvzySwYNGtScYbZ5J3qdd+/eTWpqKhMnTnSVORwOALy9vdm+fTvdu3dv3qDboMZ8P8fHx+Pj44OXl5errG/fvqSnp1NRUYGvr2+zxtwWNeY6P/zww1x33XXcfPPNAAwcOJDi4mJuvfVWHnzwQaxW/e3fFOr7PRgSEtJsrTaglpsG8/X1ZejQoSxdutRV5nA4WLp0KSNHjqxzn5EjR7rVB1iyZEm99aVx1xngmWee4YknnmDx4sUMGzasJUJt0070Ovfp04eNGzeyYcMG1+PXv/4148aNY8OGDSQlJbVk+G1GY76fR48eza5du1zJI8COHTuIj49XYlOPxlznkpKSWglMTUJpdMvFJuOx34PNOly5nXn//feNzWYzc+fONVu2bDG33nqrCQsLM+np6cYYY6677jpz3333ueqvWLHCeHt7m2effdZs3brVzJw5U1PBG+BEr/NTTz1lfH19zfz5882hQ4dcj8LCQk99hDbhRK/z0TRbqmFO9DqnpaWZ4OBgM336dLN9+3bzv//9z8TExJg///nPnvoIbcKJXueZM2ea4OBg85///Mfs2bPHfPHFF6Z79+7myiuv9NRHaBMKCwvNjz/+aH788UcDmOeff978+OOPZu/evcYYY+677z5z3XXXuerXTAX/05/+ZLZu3WpefvllTQVvjV566SXTuXNn4+vra4YPH25++OEH17axY8eayZMnu9X/4IMPTK9evYyvr6/p37+/WbhwYQtH3DadyHXu0qWLAWo9Zs6c2fKBtzEn+v18JCU3DXei1/n77783I0aMMDabzXTr1s08+eSTpqqqqoWjbntO5DpXVlaaRx991HTv3t34+fmZpKQkM3XqVJObm9vygbchX331VZ0/b2uu7eTJk83YsWNr7TNkyBDj6+trunXrZt56661mj9NijNrfREREpP3QmBsRERFpV5TciIiISLui5EZERETaFSU3IiIi0q4ouREREZF2RcmNiIiItCtKbkRERKRdUXIj0sakpqZisVha5O7cc+fOJSwszK3s1VdfJSkpCavVypw5c3j00UcZMmRIs8eSnJzMnDlzmv08rencFouFTz755KSOceaZZ3LnnXces44nr61Ic1ByIyL1mjRpEjt27HC9LygoYPr06dx7770cOHCAW2+9lbvvvrvWvWNORl0JFcCaNWu49dZbm+w8J3JuEWlbdFdwEamXv7+/251709LSqKys5MILLyQ+Pt5VHhQU1OyxREdHN/s5mlJlZSU+Pj6eDkOkQ1LLjUgr5HA4eOaZZ+jRowc2m43OnTvz5JNP1lnXbrdz00030bVrV/z9/enduzcvvviiW53ly5czfPhwAgMDCQsLY/To0ezduxeAn376iXHjxhEcHExISAhDhw5l7dq1gHtLxty5cxk4cCAA3bp1w2KxkJqaWme31Jtvvkn//v2x2WzEx8czffp017bnn3+egQMHEhgYSFJSElOnTqWoqMgV55QpU8jPz8disWCxWHj00UeB2l0naWlp/OY3vyEoKIiQkBCuvPJKMjIyXNtr4nrnnXdITk4mNDSUq666isLCwjqv47HODc67SN94440EBwfTuXNnXn31Vde2mq7CefPmMXbsWPz8/Hj33XcBeP311+nbty9+fn706dOHv//97679KioqmD59OvHx8fj5+dGlSxdmz57tFldWVhaXXHIJAQEB9OzZk08//dRt+9dff83w4cNd1/q+++6jqqqqzs8IkJmZycSJE/H396dr166uOEXalWa/e5WInLB77rnHhIeHm7lz55pdu3aZb7/91rz22mvGGGNSUlIMYH788UdjjDEVFRXmkUceMWvWrDF79uwx//73v01AQICZN2+eMcZ5g8DQ0FBz9913m127dpktW7aYuXPnuu7i279/f/Pb3/7WbN261ezYscN88MEHZsOGDcYYY9566y0TGhpqjDGmpKTEfPnllwYwq1evNocOHTJVVVVm5syZZvDgwa7Y//73vxs/Pz8zZ84cs337drN69WrzwgsvuLa/8MILZtmyZSYlJcUsXbrU9O7d2/z+9783xhhTXl5u5syZY0JCQmrd3b1Lly6u49jtdjNkyBAzZswYs3btWvPDDz+YoUOHut2wb+bMmSYoKMhceumlZuPGjeabb74xcXFx5oEHHqjzmh/v3BEREebll182O3fuNLNnzzZWq9Vs27bN7WuSnJxsPvroI7Nnzx5z8OBB8+9//9vEx8e7yj766CMTERFh5s6da4wx5i9/+YtJSkoy33zzjUlNTTXffvutee+991wxAaZTp07mvffeMzt37jS33367CQoKMtnZ2cYYY/bv328CAgLM1KlTzdatW83HH39soqKi3G4aO3bsWHPHHXe43p9//vlm8ODBZuXKlWbt2rVm1KhRxt/f3+1rJNLWKbkRaWUKCgqMzWZzJTNHOzq5qcu0adPMZZddZowxJjs72wBm+fLlddYNDg52/bI92pHJjTHG/PjjjwYwKSkprrKjk5uEhATz4IMP1hvb0T788EMTGRlZ7zlrHJncfPHFF8bLy8ukpaW5tm/evNmVeNXEFRAQYAoKClx1/vSnP5kRI0bUG8uxzv3b3/7W9d7hcJiYmBjzj3/8wxjzy9dkzpw5bvt1797dLVkxxpgnnnjCjBw50hhjzB/+8Adz1llnGYfDUWc8gHnooYdc74uKigxgPvvsM2OMMQ888IDp3bu32/4vv/yyCQoKMna73Rjjntxs377d7RoZY8zWrVsNoORG2hV1S4m0Mlu3bqW8vJyzzz67wfu8/PLLDB06lOjoaIKCgnj11VdJS0sDICIightuuIEJEyYwceJEXnzxRQ4dOuTad8aMGdx8882MHz+ep556it27dzc69szMTA4ePHjM2L/88kvOPvtsEhMTCQ4O5rrrriM7O5uSkpIGn2fr1q0kJSWRlJTkKuvXrx9hYWFs3brVVZacnExwcLDrfXx8PJmZmSf4qZwGDRrkem2xWIiLi6t1rGHDhrleFxcXs3v3bm666SaCgoJcjz//+c+ua3zDDTewYcMGevfuze23384XX3xxzPMGBgYSEhLiOu/WrVsZOXIkFovFVWf06NEUFRWxf//+WsfaunUr3t7eDB061FXWp08fDaKWdkfJjUgrc+QA3oZ4//33ufvuu7npppv44osv2LBhA1OmTKGiosJV56233mLlypWMGjWKefPm0atXL3744QfAOTZl8+bNXHjhhSxbtox+/frx8ccfN0vsqampXHTRRQwaNIiPPvqIdevW8fLLLwO4xdtUjh7Qa7FYcDgczXaswMBA1+uacUSvvfYaGzZscD02bdrkuvannnoqKSkpPPHEE5SWlnLllVdy+eWXN9tnEOkolNyItDI9e/bE39+/wdOrV6xYwahRo5g6dSqnnHIKPXr0qLP15ZRTTuH+++/n+++/Z8CAAbz33nuubb169eKuu+7iiy++4NJLL+Wtt95qVOzBwcEkJyfXG/u6detwOBw899xz/OpXv6JXr14cPHjQrY6vry92u/2Y5+nbty/79u1j3759rrItW7aQl5dHv379GhV7Q8/dULGxsSQkJLBnzx569Ojh9ujataurXkhICJMmTeK1115j3rx5fPTRR+Tk5DToHH379mXlypUYY1xlK1asIDg4mE6dOtWq36dPH6qqqli3bp2rbPv27eTl5TX+g4q0QkpuRFoZPz8/7r33Xu655x7+9a9/sXv3bn744QfeeOONOuv37NmTtWvX8vnnn7Njxw4efvhh1qxZ49qekpLC/fffz8qVK9m7dy9ffPEFO3fupG/fvpSWljJ9+nSWL1/O3r17WbFiBWvWrKFv376Njv/RRx/lueee469//Ss7d+5k/fr1vPTSSwD06NGDyspKXnrpJfbs2cM777zDK6+84rZ/cnIyRUVFLF26lKysrDq7q8aPH8/AgQO59tprWb9+PatXr+b6669n7Nixbl1DJ6oh5z4Rjz32GLNnz+avf/0rO3bsYOPGjbz11ls8//zzgHPm2H/+8x+2bdvGjh07+PDDD4mLi2twN9HUqVPZt28ff/jDH9i2bRv/93//x8yZM5kxYwZWa+0f77179+a8887jd7/7HatWrWLdunXcfPPNJ9xaKNLaKbkRaYUefvhh/vjHP/LII4/Qt29fJk2aVO9Ykd/97ndceumlTJo0iREjRpCdnc3UqVNd2wMCAti2bRuXXXYZvXr14tZbb2XatGn87ne/w8vLi+zsbK6//np69erFlVdeyfnnn89jjz3W6NgnT57MnDlz+Pvf/07//v256KKL2LlzJwCDBw/m+eef5+mnn2bAgAG8++67taY+jxo1ittuu41JkyYRHR3NM888U+scFouF//u//yM8PJwzzjiD8ePH061bN+bNm9fouBt67hNx88038/rrr/PWW28xcOBAxo4dy9y5c10tN8HBwTzzzDMMGzaM0047jdTUVBYtWlRnYlKXxMREFi1axOrVqxk8eDC33XYbN910Ew899FC9+7z11lskJCQwduxYLr30Um699VZiYmJO6nOKtDYWc2R7poiIiEgbp5YbERERaVeU3IiIiEi7ouRGRERE2hUlNyIiItKuKLkRERGRdkXJjYiIiLQrSm5ERESkXVFyIyIiIu2KkhsRERFpV5TciIiISLui5EZERETaFSU3IiIi0q78P/PFje5qeC66AAAAAElFTkSuQmCC",
+      "image/png": "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y8spKChwu8mxJScnM2fOHE+XISIi0ihtKtw0xuzZswkNDXXd2usVwc8880zuvPPOJnmv1atXc8sttzTJe4mIiLS0NjUVPC4ujszMTLdtmZmZhISEuGboHO2+++5jxowZruc1VxXtaIwx2O12vL2P/0ceHR3dAhWJiLQRxoBxgMMOjiowdudj43C+VvuA+t+n7hda//4n+t5eNgiOrfu1FtCmws2oUaNYtGiR27bFixczatSoeo+x2WzYbLbmLs2jbrjhBr755hu++eYbnn/+eQBef/11Jk+ezKJFi3jwwQfZsGEDX375JUlJScyYMYMff/yR4uJi+vbty+zZs93GMiUnJ3PnnXe6WoIsFgsvv/wyCxcu5IsvviAxMZFnnnmG3/zmN574uiLSjhljKC8vozjvIOUFB6kszMZRnIOjvAh7RQmmvARTWYKpKMFUlWCvLMFeVYrDXoqxl2E3ldgddhzYcRgHVTic/xk7DhzYLab6scFuceDAYHBUPzc4MDiq78FgMFiq/wI/+q9xc9S8iVqv13p+7IkWxz3+BD/vWJ99/FqP/dm139+dNzFMu+OnYx/UjDwaboqKitixY4freWpqKuvXryciIoLOnTtz3333sW/fPv71r38BcOutt/Liiy/ypz/9iRtvvJGlS5fy3nvvsXDhwmar0RhDaaW92d7/WPx9vBo06+j5559n27ZtDBgwgMceewyATZs2AXDvvffy9NNP061bN8LDw9mzZw8XXHABTzzxBDabjX/9619MmDCBrVu30rlz53o/49FHH+Wpp57ir3/9Ky+88ALXXnstu3fvJiIiomm+rIi0G3aH4VBxOfsL8sg4lMWhQ/vIL9hPSdFBykpzqKw4hKOqAIejCIejGAelGMoxlgqqLFVUWR2UWCyUWi2UWKyUWi2UWyxUWixUYqHSApUWC3arBWw4bydEa281t57lVUzz4Od7NNz89NNPnHXWWa7nNd1HkyZNYv78+Rw4cID09HTX6127dmXhwoXcddddPP/883Tq1IlXXnmlSaeBH6200k6/h5tmHZ0Ttfmx8QT4Hv+PKDQ0FF9fXwICAoiLiwNgy5YtADz22GP8+te/du0bERHB4MGDXc8ff/xxPv74Yz799FOmT59e72fccMMNXH311QDMmjWLv/3tb6xatYrzzjuvUd9NRNoWh3FQUF5A2qFMduRkknoo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3XRTS5TZ5jXmPH/66aeMGjWKadOmERsby4ABA5g1axZ2u72lym5zGnOeR48ezZo1a1xdV7t27WLRokVccMEFLVJzR+Gpvwc73IUzGys7Oxu73U5sbKzb9tjYWLZs2VLnMRkZGXXun5GR0Wx1tnWNOc9Hu+eee0hISKj1P5Qc1pjz/P333/Pqq6+yfv36FqiwfWjMed61axdLly7l2muvZdGiRezYsYOpU6dSWVnJzJkzW6LsNqcx5/maa64hOzub0047DWMMVVVV3Hrrrdx///0tUXKHUd/fgwUFBZSWluLv798sn6uWG2lXnnzySd59910+/vhj/Pz8PF1Ou1FYWMh1113Hyy+/TFRUlKfLadccDgcxMTHMmzePYcOGMXHiRB544AFeeuklT5fWrixbtoxZs2bx97//nbVr1/LRRx+xcOFCHn/8cU+XJk1ALTcNFBUVhZeXF5mZmW7bMzMziYuLq/OYuLi4E9pfGneeazz99NM8+eSTfPXVVwwaNKg5y2zzTvQ879y5k7S0NCZMmODa5nA4APD29mbr1q107969eYtugxrz8xwfH4+Pjw9eXl6ubX379iUjI4OKigp8fX2btea2qDHn+aGHHuK6665jypQpAAwcOJDi4mJuueUWHnjgAaxW/du/KdT392BISEiztdqAWm4azNfXl2HDhrFkyRLXNofDwZIlSxg1alSdx4waNcptf4DFixfXu7807jwDPPXUUzz++ON8/vnnDB8+vCVKbdNO9Dz36dOHDRs2sH79etftN7/5DWeddRbr168nKSmpJctvMxrz8zxmzBh27NjhCo8A27ZtIz4+XsGmHo05zyUlJbUCTE2gNLrkYpPx2N+DzTpcuZ159913jc1mM/PnzzebN282t9xyiwkLCzMZGRnGGGOuu+46c++997r2X758ufH29jZPP/20SUlJMTNnztRU8AY40fP85JNPGl9fX/PBBx+YAwcOuG6FhYWe+gptwome56NptlTDnOh5Tk9PN8HBwWb69Olm69at5n//+5+JiYkxf/7znz31FdqEEz3PM2fONMHBweadd94xu3btMl9++aXp3r27ufLKKz31FdqEwsJCs27dOrNu3ToDmGeffdasW7fO7N692xhjzL333muuu+461/41U8H/+Mc/mpSUFDN37lxNBW+NXnjhBdO5c2fj6+trRowYYX788UfXa2PHjjWTJk1y2/+9994zvXr1Mr6+vqZ///5m4cKFLVxx23Qi57lLly4GqHWbOXNmyxfexpzoz/ORFG4a7kTP8w8//GBGjhxpbDab6datm3niiSdMVVVVC1fd9pzIea6srDSPPPKI6d69u/Hz8zNJSUlm6tSp5tChQy1feBvy9ddf1/n7tubcTpo0yYwdO7bWMUOGDDG+vr6mW7du5vXXX2/2Oi3GqP1NRERE2g+NuREREZF2ReFGRERE2hWFGxEREWlXFG5ERESkXVG4ERERkXZF4UZERETaFYUbERERaVcUbkTamLS0NCwWS4tcnXv+/PmEhYW5bZs3bx5JSUlYrVbmzJnDI488wpAhQ5q9luTkZObMmdPsn9OaPttisfDJJ5+c1HuceeaZ3Hnnncfcx5PnVqQ5KNyISL0mTpzItm3bXM8LCgqYPn0699xzD/v27eOWW27h7rvvrnXtmJNRV6ACWL16NbfcckuTfc6JfLaItC26KriI1Mvf39/tyr3p6elUVlZy4YUXEh8f79oeFBTU7LVER0c3+2c0pcrKSnx8fDxdhkiHpJYbkVbI4XDw1FNP0aNHD2w2G507d+aJJ56oc1+73c5NN91E165d8ff3p3fv3jz//PNu+yxbtowRI0YQGBhIWFgYY8aMYffu3QD8/PPPnHXWWQQHBxMSEsKwYcP46aefAPeWjPnz5zNw4EAAunXrhsViIS0trc5uqddee43+/ftjs9mIj49n+vTprteeffZZBg4cSGBgIElJSUydOpWioiJXnZMnTyY/Px+LxYLFYuGRRx4BanedpKen89vf/pagoCBCQkK48soryczMdL1eU9ebb75JcnIyoaGhXHXVVRQWFtZ5Ho/12eC8ivSNN95IcHAwnTt3Zt68ea7XaroKFyxYwNixY/Hz8+Ott94C4JVXXqFv3774+fnRp08f/v73v7uOq6ioYPr06cTHx+Pn50eXLl2YPXu2W13Z2dlccsklBAQE0LNnTz799FO317/55htGjBjhOtf33nsvVVVVdX5HgKysLCZMmIC/vz9du3Z11SnSrjT71atE5IT96U9/MuHh4Wb+/Plmx44d5rvvvjMvv/yyMcaY1NRUA5h169YZY4ypqKgwDz/8sFm9erXZtWuX+fe//20CAgLMggULjDHOCwSGhoaau+++2+zYscNs3rzZzJ8/33UV3/79+5vf/e53JiUlxWzbts289957Zv369cYYY15//XUTGhpqjDGmpKTEfPXVVwYwq1atMgcOHDBVVVVm5syZZvDgwa7a//73vxs/Pz8zZ84cs3XrVrNq1Srz3HPPuV5/7rnnzNKlS01qaqpZsmSJ6d27t/nDH/5gjDGmvLzczJkzx4SEhNS6unuXLl1c72O3282QIUPMaaedZn766Sfz448/mmHDhrldsG/mzJkmKCjIXHrppWbDhg3m22+/NXFxceb++++v85wf77MjIiLM3Llzzfbt283s2bON1Wo1W7ZscfszSU5ONh9++KHZtWuX2b9/v/n3v/9t4uPjXds+/PBDExERYebPn2+MMeavf/2rSUpKMt9++61JS0sz3333nXn77bddNQGmU6dO5u233zbbt283t99+uwkKCjI5OTnGGGP27t1rAgICzNSpU01KSor5+OOPTVRUlNtFY8eOHWvuuOMO1/Pzzz/fDB482KxYscL89NNPZvTo0cbf39/tz0ikrVO4EWllCgoKjM1mc4WZox0dbuoybdo0c9lllxljjMnJyTGAWbZsWZ37BgcHu/6yPdqR4cYYY9atW2cAk5qa6tp2dLhJSEgwDzzwQL21He399983kZGR9X5mjSPDzZdffmm8vLxMenq66/VNmza5gldNXQEBAaagoMC1zx//+EczcuTIems51mf/7ne/cz13OBwmJibG/OMf/zDGHP4zmTNnjttx3bt3dwsrxhjz+OOPm1GjRhljjLntttvM2WefbRwOR531AObBBx90PS8qKjKA+eyzz4wxxtx///2md+/ebsfPnTvXBAUFGbvdboxxDzdbt251O0fGGJOSkmIAhRtpV9QtJdLKpKSkUF5ezjnnnNPgY+bOncuwYcOIjo4mKCiIefPmkZ6eDkBERAQ33HAD48ePZ8KECTz//PMcOHDAdeyMGTOYMmUK48aN48knn2Tnzp2Nrj0rK4v9+/cfs/avvvqKc845h8TERIKDg7nuuuvIycmhpKSkwZ+TkpJCUlISSUlJrm39+vUjLCyMlJQU17bk5GSCg4Ndz+Pj48nKyjrBb+U0aNAg12OLxUJcXFyt9xo+fLjrcXFxMTt37uSmm24iKCjIdfvzn//sOsc33HAD69evp3fv3tx+++18+eWXx/zcwMBAQkJCXJ+bkpLCqFGjsFgsrn3GjBlDUVERe/furfVeKSkpeHt7M2zYMNe2Pn36aBC1tDsKNyKtzJEDeBvi3Xff5e677+amm27iyy+/ZP369UyePJmKigrXPq+//jorVqxg9OjRLFiwgF69evHjjz8CzrEpmzZt4sILL2Tp0qX069ePjz/+uFlqT0tL46KLLmLQoEF8+OGHrFmzhrlz5wK41dtUjh7Qa7FYcDgczfZegYGBrsc144hefvll1q9f77pt3LjRde5POeUUUlNTefzxxyktLeXKK6/k8ssvb7bvINJRKNyItDI9e/bE39+/wdOrly9fzujRo5k6dSpDhw6lR48edba+DB06lPvuu48ffviBAQMG8Pbbb7te69WrF3fddRdffvkll156Ka+//nqjag8ODiY5Obne2tesWYPD4eCZZ57hV7/6Fb169WL//v1u+/j6+mK324/5OX379mXPnj3s2bPHtW3z5s3k5eXRr1+/RtXe0M9uqNjYWBISEti1axc9evRwu3Xt2tW1X0hICBMnTuTll19mwYIFfPjhh+Tm5jboM/r27cuKFSswxri2LV++nODgYDp16lRr/z59+lBVVcWaNWtc27Zu3UpeXl7jv6hIK6RwI9LK+Pn5cc899/CnP/2Jf/3rX+zcuZMff/yRV199tc79e/bsyU8//cQXX3zBtm3beOihh1i9erXr9dTUVO677z5WrFjB7t27+fLLL9m+fTt9+/altLSU6dOns2zZMnbv3s3y5ctZvXo1ffv2bXT9jzzyCM888wx/+9vf2L59O2vXruWFF14AoEePHlRWVvLCCy+wa9cu3nzzTV566SW345OTkykqKmLJkiVkZ2fX2V01btw4Bg4cyLXXXsvatWtZtWoV119/PWPHjnXrGjpRDfnsE/Hoo48ye/Zs/va3v7Ft2zY2bNjA66+/zrPPPgs4Z4698847bNmyhW3btvH+++8TFxfX4G6iqVOnsmfPHm677Ta2bNnCf/7zH2bOnMmMGTOwWmv/eu/duzfnnXcev//971m5ciVr1qxhypQpJ9xaKNLaKdyItEIPPfQQ//d//8fDDz9M3759mThxYr1jRX7/+99z6aWXMnHiREaOHElOTg5Tp051vR4QEMCWLVu47LLL6NWrF7fccgvTpk3j97//PV5eXuTk5HD99dfTq1cvrrzySs4//3weffTRRtc+adIk5syZw9///nf69+/PRRddxPbt2wEYPHgwzz77LH/5y18YMGAAb731Vq2pz6NHj+bWW29l4sSJREdH89RTT9X6DIvFwn/+8x/Cw8M544wzGDduHN26dWPBggWNrruhn30ipkyZwiuvvMLrr7/OwIEDGTt2LPPnz3e13AQHB/PUU08xfPhwTj31VNLS0li0aFGdwaQuiYmJLFq0iFWrVjF48GBuvfVWbrrpJh588MF6j3n99ddJSEhg7NixXHrppdxyyy3ExMSc1PcUaW0s5sj2TBEREZE2Ti03IiIi0q4o3IiIiEi7onAjIiIi7YrCjYiIiLQrCjciIiLSrijciIiISLuicCMiIiLtisKNiIiItCsKNyIiItKuKNyIiIhIu6JwIyIiIu2Kwo2IiIi0K/8Pisq3pFQILCwAAAAASUVORK5CYII=",
       "text/plain": [
        "<Figure size 640x480 with 1 Axes>"
       ]
@@ -401,19 +540,26 @@
   },
   {
    "cell_type": "code",
-   "execution_count": 17,
+   "execution_count": 8,
    "id": "a2782025-287b-4e3e-8e49-8d3a487554cb",
    "metadata": {},
    "outputs": [
     {
      "data": {
-      "image/png": "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xJ49e8S3334rIiMjnRYCHjBggBg/frz0/LbbbhMpKSkiNzdXbNmyRfTr108EBAQ4/R0RNXUMQERNUFlZmdDpdFLgudjFAciVsWPHivvuu08IIcSZM2cEALFu3TqXbUNCQqQv5ItdGICEEGL79u0CgDh8+LC07eIAFB8fL1566aU6a7vYokWLRMuWLet8T4cLA9CqVauESqUSx44dk/b/+eefUjhz1BUYGCjKysqkNhMnThSpqal11nKp93744Yel5zabTURHR4uPPvpICHH+72TmzJlOr+vQoYNToBFCiNdee02kpaUJIYR48sknxU033SRsNpvLegCIKVOmSM8rKioEAPHjjz8KIYSYPHmy6NKli9PrZ82aJYKDg4XVahVCOAegvXv3Op0jIYTYs2ePAMAARM0KL4ERNUF79uyB0WjEzTffXO/XzJo1C7169UJUVBSCg4MxZ84cHDt2DAAQERGB4cOHIyMjA3feeSfee+89nD59WnrthAkT8OijjyI9PR1vvvkmDh482ODaCwsLcerUqUvWvmbNGtx8881o1aoVQkJC8Mgjj+DMmTOorKys9/vs2bMHCQkJSEhIkLZ169YN4eHh2LNnj7QtMTERISEh0vO4uDgUFha6+ansrrrqKulnhUKB2NjYWsfq3bu39LPBYMDBgwcxatQoBAcHS4/XX39dOsfDhw/Hjh070KVLFzz11FNYtWrVJd83KCgIoaGh0vvu2bMHaWlpUCgUUpv+/fujoqICJ06cqHWsPXv2QK1Wo1evXtK2pKQkDvymZocBiKgJunDQcX0sWLAAzz33HEaNGoVVq1Zhx44dGDFiBEwmk9Rm7ty5yM3NRb9+/bBw4UJ07twZv/32GwD7WJk///wTgwYNwtq1a9GtWzd8++23Hqn9yJEjuOOOO3DVVVdh8eLF2Lp1K2bNmgUATvU2losHISsUCthsNo8dKygoSPrZMa7pk08+wY4dO6THrl27pHN/zTXX4PDhw3jttddQVVWFwYMH4/777/fYZyDyFwxARE1Qp06dEBAQUO9by9evX49+/fphzJgxuPrqq9GxY0eXvThXX301Jk2ahA0bNqBHjx6YP3++tK9z58545plnsGrVKtx7772YO3dug2oPCQlBYmJinbVv3boVNpsNM2bMwLXXXovOnTvj1KlTTm20Wi2sVusl36dr1644fvw4jh8/Lm3bvXs3SkpK0K1btwbVXt/3rq+YmBjEx8fj0KFD6Nixo9OjXbt2UrvQ0FBkZWXhk08+wcKFC7F48WKcPXu2Xu/RtWtX5ObmQgghbVu/fj1CQkLQunXrWu2TkpJgsViwdetWadvevXtRUlLS8A9K5IMYgIiaIL1ejxdeeAHPP/88/v3vf+PgwYP47bff8Omnn7ps36lTJ2zZsgUrV67Evn378PLLL2Pz5s3S/sOHD2PSpEnIzc3F0aNHsWrVKuzfvx9du3ZFVVUVxo0bh3Xr1uHo0aNYv349Nm/ejK5duza4/mnTpmHGjBn45z//if3792Pbtm14//33AQAdO3aE2WzG+++/j0OHDuGLL77A7NmznV6fmJiIiooK5OTkoLi42OWlsfT0dCQnJ+Ohhx7Ctm3bsGnTJgwdOhQDBgxwugzlrvq8tzteeeUVTJ8+Hf/85z+xb98+/PHHH5g7dy7effddAPY74r766ivk5eVh3759WLRoEWJjY+t9SWrMmDE4fvw4nnzySeTl5eG7775DdnY2JkyYAKWy9ldAly5dcOutt+Lxxx/Hxo0bsXXrVjz66KNu9zoS+ToGIKIm6uWXX8azzz6LqVOnomvXrsjKyqpz7Mrjjz+Oe++9F1lZWUhNTcWZM2cwZswYaX9gYCDy8vJw3333oXPnzhg9ejTGjh2Lxx9/HCqVCmfOnMHQoUPRuXNnDB48GLfddhteeeWVBtc+bNgwzJw5Ex9++CG6d++OO+64A/v37wcApKSk4N1338Vbb72FHj164Msvv6x123e/fv3wxBNPICsrC1FRUXj77bdrvYdCocB3332HFi1a4IYbbkB6ejrat2+PhQsXNrju+r63Ox599FH861//wty5c5GcnIwBAwZg3rx5Ug9QSEgI3n77bfTu3Rt9+vTBkSNHsHz5cpfhxZVWrVph+fLl2LRpE1JSUvDEE09g1KhRmDJlSp2vmTt3LuLj4zFgwADce++9GD16NKKjo6/ocxL5GoW4sF+UiIiIyA+wB4iIiIj8DgMQERER+R0GICIiIvI7DEBERETkdxiAiIiIyO8wABEREZHfYQAiIiIiv8MARERERH6HAYiIiIj8DgMQERER+R0GICIiIvI7DEBERETkd/4fCQmXVHapdtUAAAAASUVORK5CYII=",
+      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAkgAAAHHCAYAAABEEKc/AAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjguMywgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy/H5lhTAAAACXBIWXMAAA9hAAAPYQGoP6dpAABvHElEQVR4nO3dd3hUVeI+8HdmMiW9dwIJNZSQUEPAFZT8jIIlihJYFEQE/QqIxAaIBGuw4KKCi1iwrCyIIOuyiEAQC0RKABWkt9DSCMmkTzu/P8LcMGlkwkxmEt7P88yzzL3n3nvulSVvzjn3HJkQQoCIiIiIJHJHV4CIiIjI2TAgEREREdXCgERERERUCwMSERERUS0MSERERES1MCARERER1cKARERERFQLAxIRERFRLQxIRERERLUwIBERtYD58+dDJpOhoKDA0VUBYJ/6DBs2DMOGDbtmuW3btkEmk2Hbtm02uzaRrTEgEbUin332GWQyWb2fWbNmSeU2bdqESZMmoVevXlAoFIiMjHRcpW8wr7/+OtatW+foahDRdXJxdAWIyHovv/wyoqKiLLb16tVL+vOKFSuwatUq9O3bF2FhYS1dvRva66+/jvvvvx/JycmOrgoRXQcGJKJW6I477kD//v0b3P/666/jo48+glKpxJ133okDBw60YO2un8FggMlkgkqlcnRVnILJZIJOp4NGo3F0VYhuGOxiI2qDwsLCoFQqm338ypUr0a9fP3h6esLLywsxMTF49913LcoUFRVh5syZiIyMhFqtRrt27TB+/HiLMS15eXmYNGkSgoODodFoEBsbi88//9ziPKdPn4ZMJsPbb7+NRYsWoVOnTlCr1fjrr78AAIcPH8b9998PPz8/aDQa9O/fH999912j9dfr9fDz88PEiRPr7NNqtdBoNHjmmWekbe+//z569uwJNzc3+Pr6on///lixYoXVz00mk6GsrAyff/651PX58MMPW5QpKirCww8/DB8fH3h7e2PixIkoLy+vc55p06bhq6++Qs+ePaFWq7Fx40YAwPnz5/HII48gODgYarUaPXv2xKefflqnLk29p6bUx2Aw4JVXXpH+20RGRmLOnDmoqqq65jM5d+4ckpOT4e7ujqCgIMycObNJxxE5GluQiFqh4uLiOoNrAwICbHLuzZs3Y+zYsRg+fDjeeOMNAMChQ4ewfft2zJgx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",
       "text/plain": [
        "<Figure size 640x480 with 1 Axes>"
       ]
      },
      "metadata": {},
      "output_type": "display_data"
+    },
+    {
+     "name": "stdout",
+     "output_type": "stream",
+     "text": [
+      "F1 score maximized at threshold 0.555\n"
+     ]
     }
    ],
    "source": [
@@ -430,7 +576,7 @@
   },
   {
    "cell_type": "code",
-   "execution_count": 18,
+   "execution_count": 9,
    "id": "b5644cf6-3b0f-4ff6-abe4-60dd790fa337",
    "metadata": {
     "scrolled": true
@@ -438,7 +584,7 @@
    "outputs": [
     {
      "data": {
-      "image/png": "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",
+      "image/png": "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",
       "text/plain": [
        "<Figure size 640x480 with 1 Axes>"
       ]
@@ -461,13 +607,13 @@
   },
   {
    "cell_type": "code",
-   "execution_count": 8,
+   "execution_count": 14,
    "id": "0668184c-cd7c-4349-aee3-7397605c62b9",
    "metadata": {},
    "outputs": [
     {
      "data": {
-      "image/png": "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",
+      "image/png": "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",
       "text/plain": [
        "<Figure size 640x480 with 1 Axes>"
       ]
diff --git a/basic_feedforward.py b/basic_feedforward.py
index c36011b..431eb87 100644
--- a/basic_feedforward.py
+++ b/basic_feedforward.py
@@ -12,63 +12,63 @@ from forge import flags
 # )
 
 class PerceptronNN(nn.Module):
-    def __init__(self, input_size, num_labels):
-        super(PerceptronNN, self).__init__()
-        # Define the layers
-        self.fc1 = nn.Linear(input_size, 128)  # First dense layer
-        self.fc2 = nn.Linear(128, 64)         # Second dense layer
-        # self.fc23 = nn.Linear(64,64)
-        self.fc3 = nn.Linear(64, 64)          # Third dense layer
-        self.fc4 = nn.Linear(64, num_labels)  # Output layer
-        # self.softmax = nn.Softmax(dim=1)
+	def __init__(self, input_size, num_labels):
+		super(PerceptronNN, self).__init__()
+		# Define the layers
+		self.fc1 = nn.Linear(input_size, 128)  # First dense layer
+		self.fc2 = nn.Linear(128, 64)         # Second dense layer
+		# self.fc23 = nn.Linear(64,64)
+		self.fc3 = nn.Linear(64, 64)          # Third dense layer
+		self.fc4 = nn.Linear(64, num_labels)  # Output layer
+		# self.softmax = nn.Softmax(dim=1)
 
-    def forward(self, x):
-        # Forward pass through the network
-        x = F.relu(self.fc1(x))  # Activation function between layers
-        x = F.relu(self.fc2(x))
-        # x = F.relu(self.fc23(x))
-        x = F.relu(self.fc3(x))
-        x = self.fc4(x)  # No activation, this will be included in the loss function
-        # x = self.softmax(x)
-        return x
+	def forward(self, x):
+		# Forward pass through the network
+		x = F.relu(self.fc1(x))  # Activation function between layers
+		x = F.relu(self.fc2(x))
+		# x = F.relu(self.fc23(x))
+		x = F.relu(self.fc3(x))
+		x = self.fc4(x)  # No activation, this will be included in the loss function
+		# x = self.softmax(x)
+		return x
 
-class GPT_PNN(nn.Module):
-    def __init__(self, input_size, num_labels):
-        super(GPT_PNN, self).__init__()
-        # Define the layers
-        self.fc1 = nn.Linear(input_size, 64)  # First dense layer, reduced size
-        self.bn1 = nn.BatchNorm1d(64)  # Batch Normalization for the first layer
-        self.dropout1 = nn.Dropout(0.5)  # Dropout with 50% probability
-        
-        # Commenting out to reduce model complexity
-        # self.fc2 = nn.Linear(128, 64)  # Second dense layer
-        # self.dropout2 = nn.Dropout(0.5)  # Additional dropout layer
-        
-        # Simplified to have fewer layers and neurons
-        self.fc2 = nn.Linear(64, 32)  # Reduced size for second dense layer
-        self.bn2 = nn.BatchNorm1d(32)  # Batch Normalization for the second layer
-        self.dropout2 = nn.Dropout(0.5)  # Dropout with 50% probability
+class BasicFFNN(nn.Module):
+	def __init__(self, input_size, num_labels):
+		super(BasicFFNN, self).__init__()
+		# Define the layers
+		self.fc1 = nn.Linear(input_size, 64)  # First dense layer, reduced size
+		self.bn1 = nn.BatchNorm1d(64)  # Batch Normalization for the first layer
+		self.dropout1 = nn.Dropout(0.5)  # Dropout with 50% probability
+		
+		self.fc2 = nn.Linear(64, 32)  # Reduced size for second dense layer
+		self.bn2 = nn.BatchNorm1d(32)  # Batch Normalization for the second layer
+		self.dropout2 = nn.Dropout(0.5)  # Dropout with 50% probability
 
-        # Output layer remains the same, adjusted for reduced prior layer size
-        self.fc3 = nn.Linear(32, num_labels)  # Output layer
+		# self.fc3 = nn.Linear(32,32)
+		# self.bn3 = nn.BatchNorm1d(32)
 
-    def forward(self, x):
-        # x = x[:,::2] # try using every other wavelength
-        # Forward pass through the network with activations, batch normalization, and dropout
-        x = F.relu(self.bn1(self.fc1(x)))
-        x = self.dropout1(x)
-        x = F.relu(self.bn2(self.fc2(x)))
-        x = self.dropout2(x)
-        x = self.fc3(x)  # No activation here, use sigmoid or softmax outside if needed for binary classification
-        return x
+		self.fc4 = nn.Linear(32, num_labels)  # Output layer
+
+	def forward(self, x):
+		x = x['data'].float()
+		# Forward pass through the network with activations, batch normalization, and dropout
+		x = F.relu(self.bn1(self.fc1(x)))
+		x = self.dropout1(x)
+		x = F.relu(self.bn2(self.fc2(x)))
+		x = self.dropout2(x)
+		# x = F.relu(self.bn3(self.fc3(x)))
+		x = self.fc4(x)  # No activation here, use sigmoid or softmax outside if needed for binary classification
+		return x
 
 def load(config):
 
-    # n_channels = 1
-    n_features = config.input_size
-    
-    # mlp = PerceptronNN(n_features,2)
+	# n_channels = 1
+	n_features = config.input_size
+
+	mlp = BasicFFNN(n_features,2)
+	
+	return mlp, "gpt_feedforward_halfLs"
+
+
+
 
-    mlp = GPT_PNN(n_features,2)
-    
-    return mlp, "gpt_feedforward_halfLs"
\ No newline at end of file
diff --git a/checkpoints/.DS_Store b/checkpoints/.DS_Store
index d2830ac..5cf60f5 100644
Binary files a/checkpoints/.DS_Store and b/checkpoints/.DS_Store differ
diff --git a/checkpoints/penn_data/.DS_Store b/checkpoints/penn_data/.DS_Store
index 2d5c952..36f691b 100644
Binary files a/checkpoints/penn_data/.DS_Store and b/checkpoints/penn_data/.DS_Store differ
diff --git a/checkpoints/penn_data/feedforward/.DS_Store b/checkpoints/penn_data/feedforward/.DS_Store
deleted file mode 100644
index 4a7e165..0000000
Binary files a/checkpoints/penn_data/feedforward/.DS_Store and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/.DS_Store b/checkpoints/penn_data/feedforward/hyperparam_testing/.DS_Store
deleted file mode 100644
index 41a19c1..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/.DS_Store and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/1/basic_feedforward.py b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/1/basic_feedforward.py
deleted file mode 100644
index cdd5158..0000000
--- a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/1/basic_feedforward.py
+++ /dev/null
@@ -1,42 +0,0 @@
-import torch
-import torch.nn as nn
-import torch.nn.functional as F
-import numpy as np
-
-from forge import flags
-
-# flags.DEFINE_boolean(
-#     "model_with_dict",
-#     True,
-#     "Makes model output predictions in dictionary instead of directly."
-# )
-
-class PerceptronNN(nn.Module):
-    def __init__(self, input_size, num_labels):
-        super(PerceptronNN, self).__init__()
-        # Define the layers
-        self.fc1 = nn.Linear(input_size, 128)  # First dense layer
-        self.fc2 = nn.Linear(128, 64)         # Second dense layer
-        # self.fc23 = nn.Linear(64,64)
-        self.fc3 = nn.Linear(64, 64)          # Third dense layer
-        self.fc4 = nn.Linear(64, num_labels)  # Output layer
-        # self.softmax = nn.Softmax(dim=1)
-
-    def forward(self, x):
-        # Forward pass through the network
-        x = F.relu(self.fc1(x))  # Activation function between layers
-        x = F.relu(self.fc2(x))
-        # x = F.relu(self.fc23(x))
-        x = F.relu(self.fc3(x))
-        x = self.fc4(x)  # No activation, this will be included in the loss function
-        # x = self.softmax(x)
-        return x
-
-def load(config):
-
-    # n_channels = 1
-    n_features = config.input_size
-    
-    mlp = PerceptronNN(n_features,2)
-    
-    return mlp, "feedforward"
\ No newline at end of file
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/1/data_fold1/model_fold1.ckpt-0 b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/1/data_fold1/model_fold1.ckpt-0
deleted file mode 100644
index 52120eb..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/1/data_fold1/model_fold1.ckpt-0 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/1/data_fold1/model_fold1.ckpt-11511 b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/1/data_fold1/model_fold1.ckpt-11511
deleted file mode 100644
index c07bbf7..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/1/data_fold1/model_fold1.ckpt-11511 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/1/data_fold1/model_fold1.ckpt-23021 b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/1/data_fold1/model_fold1.ckpt-23021
deleted file mode 100644
index 673537d..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/1/data_fold1/model_fold1.ckpt-23021 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/1/data_fold1/model_fold1.ckpt-34531 b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/1/data_fold1/model_fold1.ckpt-34531
deleted file mode 100644
index 8a8908b..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/1/data_fold1/model_fold1.ckpt-34531 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/1/data_fold1/model_fold1.ckpt-early_stop b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/1/data_fold1/model_fold1.ckpt-early_stop
deleted file mode 100644
index 2bc3fc7..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/1/data_fold1/model_fold1.ckpt-early_stop and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/1/data_fold1/results_dict.h5 b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/1/data_fold1/results_dict.h5
deleted file mode 100644
index 24cb9ff..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/1/data_fold1/results_dict.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/1/data_fold1/results_dict_train.h5 b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/1/data_fold1/results_dict_train.h5
deleted file mode 100644
index b082cf7..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/1/data_fold1/results_dict_train.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/1/data_fold1/results_dict_val.h5 b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/1/data_fold1/results_dict_val.h5
deleted file mode 100644
index eebc137..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/1/data_fold1/results_dict_val.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/1/data_fold1/test_headings.txt b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/1/data_fold1/test_headings.txt
deleted file mode 100644
index 05c4825..0000000
--- a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/1/data_fold1/test_headings.txt
+++ /dev/null
@@ -1,4 +0,0 @@
-aaa0060
-aaa0061
-aaa0069
-aaa_0059
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/1/events.out.tfevents.1709686078.MacBook-Pro-4.local.3000.0 b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/1/events.out.tfevents.1709686078.MacBook-Pro-4.local.3000.0
deleted file mode 100644
index 5ff3f3f..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/1/events.out.tfevents.1709686078.MacBook-Pro-4.local.3000.0 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/1/flags.json b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/1/flags.json
deleted file mode 100644
index 617a174..0000000
--- a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/1/flags.json
+++ /dev/null
@@ -1,27 +0,0 @@
-{
-    "batch_size": 100,
-    "beta1": 0.9,
-    "beta2": 0.999,
-    "cross_validate": false,
-    "data_config": "penn_dataset.py",
-    "git_commit": "7416bf730b356aabfe0df644240e40948a8196bb",
-    "include_coords": false,
-    "input_size": 39,
-    "learning_rate": 0.001,
-    "log_train_values": true,
-    "log_val_test": true,
-    "model_config": "basic_feedforward.py",
-    "n_repeats": 1,
-    "report_loss_every": 50,
-    "rescale": true,
-    "results_dir": "checkpoints",
-    "resume": false,
-    "run_name": "hyperparam_testing",
-    "save_check_points": 10,
-    "save_test_predictions": false,
-    "split_seed": 1,
-    "total_evaluations": 100,
-    "train_epochs": 30,
-    "train_split": 0.8,
-    "use_mps": false
-}
\ No newline at end of file
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/1/git_diff.txt b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/1/git_diff.txt
deleted file mode 100644
index 3ad4daa..0000000
--- a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/1/git_diff.txt
+++ /dev/null
@@ -1,1775 +0,0 @@
-Tue Mar 5 16:47:58 PST 2024
-diff --git a/.DS_Store b/.DS_Store
-index e2836a8..c46cff7 100644
-Binary files a/.DS_Store and b/.DS_Store differ
-diff --git a/.ipynb_checkpoints/basic_feedforward-checkpoint.py b/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-index 688c282..0c4bcd1 100644
---- a/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-+++ b/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-@@ -5,6 +5,12 @@ import numpy as np
- 
- from forge import flags
- 
-+flags.DEFINE_boolean(
-+    "model_with_dict",
-+    True,
-+    "Makes model output predictions in dictionary instead of directly."
-+)
-+
- class PerceptronNN(nn.Module):
-     def __init__(self, input_size, num_labels):
-         super(PerceptronNN, self).__init__()
-@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-+        self.softmax = nn.Softmax(dim=1)
- 
-     def forward(self, x):
-         # Forward pass through the network
-@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-         x = F.relu(self.fc2(x))
-         x = F.relu(self.fc3(x))
-         x = self.fc4(x)  # No activation, this will be included in the loss function
-+        x = self.softmax(x)
-         return x
- 
- def load(config):
-@@ -29,4 +37,4 @@ def load(config):
-     
-     mlp = PerceptronNN(n_features,2)
-     
--    return mlp
-\ No newline at end of file
-+    return mlp, "feedforward"
-\ No newline at end of file
-diff --git a/__pycache__/basic_feedforward.cpython-39.pyc b/__pycache__/basic_feedforward.cpython-39.pyc
-index f541140..dddecf8 100644
-Binary files a/__pycache__/basic_feedforward.cpython-39.pyc and b/__pycache__/basic_feedforward.cpython-39.pyc differ
-diff --git a/__pycache__/penn_dataset.cpython-39.pyc b/__pycache__/penn_dataset.cpython-39.pyc
-index 0d7a4de..19121eb 100644
-Binary files a/__pycache__/penn_dataset.cpython-39.pyc and b/__pycache__/penn_dataset.cpython-39.pyc differ
-diff --git a/basic_feedforward.py b/basic_feedforward.py
-index 688c282..cdd5158 100644
---- a/basic_feedforward.py
-+++ b/basic_feedforward.py
-@@ -5,21 +5,31 @@ import numpy as np
- 
- from forge import flags
- 
-+# flags.DEFINE_boolean(
-+#     "model_with_dict",
-+#     True,
-+#     "Makes model output predictions in dictionary instead of directly."
-+# )
-+
- class PerceptronNN(nn.Module):
-     def __init__(self, input_size, num_labels):
-         super(PerceptronNN, self).__init__()
-         # Define the layers
-         self.fc1 = nn.Linear(input_size, 128)  # First dense layer
-         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-+        # self.fc23 = nn.Linear(64,64)
-         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-+        # self.softmax = nn.Softmax(dim=1)
- 
-     def forward(self, x):
-         # Forward pass through the network
-         x = F.relu(self.fc1(x))  # Activation function between layers
-         x = F.relu(self.fc2(x))
-+        # x = F.relu(self.fc23(x))
-         x = F.relu(self.fc3(x))
-         x = self.fc4(x)  # No activation, this will be included in the loss function
-+        # x = self.softmax(x)
-         return x
- 
- def load(config):
-@@ -29,4 +39,4 @@ def load(config):
-     
-     mlp = PerceptronNN(n_features,2)
-     
--    return mlp
-\ No newline at end of file
-+    return mlp, "feedforward"
-\ No newline at end of file
-diff --git a/checkpoints/feedforward/1/basic_feedforward.py b/checkpoints/feedforward/1/basic_feedforward.py
-index 688c282..3a65525 100644
---- a/checkpoints/feedforward/1/basic_feedforward.py
-+++ b/checkpoints/feedforward/1/basic_feedforward.py
-@@ -5,6 +5,12 @@ import numpy as np
- 
- from forge import flags
- 
-+# flags.DEFINE_boolean(
-+#     "model_with_dict",
-+#     True,
-+#     "Makes model output predictions in dictionary instead of directly."
-+# )
-+
- class PerceptronNN(nn.Module):
-     def __init__(self, input_size, num_labels):
-         super(PerceptronNN, self).__init__()
-@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-+        self.softmax = nn.Softmax(dim=1)
- 
-     def forward(self, x):
-         # Forward pass through the network
-@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-         x = F.relu(self.fc2(x))
-         x = F.relu(self.fc3(x))
-         x = self.fc4(x)  # No activation, this will be included in the loss function
-+        x = self.softmax(x)
-         return x
- 
- def load(config):
-@@ -29,4 +37,4 @@ def load(config):
-     
-     mlp = PerceptronNN(n_features,2)
-     
--    return mlp
-\ No newline at end of file
-+    return mlp, "feedforward"
-\ No newline at end of file
-diff --git a/checkpoints/feedforward/1/flags.json b/checkpoints/feedforward/1/flags.json
-index 1d000c3..889a6ea 100644
---- a/checkpoints/feedforward/1/flags.json
-+++ b/checkpoints/feedforward/1/flags.json
-@@ -1,9 +1,15 @@
- {
-     "batch_size": 100,
-+    "beta1": 0.9,
-+    "beta2": 0.999,
-+    "cross_validate": false,
-     "data_config": "penn_dataset.py",
-+    "git_commit": "7416bf730b356aabfe0df644240e40948a8196bb",
-     "include_coords": false,
-     "input_size": 39,
--    "learning_rate": 1e-05,
-+    "learning_rate": 0.0001,
-+    "log_train_values": true,
-+    "log_val_test": true,
-     "model_config": "basic_feedforward.py",
-     "n_repeats": 1,
-     "report_loss_every": 50,
-@@ -11,7 +17,10 @@
-     "results_dir": "checkpoints",
-     "resume": false,
-     "run_name": "feedforward",
-+    "save_check_points": 50,
-+    "save_test_predictions": false,
-     "split_seed": 1,
--    "train_epochs": 20,
-+    "total_evaluations": 100,
-+    "train_epochs": 100,
-     "train_split": 0.8
- }
-\ No newline at end of file
-diff --git a/checkpoints/feedforward/1/git_diff.txt b/checkpoints/feedforward/1/git_diff.txt
-index 7b37e6f..ec23707 100644
---- a/checkpoints/feedforward/1/git_diff.txt
-+++ b/checkpoints/feedforward/1/git_diff.txt
-@@ -1 +1,873 @@
--Mon Mar 4 11:45:48 PST 2024
-+Mon Mar 4 16:34:02 PST 2024
-+diff --git a/.DS_Store b/.DS_Store
-+index e2836a8..7e3fa32 100644
-+Binary files a/.DS_Store and b/.DS_Store differ
-+diff --git a/.ipynb_checkpoints/basic_feedforward-checkpoint.py b/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-+index 688c282..0c4bcd1 100644
-+--- a/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-++++ b/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-+@@ -5,6 +5,12 @@ import numpy as np
-+ 
-+ from forge import flags
-+ 
-++flags.DEFINE_boolean(
-++    "model_with_dict",
-++    True,
-++    "Makes model output predictions in dictionary instead of directly."
-++)
-++
-+ class PerceptronNN(nn.Module):
-+     def __init__(self, input_size, num_labels):
-+         super(PerceptronNN, self).__init__()
-+@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-+         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-+         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-+         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-++        self.softmax = nn.Softmax(dim=1)
-+ 
-+     def forward(self, x):
-+         # Forward pass through the network
-+@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-+         x = F.relu(self.fc2(x))
-+         x = F.relu(self.fc3(x))
-+         x = self.fc4(x)  # No activation, this will be included in the loss function
-++        x = self.softmax(x)
-+         return x
-+ 
-+ def load(config):
-+@@ -29,4 +37,4 @@ def load(config):
-+     
-+     mlp = PerceptronNN(n_features,2)
-+     
-+-    return mlp
-+\ No newline at end of file
-++    return mlp, "feedforward"
-+\ No newline at end of file
-+diff --git a/__pycache__/basic_feedforward.cpython-39.pyc b/__pycache__/basic_feedforward.cpython-39.pyc
-+index f541140..5ad96de 100644
-+Binary files a/__pycache__/basic_feedforward.cpython-39.pyc and b/__pycache__/basic_feedforward.cpython-39.pyc differ
-+diff --git a/__pycache__/penn_dataset.cpython-39.pyc b/__pycache__/penn_dataset.cpython-39.pyc
-+index 0d7a4de..19121eb 100644
-+Binary files a/__pycache__/penn_dataset.cpython-39.pyc and b/__pycache__/penn_dataset.cpython-39.pyc differ
-+diff --git a/basic_feedforward.py b/basic_feedforward.py
-+index 688c282..3a65525 100644
-+--- a/basic_feedforward.py
-++++ b/basic_feedforward.py
-+@@ -5,6 +5,12 @@ import numpy as np
-+ 
-+ from forge import flags
-+ 
-++# flags.DEFINE_boolean(
-++#     "model_with_dict",
-++#     True,
-++#     "Makes model output predictions in dictionary instead of directly."
-++# )
-++
-+ class PerceptronNN(nn.Module):
-+     def __init__(self, input_size, num_labels):
-+         super(PerceptronNN, self).__init__()
-+@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-+         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-+         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-+         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-++        self.softmax = nn.Softmax(dim=1)
-+ 
-+     def forward(self, x):
-+         # Forward pass through the network
-+@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-+         x = F.relu(self.fc2(x))
-+         x = F.relu(self.fc3(x))
-+         x = self.fc4(x)  # No activation, this will be included in the loss function
-++        x = self.softmax(x)
-+         return x
-+ 
-+ def load(config):
-+@@ -29,4 +37,4 @@ def load(config):
-+     
-+     mlp = PerceptronNN(n_features,2)
-+     
-+-    return mlp
-+\ No newline at end of file
-++    return mlp, "feedforward"
-+\ No newline at end of file
-+diff --git a/checkpoints/feedforward/1/basic_feedforward.py b/checkpoints/feedforward/1/basic_feedforward.py
-+index 688c282..3a65525 100644
-+--- a/checkpoints/feedforward/1/basic_feedforward.py
-++++ b/checkpoints/feedforward/1/basic_feedforward.py
-+@@ -5,6 +5,12 @@ import numpy as np
-+ 
-+ from forge import flags
-+ 
-++# flags.DEFINE_boolean(
-++#     "model_with_dict",
-++#     True,
-++#     "Makes model output predictions in dictionary instead of directly."
-++# )
-++
-+ class PerceptronNN(nn.Module):
-+     def __init__(self, input_size, num_labels):
-+         super(PerceptronNN, self).__init__()
-+@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-+         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-+         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-+         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-++        self.softmax = nn.Softmax(dim=1)
-+ 
-+     def forward(self, x):
-+         # Forward pass through the network
-+@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-+         x = F.relu(self.fc2(x))
-+         x = F.relu(self.fc3(x))
-+         x = self.fc4(x)  # No activation, this will be included in the loss function
-++        x = self.softmax(x)
-+         return x
-+ 
-+ def load(config):
-+@@ -29,4 +37,4 @@ def load(config):
-+     
-+     mlp = PerceptronNN(n_features,2)
-+     
-+-    return mlp
-+\ No newline at end of file
-++    return mlp, "feedforward"
-+\ No newline at end of file
-+diff --git a/checkpoints/feedforward/1/flags.json b/checkpoints/feedforward/1/flags.json
-+index 1d000c3..889a6ea 100644
-+--- a/checkpoints/feedforward/1/flags.json
-++++ b/checkpoints/feedforward/1/flags.json
-+@@ -1,9 +1,15 @@
-+ {
-+     "batch_size": 100,
-++    "beta1": 0.9,
-++    "beta2": 0.999,
-++    "cross_validate": false,
-+     "data_config": "penn_dataset.py",
-++    "git_commit": "7416bf730b356aabfe0df644240e40948a8196bb",
-+     "include_coords": false,
-+     "input_size": 39,
-+-    "learning_rate": 1e-05,
-++    "learning_rate": 0.0001,
-++    "log_train_values": true,
-++    "log_val_test": true,
-+     "model_config": "basic_feedforward.py",
-+     "n_repeats": 1,
-+     "report_loss_every": 50,
-+@@ -11,7 +17,10 @@
-+     "results_dir": "checkpoints",
-+     "resume": false,
-+     "run_name": "feedforward",
-++    "save_check_points": 50,
-++    "save_test_predictions": false,
-+     "split_seed": 1,
-+-    "train_epochs": 20,
-++    "total_evaluations": 100,
-++    "train_epochs": 100,
-+     "train_split": 0.8
-+ }
-+\ No newline at end of file
-+diff --git a/checkpoints/feedforward/1/git_diff.txt b/checkpoints/feedforward/1/git_diff.txt
-+index 7b37e6f..5c561db 100644
-+--- a/checkpoints/feedforward/1/git_diff.txt
-++++ b/checkpoints/feedforward/1/git_diff.txt
-+@@ -1 +1 @@
-+-Mon Mar 4 11:45:48 PST 2024
-++Mon Mar 4 16:34:02 PST 2024
-+diff --git a/checkpoints/feedforward/1/penn_dataset.py b/checkpoints/feedforward/1/penn_dataset.py
-+index aa2f5a0..7f5a4fc 100644
-+--- a/checkpoints/feedforward/1/penn_dataset.py
-++++ b/checkpoints/feedforward/1/penn_dataset.py
-+@@ -15,6 +15,7 @@ from forge import flags
-+ # aspects of data managmement
-+ flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
-+ flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-++flags.DEFINE_boolean("cross_validate",False,"Do K-fold cross-validation")
-+ 
-+ # Job management
-+ # flags.DEFINE_integer("batch size",5,"training batch size")
-+@@ -109,15 +110,15 @@ def load(config):
-+         
-+         # set up training DataLoader
-+         train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, n_train),num_workers=0,shuffle = True)
-++        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
-+ 
-+         # set up test DataLoader
-+         test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, n_test),num_workers=0,shuffle = True)
-++        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
-+ 
-+         # set up val DataLoader
-+         val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, n_val),num_workers=0,shuffle = True)
-++        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-+         
-+ 
-+         dataloaders = {'train':train_loader, 
-+@@ -125,8 +126,12 @@ def load(config):
-+                        'val':val_loader,
-+                        'train_inds':train_ind,
-+                        'test_inds':test_ind,
-+-                       'n_val':n_val
-++                       'n_val':n_val,
-++                       'test_headings':list(HEADINGS[test_ind])
-+                       }
-+         kf_dataloaders.append(dataloaders)
-+ 
-++        if not config.cross_validate:
-++        	break
-++
-+     return kf_dataloaders
-+diff --git a/penn_dataset.py b/penn_dataset.py
-+index aa2f5a0..7f5a4fc 100644
-+--- a/penn_dataset.py
-++++ b/penn_dataset.py
-+@@ -15,6 +15,7 @@ from forge import flags
-+ # aspects of data managmement
-+ flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
-+ flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-++flags.DEFINE_boolean("cross_validate",False,"Do K-fold cross-validation")
-+ 
-+ # Job management
-+ # flags.DEFINE_integer("batch size",5,"training batch size")
-+@@ -109,15 +110,15 @@ def load(config):
-+         
-+         # set up training DataLoader
-+         train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, n_train),num_workers=0,shuffle = True)
-++        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
-+ 
-+         # set up test DataLoader
-+         test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, n_test),num_workers=0,shuffle = True)
-++        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
-+ 
-+         # set up val DataLoader
-+         val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, n_val),num_workers=0,shuffle = True)
-++        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-+         
-+ 
-+         dataloaders = {'train':train_loader, 
-+@@ -125,8 +126,12 @@ def load(config):
-+                        'val':val_loader,
-+                        'train_inds':train_ind,
-+                        'test_inds':test_ind,
-+-                       'n_val':n_val
-++                       'n_val':n_val,
-++                       'test_headings':list(HEADINGS[test_ind])
-+                       }
-+         kf_dataloaders.append(dataloaders)
-+ 
-++        if not config.cross_validate:
-++        	break
-++
-+     return kf_dataloaders
-+diff --git a/testing.ipynb b/testing.ipynb
-+index e5a167b..a928d8d 100644
-+--- a/testing.ipynb
-++++ b/testing.ipynb
-+@@ -2,7 +2,7 @@
-+  "cells": [
-+   {
-+    "cell_type": "code",
-+-   "execution_count": 1,
-++   "execution_count": 2,
-+    "id": "4dee7ff1-01a4-4038-b493-9729ff3693f7",
-+    "metadata": {},
-+    "outputs": [],
-+@@ -23,19 +23,19 @@
-+   },
-+   {
-+    "cell_type": "code",
-+-   "execution_count": 2,
-++   "execution_count": 3,
-+    "id": "cad0fdc8-5c35-4610-bba3-b71e60dc1b98",
-+    "metadata": {},
-+    "outputs": [],
-+    "source": [
-+-    "flags.DEFINE_integer(\"batch_size\", 100, \"Mini-batch size.\")\n",
-++    "flags.DEFINE_integer(\"batch_size\", 10, \"Mini-batch size.\")\n",
-+     "\n",
-+     "flags.DEFINE_integer(\"input_size\",39,\"Input shape to model\")"
-+    ]
-+   },
-+   {
-+    "cell_type": "code",
-+-   "execution_count": 3,
-++   "execution_count": 4,
-+    "id": "ce1b936b-8a7c-426e-a3aa-3c1c38f645de",
-+    "metadata": {},
-+    "outputs": [
-+@@ -54,8 +54,8 @@
-+   },
-+   {
-+    "cell_type": "code",
-+-   "execution_count": 9,
-+-   "id": "e862b7e2-57f5-44bf-bcf1-a91160ba66cc",
-++   "execution_count": 5,
-++   "id": "4469cddf-4dac-4468-be88-241d440401c3",
-+    "metadata": {},
-+    "outputs": [
-+     {
-+@@ -67,35 +67,89 @@
-+     }
-+    ],
-+    "source": [
-+-    "model = fet.load(\"basic_feedforward.py\",config)"
-++    "model,modelname = fet.load(\"basic_feedforward.py\",config)"
-+    ]
-+   },
-+   {
-+    "cell_type": "code",
-+-   "execution_count": 10,
-+-   "id": "07e0b160-d5d1-4e54-b4a7-ccaf2224598a",
-++   "execution_count": 17,
-++   "id": "7c9a9fe9-f5e8-456a-b964-4be13027725b",
-+    "metadata": {},
-+    "outputs": [
-+     {
-+      "data": {
-+       "text/plain": [
-+-       "PerceptronNN(\n",
-+-       "  (fc1): Linear(in_features=39, out_features=128, bias=True)\n",
-+-       "  (fc2): Linear(in_features=128, out_features=64, bias=True)\n",
-+-       "  (fc3): Linear(in_features=64, out_features=64, bias=True)\n",
-+-       "  (fc4): Linear(in_features=64, out_features=2, bias=True)\n",
-+-       ")"
-++       "['aaa0060', 'aaa0061', 'aaa0069', 'aaa_0059']"
-+       ]
-+      },
-+-     "execution_count": 10,
-++     "execution_count": 17,
-+      "metadata": {},
-+      "output_type": "execute_result"
-+     }
-+    ],
-+    "source": [
-+-    "model"
-++    "loaddat[0]['test_headings']"
-++   ]
-++  },
-++  {
-++   "cell_type": "code",
-++   "execution_count": 19,
-++   "id": "e862b7e2-57f5-44bf-bcf1-a91160ba66cc",
-++   "metadata": {},
-++   "outputs": [
-++    {
-++     "name": "stdout",
-++     "output_type": "stream",
-++     "text": [
-++      "Keys: ['cross_entropy', 'time']\n"
-++     ]
-++    }
-++   ],
-++   "source": [
-++    "import h5py\n",
-++    "\n",
-++    "file_path = \"./checkpoints/feedforward/2/data_fold1/results_dict.h5\"\n",
-++    "# Replace 'your_file.h5' with the actual path to your file\n",
-++    "f =  h5py.File(file_path, 'r') \n",
-++    "\n",
-++    "    # Get information about the data stored in the file\n",
-++    "print(\"Keys:\", list(f.keys()))  # List the top-level datasets and groups\n",
-++    "\n",
-++    "    # # Access a dataset by its name\n",
-++    "    # dataset_name = \"your_dataset_name\"\n",
-++    "    # if dataset_name in f:\n",
-++    "    #     dataset = f[dataset_name]\n",
-++    "    #     print(\"Dataset shape:\", dataset.shape)\n",
-++    "    #     print(\"Dataset dtype:\", dataset.dtype)\n",
-++    "\n",
-++    "    #     # Access the data as a NumPy array\n",
-++    "    #     data = dataset[:]  # Read the entire dataset\n",
-++    "\n",
-++    "    #     # You can now work with the data as needed, for example:\n",
-++    "    #     # Perform calculations, visualizations, etc.\n",
-++    "    # else:\n",
-++    "    #     print(f\"Dataset '{dataset_name}' not found in the file.\")"
-+    ]
-+   },
-++  {
-++   "cell_type": "code",
-++   "execution_count": 13,
-++   "id": "07e0b160-d5d1-4e54-b4a7-ccaf2224598a",
-++   "metadata": {},
-++   "outputs": [
-++    {
-++     "data": {
-++      "text/plain": [
-++       "<generator object Module.parameters at 0x3007207b0>"
-++      ]
-++     },
-++     "execution_count": 13,
-++     "metadata": {},
-++     "output_type": "execute_result"
-++    }
-++   ],
-++   "source": []
-++  },
-+   {
-+    "cell_type": "code",
-+    "execution_count": null,
-+diff --git a/train.py b/train.py
-+index c266102..516bfa9 100644
-+--- a/train.py
-++++ b/train.py
-+@@ -1,49 +1,440 @@
-+ from os import path as osp
-++import os
-++import numpy as np
-++import time
-+ 
-+ import torch
-++import torch.nn as nn
-+ import torch.nn.functional as F
-+ import torch.optim as optim
-+-
-+-import numpy as np
-++from torch.utils.tensorboard import SummaryWriter
-+ 
-+ import forge
-+ from forge import flags
-+ import forge.experiment_tools as fet
-+ 
-++from train_tools import (
-++	log_tensorboard,
-++	parse_reports,
-++	parse_reports_cpu,
-++	print_reports,
-++	load_checkpoint,
-++	save_checkpoint,
-++	nested_to,
-++	param_count,
-++)
-++
-++from copy import deepcopy
-++from attrdict import AttrDict
-++import deepdish as dd
-++from tqdm import tqdm
-++
-++# For reproducibility while researching, but might affect speed!
-++torch.backends.cudnn.deterministic = True
-++torch.backends.cudnn.benchmark = False
-++torch.manual_seed(0)
-++
-+ 
-+ # Job config
-+ flags.DEFINE_string('data_config', 'penn_dataset.py',
-+-                    'Path to a data config file.')
-++					'Path to a data config file.')
-+ flags.DEFINE_string('model_config', 'basic_feedforward.py',
-+-                    'Path to a model config file.')
-++					'Path to a model config file.')
-+ flags.DEFINE_string('results_dir', 'checkpoints',
-+-                    'Top directory for all experimental results.')
-++					'Top directory for all experimental results.')
-+ flags.DEFINE_string('run_name', 'feedforward',
-+-                    'Name of this job and name of results folder.')
-++					'Name of this job and name of results folder.')
-+ flags.DEFINE_boolean('resume', False, 'Tries to resume a job if True.')
-+ 
-+ # Logging config
-+ flags.DEFINE_integer('report_loss_every', 50,
-+-                     'Number of iterations between reporting minibatch loss.')
-+-flags.DEFINE_integer('train_epochs', 20, 'Maximum number of training epochs.')
-++					 'Number of iterations between reporting minibatch loss.')
-++flags.DEFINE_integer('train_epochs', 100, 'Maximum number of training epochs.')
-++flags.DEFINE_integer(
-++	"save_check_points",
-++	50,
-++	"frequency with which to save checkpoints, in number of epoches.",
-++)
-++flags.DEFINE_boolean("log_train_values", True, "Logs train values if True.")
-++flags.DEFINE_integer(
-++	"total_evaluations",
-++	100,
-++	"Maximum number of evaluations on test and validation data during training.",
-++)
-++flags.DEFINE_boolean(
-++	"save_test_predictions",
-++	False,
-++	"Makes and saves test predictions on one or more test sets (e.g. 5-step and 100-step predictions) at the end of training.",
-++)
-++flags.DEFINE_boolean(
-++    "log_val_test", True, "Turns off computation of validation and test errors."
-++)
-+ 
-+ # Experiment config
-+ flags.DEFINE_integer('batch_size', 100, 'Mini-batch size.')
-+-flags.DEFINE_float('learning_rate', 1e-5, 'SGD learning rate.')
-++flags.DEFINE_float("learning_rate", 1e-4, "Adam learning rate.")
-++flags.DEFINE_float("beta1", 0.9, "Adam Beta 1 parameter")
-++flags.DEFINE_float("beta2", 0.999, "Adam Beta 2 parameter")
-+ 
-+ # Specific config options
-+ flags.DEFINE_integer("input_size",39,"Input shape to model")
-+ 
-++#########################################################################################
-++
-++def evaluate(model, loader, device,fold = 0,headings = [],loss_func = nn.CrossEntropyLoss()):
-++	reports = None
-++	for data in loader:
-++		labels = data['label']
-++		inputs = nested_to(data['data'],device,torch.float32)
-++		
-++		labels_tensor = torch.zeros((len(labels), 2))
-++		for i, label in enumerate(labels):
-++			labels_tensor[i, label] = 1
-++
-++		model_output = model(inputs) # evaluate model
-++
-++		loss = loss_func(model_output, labels_tensor) # compute loss
-++		outputs = AttrDict({"loss": loss, "prediction": model_output,'data_fold':fold})
-++		outputs.reports = AttrDict({"cross_entropy": loss})
-++
-++		if reports is None:
-++			reports = {k: v.detach().clone().cpu() for k, v in outputs.reports.items()}
-++		else:
-++			for k, v in outputs.reports.items():
-++				reports[k] += v.detach().clone().cpu()
-++
-++	for k, v in reports.items():
-++		reports[k] = v / len(
-++			loader
-++		)  # SZ: note this can be slightly incorrect if mini-batch sizes vary (if batch_size doesn't divide train_size), but approximately correct.
-++
-++	# reports['test_headings'] = np.array(headings)
-++
-++	return reports
-++
-++def main():
-++
-++	config = forge.config()
-++
-++	# Set device
-++	if torch.cuda.is_available():
-++		device = f"cuda:{config.device}"
-++		torch.cuda.set_device(device)
-++	else:
-++		device = "cpu" # can change this to MPS on M1 Macs
-++
-++	# Load data
-++	data_name = "penn_data"
-++	kfold_loaders = fet.load(config.data_config, config)
-++
-++	# Load model
-++	model,model_name = fet.load(config.model_config, config)
-++	model = model.to(device)
-++
-++	loss_func = nn.CrossEntropyLoss()
-++
-++	# Prepare environment
-++	params_in_run_name = [
-++		("batch_size", "bs"),
-++		("learning_rate", "lr"),
-++		("n_train", "ntrain")
-++	]
-++
-++	run_name = ""  # config.run_name
-++	for config_param in params_in_run_name:
-++		attr = config_param[0]
-++		abbrev = config_param[1]
-++
-++		if hasattr(config, attr):
-++			run_name += abbrev
-++			run_name += str(getattr(config, attr))
-++			run_name += "_"
-++
-++	results_folder_name = osp.join(
-++		data_name,
-++		model_name,
-++		config.run_name,
-++		run_name,
-++	)
-++
-++	# Prepare environment
-++	logdir = osp.join(config.results_dir, config.run_name)
-++	logdir, resume_checkpoint = fet.init_checkpoint(
-++		logdir, config.data_config, config.model_config, config.resume)
-++
-++	print("Checkpoint directory:",logdir)
-++
-++	# Print flags
-++	fet.print_flags()
-++	# Print model info
-++	print(model)
-++
-++	# Setup optimizer
-++	model_params = model.parameters()
-++	opt_learning_rate = config.learning_rate
-++	model_opt = torch.optim.Adam(
-++		model_params, lr=opt_learning_rate, betas=(config.beta1, config.beta2)
-++	)
-++	print("Model Optimizer:")
-++	print(model_opt)
-++
-++	# Try to restore model and optimizer from checkpoint
-++	if resume_checkpoint is not None:
-++		start_epoch = load_checkpoint(resume_checkpoint, model, model_opt)
-++	else:
-++		start_epoch = 1
-++
-++	n_folds = len(kfold_loaders)
-++	print("Doing {}-fold cross-validation.".format(n_folds))
-++
-++	# KFOLD TRAINING LOOP
-++	for k,loader_k in enumerate(kfold_loaders): # loop over data splits
-++
-++		print("Training fold {}...".format(k+1))
-++
-++		# load the training data
-++		train_loader = loader_k["train"]
-++		n_train = len(train_loader.dataset)
-++		train_batch_size = train_loader.batch_size
-++
-++		# load testing, validation
-++		test_loader = loader_k["test"]
-++		n_test = len(test_loader.dataset)
-++		val_loader = loader_k["val"]
-++		n_val = len(val_loader.dataset)
-++		
-++		# create folder for this data split
-++		fold_dir = osp.join(logdir,"data_fold{}".format(k+1))
-++		fold_dir_exists = osp.exists(fold_dir)
-++		if not fold_dir_exists:
-++			if config.resume:
-++				raise ValueError("Can't resume when the checkpoint/fold dir '{}' doesn't exist.".format(fold_dir))
-++			else:
-++				os.makedirs(fold_dir)
-++		checkpoint_name = osp.join(fold_dir, 'model_fold{}.ckpt'.format(k+1))
-++
-++		# keep track of which data is test data for a given Kfold data split
-++		test_headings = loader_k['test_headings']
-++		headingsFile = osp.join(fold_dir,"test_headings.txt")
-++		with open(headingsFile,'w') as headfile:
-++			for heading in test_headings:
-++				headfile.write(heading+'\n')
-++
-++		# print(checkpoint_name)
-++
-++		train_iter = (start_epoch - 1) * (
-++		len(train_loader.dataset) // train_batch_size
-++		) + 1
-++
-++		print("Starting training at epoch = {}, iter = {}".format(start_epoch, train_iter))
-++
-++		# Setup tensorboard writing
-++		summary_writer = SummaryWriter(logdir)
-++
-++		train_reports = []
-++		report_all = {}
-++		report_all_val = {}
-++
-++		# Saving model at epoch 0 before training
-++		print("saving model at epoch 0 before training ... ")
-++		save_checkpoint(checkpoint_name, 0, model, model_opt, loss=0.0)
-++		print("finished saving model at epoch 0 before training")
-++
-++		num_params = param_count(model)
-++		print(f"Number of model parameters: {num_params}")
-++
-++		# Training
-++		start_t = time.time()
-++
-++		total_train_iters = len(train_loader) * config.train_epochs
-++		iters_per_eval = max(1, int(total_train_iters / config.total_evaluations))
-++		# print('batch',train_batch_size)
-++		# print('ntrain',n_train)
-++		# assert (
-++		# 	n_train % min(train_batch_size, n_train) == 0
-++		# ), "Batch size doesn't divide dataset size. Can be inaccurate for loss computation (see below)."
-++
-++		training_failed = False
-++		best_val_loss_so_far = 1e7
-++
-++		for epoch in tqdm(range(start_epoch, config.train_epochs + 1)):
-++			model.train()
-++
-++			for batch_idx, data_dict in enumerate(train_loader): # Loop over batched data
-++
-++				labels = data_dict['label']
-++				data = data_dict['data']
-++
-++				# send data to device
-++				data = nested_to(data,device,torch.float32)
-++				# One-hot encode the data labels
-++				labels_tensor = torch.zeros((len(labels), 2))
-++				for i, label in enumerate(labels):
-++					labels_tensor[i, label] = 1
-++
-++				model_output = model(data) # evaluate model
-++
-++				loss = loss_func(model_output, labels_tensor) # compute loss
-++				outputs = AttrDict({"loss": loss, "prediction": model_output})
-++				outputs.reports = AttrDict({"cross_entropy": loss})
-++
-++				if torch.isnan(outputs.loss): # check for failure in training
-++					if not training_failed:
-++						epoch_of_nan = epoch
-++					if (epoch > epoch_of_nan + 1) and training_failed:
-++						raise ValueError("Loss Nan-ed.")
-++					training_failed = True
-++
-++				model_opt.zero_grad()
-++				outputs.loss.backward(retain_graph=False)
-++
-++				model_opt.step() # move optimizer forward
-++
-++				train_reports.append(parse_reports_cpu(outputs.reports))
-++
-++				if config.log_train_values:
-++					reports = parse_reports(outputs.reports)
-++					if batch_idx % config.report_loss_every == 0:
-++						log_tensorboard(summary_writer, train_iter, reports, "train/")
-++						print_reports(
-++							reports,
-++							start_t,
-++							epoch,
-++							batch_idx,
-++							len(train_loader.dataset) // train_batch_size,
-++							prefix="train",
-++						)
-++						log_tensorboard(
-++							summary_writer,
-++							train_iter,
-++							{"lr": model_opt.param_groups[0]["lr"]},
-++							"hyperparams/",
-++						)
-++				# Logging and evaluation
-++				if (
-++					train_iter % iters_per_eval == 0 or (train_iter == total_train_iters)
-++				) and config.log_val_test:  # batch_idx % config.evaluate_every == 0:
-++					model.eval()
-++					with torch.no_grad():
-++						reports = evaluate(model, test_loader, device,fold = k,headings = loader_k['test_headings'])
-++						# print("REPORTS",reports)
-++						reports = parse_reports(reports)
-++						reports["time"] = time.time() - start_t
-++						if report_all == {}:
-++							report_all = deepcopy(reports)
-++
-++							for d in reports.keys():
-++								report_all[d] = [report_all[d]]
-++						else:
-++							for d in reports.keys():
-++								report_all[d].append(reports[d])
-++
-++						log_tensorboard(summary_writer, train_iter, reports, "test/")
-++						print_reports(
-++							reports,
-++							start_t,
-++							epoch,
-++							batch_idx,
-++							len(train_loader.dataset) // config.batch_size,
-++							prefix="test",
-++						)
-++
-++						# repeat for validation data
-++						reports = evaluate(model, val_loader, device,fold = k,headings = loader_k['test_headings'])
-++						reports = parse_reports(reports)
-++						reports["time"] = time.time() - start_t
-++						if report_all_val == {}:
-++							report_all_val = deepcopy(reports)
-++
-++							for d in reports.keys():
-++								report_all_val[d] = [report_all_val[d]]
-++						else:
-++							for d in reports.keys():
-++								report_all_val[d].append(reports[d])
-++
-++						log_tensorboard(summary_writer, train_iter, reports, "val/")
-++						print_reports(
-++							reports,
-++							start_t,
-++							epoch,
-++							batch_idx,
-++							len(train_loader.dataset) // config.batch_size,
-++							prefix="val",
-++						)
-++
-++						if report_all_val["cross_entropy"][-1] < best_val_loss_so_far:
-++							save_checkpoint(
-++								checkpoint_name,
-++								f"early_stop",
-++								model,
-++								model_opt,
-++								loss=outputs.loss,
-++							)
-++							best_val_loss_so_far = report_all_val["cross_entropy"][-1]
-++
-++					model.train()
-++
-++				train_iter += 1
-++
-++			if epoch % config.save_check_points == 0:
-++				save_checkpoint(
-++					checkpoint_name, train_iter, model, model_opt, loss=outputs.loss
-++				)
-++
-++		dd.io.save(fold_dir + "/results_dict_train.h5", train_reports)
-++		dd.io.save(fold_dir + "/results_dict.h5", report_all)
-++		dd.io.save(fold_dir + "/results_dict_val.h5", report_all_val)
-++
-++	# always save final model
-++	save_checkpoint(checkpoint_name, train_iter, model, model_opt, loss=outputs.loss)
-++
-++	
-++	if config.save_test_predictions:
-++		pass
-++		# print("Starting to make model predictions on test sets for *final model*.")
-++		# for chunk_len in [5, 100]:
-++		#     start_t_preds = time.time()
-++		#     data_config = SimpleNamespace(
-++		#         **{
-++		#             **config.__dict__["__flags"],
-++		#             **{"chunk_len": chunk_len, "batch_size": 500},
-++		#         }
-++		#     )
-++		#     dataloaders, data_name = fet.load(config.data_config, config=data_config)
-++		#     test_loader_preds = dataloaders["test"]
-++
-++		#     torch.cuda.empty_cache()
-++		#     with torch.no_grad():
-++		#         preds = []
-++		#         true = []
-++		#         num_datapoints = 0
-++		#         for idx, d in enumerate(test_loader_preds):
-++		#             true.append(d[-1])
-++		#             d = nested_to(d, device, torch.float32)
-++		#             outputs = model(d)
-++
-++		#             pred_zs = outputs.prediction
-++		#             preds.append(pred_zs)
-++
-++		#             num_datapoints += len(pred_zs)
-++
-++		#             if num_datapoints >= 2000:
-++		#                 break
-+ 
-+-config = forge.config()
-++		#         preds = torch.cat(preds, dim=0).cpu()
-++		#         true = torch.cat(true, dim=0).cpu()
-+ 
-+-# Prepare environment
-+-logdir = osp.join(config.results_dir, config.run_name)
-+-logdir, resume_checkpoint = fet.init_checkpoint(
-+-    logdir, config.data_config, config.model_config, config.resume)
-+-checkpoint_name = osp.join(logdir, 'model.ckpt')
-++		#         save_dir = osp.join(logdir, f"traj_preds_{chunk_len}_steps_2k_test.pt")
-++		#         torch.save(preds, save_dir)
-+ 
-++		#         save_dir = osp.join(logdir, f"traj_true_{chunk_len}_steps_2k_test.pt")
-++		#         torch.save(true, save_dir)
-+ 
-+-print(logdir)
-++		#         print(
-++		#             f"Completed making test predictions for chunk_len = {chunk_len} in {time.time() - start_t_preds:.2f} seconds."
-++		#         )	
-++		
-+ 
-++if __name__ == "__main__":
-++	main()
-+ 
-diff --git a/checkpoints/feedforward/1/penn_dataset.py b/checkpoints/feedforward/1/penn_dataset.py
-index aa2f5a0..7f5a4fc 100644
---- a/checkpoints/feedforward/1/penn_dataset.py
-+++ b/checkpoints/feedforward/1/penn_dataset.py
-@@ -15,6 +15,7 @@ from forge import flags
- # aspects of data managmement
- flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
- flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-+flags.DEFINE_boolean("cross_validate",False,"Do K-fold cross-validation")
- 
- # Job management
- # flags.DEFINE_integer("batch size",5,"training batch size")
-@@ -109,15 +110,15 @@ def load(config):
-         
-         # set up training DataLoader
-         train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, n_train),num_workers=0,shuffle = True)
-+        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
- 
-         # set up test DataLoader
-         test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, n_test),num_workers=0,shuffle = True)
-+        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
- 
-         # set up val DataLoader
-         val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, n_val),num_workers=0,shuffle = True)
-+        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-         
- 
-         dataloaders = {'train':train_loader, 
-@@ -125,8 +126,12 @@ def load(config):
-                        'val':val_loader,
-                        'train_inds':train_ind,
-                        'test_inds':test_ind,
--                       'n_val':n_val
-+                       'n_val':n_val,
-+                       'test_headings':list(HEADINGS[test_ind])
-                       }
-         kf_dataloaders.append(dataloaders)
- 
-+        if not config.cross_validate:
-+        	break
-+
-     return kf_dataloaders
-diff --git a/georgehulsey_2024.pdf b/georgehulsey_2024.pdf
-deleted file mode 100644
-index 1ab17f6..0000000
-Binary files a/georgehulsey_2024.pdf and /dev/null differ
-diff --git a/penn_dataset.py b/penn_dataset.py
-index aa2f5a0..7f5a4fc 100644
---- a/penn_dataset.py
-+++ b/penn_dataset.py
-@@ -15,6 +15,7 @@ from forge import flags
- # aspects of data managmement
- flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
- flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-+flags.DEFINE_boolean("cross_validate",False,"Do K-fold cross-validation")
- 
- # Job management
- # flags.DEFINE_integer("batch size",5,"training batch size")
-@@ -109,15 +110,15 @@ def load(config):
-         
-         # set up training DataLoader
-         train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, n_train),num_workers=0,shuffle = True)
-+        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
- 
-         # set up test DataLoader
-         test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, n_test),num_workers=0,shuffle = True)
-+        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
- 
-         # set up val DataLoader
-         val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, n_val),num_workers=0,shuffle = True)
-+        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-         
- 
-         dataloaders = {'train':train_loader, 
-@@ -125,8 +126,12 @@ def load(config):
-                        'val':val_loader,
-                        'train_inds':train_ind,
-                        'test_inds':test_ind,
--                       'n_val':n_val
-+                       'n_val':n_val,
-+                       'test_headings':list(HEADINGS[test_ind])
-                       }
-         kf_dataloaders.append(dataloaders)
- 
-+        if not config.cross_validate:
-+        	break
-+
-     return kf_dataloaders
-diff --git a/testing.ipynb b/testing.ipynb
-index e5a167b..0110538 100644
---- a/testing.ipynb
-+++ b/testing.ipynb
-@@ -2,7 +2,7 @@
-  "cells": [
-   {
-    "cell_type": "code",
--   "execution_count": 1,
-+   "execution_count": 4,
-    "id": "4dee7ff1-01a4-4038-b493-9729ff3693f7",
-    "metadata": {},
-    "outputs": [],
-@@ -23,7 +23,7 @@
-   },
-   {
-    "cell_type": "code",
--   "execution_count": 2,
-+   "execution_count": 6,
-    "id": "cad0fdc8-5c35-4610-bba3-b71e60dc1b98",
-    "metadata": {},
-    "outputs": [],
-@@ -35,7 +35,7 @@
-   },
-   {
-    "cell_type": "code",
--   "execution_count": 3,
-+   "execution_count": 7,
-    "id": "ce1b936b-8a7c-426e-a3aa-3c1c38f645de",
-    "metadata": {},
-    "outputs": [
-@@ -54,8 +54,8 @@
-   },
-   {
-    "cell_type": "code",
--   "execution_count": 9,
--   "id": "e862b7e2-57f5-44bf-bcf1-a91160ba66cc",
-+   "execution_count": 5,
-+   "id": "4469cddf-4dac-4468-be88-241d440401c3",
-    "metadata": {},
-    "outputs": [
-     {
-@@ -67,35 +67,98 @@
-     }
-    ],
-    "source": [
--    "model = fet.load(\"basic_feedforward.py\",config)"
-+    "model,modelname = fet.load(\"basic_feedforward.py\",config)"
-    ]
-   },
-   {
-    "cell_type": "code",
--   "execution_count": 10,
--   "id": "07e0b160-d5d1-4e54-b4a7-ccaf2224598a",
-+   "execution_count": 13,
-+   "id": "7c9a9fe9-f5e8-456a-b964-4be13027725b",
-    "metadata": {},
-    "outputs": [
-     {
-      "data": {
-       "text/plain": [
--       "PerceptronNN(\n",
--       "  (fc1): Linear(in_features=39, out_features=128, bias=True)\n",
--       "  (fc2): Linear(in_features=128, out_features=64, bias=True)\n",
--       "  (fc3): Linear(in_features=64, out_features=64, bias=True)\n",
--       "  (fc4): Linear(in_features=64, out_features=2, bias=True)\n",
--       ")"
-+       "array([114170,    904])"
-       ]
-      },
--     "execution_count": 10,
-+     "execution_count": 13,
-      "metadata": {},
-      "output_type": "execute_result"
-     }
-    ],
-    "source": [
--    "model"
-+    "np.bincount(loaddat[0]['train'].dataset.all_labels)"
-    ]
-   },
-+  {
-+   "cell_type": "code",
-+   "execution_count": 1,
-+   "id": "e862b7e2-57f5-44bf-bcf1-a91160ba66cc",
-+   "metadata": {},
-+   "outputs": [
-+    {
-+     "ename": "FileNotFoundError",
-+     "evalue": "[Errno 2] Unable to open file (unable to open file: name = './checkpoints/feedforward/2/data_fold1/results_dict.h5', errno = 2, error message = 'No such file or directory', flags = 0, o_flags = 0)",
-+     "output_type": "error",
-+     "traceback": [
-+      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
-+      "\u001b[0;31mFileNotFoundError\u001b[0m                         Traceback (most recent call last)",
-+      "Cell \u001b[0;32mIn[1], line 5\u001b[0m\n\u001b[1;32m      3\u001b[0m file_path \u001b[38;5;241m=\u001b[39m \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124m./checkpoints/feedforward/2/data_fold1/results_dict.h5\u001b[39m\u001b[38;5;124m\"\u001b[39m\n\u001b[1;32m      4\u001b[0m \u001b[38;5;66;03m# Replace 'your_file.h5' with the actual path to your file\u001b[39;00m\n\u001b[0;32m----> 5\u001b[0m f \u001b[38;5;241m=\u001b[39m  \u001b[43mh5py\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mFile\u001b[49m\u001b[43m(\u001b[49m\u001b[43mfile_path\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[38;5;124;43mr\u001b[39;49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[43m)\u001b[49m \n\u001b[1;32m      7\u001b[0m     \u001b[38;5;66;03m# Get information about the data stored in the file\u001b[39;00m\n\u001b[1;32m      8\u001b[0m \u001b[38;5;28mprint\u001b[39m(\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mKeys:\u001b[39m\u001b[38;5;124m\"\u001b[39m, \u001b[38;5;28mlist\u001b[39m(f\u001b[38;5;241m.\u001b[39mkeys()))\n",
-+      "File \u001b[0;32m/Applications/miniconda3/envs/lietransformer/lib/python3.9/site-packages/h5py/_hl/files.py:562\u001b[0m, in \u001b[0;36mFile.__init__\u001b[0;34m(self, name, mode, driver, libver, userblock_size, swmr, rdcc_nslots, rdcc_nbytes, rdcc_w0, track_order, fs_strategy, fs_persist, fs_threshold, fs_page_size, page_buf_size, min_meta_keep, min_raw_keep, locking, alignment_threshold, alignment_interval, meta_block_size, **kwds)\u001b[0m\n\u001b[1;32m    553\u001b[0m     fapl \u001b[38;5;241m=\u001b[39m make_fapl(driver, libver, rdcc_nslots, rdcc_nbytes, rdcc_w0,\n\u001b[1;32m    554\u001b[0m                      locking, page_buf_size, min_meta_keep, min_raw_keep,\n\u001b[1;32m    555\u001b[0m                      alignment_threshold\u001b[38;5;241m=\u001b[39malignment_threshold,\n\u001b[1;32m    556\u001b[0m                      alignment_interval\u001b[38;5;241m=\u001b[39malignment_interval,\n\u001b[1;32m    557\u001b[0m                      meta_block_size\u001b[38;5;241m=\u001b[39mmeta_block_size,\n\u001b[1;32m    558\u001b[0m                      \u001b[38;5;241m*\u001b[39m\u001b[38;5;241m*\u001b[39mkwds)\n\u001b[1;32m    559\u001b[0m     fcpl \u001b[38;5;241m=\u001b[39m make_fcpl(track_order\u001b[38;5;241m=\u001b[39mtrack_order, fs_strategy\u001b[38;5;241m=\u001b[39mfs_strategy,\n\u001b[1;32m    560\u001b[0m                      fs_persist\u001b[38;5;241m=\u001b[39mfs_persist, fs_threshold\u001b[38;5;241m=\u001b[39mfs_threshold,\n\u001b[1;32m    561\u001b[0m                      fs_page_size\u001b[38;5;241m=\u001b[39mfs_page_size)\n\u001b[0;32m--> 562\u001b[0m     fid \u001b[38;5;241m=\u001b[39m \u001b[43mmake_fid\u001b[49m\u001b[43m(\u001b[49m\u001b[43mname\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mmode\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43muserblock_size\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mfapl\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mfcpl\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mswmr\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43mswmr\u001b[49m\u001b[43m)\u001b[49m\n\u001b[1;32m    564\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;28misinstance\u001b[39m(libver, \u001b[38;5;28mtuple\u001b[39m):\n\u001b[1;32m    565\u001b[0m     \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_libver \u001b[38;5;241m=\u001b[39m libver\n",
-+      "File \u001b[0;32m/Applications/miniconda3/envs/lietransformer/lib/python3.9/site-packages/h5py/_hl/files.py:235\u001b[0m, in \u001b[0;36mmake_fid\u001b[0;34m(name, mode, userblock_size, fapl, fcpl, swmr)\u001b[0m\n\u001b[1;32m    233\u001b[0m     \u001b[38;5;28;01mif\u001b[39;00m swmr \u001b[38;5;129;01mand\u001b[39;00m swmr_support:\n\u001b[1;32m    234\u001b[0m         flags \u001b[38;5;241m|\u001b[39m\u001b[38;5;241m=\u001b[39m h5f\u001b[38;5;241m.\u001b[39mACC_SWMR_READ\n\u001b[0;32m--> 235\u001b[0m     fid \u001b[38;5;241m=\u001b[39m \u001b[43mh5f\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mopen\u001b[49m\u001b[43m(\u001b[49m\u001b[43mname\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mflags\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mfapl\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43mfapl\u001b[49m\u001b[43m)\u001b[49m\n\u001b[1;32m    236\u001b[0m \u001b[38;5;28;01melif\u001b[39;00m mode \u001b[38;5;241m==\u001b[39m \u001b[38;5;124m'\u001b[39m\u001b[38;5;124mr+\u001b[39m\u001b[38;5;124m'\u001b[39m:\n\u001b[1;32m    237\u001b[0m     fid \u001b[38;5;241m=\u001b[39m h5f\u001b[38;5;241m.\u001b[39mopen(name, h5f\u001b[38;5;241m.\u001b[39mACC_RDWR, fapl\u001b[38;5;241m=\u001b[39mfapl)\n",
-+      "File \u001b[0;32mh5py/_objects.pyx:54\u001b[0m, in \u001b[0;36mh5py._objects.with_phil.wrapper\u001b[0;34m()\u001b[0m\n",
-+      "File \u001b[0;32mh5py/_objects.pyx:55\u001b[0m, in \u001b[0;36mh5py._objects.with_phil.wrapper\u001b[0;34m()\u001b[0m\n",
-+      "File \u001b[0;32mh5py/h5f.pyx:102\u001b[0m, in \u001b[0;36mh5py.h5f.open\u001b[0;34m()\u001b[0m\n",
-+      "\u001b[0;31mFileNotFoundError\u001b[0m: [Errno 2] Unable to open file (unable to open file: name = './checkpoints/feedforward/2/data_fold1/results_dict.h5', errno = 2, error message = 'No such file or directory', flags = 0, o_flags = 0)"
-+     ]
-+    }
-+   ],
-+   "source": [
-+    "import h5py\n",
-+    "\n",
-+    "file_path = \"./checkpoints/feedforward/2/data_fold1/results_dict.h5\"\n",
-+    "# Replace 'your_file.h5' with the actual path to your file\n",
-+    "f =  h5py.File(file_path, 'r') \n",
-+    "\n",
-+    "    # Get information about the data stored in the file\n",
-+    "print(\"Keys:\", list(f.keys()))  # List the top-level datasets and groups\n",
-+    "\n",
-+    "    # # Access a dataset by its name\n",
-+    "    # dataset_name = \"your_dataset_name\"\n",
-+    "    # if dataset_name in f:\n",
-+    "    #     dataset = f[dataset_name]\n",
-+    "    #     print(\"Dataset shape:\", dataset.shape)\n",
-+    "    #     print(\"Dataset dtype:\", dataset.dtype)\n",
-+    "\n",
-+    "    #     # Access the data as a NumPy array\n",
-+    "    #     data = dataset[:]  # Read the entire dataset\n",
-+    "\n",
-+    "    #     # You can now work with the data as needed, for example:\n",
-+    "    #     # Perform calculations, visualizations, etc.\n",
-+    "    # else:\n",
-+    "    #     print(f\"Dataset '{dataset_name}' not found in the file.\")"
-+   ]
-+  },
-+  {
-+   "cell_type": "code",
-+   "execution_count": 13,
-+   "id": "07e0b160-d5d1-4e54-b4a7-ccaf2224598a",
-+   "metadata": {},
-+   "outputs": [
-+    {
-+     "data": {
-+      "text/plain": [
-+       "<generator object Module.parameters at 0x3007207b0>"
-+      ]
-+     },
-+     "execution_count": 13,
-+     "metadata": {},
-+     "output_type": "execute_result"
-+    }
-+   ],
-+   "source": []
-+  },
-   {
-    "cell_type": "code",
-    "execution_count": null,
-diff --git a/train.py b/train.py
-index c266102..84b3f43 100644
---- a/train.py
-+++ b/train.py
-@@ -1,49 +1,458 @@
- from os import path as osp
-+import os
-+import numpy as np
-+import time
- 
- import torch
-+import torch.nn as nn
- import torch.nn.functional as F
- import torch.optim as optim
--
--import numpy as np
-+from torch.utils.tensorboard import SummaryWriter
- 
- import forge
- from forge import flags
- import forge.experiment_tools as fet
- 
-+from train_tools import (
-+	log_tensorboard,
-+	parse_reports,
-+	parse_reports_cpu,
-+	print_reports,
-+	load_checkpoint,
-+	save_checkpoint,
-+	nested_to,
-+	param_count,
-+)
-+
-+from copy import deepcopy
-+from attrdict import AttrDict
-+import deepdish as dd
-+from tqdm import tqdm
-+
-+# For reproducibility while researching, but might affect speed!
-+torch.backends.cudnn.deterministic = True
-+torch.backends.cudnn.benchmark = False
-+torch.manual_seed(0)
-+
- 
- # Job config
- flags.DEFINE_string('data_config', 'penn_dataset.py',
--                    'Path to a data config file.')
-+					'Path to a data config file.')
- flags.DEFINE_string('model_config', 'basic_feedforward.py',
--                    'Path to a model config file.')
-+					'Path to a model config file.')
- flags.DEFINE_string('results_dir', 'checkpoints',
--                    'Top directory for all experimental results.')
--flags.DEFINE_string('run_name', 'feedforward',
--                    'Name of this job and name of results folder.')
-+					'Top directory for all experimental results.')
-+flags.DEFINE_string('run_name', 'hyperparam_testing',
-+					'Name of this job and name of results folder.')
- flags.DEFINE_boolean('resume', False, 'Tries to resume a job if True.')
- 
- # Logging config
- flags.DEFINE_integer('report_loss_every', 50,
--                     'Number of iterations between reporting minibatch loss.')
--flags.DEFINE_integer('train_epochs', 20, 'Maximum number of training epochs.')
-+					 'Number of iterations between reporting minibatch loss.')
-+flags.DEFINE_integer('train_epochs', 30, 'Maximum number of training epochs.')
-+flags.DEFINE_integer(
-+	"save_check_points",
-+	10,
-+	"frequency with which to save checkpoints, in number of epoches.",
-+)
-+flags.DEFINE_boolean("log_train_values", True, "Logs train values if True.")
-+flags.DEFINE_integer(
-+	"total_evaluations",
-+	100,
-+	"Maximum number of evaluations on test and validation data during training.",
-+)
-+flags.DEFINE_boolean(
-+	"save_test_predictions",
-+	False,
-+	"Makes and saves test predictions on one or more test sets (e.g. 5-step and 100-step predictions) at the end of training.",
-+)
-+flags.DEFINE_boolean(
-+    "log_val_test", True, "Turns off computation of validation and test errors."
-+)
-+
-+flags.DEFINE_boolean('use_mps',False,"Use Metal Performance Shaders (M1) for training.")
- 
- # Experiment config
- flags.DEFINE_integer('batch_size', 100, 'Mini-batch size.')
--flags.DEFINE_float('learning_rate', 1e-5, 'SGD learning rate.')
-+flags.DEFINE_float("learning_rate", 1e-3, "Adam learning rate.")
-+flags.DEFINE_float("beta1", 0.9, "Adam Beta 1 parameter")
-+flags.DEFINE_float("beta2", 0.999, "Adam Beta 2 parameter")
- 
- # Specific config options
- flags.DEFINE_integer("input_size",39,"Input shape to model")
- 
-+#########################################################################################
-+
-+def evaluate(model, loader, device,fold = 0,headings = [],loss_func = nn.CrossEntropyLoss()):
-+	# this function does not account for class weights when evaluating cross-entropy loss.
-+	# however, they are accounted for when evaluating training loss
-+	reports = None
-+	for data in loader:
-+		labels = data['label']
-+		inputs = nested_to(data['data'],device,torch.float32)
-+		
-+		labels_tensor = torch.zeros((len(labels), 2))
-+		for i, label in enumerate(labels):
-+			labels_tensor[i, label] = 1
-+
-+		model_output = model(inputs) # evaluate model
-+
-+		loss = loss_func(model_output, labels_tensor) # compute loss
-+		outputs = AttrDict({"loss": loss, "prediction": model_output,'data_fold':fold})
-+		outputs.reports = AttrDict({"cross_entropy": loss})
-+
-+		if reports is None:
-+			reports = {k: v.detach().clone().cpu() for k, v in outputs.reports.items()}
-+		else:
-+			for k, v in outputs.reports.items():
-+				reports[k] += v.detach().clone().cpu()
-+
-+	for k, v in reports.items():
-+		reports[k] = v / len(
-+			loader
-+		)  # SZ: note this can be slightly incorrect if mini-batch sizes vary (if batch_size doesn't divide train_size), but approximately correct.
-+
-+	# reports['test_headings'] = np.array(headings)
-+
-+	return reports
-+
-+def main():
-+
-+	config = forge.config()
-+
-+	# Set device
-+	if torch.cuda.is_available():
-+		device = f"cuda:{config.device}"
-+		torch.cuda.set_device(device)
-+	else:
-+		device = "cpu" # can change this to MPS on M1 Macs
-+
-+	if config.use_mps:
-+		device = "mps"
-+
-+	# Load data
-+	data_name = "penn_data"
-+	kfold_loaders = fet.load(config.data_config, config)
-+
-+	# Load model
-+	model,model_name = fet.load(config.model_config, config)
-+	model = model.to(device)
-+
-+	# Prepare environment
-+	params_in_run_name = [
-+		("batch_size", "bs"),
-+		("learning_rate", "lr"),
-+		("n_train", "ntrain"),
-+		("include_coords",'inclx'),
-+		("input_size",'inpsize'),
-+		("cross_validate",'crval'),
-+		("train_epochs",'n_epochs'),
-+	]
-+
-+	run_name = ""  # config.run_name
-+	for config_param in params_in_run_name:
-+		attr = config_param[0]
-+		abbrev = config_param[1]
-+
-+		if hasattr(config, attr):
-+			run_name += abbrev
-+			run_name += str(getattr(config, attr))
-+			run_name += "_"
-+
-+	results_folder_name = osp.join(
-+		data_name,
-+		model_name,
-+		config.run_name,
-+		run_name,
-+	)
-+
-+	# Prepare environment
-+	logdir = osp.join(config.results_dir, results_folder_name.replace(".", "_"))
-+	logdir, resume_checkpoint = fet.init_checkpoint(
-+		logdir, config.data_config, config.model_config, config.resume)
-+
-+	print("Checkpoint directory:",logdir)
-+
-+	# Print flags
-+	fet.print_flags()
-+	# Print model info
-+	print(model)
-+
-+	# Setup optimizer
-+	model_params = model.parameters()
-+	opt_learning_rate = config.learning_rate
-+	model_opt = torch.optim.Adam(
-+		model_params, lr=opt_learning_rate, betas=(config.beta1, config.beta2)
-+	)
-+	scheduler = torch.optim.lr_scheduler.StepLR(model_opt, step_size=10, gamma=0.5)
-+	print("Model Optimizer:")
-+	print(model_opt)
-+
-+	# Try to restore model and optimizer from checkpoint
-+	if resume_checkpoint is not None:
-+		start_epoch = load_checkpoint(resume_checkpoint, model, model_opt)
-+	else:
-+		start_epoch = 1
-+
-+	n_folds = len(kfold_loaders)
-+	print("Doing {}-fold cross-validation.".format(n_folds))
-+
-+	# KFOLD TRAINING LOOP
-+	for k,loader_k in enumerate(kfold_loaders): # loop over data splits
-+
-+		print("Training fold {}...".format(k+1))
-+
-+		# load the training data
-+		train_loader = loader_k["train"]
-+		n_train = len(train_loader.dataset)
-+		train_batch_size = train_loader.batch_size
-+
-+		# load testing, validation
-+		test_loader = loader_k["test"]
-+		n_test = len(test_loader.dataset)
-+		val_loader = loader_k["val"]
-+		n_val = len(val_loader.dataset)
-+
-+		train_class_counts = np.bincount(train_loader.dataset.all_labels)
-+		train_total_counts = sum(train_class_counts)
-+		class_weight = torch.tensor(1.0 / train_class_counts) * train_total_counts / 2.0
-+
-+		loss_func = nn.CrossEntropyLoss(weight = class_weight) # define reweighted loss function
-+				
-+		# create folder for this data split
-+		fold_dir = osp.join(logdir,"data_fold{}".format(k+1))
-+		fold_dir_exists = osp.exists(fold_dir)
-+		if not fold_dir_exists:
-+			if config.resume:
-+				raise ValueError("Can't resume when the checkpoint/fold dir '{}' doesn't exist.".format(fold_dir))
-+			else:
-+				os.makedirs(fold_dir)
-+		checkpoint_name = osp.join(fold_dir, 'model_fold{}.ckpt'.format(k+1))
-+
-+		# keep track of which data is test data for a given Kfold data split
-+		test_headings = loader_k['test_headings']
-+		headingsFile = osp.join(fold_dir,"test_headings.txt")
-+		with open(headingsFile,'w') as headfile:
-+			for heading in test_headings:
-+				headfile.write(heading+'\n')
-+
-+		# print(checkpoint_name)
-+
-+		train_iter = (start_epoch - 1) * (
-+		len(train_loader.dataset) // train_batch_size
-+		) + 1
-+
-+		print("Starting training at epoch = {}, iter = {}".format(start_epoch, train_iter))
-+
-+		# Setup tensorboard writing
-+		summary_writer = SummaryWriter(logdir)
-+
-+		train_reports = []
-+		report_all = {}
-+		report_all_val = {}
-+
-+		# Saving model at epoch 0 before training
-+		print("saving model at epoch 0 before training ... ")
-+		save_checkpoint(checkpoint_name, 0, model, model_opt, loss=0.0)
-+		print("finished saving model at epoch 0 before training")
-+
-+		num_params = param_count(model)
-+		print(f"Number of model parameters: {num_params}")
-+
-+		# Training
-+		start_t = time.time()
-+
-+		total_train_iters = len(train_loader) * config.train_epochs
-+		iters_per_eval = max(1, int(total_train_iters / config.total_evaluations))
-+		# print('batch',train_batch_size)
-+		# print('ntrain',n_train)
-+		# assert (
-+		# 	n_train % min(train_batch_size, n_train) == 0
-+		# ), "Batch size doesn't divide dataset size. Can be inaccurate for loss computation (see below)."
-+
-+		training_failed = False
-+		best_val_loss_so_far = 1e7
-+
-+		for epoch in tqdm(range(start_epoch, config.train_epochs + 1)):
-+			model.train()
-+
-+			for batch_idx, data_dict in enumerate(train_loader): # Loop over batched data
-+
-+				labels = data_dict['label']
-+				data = data_dict['data']
-+
-+				# send data to device
-+				data = nested_to(data,device,torch.float32)
-+				# One-hot encode the data labels
-+				labels_tensor = torch.zeros((len(labels), 2))
-+				for i, label in enumerate(labels):
-+					labels_tensor[i, label] = 1
-+
-+				model_output = model(data) # evaluate model
-+
-+				loss = loss_func(model_output, labels_tensor) # compute loss
-+				outputs = AttrDict({"loss": loss, "prediction": model_output})
-+				outputs.reports = AttrDict({"cross_entropy": loss})
-+
-+				if torch.isnan(outputs.loss): # check for failure in training
-+					if not training_failed:
-+						epoch_of_nan = epoch
-+					if (epoch > epoch_of_nan + 1) and training_failed:
-+						raise ValueError("Loss Nan-ed.")
-+					training_failed = True
-+
-+				model_opt.zero_grad()
-+				outputs.loss.backward(retain_graph=False)
-+
-+				model_opt.step() # move optimizer forward
-+
-+				train_reports.append(parse_reports_cpu(outputs.reports))
-+
-+				if config.log_train_values:
-+					reports = parse_reports(outputs.reports)
-+					if batch_idx % config.report_loss_every == 0:
-+						log_tensorboard(summary_writer, train_iter, reports, "train/")
-+						print_reports(
-+							reports,
-+							start_t,
-+							epoch,
-+							batch_idx,
-+							len(train_loader.dataset) // train_batch_size,
-+							prefix="train",
-+						)
-+						log_tensorboard(
-+							summary_writer,
-+							train_iter,
-+							{"lr": model_opt.param_groups[0]["lr"]},
-+							"hyperparams/",
-+						)
-+				# Logging and evaluation
-+				if (
-+					train_iter % iters_per_eval == 0 or (train_iter == total_train_iters)
-+				) and config.log_val_test:  # batch_idx % config.evaluate_every == 0:
-+					model.eval()
-+					with torch.no_grad():
-+						reports = evaluate(model, test_loader, device,fold = k,headings = loader_k['test_headings'],loss_func = loss_func)
-+						# print("REPORTS",reports)
-+						reports = parse_reports(reports)
-+						reports["time"] = time.time() - start_t
-+						if report_all == {}:
-+							report_all = deepcopy(reports)
-+
-+							for d in reports.keys():
-+								report_all[d] = [report_all[d]]
-+						else:
-+							for d in reports.keys():
-+								report_all[d].append(reports[d])
-+
-+						log_tensorboard(summary_writer, train_iter, reports, "test/")
-+						print_reports(
-+							reports,
-+							start_t,
-+							epoch,
-+							batch_idx,
-+							len(train_loader.dataset) // config.batch_size,
-+							prefix="test",
-+						)
-+
-+						# repeat for validation data
-+						reports = evaluate(model, val_loader, device,fold = k,headings = loader_k['test_headings'])
-+						reports = parse_reports(reports)
-+						reports["time"] = time.time() - start_t
-+						if report_all_val == {}:
-+							report_all_val = deepcopy(reports)
-+
-+							for d in reports.keys():
-+								report_all_val[d] = [report_all_val[d]]
-+						else:
-+							for d in reports.keys():
-+								report_all_val[d].append(reports[d])
-+
-+						log_tensorboard(summary_writer, train_iter, reports, "val/")
-+						print_reports(
-+							reports,
-+							start_t,
-+							epoch,
-+							batch_idx,
-+							len(train_loader.dataset) // config.batch_size,
-+							prefix="val",
-+						)
-+
-+						if report_all_val["cross_entropy"][-1] < best_val_loss_so_far:
-+							save_checkpoint(
-+								checkpoint_name,
-+								f"early_stop",
-+								model,
-+								model_opt,
-+								loss=outputs.loss,
-+							)
-+							best_val_loss_so_far = report_all_val["cross_entropy"][-1]
-+
-+					model.train()
-+
-+				train_iter += 1
-+
-+			scheduler.step()
-+
-+			if epoch % config.save_check_points == 0:
-+				save_checkpoint(
-+					checkpoint_name, train_iter, model, model_opt, loss=outputs.loss
-+				)
-+		
-+		dd.io.save(fold_dir + "/results_dict_train.h5", train_reports)
-+		dd.io.save(fold_dir + "/results_dict.h5", report_all)
-+		dd.io.save(fold_dir + "/results_dict_val.h5", report_all_val)
-+
-+	# always save final model
-+	save_checkpoint(checkpoint_name, train_iter, model, model_opt, loss=outputs.loss)
-+
-+	
-+	if config.save_test_predictions:
-+		pass
-+		# print("Starting to make model predictions on test sets for *final model*.")
-+		# for chunk_len in [5, 100]:
-+		#     start_t_preds = time.time()
-+		#     data_config = SimpleNamespace(
-+		#         **{
-+		#             **config.__dict__["__flags"],
-+		#             **{"chunk_len": chunk_len, "batch_size": 500},
-+		#         }
-+		#     )
-+		#     dataloaders, data_name = fet.load(config.data_config, config=data_config)
-+		#     test_loader_preds = dataloaders["test"]
-+
-+		#     torch.cuda.empty_cache()
-+		#     with torch.no_grad():
-+		#         preds = []
-+		#         true = []
-+		#         num_datapoints = 0
-+		#         for idx, d in enumerate(test_loader_preds):
-+		#             true.append(d[-1])
-+		#             d = nested_to(d, device, torch.float32)
-+		#             outputs = model(d)
-+
-+		#             pred_zs = outputs.prediction
-+		#             preds.append(pred_zs)
-+
-+		#             num_datapoints += len(pred_zs)
-+
-+		#             if num_datapoints >= 2000:
-+		#                 break
- 
--config = forge.config()
-+		#         preds = torch.cat(preds, dim=0).cpu()
-+		#         true = torch.cat(true, dim=0).cpu()
- 
--# Prepare environment
--logdir = osp.join(config.results_dir, config.run_name)
--logdir, resume_checkpoint = fet.init_checkpoint(
--    logdir, config.data_config, config.model_config, config.resume)
--checkpoint_name = osp.join(logdir, 'model.ckpt')
-+		#         save_dir = osp.join(logdir, f"traj_preds_{chunk_len}_steps_2k_test.pt")
-+		#         torch.save(preds, save_dir)
- 
-+		#         save_dir = osp.join(logdir, f"traj_true_{chunk_len}_steps_2k_test.pt")
-+		#         torch.save(true, save_dir)
- 
--print(logdir)
-+		#         print(
-+		#             f"Completed making test predictions for chunk_len = {chunk_len} in {time.time() - start_t_preds:.2f} seconds."
-+		#         )	
-+		
- 
-+if __name__ == "__main__":
-+	main()
- 
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/1/penn_dataset.py b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/1/penn_dataset.py
deleted file mode 100644
index 7f5a4fc..0000000
--- a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/1/penn_dataset.py
+++ /dev/null
@@ -1,137 +0,0 @@
-import os
-import torch
-import pandas as pd
-import numpy as np
-
-from torchvision import datasets, transforms
-from torch.utils.data import Dataset, DataLoader
-from sklearn.model_selection import RepeatedKFold
-
-from os import path as osp
-import forge
-from forge import flags
-
-
-# aspects of data managmement
-flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
-flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-flags.DEFINE_boolean("cross_validate",False,"Do K-fold cross-validation")
-
-# Job management
-# flags.DEFINE_integer("batch size",5,"training batch size")
-flags.DEFINE_float("train_split",0.8,'Fraction of data to use for training.')
-flags.DEFINE_integer("n_repeats",1,"Times to repeat K-fold cross-validation")
-flags.DEFINE_integer("split_seed",1,"Seed for KFold split (integer for reproducibility")
-
-# "wavelengths between 0.05 and 1 mm in 0.025 mm increments."
-LSPACE = np.arange(0.05,1.05,0.025) # corresponds to 39 non-coord columns of data
-L_INDS = None
-
-DATAFOLDER = './penn_data'
-
-HEADINGS = np.array(['aaa0043','aaa0044','aaa0060','aaa0061','aaa0063','aaa0064','aaa0066','aaa0069','aaa0086','aaa0087','aaa_0051','aaa_0053','aaa_0054','aaa_0059','aaa_0071','aaa_0072'])
-
-
-class PennData(Dataset):
-
-    def __init__(self,path_to_data,headings,k_inds = None,include_coords = True,rescale = True,spectra_prefix = "kvals_fuse_rotate_",label_prefix = 'labels_fuse_rotate_'):
-        
-        self.data_dir = path_to_data
-        self.headings = headings
-
-        df_list = []
-        label_list = []
-        for heading in self.headings: # for each datafile heading,
-            data_name = osp.join(self.data_dir,spectra_prefix + heading+'.csv') # read kvals
-            df_temp = pd.read_csv(data_name,header=None)
-            df_list.append(df_temp)
-
-            label_name = osp.join(self.data_dir,label_prefix + heading + '.csv') # read labels
-            label_temp = pd.read_csv(label_name,header=None, names=['label'])
-            label_list.append(label_temp)
-
-        df = pd.concat(df_list, ignore_index=True)
-
-        labels = pd.concat(label_list, ignore_index=True)
-        df = pd.concat([labels, df], axis="columns") # Append labels to data
-
-        all_labels = df['label'].to_numpy()
-        all_data = df.iloc[:,1:].to_numpy()
-
-        if rescale: # rescale (normalize) wavelength intensity data
-            lambdas = all_data[:,2:] # wavelengths
-            lam_std = np.std(lambdas, axis=0)  # Calculate standard deviation along columns
-            lam_mean = np.mean(lambdas, axis=0)  # Calculate mean along columns
-            lambdas_rescaled = (lambdas - lam_mean) / lam_std 
-            all_data[:,2:] = lambdas_rescaled
-
-        if not include_coords: # removes x,y coordinates from data
-            all_data = all_data[:,2:]
-        
-        if k_inds != None: # in this case, only use subset of wavelengths
-            all_data = all_data[:,np.array(k_inds)]
-
-        self.all_data = all_data
-        self.all_labels = all_labels
-
-    def __len__(self):
-        return len(self.all_data)
-
-    def __getitem__(self,i):
-        state = {'label':self.all_labels[i],'data':self.all_data[i]}
-        return state
-
-    def __getstate__(self):
-        state = {
-            'data': self.all_data,
-            'label': self.all_labels,
-                }
-        return state
-
-    def __setstate__(self, state):
-        # Set the object's state from the provided dictionary
-        self.all_data = state['data']
-        self.all_labels = state['label']
-        
-
-
-def load(config):
-
-    n_splits = int(len(HEADINGS)/((1-config.train_split)*len(HEADINGS)))
-
-    kf = RepeatedKFold(n_splits = n_splits, n_repeats = config.n_repeats, random_state = config.split_seed) # K-fold cross validation
-
-    kf_dataloaders = []
-
-    for i, (train_ind, test_ind) in enumerate(kf.split(HEADINGS)): # for each K-fold split, 
-        n_val = len(test_ind)//2
-        n_test = len(test_ind)-n_val   
-        n_train = len(train_ind)
-        
-        # set up training DataLoader
-        train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
-
-        # set up test DataLoader
-        test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
-
-        # set up val DataLoader
-        val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-        
-
-        dataloaders = {'train':train_loader, 
-                       'test':test_loader,
-                       'val':val_loader,
-                       'train_inds':train_ind,
-                       'test_inds':test_ind,
-                       'n_val':n_val,
-                       'test_headings':list(HEADINGS[test_ind])
-                      }
-        kf_dataloaders.append(dataloaders)
-
-        if not config.cross_validate:
-        	break
-
-    return kf_dataloaders
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/2/__pycache__/basic_feedforward.cpython-39.pyc b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/2/__pycache__/basic_feedforward.cpython-39.pyc
deleted file mode 100644
index 7bec4ab..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/2/__pycache__/basic_feedforward.cpython-39.pyc and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/2/__pycache__/penn_dataset.cpython-39.pyc b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/2/__pycache__/penn_dataset.cpython-39.pyc
deleted file mode 100644
index f41ca1b..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/2/__pycache__/penn_dataset.cpython-39.pyc and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/2/basic_feedforward.py b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/2/basic_feedforward.py
deleted file mode 100644
index cdd5158..0000000
--- a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/2/basic_feedforward.py
+++ /dev/null
@@ -1,42 +0,0 @@
-import torch
-import torch.nn as nn
-import torch.nn.functional as F
-import numpy as np
-
-from forge import flags
-
-# flags.DEFINE_boolean(
-#     "model_with_dict",
-#     True,
-#     "Makes model output predictions in dictionary instead of directly."
-# )
-
-class PerceptronNN(nn.Module):
-    def __init__(self, input_size, num_labels):
-        super(PerceptronNN, self).__init__()
-        # Define the layers
-        self.fc1 = nn.Linear(input_size, 128)  # First dense layer
-        self.fc2 = nn.Linear(128, 64)         # Second dense layer
-        # self.fc23 = nn.Linear(64,64)
-        self.fc3 = nn.Linear(64, 64)          # Third dense layer
-        self.fc4 = nn.Linear(64, num_labels)  # Output layer
-        # self.softmax = nn.Softmax(dim=1)
-
-    def forward(self, x):
-        # Forward pass through the network
-        x = F.relu(self.fc1(x))  # Activation function between layers
-        x = F.relu(self.fc2(x))
-        # x = F.relu(self.fc23(x))
-        x = F.relu(self.fc3(x))
-        x = self.fc4(x)  # No activation, this will be included in the loss function
-        # x = self.softmax(x)
-        return x
-
-def load(config):
-
-    # n_channels = 1
-    n_features = config.input_size
-    
-    mlp = PerceptronNN(n_features,2)
-    
-    return mlp, "feedforward"
\ No newline at end of file
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/2/data_fold1/model_fold1.ckpt-0 b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/2/data_fold1/model_fold1.ckpt-0
deleted file mode 100644
index 4f96e04..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/2/data_fold1/model_fold1.ckpt-0 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/2/data_fold1/model_fold1.ckpt-11511 b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/2/data_fold1/model_fold1.ckpt-11511
deleted file mode 100644
index 440704f..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/2/data_fold1/model_fold1.ckpt-11511 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/2/data_fold1/model_fold1.ckpt-23021 b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/2/data_fold1/model_fold1.ckpt-23021
deleted file mode 100644
index ae595b0..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/2/data_fold1/model_fold1.ckpt-23021 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/2/data_fold1/model_fold1.ckpt-34531 b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/2/data_fold1/model_fold1.ckpt-34531
deleted file mode 100644
index 95f53ac..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/2/data_fold1/model_fold1.ckpt-34531 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/2/data_fold1/model_fold1.ckpt-early_stop b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/2/data_fold1/model_fold1.ckpt-early_stop
deleted file mode 100644
index 3291e82..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/2/data_fold1/model_fold1.ckpt-early_stop and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/2/data_fold1/results_dict.h5 b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/2/data_fold1/results_dict.h5
deleted file mode 100644
index f5185ce..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/2/data_fold1/results_dict.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/2/data_fold1/results_dict_train.h5 b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/2/data_fold1/results_dict_train.h5
deleted file mode 100644
index e8f0510..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/2/data_fold1/results_dict_train.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/2/data_fold1/results_dict_val.h5 b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/2/data_fold1/results_dict_val.h5
deleted file mode 100644
index 9679d41..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/2/data_fold1/results_dict_val.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/2/data_fold1/test_headings.txt b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/2/data_fold1/test_headings.txt
deleted file mode 100644
index 05c4825..0000000
--- a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/2/data_fold1/test_headings.txt
+++ /dev/null
@@ -1,4 +0,0 @@
-aaa0060
-aaa0061
-aaa0069
-aaa_0059
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/2/events.out.tfevents.1709686283.MacBook-Pro-4.local.3051.0 b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/2/events.out.tfevents.1709686283.MacBook-Pro-4.local.3051.0
deleted file mode 100644
index 610c133..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/2/events.out.tfevents.1709686283.MacBook-Pro-4.local.3051.0 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/2/flags.json b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/2/flags.json
deleted file mode 100644
index 617a174..0000000
--- a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/2/flags.json
+++ /dev/null
@@ -1,27 +0,0 @@
-{
-    "batch_size": 100,
-    "beta1": 0.9,
-    "beta2": 0.999,
-    "cross_validate": false,
-    "data_config": "penn_dataset.py",
-    "git_commit": "7416bf730b356aabfe0df644240e40948a8196bb",
-    "include_coords": false,
-    "input_size": 39,
-    "learning_rate": 0.001,
-    "log_train_values": true,
-    "log_val_test": true,
-    "model_config": "basic_feedforward.py",
-    "n_repeats": 1,
-    "report_loss_every": 50,
-    "rescale": true,
-    "results_dir": "checkpoints",
-    "resume": false,
-    "run_name": "hyperparam_testing",
-    "save_check_points": 10,
-    "save_test_predictions": false,
-    "split_seed": 1,
-    "total_evaluations": 100,
-    "train_epochs": 30,
-    "train_split": 0.8,
-    "use_mps": false
-}
\ No newline at end of file
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/2/git_diff.txt b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/2/git_diff.txt
deleted file mode 100644
index 671f147..0000000
--- a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/2/git_diff.txt
+++ /dev/null
@@ -1,1775 +0,0 @@
-Tue Mar 5 16:51:23 PST 2024
-diff --git a/.DS_Store b/.DS_Store
-index e2836a8..bf7630a 100644
-Binary files a/.DS_Store and b/.DS_Store differ
-diff --git a/.ipynb_checkpoints/basic_feedforward-checkpoint.py b/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-index 688c282..0c4bcd1 100644
---- a/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-+++ b/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-@@ -5,6 +5,12 @@ import numpy as np
- 
- from forge import flags
- 
-+flags.DEFINE_boolean(
-+    "model_with_dict",
-+    True,
-+    "Makes model output predictions in dictionary instead of directly."
-+)
-+
- class PerceptronNN(nn.Module):
-     def __init__(self, input_size, num_labels):
-         super(PerceptronNN, self).__init__()
-@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-+        self.softmax = nn.Softmax(dim=1)
- 
-     def forward(self, x):
-         # Forward pass through the network
-@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-         x = F.relu(self.fc2(x))
-         x = F.relu(self.fc3(x))
-         x = self.fc4(x)  # No activation, this will be included in the loss function
-+        x = self.softmax(x)
-         return x
- 
- def load(config):
-@@ -29,4 +37,4 @@ def load(config):
-     
-     mlp = PerceptronNN(n_features,2)
-     
--    return mlp
-\ No newline at end of file
-+    return mlp, "feedforward"
-\ No newline at end of file
-diff --git a/__pycache__/basic_feedforward.cpython-39.pyc b/__pycache__/basic_feedforward.cpython-39.pyc
-index f541140..dddecf8 100644
-Binary files a/__pycache__/basic_feedforward.cpython-39.pyc and b/__pycache__/basic_feedforward.cpython-39.pyc differ
-diff --git a/__pycache__/penn_dataset.cpython-39.pyc b/__pycache__/penn_dataset.cpython-39.pyc
-index 0d7a4de..19121eb 100644
-Binary files a/__pycache__/penn_dataset.cpython-39.pyc and b/__pycache__/penn_dataset.cpython-39.pyc differ
-diff --git a/basic_feedforward.py b/basic_feedforward.py
-index 688c282..cdd5158 100644
---- a/basic_feedforward.py
-+++ b/basic_feedforward.py
-@@ -5,21 +5,31 @@ import numpy as np
- 
- from forge import flags
- 
-+# flags.DEFINE_boolean(
-+#     "model_with_dict",
-+#     True,
-+#     "Makes model output predictions in dictionary instead of directly."
-+# )
-+
- class PerceptronNN(nn.Module):
-     def __init__(self, input_size, num_labels):
-         super(PerceptronNN, self).__init__()
-         # Define the layers
-         self.fc1 = nn.Linear(input_size, 128)  # First dense layer
-         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-+        # self.fc23 = nn.Linear(64,64)
-         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-+        # self.softmax = nn.Softmax(dim=1)
- 
-     def forward(self, x):
-         # Forward pass through the network
-         x = F.relu(self.fc1(x))  # Activation function between layers
-         x = F.relu(self.fc2(x))
-+        # x = F.relu(self.fc23(x))
-         x = F.relu(self.fc3(x))
-         x = self.fc4(x)  # No activation, this will be included in the loss function
-+        # x = self.softmax(x)
-         return x
- 
- def load(config):
-@@ -29,4 +39,4 @@ def load(config):
-     
-     mlp = PerceptronNN(n_features,2)
-     
--    return mlp
-\ No newline at end of file
-+    return mlp, "feedforward"
-\ No newline at end of file
-diff --git a/checkpoints/feedforward/1/basic_feedforward.py b/checkpoints/feedforward/1/basic_feedforward.py
-index 688c282..3a65525 100644
---- a/checkpoints/feedforward/1/basic_feedforward.py
-+++ b/checkpoints/feedforward/1/basic_feedforward.py
-@@ -5,6 +5,12 @@ import numpy as np
- 
- from forge import flags
- 
-+# flags.DEFINE_boolean(
-+#     "model_with_dict",
-+#     True,
-+#     "Makes model output predictions in dictionary instead of directly."
-+# )
-+
- class PerceptronNN(nn.Module):
-     def __init__(self, input_size, num_labels):
-         super(PerceptronNN, self).__init__()
-@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-+        self.softmax = nn.Softmax(dim=1)
- 
-     def forward(self, x):
-         # Forward pass through the network
-@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-         x = F.relu(self.fc2(x))
-         x = F.relu(self.fc3(x))
-         x = self.fc4(x)  # No activation, this will be included in the loss function
-+        x = self.softmax(x)
-         return x
- 
- def load(config):
-@@ -29,4 +37,4 @@ def load(config):
-     
-     mlp = PerceptronNN(n_features,2)
-     
--    return mlp
-\ No newline at end of file
-+    return mlp, "feedforward"
-\ No newline at end of file
-diff --git a/checkpoints/feedforward/1/flags.json b/checkpoints/feedforward/1/flags.json
-index 1d000c3..889a6ea 100644
---- a/checkpoints/feedforward/1/flags.json
-+++ b/checkpoints/feedforward/1/flags.json
-@@ -1,9 +1,15 @@
- {
-     "batch_size": 100,
-+    "beta1": 0.9,
-+    "beta2": 0.999,
-+    "cross_validate": false,
-     "data_config": "penn_dataset.py",
-+    "git_commit": "7416bf730b356aabfe0df644240e40948a8196bb",
-     "include_coords": false,
-     "input_size": 39,
--    "learning_rate": 1e-05,
-+    "learning_rate": 0.0001,
-+    "log_train_values": true,
-+    "log_val_test": true,
-     "model_config": "basic_feedforward.py",
-     "n_repeats": 1,
-     "report_loss_every": 50,
-@@ -11,7 +17,10 @@
-     "results_dir": "checkpoints",
-     "resume": false,
-     "run_name": "feedforward",
-+    "save_check_points": 50,
-+    "save_test_predictions": false,
-     "split_seed": 1,
--    "train_epochs": 20,
-+    "total_evaluations": 100,
-+    "train_epochs": 100,
-     "train_split": 0.8
- }
-\ No newline at end of file
-diff --git a/checkpoints/feedforward/1/git_diff.txt b/checkpoints/feedforward/1/git_diff.txt
-index 7b37e6f..ec23707 100644
---- a/checkpoints/feedforward/1/git_diff.txt
-+++ b/checkpoints/feedforward/1/git_diff.txt
-@@ -1 +1,873 @@
--Mon Mar 4 11:45:48 PST 2024
-+Mon Mar 4 16:34:02 PST 2024
-+diff --git a/.DS_Store b/.DS_Store
-+index e2836a8..7e3fa32 100644
-+Binary files a/.DS_Store and b/.DS_Store differ
-+diff --git a/.ipynb_checkpoints/basic_feedforward-checkpoint.py b/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-+index 688c282..0c4bcd1 100644
-+--- a/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-++++ b/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-+@@ -5,6 +5,12 @@ import numpy as np
-+ 
-+ from forge import flags
-+ 
-++flags.DEFINE_boolean(
-++    "model_with_dict",
-++    True,
-++    "Makes model output predictions in dictionary instead of directly."
-++)
-++
-+ class PerceptronNN(nn.Module):
-+     def __init__(self, input_size, num_labels):
-+         super(PerceptronNN, self).__init__()
-+@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-+         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-+         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-+         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-++        self.softmax = nn.Softmax(dim=1)
-+ 
-+     def forward(self, x):
-+         # Forward pass through the network
-+@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-+         x = F.relu(self.fc2(x))
-+         x = F.relu(self.fc3(x))
-+         x = self.fc4(x)  # No activation, this will be included in the loss function
-++        x = self.softmax(x)
-+         return x
-+ 
-+ def load(config):
-+@@ -29,4 +37,4 @@ def load(config):
-+     
-+     mlp = PerceptronNN(n_features,2)
-+     
-+-    return mlp
-+\ No newline at end of file
-++    return mlp, "feedforward"
-+\ No newline at end of file
-+diff --git a/__pycache__/basic_feedforward.cpython-39.pyc b/__pycache__/basic_feedforward.cpython-39.pyc
-+index f541140..5ad96de 100644
-+Binary files a/__pycache__/basic_feedforward.cpython-39.pyc and b/__pycache__/basic_feedforward.cpython-39.pyc differ
-+diff --git a/__pycache__/penn_dataset.cpython-39.pyc b/__pycache__/penn_dataset.cpython-39.pyc
-+index 0d7a4de..19121eb 100644
-+Binary files a/__pycache__/penn_dataset.cpython-39.pyc and b/__pycache__/penn_dataset.cpython-39.pyc differ
-+diff --git a/basic_feedforward.py b/basic_feedforward.py
-+index 688c282..3a65525 100644
-+--- a/basic_feedforward.py
-++++ b/basic_feedforward.py
-+@@ -5,6 +5,12 @@ import numpy as np
-+ 
-+ from forge import flags
-+ 
-++# flags.DEFINE_boolean(
-++#     "model_with_dict",
-++#     True,
-++#     "Makes model output predictions in dictionary instead of directly."
-++# )
-++
-+ class PerceptronNN(nn.Module):
-+     def __init__(self, input_size, num_labels):
-+         super(PerceptronNN, self).__init__()
-+@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-+         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-+         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-+         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-++        self.softmax = nn.Softmax(dim=1)
-+ 
-+     def forward(self, x):
-+         # Forward pass through the network
-+@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-+         x = F.relu(self.fc2(x))
-+         x = F.relu(self.fc3(x))
-+         x = self.fc4(x)  # No activation, this will be included in the loss function
-++        x = self.softmax(x)
-+         return x
-+ 
-+ def load(config):
-+@@ -29,4 +37,4 @@ def load(config):
-+     
-+     mlp = PerceptronNN(n_features,2)
-+     
-+-    return mlp
-+\ No newline at end of file
-++    return mlp, "feedforward"
-+\ No newline at end of file
-+diff --git a/checkpoints/feedforward/1/basic_feedforward.py b/checkpoints/feedforward/1/basic_feedforward.py
-+index 688c282..3a65525 100644
-+--- a/checkpoints/feedforward/1/basic_feedforward.py
-++++ b/checkpoints/feedforward/1/basic_feedforward.py
-+@@ -5,6 +5,12 @@ import numpy as np
-+ 
-+ from forge import flags
-+ 
-++# flags.DEFINE_boolean(
-++#     "model_with_dict",
-++#     True,
-++#     "Makes model output predictions in dictionary instead of directly."
-++# )
-++
-+ class PerceptronNN(nn.Module):
-+     def __init__(self, input_size, num_labels):
-+         super(PerceptronNN, self).__init__()
-+@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-+         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-+         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-+         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-++        self.softmax = nn.Softmax(dim=1)
-+ 
-+     def forward(self, x):
-+         # Forward pass through the network
-+@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-+         x = F.relu(self.fc2(x))
-+         x = F.relu(self.fc3(x))
-+         x = self.fc4(x)  # No activation, this will be included in the loss function
-++        x = self.softmax(x)
-+         return x
-+ 
-+ def load(config):
-+@@ -29,4 +37,4 @@ def load(config):
-+     
-+     mlp = PerceptronNN(n_features,2)
-+     
-+-    return mlp
-+\ No newline at end of file
-++    return mlp, "feedforward"
-+\ No newline at end of file
-+diff --git a/checkpoints/feedforward/1/flags.json b/checkpoints/feedforward/1/flags.json
-+index 1d000c3..889a6ea 100644
-+--- a/checkpoints/feedforward/1/flags.json
-++++ b/checkpoints/feedforward/1/flags.json
-+@@ -1,9 +1,15 @@
-+ {
-+     "batch_size": 100,
-++    "beta1": 0.9,
-++    "beta2": 0.999,
-++    "cross_validate": false,
-+     "data_config": "penn_dataset.py",
-++    "git_commit": "7416bf730b356aabfe0df644240e40948a8196bb",
-+     "include_coords": false,
-+     "input_size": 39,
-+-    "learning_rate": 1e-05,
-++    "learning_rate": 0.0001,
-++    "log_train_values": true,
-++    "log_val_test": true,
-+     "model_config": "basic_feedforward.py",
-+     "n_repeats": 1,
-+     "report_loss_every": 50,
-+@@ -11,7 +17,10 @@
-+     "results_dir": "checkpoints",
-+     "resume": false,
-+     "run_name": "feedforward",
-++    "save_check_points": 50,
-++    "save_test_predictions": false,
-+     "split_seed": 1,
-+-    "train_epochs": 20,
-++    "total_evaluations": 100,
-++    "train_epochs": 100,
-+     "train_split": 0.8
-+ }
-+\ No newline at end of file
-+diff --git a/checkpoints/feedforward/1/git_diff.txt b/checkpoints/feedforward/1/git_diff.txt
-+index 7b37e6f..5c561db 100644
-+--- a/checkpoints/feedforward/1/git_diff.txt
-++++ b/checkpoints/feedforward/1/git_diff.txt
-+@@ -1 +1 @@
-+-Mon Mar 4 11:45:48 PST 2024
-++Mon Mar 4 16:34:02 PST 2024
-+diff --git a/checkpoints/feedforward/1/penn_dataset.py b/checkpoints/feedforward/1/penn_dataset.py
-+index aa2f5a0..7f5a4fc 100644
-+--- a/checkpoints/feedforward/1/penn_dataset.py
-++++ b/checkpoints/feedforward/1/penn_dataset.py
-+@@ -15,6 +15,7 @@ from forge import flags
-+ # aspects of data managmement
-+ flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
-+ flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-++flags.DEFINE_boolean("cross_validate",False,"Do K-fold cross-validation")
-+ 
-+ # Job management
-+ # flags.DEFINE_integer("batch size",5,"training batch size")
-+@@ -109,15 +110,15 @@ def load(config):
-+         
-+         # set up training DataLoader
-+         train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, n_train),num_workers=0,shuffle = True)
-++        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
-+ 
-+         # set up test DataLoader
-+         test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, n_test),num_workers=0,shuffle = True)
-++        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
-+ 
-+         # set up val DataLoader
-+         val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, n_val),num_workers=0,shuffle = True)
-++        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-+         
-+ 
-+         dataloaders = {'train':train_loader, 
-+@@ -125,8 +126,12 @@ def load(config):
-+                        'val':val_loader,
-+                        'train_inds':train_ind,
-+                        'test_inds':test_ind,
-+-                       'n_val':n_val
-++                       'n_val':n_val,
-++                       'test_headings':list(HEADINGS[test_ind])
-+                       }
-+         kf_dataloaders.append(dataloaders)
-+ 
-++        if not config.cross_validate:
-++        	break
-++
-+     return kf_dataloaders
-+diff --git a/penn_dataset.py b/penn_dataset.py
-+index aa2f5a0..7f5a4fc 100644
-+--- a/penn_dataset.py
-++++ b/penn_dataset.py
-+@@ -15,6 +15,7 @@ from forge import flags
-+ # aspects of data managmement
-+ flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
-+ flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-++flags.DEFINE_boolean("cross_validate",False,"Do K-fold cross-validation")
-+ 
-+ # Job management
-+ # flags.DEFINE_integer("batch size",5,"training batch size")
-+@@ -109,15 +110,15 @@ def load(config):
-+         
-+         # set up training DataLoader
-+         train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, n_train),num_workers=0,shuffle = True)
-++        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
-+ 
-+         # set up test DataLoader
-+         test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, n_test),num_workers=0,shuffle = True)
-++        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
-+ 
-+         # set up val DataLoader
-+         val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, n_val),num_workers=0,shuffle = True)
-++        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-+         
-+ 
-+         dataloaders = {'train':train_loader, 
-+@@ -125,8 +126,12 @@ def load(config):
-+                        'val':val_loader,
-+                        'train_inds':train_ind,
-+                        'test_inds':test_ind,
-+-                       'n_val':n_val
-++                       'n_val':n_val,
-++                       'test_headings':list(HEADINGS[test_ind])
-+                       }
-+         kf_dataloaders.append(dataloaders)
-+ 
-++        if not config.cross_validate:
-++        	break
-++
-+     return kf_dataloaders
-+diff --git a/testing.ipynb b/testing.ipynb
-+index e5a167b..a928d8d 100644
-+--- a/testing.ipynb
-++++ b/testing.ipynb
-+@@ -2,7 +2,7 @@
-+  "cells": [
-+   {
-+    "cell_type": "code",
-+-   "execution_count": 1,
-++   "execution_count": 2,
-+    "id": "4dee7ff1-01a4-4038-b493-9729ff3693f7",
-+    "metadata": {},
-+    "outputs": [],
-+@@ -23,19 +23,19 @@
-+   },
-+   {
-+    "cell_type": "code",
-+-   "execution_count": 2,
-++   "execution_count": 3,
-+    "id": "cad0fdc8-5c35-4610-bba3-b71e60dc1b98",
-+    "metadata": {},
-+    "outputs": [],
-+    "source": [
-+-    "flags.DEFINE_integer(\"batch_size\", 100, \"Mini-batch size.\")\n",
-++    "flags.DEFINE_integer(\"batch_size\", 10, \"Mini-batch size.\")\n",
-+     "\n",
-+     "flags.DEFINE_integer(\"input_size\",39,\"Input shape to model\")"
-+    ]
-+   },
-+   {
-+    "cell_type": "code",
-+-   "execution_count": 3,
-++   "execution_count": 4,
-+    "id": "ce1b936b-8a7c-426e-a3aa-3c1c38f645de",
-+    "metadata": {},
-+    "outputs": [
-+@@ -54,8 +54,8 @@
-+   },
-+   {
-+    "cell_type": "code",
-+-   "execution_count": 9,
-+-   "id": "e862b7e2-57f5-44bf-bcf1-a91160ba66cc",
-++   "execution_count": 5,
-++   "id": "4469cddf-4dac-4468-be88-241d440401c3",
-+    "metadata": {},
-+    "outputs": [
-+     {
-+@@ -67,35 +67,89 @@
-+     }
-+    ],
-+    "source": [
-+-    "model = fet.load(\"basic_feedforward.py\",config)"
-++    "model,modelname = fet.load(\"basic_feedforward.py\",config)"
-+    ]
-+   },
-+   {
-+    "cell_type": "code",
-+-   "execution_count": 10,
-+-   "id": "07e0b160-d5d1-4e54-b4a7-ccaf2224598a",
-++   "execution_count": 17,
-++   "id": "7c9a9fe9-f5e8-456a-b964-4be13027725b",
-+    "metadata": {},
-+    "outputs": [
-+     {
-+      "data": {
-+       "text/plain": [
-+-       "PerceptronNN(\n",
-+-       "  (fc1): Linear(in_features=39, out_features=128, bias=True)\n",
-+-       "  (fc2): Linear(in_features=128, out_features=64, bias=True)\n",
-+-       "  (fc3): Linear(in_features=64, out_features=64, bias=True)\n",
-+-       "  (fc4): Linear(in_features=64, out_features=2, bias=True)\n",
-+-       ")"
-++       "['aaa0060', 'aaa0061', 'aaa0069', 'aaa_0059']"
-+       ]
-+      },
-+-     "execution_count": 10,
-++     "execution_count": 17,
-+      "metadata": {},
-+      "output_type": "execute_result"
-+     }
-+    ],
-+    "source": [
-+-    "model"
-++    "loaddat[0]['test_headings']"
-++   ]
-++  },
-++  {
-++   "cell_type": "code",
-++   "execution_count": 19,
-++   "id": "e862b7e2-57f5-44bf-bcf1-a91160ba66cc",
-++   "metadata": {},
-++   "outputs": [
-++    {
-++     "name": "stdout",
-++     "output_type": "stream",
-++     "text": [
-++      "Keys: ['cross_entropy', 'time']\n"
-++     ]
-++    }
-++   ],
-++   "source": [
-++    "import h5py\n",
-++    "\n",
-++    "file_path = \"./checkpoints/feedforward/2/data_fold1/results_dict.h5\"\n",
-++    "# Replace 'your_file.h5' with the actual path to your file\n",
-++    "f =  h5py.File(file_path, 'r') \n",
-++    "\n",
-++    "    # Get information about the data stored in the file\n",
-++    "print(\"Keys:\", list(f.keys()))  # List the top-level datasets and groups\n",
-++    "\n",
-++    "    # # Access a dataset by its name\n",
-++    "    # dataset_name = \"your_dataset_name\"\n",
-++    "    # if dataset_name in f:\n",
-++    "    #     dataset = f[dataset_name]\n",
-++    "    #     print(\"Dataset shape:\", dataset.shape)\n",
-++    "    #     print(\"Dataset dtype:\", dataset.dtype)\n",
-++    "\n",
-++    "    #     # Access the data as a NumPy array\n",
-++    "    #     data = dataset[:]  # Read the entire dataset\n",
-++    "\n",
-++    "    #     # You can now work with the data as needed, for example:\n",
-++    "    #     # Perform calculations, visualizations, etc.\n",
-++    "    # else:\n",
-++    "    #     print(f\"Dataset '{dataset_name}' not found in the file.\")"
-+    ]
-+   },
-++  {
-++   "cell_type": "code",
-++   "execution_count": 13,
-++   "id": "07e0b160-d5d1-4e54-b4a7-ccaf2224598a",
-++   "metadata": {},
-++   "outputs": [
-++    {
-++     "data": {
-++      "text/plain": [
-++       "<generator object Module.parameters at 0x3007207b0>"
-++      ]
-++     },
-++     "execution_count": 13,
-++     "metadata": {},
-++     "output_type": "execute_result"
-++    }
-++   ],
-++   "source": []
-++  },
-+   {
-+    "cell_type": "code",
-+    "execution_count": null,
-+diff --git a/train.py b/train.py
-+index c266102..516bfa9 100644
-+--- a/train.py
-++++ b/train.py
-+@@ -1,49 +1,440 @@
-+ from os import path as osp
-++import os
-++import numpy as np
-++import time
-+ 
-+ import torch
-++import torch.nn as nn
-+ import torch.nn.functional as F
-+ import torch.optim as optim
-+-
-+-import numpy as np
-++from torch.utils.tensorboard import SummaryWriter
-+ 
-+ import forge
-+ from forge import flags
-+ import forge.experiment_tools as fet
-+ 
-++from train_tools import (
-++	log_tensorboard,
-++	parse_reports,
-++	parse_reports_cpu,
-++	print_reports,
-++	load_checkpoint,
-++	save_checkpoint,
-++	nested_to,
-++	param_count,
-++)
-++
-++from copy import deepcopy
-++from attrdict import AttrDict
-++import deepdish as dd
-++from tqdm import tqdm
-++
-++# For reproducibility while researching, but might affect speed!
-++torch.backends.cudnn.deterministic = True
-++torch.backends.cudnn.benchmark = False
-++torch.manual_seed(0)
-++
-+ 
-+ # Job config
-+ flags.DEFINE_string('data_config', 'penn_dataset.py',
-+-                    'Path to a data config file.')
-++					'Path to a data config file.')
-+ flags.DEFINE_string('model_config', 'basic_feedforward.py',
-+-                    'Path to a model config file.')
-++					'Path to a model config file.')
-+ flags.DEFINE_string('results_dir', 'checkpoints',
-+-                    'Top directory for all experimental results.')
-++					'Top directory for all experimental results.')
-+ flags.DEFINE_string('run_name', 'feedforward',
-+-                    'Name of this job and name of results folder.')
-++					'Name of this job and name of results folder.')
-+ flags.DEFINE_boolean('resume', False, 'Tries to resume a job if True.')
-+ 
-+ # Logging config
-+ flags.DEFINE_integer('report_loss_every', 50,
-+-                     'Number of iterations between reporting minibatch loss.')
-+-flags.DEFINE_integer('train_epochs', 20, 'Maximum number of training epochs.')
-++					 'Number of iterations between reporting minibatch loss.')
-++flags.DEFINE_integer('train_epochs', 100, 'Maximum number of training epochs.')
-++flags.DEFINE_integer(
-++	"save_check_points",
-++	50,
-++	"frequency with which to save checkpoints, in number of epoches.",
-++)
-++flags.DEFINE_boolean("log_train_values", True, "Logs train values if True.")
-++flags.DEFINE_integer(
-++	"total_evaluations",
-++	100,
-++	"Maximum number of evaluations on test and validation data during training.",
-++)
-++flags.DEFINE_boolean(
-++	"save_test_predictions",
-++	False,
-++	"Makes and saves test predictions on one or more test sets (e.g. 5-step and 100-step predictions) at the end of training.",
-++)
-++flags.DEFINE_boolean(
-++    "log_val_test", True, "Turns off computation of validation and test errors."
-++)
-+ 
-+ # Experiment config
-+ flags.DEFINE_integer('batch_size', 100, 'Mini-batch size.')
-+-flags.DEFINE_float('learning_rate', 1e-5, 'SGD learning rate.')
-++flags.DEFINE_float("learning_rate", 1e-4, "Adam learning rate.")
-++flags.DEFINE_float("beta1", 0.9, "Adam Beta 1 parameter")
-++flags.DEFINE_float("beta2", 0.999, "Adam Beta 2 parameter")
-+ 
-+ # Specific config options
-+ flags.DEFINE_integer("input_size",39,"Input shape to model")
-+ 
-++#########################################################################################
-++
-++def evaluate(model, loader, device,fold = 0,headings = [],loss_func = nn.CrossEntropyLoss()):
-++	reports = None
-++	for data in loader:
-++		labels = data['label']
-++		inputs = nested_to(data['data'],device,torch.float32)
-++		
-++		labels_tensor = torch.zeros((len(labels), 2))
-++		for i, label in enumerate(labels):
-++			labels_tensor[i, label] = 1
-++
-++		model_output = model(inputs) # evaluate model
-++
-++		loss = loss_func(model_output, labels_tensor) # compute loss
-++		outputs = AttrDict({"loss": loss, "prediction": model_output,'data_fold':fold})
-++		outputs.reports = AttrDict({"cross_entropy": loss})
-++
-++		if reports is None:
-++			reports = {k: v.detach().clone().cpu() for k, v in outputs.reports.items()}
-++		else:
-++			for k, v in outputs.reports.items():
-++				reports[k] += v.detach().clone().cpu()
-++
-++	for k, v in reports.items():
-++		reports[k] = v / len(
-++			loader
-++		)  # SZ: note this can be slightly incorrect if mini-batch sizes vary (if batch_size doesn't divide train_size), but approximately correct.
-++
-++	# reports['test_headings'] = np.array(headings)
-++
-++	return reports
-++
-++def main():
-++
-++	config = forge.config()
-++
-++	# Set device
-++	if torch.cuda.is_available():
-++		device = f"cuda:{config.device}"
-++		torch.cuda.set_device(device)
-++	else:
-++		device = "cpu" # can change this to MPS on M1 Macs
-++
-++	# Load data
-++	data_name = "penn_data"
-++	kfold_loaders = fet.load(config.data_config, config)
-++
-++	# Load model
-++	model,model_name = fet.load(config.model_config, config)
-++	model = model.to(device)
-++
-++	loss_func = nn.CrossEntropyLoss()
-++
-++	# Prepare environment
-++	params_in_run_name = [
-++		("batch_size", "bs"),
-++		("learning_rate", "lr"),
-++		("n_train", "ntrain")
-++	]
-++
-++	run_name = ""  # config.run_name
-++	for config_param in params_in_run_name:
-++		attr = config_param[0]
-++		abbrev = config_param[1]
-++
-++		if hasattr(config, attr):
-++			run_name += abbrev
-++			run_name += str(getattr(config, attr))
-++			run_name += "_"
-++
-++	results_folder_name = osp.join(
-++		data_name,
-++		model_name,
-++		config.run_name,
-++		run_name,
-++	)
-++
-++	# Prepare environment
-++	logdir = osp.join(config.results_dir, config.run_name)
-++	logdir, resume_checkpoint = fet.init_checkpoint(
-++		logdir, config.data_config, config.model_config, config.resume)
-++
-++	print("Checkpoint directory:",logdir)
-++
-++	# Print flags
-++	fet.print_flags()
-++	# Print model info
-++	print(model)
-++
-++	# Setup optimizer
-++	model_params = model.parameters()
-++	opt_learning_rate = config.learning_rate
-++	model_opt = torch.optim.Adam(
-++		model_params, lr=opt_learning_rate, betas=(config.beta1, config.beta2)
-++	)
-++	print("Model Optimizer:")
-++	print(model_opt)
-++
-++	# Try to restore model and optimizer from checkpoint
-++	if resume_checkpoint is not None:
-++		start_epoch = load_checkpoint(resume_checkpoint, model, model_opt)
-++	else:
-++		start_epoch = 1
-++
-++	n_folds = len(kfold_loaders)
-++	print("Doing {}-fold cross-validation.".format(n_folds))
-++
-++	# KFOLD TRAINING LOOP
-++	for k,loader_k in enumerate(kfold_loaders): # loop over data splits
-++
-++		print("Training fold {}...".format(k+1))
-++
-++		# load the training data
-++		train_loader = loader_k["train"]
-++		n_train = len(train_loader.dataset)
-++		train_batch_size = train_loader.batch_size
-++
-++		# load testing, validation
-++		test_loader = loader_k["test"]
-++		n_test = len(test_loader.dataset)
-++		val_loader = loader_k["val"]
-++		n_val = len(val_loader.dataset)
-++		
-++		# create folder for this data split
-++		fold_dir = osp.join(logdir,"data_fold{}".format(k+1))
-++		fold_dir_exists = osp.exists(fold_dir)
-++		if not fold_dir_exists:
-++			if config.resume:
-++				raise ValueError("Can't resume when the checkpoint/fold dir '{}' doesn't exist.".format(fold_dir))
-++			else:
-++				os.makedirs(fold_dir)
-++		checkpoint_name = osp.join(fold_dir, 'model_fold{}.ckpt'.format(k+1))
-++
-++		# keep track of which data is test data for a given Kfold data split
-++		test_headings = loader_k['test_headings']
-++		headingsFile = osp.join(fold_dir,"test_headings.txt")
-++		with open(headingsFile,'w') as headfile:
-++			for heading in test_headings:
-++				headfile.write(heading+'\n')
-++
-++		# print(checkpoint_name)
-++
-++		train_iter = (start_epoch - 1) * (
-++		len(train_loader.dataset) // train_batch_size
-++		) + 1
-++
-++		print("Starting training at epoch = {}, iter = {}".format(start_epoch, train_iter))
-++
-++		# Setup tensorboard writing
-++		summary_writer = SummaryWriter(logdir)
-++
-++		train_reports = []
-++		report_all = {}
-++		report_all_val = {}
-++
-++		# Saving model at epoch 0 before training
-++		print("saving model at epoch 0 before training ... ")
-++		save_checkpoint(checkpoint_name, 0, model, model_opt, loss=0.0)
-++		print("finished saving model at epoch 0 before training")
-++
-++		num_params = param_count(model)
-++		print(f"Number of model parameters: {num_params}")
-++
-++		# Training
-++		start_t = time.time()
-++
-++		total_train_iters = len(train_loader) * config.train_epochs
-++		iters_per_eval = max(1, int(total_train_iters / config.total_evaluations))
-++		# print('batch',train_batch_size)
-++		# print('ntrain',n_train)
-++		# assert (
-++		# 	n_train % min(train_batch_size, n_train) == 0
-++		# ), "Batch size doesn't divide dataset size. Can be inaccurate for loss computation (see below)."
-++
-++		training_failed = False
-++		best_val_loss_so_far = 1e7
-++
-++		for epoch in tqdm(range(start_epoch, config.train_epochs + 1)):
-++			model.train()
-++
-++			for batch_idx, data_dict in enumerate(train_loader): # Loop over batched data
-++
-++				labels = data_dict['label']
-++				data = data_dict['data']
-++
-++				# send data to device
-++				data = nested_to(data,device,torch.float32)
-++				# One-hot encode the data labels
-++				labels_tensor = torch.zeros((len(labels), 2))
-++				for i, label in enumerate(labels):
-++					labels_tensor[i, label] = 1
-++
-++				model_output = model(data) # evaluate model
-++
-++				loss = loss_func(model_output, labels_tensor) # compute loss
-++				outputs = AttrDict({"loss": loss, "prediction": model_output})
-++				outputs.reports = AttrDict({"cross_entropy": loss})
-++
-++				if torch.isnan(outputs.loss): # check for failure in training
-++					if not training_failed:
-++						epoch_of_nan = epoch
-++					if (epoch > epoch_of_nan + 1) and training_failed:
-++						raise ValueError("Loss Nan-ed.")
-++					training_failed = True
-++
-++				model_opt.zero_grad()
-++				outputs.loss.backward(retain_graph=False)
-++
-++				model_opt.step() # move optimizer forward
-++
-++				train_reports.append(parse_reports_cpu(outputs.reports))
-++
-++				if config.log_train_values:
-++					reports = parse_reports(outputs.reports)
-++					if batch_idx % config.report_loss_every == 0:
-++						log_tensorboard(summary_writer, train_iter, reports, "train/")
-++						print_reports(
-++							reports,
-++							start_t,
-++							epoch,
-++							batch_idx,
-++							len(train_loader.dataset) // train_batch_size,
-++							prefix="train",
-++						)
-++						log_tensorboard(
-++							summary_writer,
-++							train_iter,
-++							{"lr": model_opt.param_groups[0]["lr"]},
-++							"hyperparams/",
-++						)
-++				# Logging and evaluation
-++				if (
-++					train_iter % iters_per_eval == 0 or (train_iter == total_train_iters)
-++				) and config.log_val_test:  # batch_idx % config.evaluate_every == 0:
-++					model.eval()
-++					with torch.no_grad():
-++						reports = evaluate(model, test_loader, device,fold = k,headings = loader_k['test_headings'])
-++						# print("REPORTS",reports)
-++						reports = parse_reports(reports)
-++						reports["time"] = time.time() - start_t
-++						if report_all == {}:
-++							report_all = deepcopy(reports)
-++
-++							for d in reports.keys():
-++								report_all[d] = [report_all[d]]
-++						else:
-++							for d in reports.keys():
-++								report_all[d].append(reports[d])
-++
-++						log_tensorboard(summary_writer, train_iter, reports, "test/")
-++						print_reports(
-++							reports,
-++							start_t,
-++							epoch,
-++							batch_idx,
-++							len(train_loader.dataset) // config.batch_size,
-++							prefix="test",
-++						)
-++
-++						# repeat for validation data
-++						reports = evaluate(model, val_loader, device,fold = k,headings = loader_k['test_headings'])
-++						reports = parse_reports(reports)
-++						reports["time"] = time.time() - start_t
-++						if report_all_val == {}:
-++							report_all_val = deepcopy(reports)
-++
-++							for d in reports.keys():
-++								report_all_val[d] = [report_all_val[d]]
-++						else:
-++							for d in reports.keys():
-++								report_all_val[d].append(reports[d])
-++
-++						log_tensorboard(summary_writer, train_iter, reports, "val/")
-++						print_reports(
-++							reports,
-++							start_t,
-++							epoch,
-++							batch_idx,
-++							len(train_loader.dataset) // config.batch_size,
-++							prefix="val",
-++						)
-++
-++						if report_all_val["cross_entropy"][-1] < best_val_loss_so_far:
-++							save_checkpoint(
-++								checkpoint_name,
-++								f"early_stop",
-++								model,
-++								model_opt,
-++								loss=outputs.loss,
-++							)
-++							best_val_loss_so_far = report_all_val["cross_entropy"][-1]
-++
-++					model.train()
-++
-++				train_iter += 1
-++
-++			if epoch % config.save_check_points == 0:
-++				save_checkpoint(
-++					checkpoint_name, train_iter, model, model_opt, loss=outputs.loss
-++				)
-++
-++		dd.io.save(fold_dir + "/results_dict_train.h5", train_reports)
-++		dd.io.save(fold_dir + "/results_dict.h5", report_all)
-++		dd.io.save(fold_dir + "/results_dict_val.h5", report_all_val)
-++
-++	# always save final model
-++	save_checkpoint(checkpoint_name, train_iter, model, model_opt, loss=outputs.loss)
-++
-++	
-++	if config.save_test_predictions:
-++		pass
-++		# print("Starting to make model predictions on test sets for *final model*.")
-++		# for chunk_len in [5, 100]:
-++		#     start_t_preds = time.time()
-++		#     data_config = SimpleNamespace(
-++		#         **{
-++		#             **config.__dict__["__flags"],
-++		#             **{"chunk_len": chunk_len, "batch_size": 500},
-++		#         }
-++		#     )
-++		#     dataloaders, data_name = fet.load(config.data_config, config=data_config)
-++		#     test_loader_preds = dataloaders["test"]
-++
-++		#     torch.cuda.empty_cache()
-++		#     with torch.no_grad():
-++		#         preds = []
-++		#         true = []
-++		#         num_datapoints = 0
-++		#         for idx, d in enumerate(test_loader_preds):
-++		#             true.append(d[-1])
-++		#             d = nested_to(d, device, torch.float32)
-++		#             outputs = model(d)
-++
-++		#             pred_zs = outputs.prediction
-++		#             preds.append(pred_zs)
-++
-++		#             num_datapoints += len(pred_zs)
-++
-++		#             if num_datapoints >= 2000:
-++		#                 break
-+ 
-+-config = forge.config()
-++		#         preds = torch.cat(preds, dim=0).cpu()
-++		#         true = torch.cat(true, dim=0).cpu()
-+ 
-+-# Prepare environment
-+-logdir = osp.join(config.results_dir, config.run_name)
-+-logdir, resume_checkpoint = fet.init_checkpoint(
-+-    logdir, config.data_config, config.model_config, config.resume)
-+-checkpoint_name = osp.join(logdir, 'model.ckpt')
-++		#         save_dir = osp.join(logdir, f"traj_preds_{chunk_len}_steps_2k_test.pt")
-++		#         torch.save(preds, save_dir)
-+ 
-++		#         save_dir = osp.join(logdir, f"traj_true_{chunk_len}_steps_2k_test.pt")
-++		#         torch.save(true, save_dir)
-+ 
-+-print(logdir)
-++		#         print(
-++		#             f"Completed making test predictions for chunk_len = {chunk_len} in {time.time() - start_t_preds:.2f} seconds."
-++		#         )	
-++		
-+ 
-++if __name__ == "__main__":
-++	main()
-+ 
-diff --git a/checkpoints/feedforward/1/penn_dataset.py b/checkpoints/feedforward/1/penn_dataset.py
-index aa2f5a0..7f5a4fc 100644
---- a/checkpoints/feedforward/1/penn_dataset.py
-+++ b/checkpoints/feedforward/1/penn_dataset.py
-@@ -15,6 +15,7 @@ from forge import flags
- # aspects of data managmement
- flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
- flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-+flags.DEFINE_boolean("cross_validate",False,"Do K-fold cross-validation")
- 
- # Job management
- # flags.DEFINE_integer("batch size",5,"training batch size")
-@@ -109,15 +110,15 @@ def load(config):
-         
-         # set up training DataLoader
-         train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, n_train),num_workers=0,shuffle = True)
-+        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
- 
-         # set up test DataLoader
-         test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, n_test),num_workers=0,shuffle = True)
-+        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
- 
-         # set up val DataLoader
-         val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, n_val),num_workers=0,shuffle = True)
-+        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-         
- 
-         dataloaders = {'train':train_loader, 
-@@ -125,8 +126,12 @@ def load(config):
-                        'val':val_loader,
-                        'train_inds':train_ind,
-                        'test_inds':test_ind,
--                       'n_val':n_val
-+                       'n_val':n_val,
-+                       'test_headings':list(HEADINGS[test_ind])
-                       }
-         kf_dataloaders.append(dataloaders)
- 
-+        if not config.cross_validate:
-+        	break
-+
-     return kf_dataloaders
-diff --git a/georgehulsey_2024.pdf b/georgehulsey_2024.pdf
-deleted file mode 100644
-index 1ab17f6..0000000
-Binary files a/georgehulsey_2024.pdf and /dev/null differ
-diff --git a/penn_dataset.py b/penn_dataset.py
-index aa2f5a0..7f5a4fc 100644
---- a/penn_dataset.py
-+++ b/penn_dataset.py
-@@ -15,6 +15,7 @@ from forge import flags
- # aspects of data managmement
- flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
- flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-+flags.DEFINE_boolean("cross_validate",False,"Do K-fold cross-validation")
- 
- # Job management
- # flags.DEFINE_integer("batch size",5,"training batch size")
-@@ -109,15 +110,15 @@ def load(config):
-         
-         # set up training DataLoader
-         train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, n_train),num_workers=0,shuffle = True)
-+        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
- 
-         # set up test DataLoader
-         test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, n_test),num_workers=0,shuffle = True)
-+        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
- 
-         # set up val DataLoader
-         val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, n_val),num_workers=0,shuffle = True)
-+        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-         
- 
-         dataloaders = {'train':train_loader, 
-@@ -125,8 +126,12 @@ def load(config):
-                        'val':val_loader,
-                        'train_inds':train_ind,
-                        'test_inds':test_ind,
--                       'n_val':n_val
-+                       'n_val':n_val,
-+                       'test_headings':list(HEADINGS[test_ind])
-                       }
-         kf_dataloaders.append(dataloaders)
- 
-+        if not config.cross_validate:
-+        	break
-+
-     return kf_dataloaders
-diff --git a/testing.ipynb b/testing.ipynb
-index e5a167b..0110538 100644
---- a/testing.ipynb
-+++ b/testing.ipynb
-@@ -2,7 +2,7 @@
-  "cells": [
-   {
-    "cell_type": "code",
--   "execution_count": 1,
-+   "execution_count": 4,
-    "id": "4dee7ff1-01a4-4038-b493-9729ff3693f7",
-    "metadata": {},
-    "outputs": [],
-@@ -23,7 +23,7 @@
-   },
-   {
-    "cell_type": "code",
--   "execution_count": 2,
-+   "execution_count": 6,
-    "id": "cad0fdc8-5c35-4610-bba3-b71e60dc1b98",
-    "metadata": {},
-    "outputs": [],
-@@ -35,7 +35,7 @@
-   },
-   {
-    "cell_type": "code",
--   "execution_count": 3,
-+   "execution_count": 7,
-    "id": "ce1b936b-8a7c-426e-a3aa-3c1c38f645de",
-    "metadata": {},
-    "outputs": [
-@@ -54,8 +54,8 @@
-   },
-   {
-    "cell_type": "code",
--   "execution_count": 9,
--   "id": "e862b7e2-57f5-44bf-bcf1-a91160ba66cc",
-+   "execution_count": 5,
-+   "id": "4469cddf-4dac-4468-be88-241d440401c3",
-    "metadata": {},
-    "outputs": [
-     {
-@@ -67,35 +67,98 @@
-     }
-    ],
-    "source": [
--    "model = fet.load(\"basic_feedforward.py\",config)"
-+    "model,modelname = fet.load(\"basic_feedforward.py\",config)"
-    ]
-   },
-   {
-    "cell_type": "code",
--   "execution_count": 10,
--   "id": "07e0b160-d5d1-4e54-b4a7-ccaf2224598a",
-+   "execution_count": 13,
-+   "id": "7c9a9fe9-f5e8-456a-b964-4be13027725b",
-    "metadata": {},
-    "outputs": [
-     {
-      "data": {
-       "text/plain": [
--       "PerceptronNN(\n",
--       "  (fc1): Linear(in_features=39, out_features=128, bias=True)\n",
--       "  (fc2): Linear(in_features=128, out_features=64, bias=True)\n",
--       "  (fc3): Linear(in_features=64, out_features=64, bias=True)\n",
--       "  (fc4): Linear(in_features=64, out_features=2, bias=True)\n",
--       ")"
-+       "array([114170,    904])"
-       ]
-      },
--     "execution_count": 10,
-+     "execution_count": 13,
-      "metadata": {},
-      "output_type": "execute_result"
-     }
-    ],
-    "source": [
--    "model"
-+    "np.bincount(loaddat[0]['train'].dataset.all_labels)"
-    ]
-   },
-+  {
-+   "cell_type": "code",
-+   "execution_count": 1,
-+   "id": "e862b7e2-57f5-44bf-bcf1-a91160ba66cc",
-+   "metadata": {},
-+   "outputs": [
-+    {
-+     "ename": "FileNotFoundError",
-+     "evalue": "[Errno 2] Unable to open file (unable to open file: name = './checkpoints/feedforward/2/data_fold1/results_dict.h5', errno = 2, error message = 'No such file or directory', flags = 0, o_flags = 0)",
-+     "output_type": "error",
-+     "traceback": [
-+      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
-+      "\u001b[0;31mFileNotFoundError\u001b[0m                         Traceback (most recent call last)",
-+      "Cell \u001b[0;32mIn[1], line 5\u001b[0m\n\u001b[1;32m      3\u001b[0m file_path \u001b[38;5;241m=\u001b[39m \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124m./checkpoints/feedforward/2/data_fold1/results_dict.h5\u001b[39m\u001b[38;5;124m\"\u001b[39m\n\u001b[1;32m      4\u001b[0m \u001b[38;5;66;03m# Replace 'your_file.h5' with the actual path to your file\u001b[39;00m\n\u001b[0;32m----> 5\u001b[0m f \u001b[38;5;241m=\u001b[39m  \u001b[43mh5py\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mFile\u001b[49m\u001b[43m(\u001b[49m\u001b[43mfile_path\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[38;5;124;43mr\u001b[39;49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[43m)\u001b[49m \n\u001b[1;32m      7\u001b[0m     \u001b[38;5;66;03m# Get information about the data stored in the file\u001b[39;00m\n\u001b[1;32m      8\u001b[0m \u001b[38;5;28mprint\u001b[39m(\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mKeys:\u001b[39m\u001b[38;5;124m\"\u001b[39m, \u001b[38;5;28mlist\u001b[39m(f\u001b[38;5;241m.\u001b[39mkeys()))\n",
-+      "File \u001b[0;32m/Applications/miniconda3/envs/lietransformer/lib/python3.9/site-packages/h5py/_hl/files.py:562\u001b[0m, in \u001b[0;36mFile.__init__\u001b[0;34m(self, name, mode, driver, libver, userblock_size, swmr, rdcc_nslots, rdcc_nbytes, rdcc_w0, track_order, fs_strategy, fs_persist, fs_threshold, fs_page_size, page_buf_size, min_meta_keep, min_raw_keep, locking, alignment_threshold, alignment_interval, meta_block_size, **kwds)\u001b[0m\n\u001b[1;32m    553\u001b[0m     fapl \u001b[38;5;241m=\u001b[39m make_fapl(driver, libver, rdcc_nslots, rdcc_nbytes, rdcc_w0,\n\u001b[1;32m    554\u001b[0m                      locking, page_buf_size, min_meta_keep, min_raw_keep,\n\u001b[1;32m    555\u001b[0m                      alignment_threshold\u001b[38;5;241m=\u001b[39malignment_threshold,\n\u001b[1;32m    556\u001b[0m                      alignment_interval\u001b[38;5;241m=\u001b[39malignment_interval,\n\u001b[1;32m    557\u001b[0m                      meta_block_size\u001b[38;5;241m=\u001b[39mmeta_block_size,\n\u001b[1;32m    558\u001b[0m                      \u001b[38;5;241m*\u001b[39m\u001b[38;5;241m*\u001b[39mkwds)\n\u001b[1;32m    559\u001b[0m     fcpl \u001b[38;5;241m=\u001b[39m make_fcpl(track_order\u001b[38;5;241m=\u001b[39mtrack_order, fs_strategy\u001b[38;5;241m=\u001b[39mfs_strategy,\n\u001b[1;32m    560\u001b[0m                      fs_persist\u001b[38;5;241m=\u001b[39mfs_persist, fs_threshold\u001b[38;5;241m=\u001b[39mfs_threshold,\n\u001b[1;32m    561\u001b[0m                      fs_page_size\u001b[38;5;241m=\u001b[39mfs_page_size)\n\u001b[0;32m--> 562\u001b[0m     fid \u001b[38;5;241m=\u001b[39m \u001b[43mmake_fid\u001b[49m\u001b[43m(\u001b[49m\u001b[43mname\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mmode\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43muserblock_size\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mfapl\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mfcpl\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mswmr\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43mswmr\u001b[49m\u001b[43m)\u001b[49m\n\u001b[1;32m    564\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;28misinstance\u001b[39m(libver, \u001b[38;5;28mtuple\u001b[39m):\n\u001b[1;32m    565\u001b[0m     \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_libver \u001b[38;5;241m=\u001b[39m libver\n",
-+      "File \u001b[0;32m/Applications/miniconda3/envs/lietransformer/lib/python3.9/site-packages/h5py/_hl/files.py:235\u001b[0m, in \u001b[0;36mmake_fid\u001b[0;34m(name, mode, userblock_size, fapl, fcpl, swmr)\u001b[0m\n\u001b[1;32m    233\u001b[0m     \u001b[38;5;28;01mif\u001b[39;00m swmr \u001b[38;5;129;01mand\u001b[39;00m swmr_support:\n\u001b[1;32m    234\u001b[0m         flags \u001b[38;5;241m|\u001b[39m\u001b[38;5;241m=\u001b[39m h5f\u001b[38;5;241m.\u001b[39mACC_SWMR_READ\n\u001b[0;32m--> 235\u001b[0m     fid \u001b[38;5;241m=\u001b[39m \u001b[43mh5f\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mopen\u001b[49m\u001b[43m(\u001b[49m\u001b[43mname\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mflags\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mfapl\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43mfapl\u001b[49m\u001b[43m)\u001b[49m\n\u001b[1;32m    236\u001b[0m \u001b[38;5;28;01melif\u001b[39;00m mode \u001b[38;5;241m==\u001b[39m \u001b[38;5;124m'\u001b[39m\u001b[38;5;124mr+\u001b[39m\u001b[38;5;124m'\u001b[39m:\n\u001b[1;32m    237\u001b[0m     fid \u001b[38;5;241m=\u001b[39m h5f\u001b[38;5;241m.\u001b[39mopen(name, h5f\u001b[38;5;241m.\u001b[39mACC_RDWR, fapl\u001b[38;5;241m=\u001b[39mfapl)\n",
-+      "File \u001b[0;32mh5py/_objects.pyx:54\u001b[0m, in \u001b[0;36mh5py._objects.with_phil.wrapper\u001b[0;34m()\u001b[0m\n",
-+      "File \u001b[0;32mh5py/_objects.pyx:55\u001b[0m, in \u001b[0;36mh5py._objects.with_phil.wrapper\u001b[0;34m()\u001b[0m\n",
-+      "File \u001b[0;32mh5py/h5f.pyx:102\u001b[0m, in \u001b[0;36mh5py.h5f.open\u001b[0;34m()\u001b[0m\n",
-+      "\u001b[0;31mFileNotFoundError\u001b[0m: [Errno 2] Unable to open file (unable to open file: name = './checkpoints/feedforward/2/data_fold1/results_dict.h5', errno = 2, error message = 'No such file or directory', flags = 0, o_flags = 0)"
-+     ]
-+    }
-+   ],
-+   "source": [
-+    "import h5py\n",
-+    "\n",
-+    "file_path = \"./checkpoints/feedforward/2/data_fold1/results_dict.h5\"\n",
-+    "# Replace 'your_file.h5' with the actual path to your file\n",
-+    "f =  h5py.File(file_path, 'r') \n",
-+    "\n",
-+    "    # Get information about the data stored in the file\n",
-+    "print(\"Keys:\", list(f.keys()))  # List the top-level datasets and groups\n",
-+    "\n",
-+    "    # # Access a dataset by its name\n",
-+    "    # dataset_name = \"your_dataset_name\"\n",
-+    "    # if dataset_name in f:\n",
-+    "    #     dataset = f[dataset_name]\n",
-+    "    #     print(\"Dataset shape:\", dataset.shape)\n",
-+    "    #     print(\"Dataset dtype:\", dataset.dtype)\n",
-+    "\n",
-+    "    #     # Access the data as a NumPy array\n",
-+    "    #     data = dataset[:]  # Read the entire dataset\n",
-+    "\n",
-+    "    #     # You can now work with the data as needed, for example:\n",
-+    "    #     # Perform calculations, visualizations, etc.\n",
-+    "    # else:\n",
-+    "    #     print(f\"Dataset '{dataset_name}' not found in the file.\")"
-+   ]
-+  },
-+  {
-+   "cell_type": "code",
-+   "execution_count": 13,
-+   "id": "07e0b160-d5d1-4e54-b4a7-ccaf2224598a",
-+   "metadata": {},
-+   "outputs": [
-+    {
-+     "data": {
-+      "text/plain": [
-+       "<generator object Module.parameters at 0x3007207b0>"
-+      ]
-+     },
-+     "execution_count": 13,
-+     "metadata": {},
-+     "output_type": "execute_result"
-+    }
-+   ],
-+   "source": []
-+  },
-   {
-    "cell_type": "code",
-    "execution_count": null,
-diff --git a/train.py b/train.py
-index c266102..61a1bb9 100644
---- a/train.py
-+++ b/train.py
-@@ -1,49 +1,458 @@
- from os import path as osp
-+import os
-+import numpy as np
-+import time
- 
- import torch
-+import torch.nn as nn
- import torch.nn.functional as F
- import torch.optim as optim
--
--import numpy as np
-+from torch.utils.tensorboard import SummaryWriter
- 
- import forge
- from forge import flags
- import forge.experiment_tools as fet
- 
-+from train_tools import (
-+	log_tensorboard,
-+	parse_reports,
-+	parse_reports_cpu,
-+	print_reports,
-+	load_checkpoint,
-+	save_checkpoint,
-+	nested_to,
-+	param_count,
-+)
-+
-+from copy import deepcopy
-+from attrdict import AttrDict
-+import deepdish as dd
-+from tqdm import tqdm
-+
-+# For reproducibility while researching, but might affect speed!
-+torch.backends.cudnn.deterministic = True
-+torch.backends.cudnn.benchmark = False
-+torch.manual_seed(0)
-+
- 
- # Job config
- flags.DEFINE_string('data_config', 'penn_dataset.py',
--                    'Path to a data config file.')
-+					'Path to a data config file.')
- flags.DEFINE_string('model_config', 'basic_feedforward.py',
--                    'Path to a model config file.')
-+					'Path to a model config file.')
- flags.DEFINE_string('results_dir', 'checkpoints',
--                    'Top directory for all experimental results.')
--flags.DEFINE_string('run_name', 'feedforward',
--                    'Name of this job and name of results folder.')
-+					'Top directory for all experimental results.')
-+flags.DEFINE_string('run_name', 'hyperparam_testing',
-+					'Name of this job and name of results folder.')
- flags.DEFINE_boolean('resume', False, 'Tries to resume a job if True.')
- 
- # Logging config
- flags.DEFINE_integer('report_loss_every', 50,
--                     'Number of iterations between reporting minibatch loss.')
--flags.DEFINE_integer('train_epochs', 20, 'Maximum number of training epochs.')
-+					 'Number of iterations between reporting minibatch loss.')
-+flags.DEFINE_integer('train_epochs', 30, 'Maximum number of training epochs.')
-+flags.DEFINE_integer(
-+	"save_check_points",
-+	10,
-+	"frequency with which to save checkpoints, in number of epoches.",
-+)
-+flags.DEFINE_boolean("log_train_values", True, "Logs train values if True.")
-+flags.DEFINE_integer(
-+	"total_evaluations",
-+	100,
-+	"Maximum number of evaluations on test and validation data during training.",
-+)
-+flags.DEFINE_boolean(
-+	"save_test_predictions",
-+	False,
-+	"Makes and saves test predictions on one or more test sets (e.g. 5-step and 100-step predictions) at the end of training.",
-+)
-+flags.DEFINE_boolean(
-+    "log_val_test", True, "Turns off computation of validation and test errors."
-+)
-+
-+flags.DEFINE_boolean('use_mps',False,"Use Metal Performance Shaders (M1) for training.")
- 
- # Experiment config
- flags.DEFINE_integer('batch_size', 100, 'Mini-batch size.')
--flags.DEFINE_float('learning_rate', 1e-5, 'SGD learning rate.')
-+flags.DEFINE_float("learning_rate", 1e-3, "Adam learning rate.")
-+flags.DEFINE_float("beta1", 0.9, "Adam Beta 1 parameter")
-+flags.DEFINE_float("beta2", 0.999, "Adam Beta 2 parameter")
- 
- # Specific config options
- flags.DEFINE_integer("input_size",39,"Input shape to model")
- 
-+#########################################################################################
-+
-+def evaluate(model, loader, device,fold = 0,headings = [],loss_func = nn.CrossEntropyLoss()):
-+	# this function does not account for class weights when evaluating cross-entropy loss.
-+	# however, they are accounted for when evaluating training loss
-+	reports = None
-+	for data in loader:
-+		labels = data['label']
-+		inputs = nested_to(data['data'],device,torch.float32)
-+		
-+		labels_tensor = torch.zeros((len(labels), 2))
-+		for i, label in enumerate(labels):
-+			labels_tensor[i, label] = 1
-+
-+		model_output = model(inputs) # evaluate model
-+
-+		loss = loss_func(model_output, labels_tensor) # compute loss
-+		outputs = AttrDict({"loss": loss, "prediction": model_output,'data_fold':fold})
-+		outputs.reports = AttrDict({"cross_entropy": loss})
-+
-+		if reports is None:
-+			reports = {k: v.detach().clone().cpu() for k, v in outputs.reports.items()}
-+		else:
-+			for k, v in outputs.reports.items():
-+				reports[k] += v.detach().clone().cpu()
-+
-+	for k, v in reports.items():
-+		reports[k] = v / len(
-+			loader
-+		)  # SZ: note this can be slightly incorrect if mini-batch sizes vary (if batch_size doesn't divide train_size), but approximately correct.
-+
-+	# reports['test_headings'] = np.array(headings)
-+
-+	return reports
-+
-+def main():
-+
-+	config = forge.config()
-+
-+	# Set device
-+	if torch.cuda.is_available():
-+		device = f"cuda:{config.device}"
-+		torch.cuda.set_device(device)
-+	else:
-+		device = "cpu" # can change this to MPS on M1 Macs
-+
-+	if config.use_mps:
-+		device = "mps"
-+
-+	# Load data
-+	data_name = "penn_data"
-+	kfold_loaders = fet.load(config.data_config, config)
-+
-+	# Load model
-+	model,model_name = fet.load(config.model_config, config)
-+	model = model.to(device)
-+
-+	# Prepare environment
-+	params_in_run_name = [
-+		("batch_size", "bs"),
-+		("learning_rate", "lr"),
-+		("n_train", "ntrain"),
-+		("include_coords",'inclx'),
-+		("input_size",'inpsize'),
-+		("cross_validate",'crval'),
-+		("train_epochs",'n_epochs'),
-+	]
-+
-+	run_name = ""  # config.run_name
-+	for config_param in params_in_run_name:
-+		attr = config_param[0]
-+		abbrev = config_param[1]
-+
-+		if hasattr(config, attr):
-+			run_name += abbrev
-+			run_name += str(getattr(config, attr))
-+			run_name += "_"
-+
-+	results_folder_name = osp.join(
-+		data_name,
-+		model_name,
-+		config.run_name,
-+		run_name,
-+	)
-+
-+	# Prepare environment
-+	logdir = osp.join(config.results_dir, results_folder_name.replace(".", "_"))
-+	logdir, resume_checkpoint = fet.init_checkpoint(
-+		logdir, config.data_config, config.model_config, config.resume)
-+
-+	print("Checkpoint directory:",logdir)
-+
-+	# Print flags
-+	fet.print_flags()
-+	# Print model info
-+	print(model)
-+
-+	# Setup optimizer
-+	model_params = model.parameters()
-+	opt_learning_rate = config.learning_rate
-+	model_opt = torch.optim.Adam(
-+		model_params, lr=opt_learning_rate, betas=(config.beta1, config.beta2)
-+	)
-+	# scheduler = torch.optim.lr_scheduler.StepLR(model_opt, step_size=10, gamma=0.5)
-+	print("Model Optimizer:")
-+	print(model_opt)
-+
-+	# Try to restore model and optimizer from checkpoint
-+	if resume_checkpoint is not None:
-+		start_epoch = load_checkpoint(resume_checkpoint, model, model_opt)
-+	else:
-+		start_epoch = 1
-+
-+	n_folds = len(kfold_loaders)
-+	print("Doing {}-fold cross-validation.".format(n_folds))
-+
-+	# KFOLD TRAINING LOOP
-+	for k,loader_k in enumerate(kfold_loaders): # loop over data splits
-+
-+		print("Training fold {}...".format(k+1))
-+
-+		# load the training data
-+		train_loader = loader_k["train"]
-+		n_train = len(train_loader.dataset)
-+		train_batch_size = train_loader.batch_size
-+
-+		# load testing, validation
-+		test_loader = loader_k["test"]
-+		n_test = len(test_loader.dataset)
-+		val_loader = loader_k["val"]
-+		n_val = len(val_loader.dataset)
-+
-+		train_class_counts = np.bincount(train_loader.dataset.all_labels)
-+		train_total_counts = sum(train_class_counts)
-+		class_weight = torch.tensor(1.0 / train_class_counts) * train_total_counts / 2.0
-+
-+		loss_func = nn.CrossEntropyLoss(weight = class_weight) # define reweighted loss function
-+				
-+		# create folder for this data split
-+		fold_dir = osp.join(logdir,"data_fold{}".format(k+1))
-+		fold_dir_exists = osp.exists(fold_dir)
-+		if not fold_dir_exists:
-+			if config.resume:
-+				raise ValueError("Can't resume when the checkpoint/fold dir '{}' doesn't exist.".format(fold_dir))
-+			else:
-+				os.makedirs(fold_dir)
-+		checkpoint_name = osp.join(fold_dir, 'model_fold{}.ckpt'.format(k+1))
-+
-+		# keep track of which data is test data for a given Kfold data split
-+		test_headings = loader_k['test_headings']
-+		headingsFile = osp.join(fold_dir,"test_headings.txt")
-+		with open(headingsFile,'w') as headfile:
-+			for heading in test_headings:
-+				headfile.write(heading+'\n')
-+
-+		# print(checkpoint_name)
-+
-+		train_iter = (start_epoch - 1) * (
-+		len(train_loader.dataset) // train_batch_size
-+		) + 1
-+
-+		print("Starting training at epoch = {}, iter = {}".format(start_epoch, train_iter))
-+
-+		# Setup tensorboard writing
-+		summary_writer = SummaryWriter(logdir)
-+
-+		train_reports = []
-+		report_all = {}
-+		report_all_val = {}
-+
-+		# Saving model at epoch 0 before training
-+		print("saving model at epoch 0 before training ... ")
-+		save_checkpoint(checkpoint_name, 0, model, model_opt, loss=0.0)
-+		print("finished saving model at epoch 0 before training")
-+
-+		num_params = param_count(model)
-+		print(f"Number of model parameters: {num_params}")
-+
-+		# Training
-+		start_t = time.time()
-+
-+		total_train_iters = len(train_loader) * config.train_epochs
-+		iters_per_eval = max(1, int(total_train_iters / config.total_evaluations))
-+		# print('batch',train_batch_size)
-+		# print('ntrain',n_train)
-+		# assert (
-+		# 	n_train % min(train_batch_size, n_train) == 0
-+		# ), "Batch size doesn't divide dataset size. Can be inaccurate for loss computation (see below)."
-+
-+		training_failed = False
-+		best_val_loss_so_far = 1e7
-+
-+		for epoch in tqdm(range(start_epoch, config.train_epochs + 1)):
-+			model.train()
-+
-+			for batch_idx, data_dict in enumerate(train_loader): # Loop over batched data
-+
-+				labels = data_dict['label']
-+				data = data_dict['data']
-+
-+				# send data to device
-+				data = nested_to(data,device,torch.float32)
-+				# One-hot encode the data labels
-+				labels_tensor = torch.zeros((len(labels), 2))
-+				for i, label in enumerate(labels):
-+					labels_tensor[i, label] = 1
-+
-+				model_output = model(data) # evaluate model
-+
-+				loss = loss_func(model_output, labels_tensor) # compute loss
-+				outputs = AttrDict({"loss": loss, "prediction": model_output})
-+				outputs.reports = AttrDict({"cross_entropy": loss})
-+
-+				if torch.isnan(outputs.loss): # check for failure in training
-+					if not training_failed:
-+						epoch_of_nan = epoch
-+					if (epoch > epoch_of_nan + 1) and training_failed:
-+						raise ValueError("Loss Nan-ed.")
-+					training_failed = True
-+
-+				model_opt.zero_grad()
-+				outputs.loss.backward(retain_graph=False)
-+
-+				model_opt.step() # move optimizer forward
-+
-+				train_reports.append(parse_reports_cpu(outputs.reports))
-+
-+				if config.log_train_values:
-+					reports = parse_reports(outputs.reports)
-+					if batch_idx % config.report_loss_every == 0:
-+						log_tensorboard(summary_writer, train_iter, reports, "train/")
-+						print_reports(
-+							reports,
-+							start_t,
-+							epoch,
-+							batch_idx,
-+							len(train_loader.dataset) // train_batch_size,
-+							prefix="train",
-+						)
-+						log_tensorboard(
-+							summary_writer,
-+							train_iter,
-+							{"lr": model_opt.param_groups[0]["lr"]},
-+							"hyperparams/",
-+						)
-+				# Logging and evaluation
-+				if (
-+					train_iter % iters_per_eval == 0 or (train_iter == total_train_iters)
-+				) and config.log_val_test:  # batch_idx % config.evaluate_every == 0:
-+					model.eval()
-+					with torch.no_grad():
-+						reports = evaluate(model, test_loader, device,fold = k,headings = loader_k['test_headings'],loss_func = loss_func)
-+						# print("REPORTS",reports)
-+						reports = parse_reports(reports)
-+						reports["time"] = time.time() - start_t
-+						if report_all == {}:
-+							report_all = deepcopy(reports)
-+
-+							for d in reports.keys():
-+								report_all[d] = [report_all[d]]
-+						else:
-+							for d in reports.keys():
-+								report_all[d].append(reports[d])
-+
-+						log_tensorboard(summary_writer, train_iter, reports, "test/")
-+						print_reports(
-+							reports,
-+							start_t,
-+							epoch,
-+							batch_idx,
-+							len(train_loader.dataset) // config.batch_size,
-+							prefix="test",
-+						)
-+
-+						# repeat for validation data
-+						reports = evaluate(model, val_loader, device,fold = k,headings = loader_k['test_headings'])
-+						reports = parse_reports(reports)
-+						reports["time"] = time.time() - start_t
-+						if report_all_val == {}:
-+							report_all_val = deepcopy(reports)
-+
-+							for d in reports.keys():
-+								report_all_val[d] = [report_all_val[d]]
-+						else:
-+							for d in reports.keys():
-+								report_all_val[d].append(reports[d])
-+
-+						log_tensorboard(summary_writer, train_iter, reports, "val/")
-+						print_reports(
-+							reports,
-+							start_t,
-+							epoch,
-+							batch_idx,
-+							len(train_loader.dataset) // config.batch_size,
-+							prefix="val",
-+						)
-+
-+						if report_all_val["cross_entropy"][-1] < best_val_loss_so_far:
-+							save_checkpoint(
-+								checkpoint_name,
-+								f"early_stop",
-+								model,
-+								model_opt,
-+								loss=outputs.loss,
-+							)
-+							best_val_loss_so_far = report_all_val["cross_entropy"][-1]
-+
-+					model.train()
-+
-+				train_iter += 1
-+
-+			# scheduler.step()
-+
-+			if epoch % config.save_check_points == 0:
-+				save_checkpoint(
-+					checkpoint_name, train_iter, model, model_opt, loss=outputs.loss
-+				)
-+		
-+		dd.io.save(fold_dir + "/results_dict_train.h5", train_reports)
-+		dd.io.save(fold_dir + "/results_dict.h5", report_all)
-+		dd.io.save(fold_dir + "/results_dict_val.h5", report_all_val)
-+
-+	# always save final model
-+	save_checkpoint(checkpoint_name, train_iter, model, model_opt, loss=outputs.loss)
-+
-+	
-+	if config.save_test_predictions:
-+		pass
-+		# print("Starting to make model predictions on test sets for *final model*.")
-+		# for chunk_len in [5, 100]:
-+		#     start_t_preds = time.time()
-+		#     data_config = SimpleNamespace(
-+		#         **{
-+		#             **config.__dict__["__flags"],
-+		#             **{"chunk_len": chunk_len, "batch_size": 500},
-+		#         }
-+		#     )
-+		#     dataloaders, data_name = fet.load(config.data_config, config=data_config)
-+		#     test_loader_preds = dataloaders["test"]
-+
-+		#     torch.cuda.empty_cache()
-+		#     with torch.no_grad():
-+		#         preds = []
-+		#         true = []
-+		#         num_datapoints = 0
-+		#         for idx, d in enumerate(test_loader_preds):
-+		#             true.append(d[-1])
-+		#             d = nested_to(d, device, torch.float32)
-+		#             outputs = model(d)
-+
-+		#             pred_zs = outputs.prediction
-+		#             preds.append(pred_zs)
-+
-+		#             num_datapoints += len(pred_zs)
-+
-+		#             if num_datapoints >= 2000:
-+		#                 break
- 
--config = forge.config()
-+		#         preds = torch.cat(preds, dim=0).cpu()
-+		#         true = torch.cat(true, dim=0).cpu()
- 
--# Prepare environment
--logdir = osp.join(config.results_dir, config.run_name)
--logdir, resume_checkpoint = fet.init_checkpoint(
--    logdir, config.data_config, config.model_config, config.resume)
--checkpoint_name = osp.join(logdir, 'model.ckpt')
-+		#         save_dir = osp.join(logdir, f"traj_preds_{chunk_len}_steps_2k_test.pt")
-+		#         torch.save(preds, save_dir)
- 
-+		#         save_dir = osp.join(logdir, f"traj_true_{chunk_len}_steps_2k_test.pt")
-+		#         torch.save(true, save_dir)
- 
--print(logdir)
-+		#         print(
-+		#             f"Completed making test predictions for chunk_len = {chunk_len} in {time.time() - start_t_preds:.2f} seconds."
-+		#         )	
-+		
- 
-+if __name__ == "__main__":
-+	main()
- 
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/2/penn_dataset.py b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/2/penn_dataset.py
deleted file mode 100644
index 7f5a4fc..0000000
--- a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/2/penn_dataset.py
+++ /dev/null
@@ -1,137 +0,0 @@
-import os
-import torch
-import pandas as pd
-import numpy as np
-
-from torchvision import datasets, transforms
-from torch.utils.data import Dataset, DataLoader
-from sklearn.model_selection import RepeatedKFold
-
-from os import path as osp
-import forge
-from forge import flags
-
-
-# aspects of data managmement
-flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
-flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-flags.DEFINE_boolean("cross_validate",False,"Do K-fold cross-validation")
-
-# Job management
-# flags.DEFINE_integer("batch size",5,"training batch size")
-flags.DEFINE_float("train_split",0.8,'Fraction of data to use for training.')
-flags.DEFINE_integer("n_repeats",1,"Times to repeat K-fold cross-validation")
-flags.DEFINE_integer("split_seed",1,"Seed for KFold split (integer for reproducibility")
-
-# "wavelengths between 0.05 and 1 mm in 0.025 mm increments."
-LSPACE = np.arange(0.05,1.05,0.025) # corresponds to 39 non-coord columns of data
-L_INDS = None
-
-DATAFOLDER = './penn_data'
-
-HEADINGS = np.array(['aaa0043','aaa0044','aaa0060','aaa0061','aaa0063','aaa0064','aaa0066','aaa0069','aaa0086','aaa0087','aaa_0051','aaa_0053','aaa_0054','aaa_0059','aaa_0071','aaa_0072'])
-
-
-class PennData(Dataset):
-
-    def __init__(self,path_to_data,headings,k_inds = None,include_coords = True,rescale = True,spectra_prefix = "kvals_fuse_rotate_",label_prefix = 'labels_fuse_rotate_'):
-        
-        self.data_dir = path_to_data
-        self.headings = headings
-
-        df_list = []
-        label_list = []
-        for heading in self.headings: # for each datafile heading,
-            data_name = osp.join(self.data_dir,spectra_prefix + heading+'.csv') # read kvals
-            df_temp = pd.read_csv(data_name,header=None)
-            df_list.append(df_temp)
-
-            label_name = osp.join(self.data_dir,label_prefix + heading + '.csv') # read labels
-            label_temp = pd.read_csv(label_name,header=None, names=['label'])
-            label_list.append(label_temp)
-
-        df = pd.concat(df_list, ignore_index=True)
-
-        labels = pd.concat(label_list, ignore_index=True)
-        df = pd.concat([labels, df], axis="columns") # Append labels to data
-
-        all_labels = df['label'].to_numpy()
-        all_data = df.iloc[:,1:].to_numpy()
-
-        if rescale: # rescale (normalize) wavelength intensity data
-            lambdas = all_data[:,2:] # wavelengths
-            lam_std = np.std(lambdas, axis=0)  # Calculate standard deviation along columns
-            lam_mean = np.mean(lambdas, axis=0)  # Calculate mean along columns
-            lambdas_rescaled = (lambdas - lam_mean) / lam_std 
-            all_data[:,2:] = lambdas_rescaled
-
-        if not include_coords: # removes x,y coordinates from data
-            all_data = all_data[:,2:]
-        
-        if k_inds != None: # in this case, only use subset of wavelengths
-            all_data = all_data[:,np.array(k_inds)]
-
-        self.all_data = all_data
-        self.all_labels = all_labels
-
-    def __len__(self):
-        return len(self.all_data)
-
-    def __getitem__(self,i):
-        state = {'label':self.all_labels[i],'data':self.all_data[i]}
-        return state
-
-    def __getstate__(self):
-        state = {
-            'data': self.all_data,
-            'label': self.all_labels,
-                }
-        return state
-
-    def __setstate__(self, state):
-        # Set the object's state from the provided dictionary
-        self.all_data = state['data']
-        self.all_labels = state['label']
-        
-
-
-def load(config):
-
-    n_splits = int(len(HEADINGS)/((1-config.train_split)*len(HEADINGS)))
-
-    kf = RepeatedKFold(n_splits = n_splits, n_repeats = config.n_repeats, random_state = config.split_seed) # K-fold cross validation
-
-    kf_dataloaders = []
-
-    for i, (train_ind, test_ind) in enumerate(kf.split(HEADINGS)): # for each K-fold split, 
-        n_val = len(test_ind)//2
-        n_test = len(test_ind)-n_val   
-        n_train = len(train_ind)
-        
-        # set up training DataLoader
-        train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
-
-        # set up test DataLoader
-        test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
-
-        # set up val DataLoader
-        val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-        
-
-        dataloaders = {'train':train_loader, 
-                       'test':test_loader,
-                       'val':val_loader,
-                       'train_inds':train_ind,
-                       'test_inds':test_ind,
-                       'n_val':n_val,
-                       'test_headings':list(HEADINGS[test_ind])
-                      }
-        kf_dataloaders.append(dataloaders)
-
-        if not config.cross_validate:
-        	break
-
-    return kf_dataloaders
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/3/__pycache__/basic_feedforward.cpython-39.pyc b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/3/__pycache__/basic_feedforward.cpython-39.pyc
deleted file mode 100644
index a280a73..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/3/__pycache__/basic_feedforward.cpython-39.pyc and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/3/__pycache__/penn_dataset.cpython-39.pyc b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/3/__pycache__/penn_dataset.cpython-39.pyc
deleted file mode 100644
index e19d023..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/3/__pycache__/penn_dataset.cpython-39.pyc and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/3/basic_feedforward.py b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/3/basic_feedforward.py
deleted file mode 100644
index cdd5158..0000000
--- a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/3/basic_feedforward.py
+++ /dev/null
@@ -1,42 +0,0 @@
-import torch
-import torch.nn as nn
-import torch.nn.functional as F
-import numpy as np
-
-from forge import flags
-
-# flags.DEFINE_boolean(
-#     "model_with_dict",
-#     True,
-#     "Makes model output predictions in dictionary instead of directly."
-# )
-
-class PerceptronNN(nn.Module):
-    def __init__(self, input_size, num_labels):
-        super(PerceptronNN, self).__init__()
-        # Define the layers
-        self.fc1 = nn.Linear(input_size, 128)  # First dense layer
-        self.fc2 = nn.Linear(128, 64)         # Second dense layer
-        # self.fc23 = nn.Linear(64,64)
-        self.fc3 = nn.Linear(64, 64)          # Third dense layer
-        self.fc4 = nn.Linear(64, num_labels)  # Output layer
-        # self.softmax = nn.Softmax(dim=1)
-
-    def forward(self, x):
-        # Forward pass through the network
-        x = F.relu(self.fc1(x))  # Activation function between layers
-        x = F.relu(self.fc2(x))
-        # x = F.relu(self.fc23(x))
-        x = F.relu(self.fc3(x))
-        x = self.fc4(x)  # No activation, this will be included in the loss function
-        # x = self.softmax(x)
-        return x
-
-def load(config):
-
-    # n_channels = 1
-    n_features = config.input_size
-    
-    mlp = PerceptronNN(n_features,2)
-    
-    return mlp, "feedforward"
\ No newline at end of file
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/3/data_fold1/model_fold1.ckpt-0 b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/3/data_fold1/model_fold1.ckpt-0
deleted file mode 100644
index 52120eb..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/3/data_fold1/model_fold1.ckpt-0 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/3/data_fold1/model_fold1.ckpt-11511 b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/3/data_fold1/model_fold1.ckpt-11511
deleted file mode 100644
index c07bbf7..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/3/data_fold1/model_fold1.ckpt-11511 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/3/data_fold1/model_fold1.ckpt-23021 b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/3/data_fold1/model_fold1.ckpt-23021
deleted file mode 100644
index 673537d..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/3/data_fold1/model_fold1.ckpt-23021 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/3/data_fold1/model_fold1.ckpt-34531 b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/3/data_fold1/model_fold1.ckpt-34531
deleted file mode 100644
index 8a8908b..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/3/data_fold1/model_fold1.ckpt-34531 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/3/data_fold1/model_fold1.ckpt-early_stop b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/3/data_fold1/model_fold1.ckpt-early_stop
deleted file mode 100644
index 2bc3fc7..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/3/data_fold1/model_fold1.ckpt-early_stop and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/3/data_fold1/results_dict.h5 b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/3/data_fold1/results_dict.h5
deleted file mode 100644
index 68e66dd..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/3/data_fold1/results_dict.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/3/data_fold1/results_dict_train.h5 b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/3/data_fold1/results_dict_train.h5
deleted file mode 100644
index 2c91e45..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/3/data_fold1/results_dict_train.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/3/data_fold1/results_dict_val.h5 b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/3/data_fold1/results_dict_val.h5
deleted file mode 100644
index d8c2efc..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/3/data_fold1/results_dict_val.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/3/data_fold1/test_headings.txt b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/3/data_fold1/test_headings.txt
deleted file mode 100644
index 05c4825..0000000
--- a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/3/data_fold1/test_headings.txt
+++ /dev/null
@@ -1,4 +0,0 @@
-aaa0060
-aaa0061
-aaa0069
-aaa_0059
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/3/events.out.tfevents.1709686632.MacBook-Pro-4.local.3161.0 b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/3/events.out.tfevents.1709686632.MacBook-Pro-4.local.3161.0
deleted file mode 100644
index 14b5cf2..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/3/events.out.tfevents.1709686632.MacBook-Pro-4.local.3161.0 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/3/flags.json b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/3/flags.json
deleted file mode 100644
index 617a174..0000000
--- a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/3/flags.json
+++ /dev/null
@@ -1,27 +0,0 @@
-{
-    "batch_size": 100,
-    "beta1": 0.9,
-    "beta2": 0.999,
-    "cross_validate": false,
-    "data_config": "penn_dataset.py",
-    "git_commit": "7416bf730b356aabfe0df644240e40948a8196bb",
-    "include_coords": false,
-    "input_size": 39,
-    "learning_rate": 0.001,
-    "log_train_values": true,
-    "log_val_test": true,
-    "model_config": "basic_feedforward.py",
-    "n_repeats": 1,
-    "report_loss_every": 50,
-    "rescale": true,
-    "results_dir": "checkpoints",
-    "resume": false,
-    "run_name": "hyperparam_testing",
-    "save_check_points": 10,
-    "save_test_predictions": false,
-    "split_seed": 1,
-    "total_evaluations": 100,
-    "train_epochs": 30,
-    "train_split": 0.8,
-    "use_mps": false
-}
\ No newline at end of file
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/3/git_diff.txt b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/3/git_diff.txt
deleted file mode 100644
index 4bc1570..0000000
--- a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/3/git_diff.txt
+++ /dev/null
@@ -1,1775 +0,0 @@
-Tue Mar 5 16:57:12 PST 2024
-diff --git a/.DS_Store b/.DS_Store
-index e2836a8..bf7630a 100644
-Binary files a/.DS_Store and b/.DS_Store differ
-diff --git a/.ipynb_checkpoints/basic_feedforward-checkpoint.py b/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-index 688c282..0c4bcd1 100644
---- a/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-+++ b/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-@@ -5,6 +5,12 @@ import numpy as np
- 
- from forge import flags
- 
-+flags.DEFINE_boolean(
-+    "model_with_dict",
-+    True,
-+    "Makes model output predictions in dictionary instead of directly."
-+)
-+
- class PerceptronNN(nn.Module):
-     def __init__(self, input_size, num_labels):
-         super(PerceptronNN, self).__init__()
-@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-+        self.softmax = nn.Softmax(dim=1)
- 
-     def forward(self, x):
-         # Forward pass through the network
-@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-         x = F.relu(self.fc2(x))
-         x = F.relu(self.fc3(x))
-         x = self.fc4(x)  # No activation, this will be included in the loss function
-+        x = self.softmax(x)
-         return x
- 
- def load(config):
-@@ -29,4 +37,4 @@ def load(config):
-     
-     mlp = PerceptronNN(n_features,2)
-     
--    return mlp
-\ No newline at end of file
-+    return mlp, "feedforward"
-\ No newline at end of file
-diff --git a/__pycache__/basic_feedforward.cpython-39.pyc b/__pycache__/basic_feedforward.cpython-39.pyc
-index f541140..dddecf8 100644
-Binary files a/__pycache__/basic_feedforward.cpython-39.pyc and b/__pycache__/basic_feedforward.cpython-39.pyc differ
-diff --git a/__pycache__/penn_dataset.cpython-39.pyc b/__pycache__/penn_dataset.cpython-39.pyc
-index 0d7a4de..19121eb 100644
-Binary files a/__pycache__/penn_dataset.cpython-39.pyc and b/__pycache__/penn_dataset.cpython-39.pyc differ
-diff --git a/basic_feedforward.py b/basic_feedforward.py
-index 688c282..cdd5158 100644
---- a/basic_feedforward.py
-+++ b/basic_feedforward.py
-@@ -5,21 +5,31 @@ import numpy as np
- 
- from forge import flags
- 
-+# flags.DEFINE_boolean(
-+#     "model_with_dict",
-+#     True,
-+#     "Makes model output predictions in dictionary instead of directly."
-+# )
-+
- class PerceptronNN(nn.Module):
-     def __init__(self, input_size, num_labels):
-         super(PerceptronNN, self).__init__()
-         # Define the layers
-         self.fc1 = nn.Linear(input_size, 128)  # First dense layer
-         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-+        # self.fc23 = nn.Linear(64,64)
-         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-+        # self.softmax = nn.Softmax(dim=1)
- 
-     def forward(self, x):
-         # Forward pass through the network
-         x = F.relu(self.fc1(x))  # Activation function between layers
-         x = F.relu(self.fc2(x))
-+        # x = F.relu(self.fc23(x))
-         x = F.relu(self.fc3(x))
-         x = self.fc4(x)  # No activation, this will be included in the loss function
-+        # x = self.softmax(x)
-         return x
- 
- def load(config):
-@@ -29,4 +39,4 @@ def load(config):
-     
-     mlp = PerceptronNN(n_features,2)
-     
--    return mlp
-\ No newline at end of file
-+    return mlp, "feedforward"
-\ No newline at end of file
-diff --git a/checkpoints/feedforward/1/basic_feedforward.py b/checkpoints/feedforward/1/basic_feedforward.py
-index 688c282..3a65525 100644
---- a/checkpoints/feedforward/1/basic_feedforward.py
-+++ b/checkpoints/feedforward/1/basic_feedforward.py
-@@ -5,6 +5,12 @@ import numpy as np
- 
- from forge import flags
- 
-+# flags.DEFINE_boolean(
-+#     "model_with_dict",
-+#     True,
-+#     "Makes model output predictions in dictionary instead of directly."
-+# )
-+
- class PerceptronNN(nn.Module):
-     def __init__(self, input_size, num_labels):
-         super(PerceptronNN, self).__init__()
-@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-+        self.softmax = nn.Softmax(dim=1)
- 
-     def forward(self, x):
-         # Forward pass through the network
-@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-         x = F.relu(self.fc2(x))
-         x = F.relu(self.fc3(x))
-         x = self.fc4(x)  # No activation, this will be included in the loss function
-+        x = self.softmax(x)
-         return x
- 
- def load(config):
-@@ -29,4 +37,4 @@ def load(config):
-     
-     mlp = PerceptronNN(n_features,2)
-     
--    return mlp
-\ No newline at end of file
-+    return mlp, "feedforward"
-\ No newline at end of file
-diff --git a/checkpoints/feedforward/1/flags.json b/checkpoints/feedforward/1/flags.json
-index 1d000c3..889a6ea 100644
---- a/checkpoints/feedforward/1/flags.json
-+++ b/checkpoints/feedforward/1/flags.json
-@@ -1,9 +1,15 @@
- {
-     "batch_size": 100,
-+    "beta1": 0.9,
-+    "beta2": 0.999,
-+    "cross_validate": false,
-     "data_config": "penn_dataset.py",
-+    "git_commit": "7416bf730b356aabfe0df644240e40948a8196bb",
-     "include_coords": false,
-     "input_size": 39,
--    "learning_rate": 1e-05,
-+    "learning_rate": 0.0001,
-+    "log_train_values": true,
-+    "log_val_test": true,
-     "model_config": "basic_feedforward.py",
-     "n_repeats": 1,
-     "report_loss_every": 50,
-@@ -11,7 +17,10 @@
-     "results_dir": "checkpoints",
-     "resume": false,
-     "run_name": "feedforward",
-+    "save_check_points": 50,
-+    "save_test_predictions": false,
-     "split_seed": 1,
--    "train_epochs": 20,
-+    "total_evaluations": 100,
-+    "train_epochs": 100,
-     "train_split": 0.8
- }
-\ No newline at end of file
-diff --git a/checkpoints/feedforward/1/git_diff.txt b/checkpoints/feedforward/1/git_diff.txt
-index 7b37e6f..ec23707 100644
---- a/checkpoints/feedforward/1/git_diff.txt
-+++ b/checkpoints/feedforward/1/git_diff.txt
-@@ -1 +1,873 @@
--Mon Mar 4 11:45:48 PST 2024
-+Mon Mar 4 16:34:02 PST 2024
-+diff --git a/.DS_Store b/.DS_Store
-+index e2836a8..7e3fa32 100644
-+Binary files a/.DS_Store and b/.DS_Store differ
-+diff --git a/.ipynb_checkpoints/basic_feedforward-checkpoint.py b/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-+index 688c282..0c4bcd1 100644
-+--- a/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-++++ b/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-+@@ -5,6 +5,12 @@ import numpy as np
-+ 
-+ from forge import flags
-+ 
-++flags.DEFINE_boolean(
-++    "model_with_dict",
-++    True,
-++    "Makes model output predictions in dictionary instead of directly."
-++)
-++
-+ class PerceptronNN(nn.Module):
-+     def __init__(self, input_size, num_labels):
-+         super(PerceptronNN, self).__init__()
-+@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-+         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-+         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-+         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-++        self.softmax = nn.Softmax(dim=1)
-+ 
-+     def forward(self, x):
-+         # Forward pass through the network
-+@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-+         x = F.relu(self.fc2(x))
-+         x = F.relu(self.fc3(x))
-+         x = self.fc4(x)  # No activation, this will be included in the loss function
-++        x = self.softmax(x)
-+         return x
-+ 
-+ def load(config):
-+@@ -29,4 +37,4 @@ def load(config):
-+     
-+     mlp = PerceptronNN(n_features,2)
-+     
-+-    return mlp
-+\ No newline at end of file
-++    return mlp, "feedforward"
-+\ No newline at end of file
-+diff --git a/__pycache__/basic_feedforward.cpython-39.pyc b/__pycache__/basic_feedforward.cpython-39.pyc
-+index f541140..5ad96de 100644
-+Binary files a/__pycache__/basic_feedforward.cpython-39.pyc and b/__pycache__/basic_feedforward.cpython-39.pyc differ
-+diff --git a/__pycache__/penn_dataset.cpython-39.pyc b/__pycache__/penn_dataset.cpython-39.pyc
-+index 0d7a4de..19121eb 100644
-+Binary files a/__pycache__/penn_dataset.cpython-39.pyc and b/__pycache__/penn_dataset.cpython-39.pyc differ
-+diff --git a/basic_feedforward.py b/basic_feedforward.py
-+index 688c282..3a65525 100644
-+--- a/basic_feedforward.py
-++++ b/basic_feedforward.py
-+@@ -5,6 +5,12 @@ import numpy as np
-+ 
-+ from forge import flags
-+ 
-++# flags.DEFINE_boolean(
-++#     "model_with_dict",
-++#     True,
-++#     "Makes model output predictions in dictionary instead of directly."
-++# )
-++
-+ class PerceptronNN(nn.Module):
-+     def __init__(self, input_size, num_labels):
-+         super(PerceptronNN, self).__init__()
-+@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-+         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-+         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-+         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-++        self.softmax = nn.Softmax(dim=1)
-+ 
-+     def forward(self, x):
-+         # Forward pass through the network
-+@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-+         x = F.relu(self.fc2(x))
-+         x = F.relu(self.fc3(x))
-+         x = self.fc4(x)  # No activation, this will be included in the loss function
-++        x = self.softmax(x)
-+         return x
-+ 
-+ def load(config):
-+@@ -29,4 +37,4 @@ def load(config):
-+     
-+     mlp = PerceptronNN(n_features,2)
-+     
-+-    return mlp
-+\ No newline at end of file
-++    return mlp, "feedforward"
-+\ No newline at end of file
-+diff --git a/checkpoints/feedforward/1/basic_feedforward.py b/checkpoints/feedforward/1/basic_feedforward.py
-+index 688c282..3a65525 100644
-+--- a/checkpoints/feedforward/1/basic_feedforward.py
-++++ b/checkpoints/feedforward/1/basic_feedforward.py
-+@@ -5,6 +5,12 @@ import numpy as np
-+ 
-+ from forge import flags
-+ 
-++# flags.DEFINE_boolean(
-++#     "model_with_dict",
-++#     True,
-++#     "Makes model output predictions in dictionary instead of directly."
-++# )
-++
-+ class PerceptronNN(nn.Module):
-+     def __init__(self, input_size, num_labels):
-+         super(PerceptronNN, self).__init__()
-+@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-+         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-+         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-+         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-++        self.softmax = nn.Softmax(dim=1)
-+ 
-+     def forward(self, x):
-+         # Forward pass through the network
-+@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-+         x = F.relu(self.fc2(x))
-+         x = F.relu(self.fc3(x))
-+         x = self.fc4(x)  # No activation, this will be included in the loss function
-++        x = self.softmax(x)
-+         return x
-+ 
-+ def load(config):
-+@@ -29,4 +37,4 @@ def load(config):
-+     
-+     mlp = PerceptronNN(n_features,2)
-+     
-+-    return mlp
-+\ No newline at end of file
-++    return mlp, "feedforward"
-+\ No newline at end of file
-+diff --git a/checkpoints/feedforward/1/flags.json b/checkpoints/feedforward/1/flags.json
-+index 1d000c3..889a6ea 100644
-+--- a/checkpoints/feedforward/1/flags.json
-++++ b/checkpoints/feedforward/1/flags.json
-+@@ -1,9 +1,15 @@
-+ {
-+     "batch_size": 100,
-++    "beta1": 0.9,
-++    "beta2": 0.999,
-++    "cross_validate": false,
-+     "data_config": "penn_dataset.py",
-++    "git_commit": "7416bf730b356aabfe0df644240e40948a8196bb",
-+     "include_coords": false,
-+     "input_size": 39,
-+-    "learning_rate": 1e-05,
-++    "learning_rate": 0.0001,
-++    "log_train_values": true,
-++    "log_val_test": true,
-+     "model_config": "basic_feedforward.py",
-+     "n_repeats": 1,
-+     "report_loss_every": 50,
-+@@ -11,7 +17,10 @@
-+     "results_dir": "checkpoints",
-+     "resume": false,
-+     "run_name": "feedforward",
-++    "save_check_points": 50,
-++    "save_test_predictions": false,
-+     "split_seed": 1,
-+-    "train_epochs": 20,
-++    "total_evaluations": 100,
-++    "train_epochs": 100,
-+     "train_split": 0.8
-+ }
-+\ No newline at end of file
-+diff --git a/checkpoints/feedforward/1/git_diff.txt b/checkpoints/feedforward/1/git_diff.txt
-+index 7b37e6f..5c561db 100644
-+--- a/checkpoints/feedforward/1/git_diff.txt
-++++ b/checkpoints/feedforward/1/git_diff.txt
-+@@ -1 +1 @@
-+-Mon Mar 4 11:45:48 PST 2024
-++Mon Mar 4 16:34:02 PST 2024
-+diff --git a/checkpoints/feedforward/1/penn_dataset.py b/checkpoints/feedforward/1/penn_dataset.py
-+index aa2f5a0..7f5a4fc 100644
-+--- a/checkpoints/feedforward/1/penn_dataset.py
-++++ b/checkpoints/feedforward/1/penn_dataset.py
-+@@ -15,6 +15,7 @@ from forge import flags
-+ # aspects of data managmement
-+ flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
-+ flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-++flags.DEFINE_boolean("cross_validate",False,"Do K-fold cross-validation")
-+ 
-+ # Job management
-+ # flags.DEFINE_integer("batch size",5,"training batch size")
-+@@ -109,15 +110,15 @@ def load(config):
-+         
-+         # set up training DataLoader
-+         train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, n_train),num_workers=0,shuffle = True)
-++        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
-+ 
-+         # set up test DataLoader
-+         test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, n_test),num_workers=0,shuffle = True)
-++        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
-+ 
-+         # set up val DataLoader
-+         val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, n_val),num_workers=0,shuffle = True)
-++        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-+         
-+ 
-+         dataloaders = {'train':train_loader, 
-+@@ -125,8 +126,12 @@ def load(config):
-+                        'val':val_loader,
-+                        'train_inds':train_ind,
-+                        'test_inds':test_ind,
-+-                       'n_val':n_val
-++                       'n_val':n_val,
-++                       'test_headings':list(HEADINGS[test_ind])
-+                       }
-+         kf_dataloaders.append(dataloaders)
-+ 
-++        if not config.cross_validate:
-++        	break
-++
-+     return kf_dataloaders
-+diff --git a/penn_dataset.py b/penn_dataset.py
-+index aa2f5a0..7f5a4fc 100644
-+--- a/penn_dataset.py
-++++ b/penn_dataset.py
-+@@ -15,6 +15,7 @@ from forge import flags
-+ # aspects of data managmement
-+ flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
-+ flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-++flags.DEFINE_boolean("cross_validate",False,"Do K-fold cross-validation")
-+ 
-+ # Job management
-+ # flags.DEFINE_integer("batch size",5,"training batch size")
-+@@ -109,15 +110,15 @@ def load(config):
-+         
-+         # set up training DataLoader
-+         train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, n_train),num_workers=0,shuffle = True)
-++        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
-+ 
-+         # set up test DataLoader
-+         test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, n_test),num_workers=0,shuffle = True)
-++        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
-+ 
-+         # set up val DataLoader
-+         val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, n_val),num_workers=0,shuffle = True)
-++        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-+         
-+ 
-+         dataloaders = {'train':train_loader, 
-+@@ -125,8 +126,12 @@ def load(config):
-+                        'val':val_loader,
-+                        'train_inds':train_ind,
-+                        'test_inds':test_ind,
-+-                       'n_val':n_val
-++                       'n_val':n_val,
-++                       'test_headings':list(HEADINGS[test_ind])
-+                       }
-+         kf_dataloaders.append(dataloaders)
-+ 
-++        if not config.cross_validate:
-++        	break
-++
-+     return kf_dataloaders
-+diff --git a/testing.ipynb b/testing.ipynb
-+index e5a167b..a928d8d 100644
-+--- a/testing.ipynb
-++++ b/testing.ipynb
-+@@ -2,7 +2,7 @@
-+  "cells": [
-+   {
-+    "cell_type": "code",
-+-   "execution_count": 1,
-++   "execution_count": 2,
-+    "id": "4dee7ff1-01a4-4038-b493-9729ff3693f7",
-+    "metadata": {},
-+    "outputs": [],
-+@@ -23,19 +23,19 @@
-+   },
-+   {
-+    "cell_type": "code",
-+-   "execution_count": 2,
-++   "execution_count": 3,
-+    "id": "cad0fdc8-5c35-4610-bba3-b71e60dc1b98",
-+    "metadata": {},
-+    "outputs": [],
-+    "source": [
-+-    "flags.DEFINE_integer(\"batch_size\", 100, \"Mini-batch size.\")\n",
-++    "flags.DEFINE_integer(\"batch_size\", 10, \"Mini-batch size.\")\n",
-+     "\n",
-+     "flags.DEFINE_integer(\"input_size\",39,\"Input shape to model\")"
-+    ]
-+   },
-+   {
-+    "cell_type": "code",
-+-   "execution_count": 3,
-++   "execution_count": 4,
-+    "id": "ce1b936b-8a7c-426e-a3aa-3c1c38f645de",
-+    "metadata": {},
-+    "outputs": [
-+@@ -54,8 +54,8 @@
-+   },
-+   {
-+    "cell_type": "code",
-+-   "execution_count": 9,
-+-   "id": "e862b7e2-57f5-44bf-bcf1-a91160ba66cc",
-++   "execution_count": 5,
-++   "id": "4469cddf-4dac-4468-be88-241d440401c3",
-+    "metadata": {},
-+    "outputs": [
-+     {
-+@@ -67,35 +67,89 @@
-+     }
-+    ],
-+    "source": [
-+-    "model = fet.load(\"basic_feedforward.py\",config)"
-++    "model,modelname = fet.load(\"basic_feedforward.py\",config)"
-+    ]
-+   },
-+   {
-+    "cell_type": "code",
-+-   "execution_count": 10,
-+-   "id": "07e0b160-d5d1-4e54-b4a7-ccaf2224598a",
-++   "execution_count": 17,
-++   "id": "7c9a9fe9-f5e8-456a-b964-4be13027725b",
-+    "metadata": {},
-+    "outputs": [
-+     {
-+      "data": {
-+       "text/plain": [
-+-       "PerceptronNN(\n",
-+-       "  (fc1): Linear(in_features=39, out_features=128, bias=True)\n",
-+-       "  (fc2): Linear(in_features=128, out_features=64, bias=True)\n",
-+-       "  (fc3): Linear(in_features=64, out_features=64, bias=True)\n",
-+-       "  (fc4): Linear(in_features=64, out_features=2, bias=True)\n",
-+-       ")"
-++       "['aaa0060', 'aaa0061', 'aaa0069', 'aaa_0059']"
-+       ]
-+      },
-+-     "execution_count": 10,
-++     "execution_count": 17,
-+      "metadata": {},
-+      "output_type": "execute_result"
-+     }
-+    ],
-+    "source": [
-+-    "model"
-++    "loaddat[0]['test_headings']"
-++   ]
-++  },
-++  {
-++   "cell_type": "code",
-++   "execution_count": 19,
-++   "id": "e862b7e2-57f5-44bf-bcf1-a91160ba66cc",
-++   "metadata": {},
-++   "outputs": [
-++    {
-++     "name": "stdout",
-++     "output_type": "stream",
-++     "text": [
-++      "Keys: ['cross_entropy', 'time']\n"
-++     ]
-++    }
-++   ],
-++   "source": [
-++    "import h5py\n",
-++    "\n",
-++    "file_path = \"./checkpoints/feedforward/2/data_fold1/results_dict.h5\"\n",
-++    "# Replace 'your_file.h5' with the actual path to your file\n",
-++    "f =  h5py.File(file_path, 'r') \n",
-++    "\n",
-++    "    # Get information about the data stored in the file\n",
-++    "print(\"Keys:\", list(f.keys()))  # List the top-level datasets and groups\n",
-++    "\n",
-++    "    # # Access a dataset by its name\n",
-++    "    # dataset_name = \"your_dataset_name\"\n",
-++    "    # if dataset_name in f:\n",
-++    "    #     dataset = f[dataset_name]\n",
-++    "    #     print(\"Dataset shape:\", dataset.shape)\n",
-++    "    #     print(\"Dataset dtype:\", dataset.dtype)\n",
-++    "\n",
-++    "    #     # Access the data as a NumPy array\n",
-++    "    #     data = dataset[:]  # Read the entire dataset\n",
-++    "\n",
-++    "    #     # You can now work with the data as needed, for example:\n",
-++    "    #     # Perform calculations, visualizations, etc.\n",
-++    "    # else:\n",
-++    "    #     print(f\"Dataset '{dataset_name}' not found in the file.\")"
-+    ]
-+   },
-++  {
-++   "cell_type": "code",
-++   "execution_count": 13,
-++   "id": "07e0b160-d5d1-4e54-b4a7-ccaf2224598a",
-++   "metadata": {},
-++   "outputs": [
-++    {
-++     "data": {
-++      "text/plain": [
-++       "<generator object Module.parameters at 0x3007207b0>"
-++      ]
-++     },
-++     "execution_count": 13,
-++     "metadata": {},
-++     "output_type": "execute_result"
-++    }
-++   ],
-++   "source": []
-++  },
-+   {
-+    "cell_type": "code",
-+    "execution_count": null,
-+diff --git a/train.py b/train.py
-+index c266102..516bfa9 100644
-+--- a/train.py
-++++ b/train.py
-+@@ -1,49 +1,440 @@
-+ from os import path as osp
-++import os
-++import numpy as np
-++import time
-+ 
-+ import torch
-++import torch.nn as nn
-+ import torch.nn.functional as F
-+ import torch.optim as optim
-+-
-+-import numpy as np
-++from torch.utils.tensorboard import SummaryWriter
-+ 
-+ import forge
-+ from forge import flags
-+ import forge.experiment_tools as fet
-+ 
-++from train_tools import (
-++	log_tensorboard,
-++	parse_reports,
-++	parse_reports_cpu,
-++	print_reports,
-++	load_checkpoint,
-++	save_checkpoint,
-++	nested_to,
-++	param_count,
-++)
-++
-++from copy import deepcopy
-++from attrdict import AttrDict
-++import deepdish as dd
-++from tqdm import tqdm
-++
-++# For reproducibility while researching, but might affect speed!
-++torch.backends.cudnn.deterministic = True
-++torch.backends.cudnn.benchmark = False
-++torch.manual_seed(0)
-++
-+ 
-+ # Job config
-+ flags.DEFINE_string('data_config', 'penn_dataset.py',
-+-                    'Path to a data config file.')
-++					'Path to a data config file.')
-+ flags.DEFINE_string('model_config', 'basic_feedforward.py',
-+-                    'Path to a model config file.')
-++					'Path to a model config file.')
-+ flags.DEFINE_string('results_dir', 'checkpoints',
-+-                    'Top directory for all experimental results.')
-++					'Top directory for all experimental results.')
-+ flags.DEFINE_string('run_name', 'feedforward',
-+-                    'Name of this job and name of results folder.')
-++					'Name of this job and name of results folder.')
-+ flags.DEFINE_boolean('resume', False, 'Tries to resume a job if True.')
-+ 
-+ # Logging config
-+ flags.DEFINE_integer('report_loss_every', 50,
-+-                     'Number of iterations between reporting minibatch loss.')
-+-flags.DEFINE_integer('train_epochs', 20, 'Maximum number of training epochs.')
-++					 'Number of iterations between reporting minibatch loss.')
-++flags.DEFINE_integer('train_epochs', 100, 'Maximum number of training epochs.')
-++flags.DEFINE_integer(
-++	"save_check_points",
-++	50,
-++	"frequency with which to save checkpoints, in number of epoches.",
-++)
-++flags.DEFINE_boolean("log_train_values", True, "Logs train values if True.")
-++flags.DEFINE_integer(
-++	"total_evaluations",
-++	100,
-++	"Maximum number of evaluations on test and validation data during training.",
-++)
-++flags.DEFINE_boolean(
-++	"save_test_predictions",
-++	False,
-++	"Makes and saves test predictions on one or more test sets (e.g. 5-step and 100-step predictions) at the end of training.",
-++)
-++flags.DEFINE_boolean(
-++    "log_val_test", True, "Turns off computation of validation and test errors."
-++)
-+ 
-+ # Experiment config
-+ flags.DEFINE_integer('batch_size', 100, 'Mini-batch size.')
-+-flags.DEFINE_float('learning_rate', 1e-5, 'SGD learning rate.')
-++flags.DEFINE_float("learning_rate", 1e-4, "Adam learning rate.")
-++flags.DEFINE_float("beta1", 0.9, "Adam Beta 1 parameter")
-++flags.DEFINE_float("beta2", 0.999, "Adam Beta 2 parameter")
-+ 
-+ # Specific config options
-+ flags.DEFINE_integer("input_size",39,"Input shape to model")
-+ 
-++#########################################################################################
-++
-++def evaluate(model, loader, device,fold = 0,headings = [],loss_func = nn.CrossEntropyLoss()):
-++	reports = None
-++	for data in loader:
-++		labels = data['label']
-++		inputs = nested_to(data['data'],device,torch.float32)
-++		
-++		labels_tensor = torch.zeros((len(labels), 2))
-++		for i, label in enumerate(labels):
-++			labels_tensor[i, label] = 1
-++
-++		model_output = model(inputs) # evaluate model
-++
-++		loss = loss_func(model_output, labels_tensor) # compute loss
-++		outputs = AttrDict({"loss": loss, "prediction": model_output,'data_fold':fold})
-++		outputs.reports = AttrDict({"cross_entropy": loss})
-++
-++		if reports is None:
-++			reports = {k: v.detach().clone().cpu() for k, v in outputs.reports.items()}
-++		else:
-++			for k, v in outputs.reports.items():
-++				reports[k] += v.detach().clone().cpu()
-++
-++	for k, v in reports.items():
-++		reports[k] = v / len(
-++			loader
-++		)  # SZ: note this can be slightly incorrect if mini-batch sizes vary (if batch_size doesn't divide train_size), but approximately correct.
-++
-++	# reports['test_headings'] = np.array(headings)
-++
-++	return reports
-++
-++def main():
-++
-++	config = forge.config()
-++
-++	# Set device
-++	if torch.cuda.is_available():
-++		device = f"cuda:{config.device}"
-++		torch.cuda.set_device(device)
-++	else:
-++		device = "cpu" # can change this to MPS on M1 Macs
-++
-++	# Load data
-++	data_name = "penn_data"
-++	kfold_loaders = fet.load(config.data_config, config)
-++
-++	# Load model
-++	model,model_name = fet.load(config.model_config, config)
-++	model = model.to(device)
-++
-++	loss_func = nn.CrossEntropyLoss()
-++
-++	# Prepare environment
-++	params_in_run_name = [
-++		("batch_size", "bs"),
-++		("learning_rate", "lr"),
-++		("n_train", "ntrain")
-++	]
-++
-++	run_name = ""  # config.run_name
-++	for config_param in params_in_run_name:
-++		attr = config_param[0]
-++		abbrev = config_param[1]
-++
-++		if hasattr(config, attr):
-++			run_name += abbrev
-++			run_name += str(getattr(config, attr))
-++			run_name += "_"
-++
-++	results_folder_name = osp.join(
-++		data_name,
-++		model_name,
-++		config.run_name,
-++		run_name,
-++	)
-++
-++	# Prepare environment
-++	logdir = osp.join(config.results_dir, config.run_name)
-++	logdir, resume_checkpoint = fet.init_checkpoint(
-++		logdir, config.data_config, config.model_config, config.resume)
-++
-++	print("Checkpoint directory:",logdir)
-++
-++	# Print flags
-++	fet.print_flags()
-++	# Print model info
-++	print(model)
-++
-++	# Setup optimizer
-++	model_params = model.parameters()
-++	opt_learning_rate = config.learning_rate
-++	model_opt = torch.optim.Adam(
-++		model_params, lr=opt_learning_rate, betas=(config.beta1, config.beta2)
-++	)
-++	print("Model Optimizer:")
-++	print(model_opt)
-++
-++	# Try to restore model and optimizer from checkpoint
-++	if resume_checkpoint is not None:
-++		start_epoch = load_checkpoint(resume_checkpoint, model, model_opt)
-++	else:
-++		start_epoch = 1
-++
-++	n_folds = len(kfold_loaders)
-++	print("Doing {}-fold cross-validation.".format(n_folds))
-++
-++	# KFOLD TRAINING LOOP
-++	for k,loader_k in enumerate(kfold_loaders): # loop over data splits
-++
-++		print("Training fold {}...".format(k+1))
-++
-++		# load the training data
-++		train_loader = loader_k["train"]
-++		n_train = len(train_loader.dataset)
-++		train_batch_size = train_loader.batch_size
-++
-++		# load testing, validation
-++		test_loader = loader_k["test"]
-++		n_test = len(test_loader.dataset)
-++		val_loader = loader_k["val"]
-++		n_val = len(val_loader.dataset)
-++		
-++		# create folder for this data split
-++		fold_dir = osp.join(logdir,"data_fold{}".format(k+1))
-++		fold_dir_exists = osp.exists(fold_dir)
-++		if not fold_dir_exists:
-++			if config.resume:
-++				raise ValueError("Can't resume when the checkpoint/fold dir '{}' doesn't exist.".format(fold_dir))
-++			else:
-++				os.makedirs(fold_dir)
-++		checkpoint_name = osp.join(fold_dir, 'model_fold{}.ckpt'.format(k+1))
-++
-++		# keep track of which data is test data for a given Kfold data split
-++		test_headings = loader_k['test_headings']
-++		headingsFile = osp.join(fold_dir,"test_headings.txt")
-++		with open(headingsFile,'w') as headfile:
-++			for heading in test_headings:
-++				headfile.write(heading+'\n')
-++
-++		# print(checkpoint_name)
-++
-++		train_iter = (start_epoch - 1) * (
-++		len(train_loader.dataset) // train_batch_size
-++		) + 1
-++
-++		print("Starting training at epoch = {}, iter = {}".format(start_epoch, train_iter))
-++
-++		# Setup tensorboard writing
-++		summary_writer = SummaryWriter(logdir)
-++
-++		train_reports = []
-++		report_all = {}
-++		report_all_val = {}
-++
-++		# Saving model at epoch 0 before training
-++		print("saving model at epoch 0 before training ... ")
-++		save_checkpoint(checkpoint_name, 0, model, model_opt, loss=0.0)
-++		print("finished saving model at epoch 0 before training")
-++
-++		num_params = param_count(model)
-++		print(f"Number of model parameters: {num_params}")
-++
-++		# Training
-++		start_t = time.time()
-++
-++		total_train_iters = len(train_loader) * config.train_epochs
-++		iters_per_eval = max(1, int(total_train_iters / config.total_evaluations))
-++		# print('batch',train_batch_size)
-++		# print('ntrain',n_train)
-++		# assert (
-++		# 	n_train % min(train_batch_size, n_train) == 0
-++		# ), "Batch size doesn't divide dataset size. Can be inaccurate for loss computation (see below)."
-++
-++		training_failed = False
-++		best_val_loss_so_far = 1e7
-++
-++		for epoch in tqdm(range(start_epoch, config.train_epochs + 1)):
-++			model.train()
-++
-++			for batch_idx, data_dict in enumerate(train_loader): # Loop over batched data
-++
-++				labels = data_dict['label']
-++				data = data_dict['data']
-++
-++				# send data to device
-++				data = nested_to(data,device,torch.float32)
-++				# One-hot encode the data labels
-++				labels_tensor = torch.zeros((len(labels), 2))
-++				for i, label in enumerate(labels):
-++					labels_tensor[i, label] = 1
-++
-++				model_output = model(data) # evaluate model
-++
-++				loss = loss_func(model_output, labels_tensor) # compute loss
-++				outputs = AttrDict({"loss": loss, "prediction": model_output})
-++				outputs.reports = AttrDict({"cross_entropy": loss})
-++
-++				if torch.isnan(outputs.loss): # check for failure in training
-++					if not training_failed:
-++						epoch_of_nan = epoch
-++					if (epoch > epoch_of_nan + 1) and training_failed:
-++						raise ValueError("Loss Nan-ed.")
-++					training_failed = True
-++
-++				model_opt.zero_grad()
-++				outputs.loss.backward(retain_graph=False)
-++
-++				model_opt.step() # move optimizer forward
-++
-++				train_reports.append(parse_reports_cpu(outputs.reports))
-++
-++				if config.log_train_values:
-++					reports = parse_reports(outputs.reports)
-++					if batch_idx % config.report_loss_every == 0:
-++						log_tensorboard(summary_writer, train_iter, reports, "train/")
-++						print_reports(
-++							reports,
-++							start_t,
-++							epoch,
-++							batch_idx,
-++							len(train_loader.dataset) // train_batch_size,
-++							prefix="train",
-++						)
-++						log_tensorboard(
-++							summary_writer,
-++							train_iter,
-++							{"lr": model_opt.param_groups[0]["lr"]},
-++							"hyperparams/",
-++						)
-++				# Logging and evaluation
-++				if (
-++					train_iter % iters_per_eval == 0 or (train_iter == total_train_iters)
-++				) and config.log_val_test:  # batch_idx % config.evaluate_every == 0:
-++					model.eval()
-++					with torch.no_grad():
-++						reports = evaluate(model, test_loader, device,fold = k,headings = loader_k['test_headings'])
-++						# print("REPORTS",reports)
-++						reports = parse_reports(reports)
-++						reports["time"] = time.time() - start_t
-++						if report_all == {}:
-++							report_all = deepcopy(reports)
-++
-++							for d in reports.keys():
-++								report_all[d] = [report_all[d]]
-++						else:
-++							for d in reports.keys():
-++								report_all[d].append(reports[d])
-++
-++						log_tensorboard(summary_writer, train_iter, reports, "test/")
-++						print_reports(
-++							reports,
-++							start_t,
-++							epoch,
-++							batch_idx,
-++							len(train_loader.dataset) // config.batch_size,
-++							prefix="test",
-++						)
-++
-++						# repeat for validation data
-++						reports = evaluate(model, val_loader, device,fold = k,headings = loader_k['test_headings'])
-++						reports = parse_reports(reports)
-++						reports["time"] = time.time() - start_t
-++						if report_all_val == {}:
-++							report_all_val = deepcopy(reports)
-++
-++							for d in reports.keys():
-++								report_all_val[d] = [report_all_val[d]]
-++						else:
-++							for d in reports.keys():
-++								report_all_val[d].append(reports[d])
-++
-++						log_tensorboard(summary_writer, train_iter, reports, "val/")
-++						print_reports(
-++							reports,
-++							start_t,
-++							epoch,
-++							batch_idx,
-++							len(train_loader.dataset) // config.batch_size,
-++							prefix="val",
-++						)
-++
-++						if report_all_val["cross_entropy"][-1] < best_val_loss_so_far:
-++							save_checkpoint(
-++								checkpoint_name,
-++								f"early_stop",
-++								model,
-++								model_opt,
-++								loss=outputs.loss,
-++							)
-++							best_val_loss_so_far = report_all_val["cross_entropy"][-1]
-++
-++					model.train()
-++
-++				train_iter += 1
-++
-++			if epoch % config.save_check_points == 0:
-++				save_checkpoint(
-++					checkpoint_name, train_iter, model, model_opt, loss=outputs.loss
-++				)
-++
-++		dd.io.save(fold_dir + "/results_dict_train.h5", train_reports)
-++		dd.io.save(fold_dir + "/results_dict.h5", report_all)
-++		dd.io.save(fold_dir + "/results_dict_val.h5", report_all_val)
-++
-++	# always save final model
-++	save_checkpoint(checkpoint_name, train_iter, model, model_opt, loss=outputs.loss)
-++
-++	
-++	if config.save_test_predictions:
-++		pass
-++		# print("Starting to make model predictions on test sets for *final model*.")
-++		# for chunk_len in [5, 100]:
-++		#     start_t_preds = time.time()
-++		#     data_config = SimpleNamespace(
-++		#         **{
-++		#             **config.__dict__["__flags"],
-++		#             **{"chunk_len": chunk_len, "batch_size": 500},
-++		#         }
-++		#     )
-++		#     dataloaders, data_name = fet.load(config.data_config, config=data_config)
-++		#     test_loader_preds = dataloaders["test"]
-++
-++		#     torch.cuda.empty_cache()
-++		#     with torch.no_grad():
-++		#         preds = []
-++		#         true = []
-++		#         num_datapoints = 0
-++		#         for idx, d in enumerate(test_loader_preds):
-++		#             true.append(d[-1])
-++		#             d = nested_to(d, device, torch.float32)
-++		#             outputs = model(d)
-++
-++		#             pred_zs = outputs.prediction
-++		#             preds.append(pred_zs)
-++
-++		#             num_datapoints += len(pred_zs)
-++
-++		#             if num_datapoints >= 2000:
-++		#                 break
-+ 
-+-config = forge.config()
-++		#         preds = torch.cat(preds, dim=0).cpu()
-++		#         true = torch.cat(true, dim=0).cpu()
-+ 
-+-# Prepare environment
-+-logdir = osp.join(config.results_dir, config.run_name)
-+-logdir, resume_checkpoint = fet.init_checkpoint(
-+-    logdir, config.data_config, config.model_config, config.resume)
-+-checkpoint_name = osp.join(logdir, 'model.ckpt')
-++		#         save_dir = osp.join(logdir, f"traj_preds_{chunk_len}_steps_2k_test.pt")
-++		#         torch.save(preds, save_dir)
-+ 
-++		#         save_dir = osp.join(logdir, f"traj_true_{chunk_len}_steps_2k_test.pt")
-++		#         torch.save(true, save_dir)
-+ 
-+-print(logdir)
-++		#         print(
-++		#             f"Completed making test predictions for chunk_len = {chunk_len} in {time.time() - start_t_preds:.2f} seconds."
-++		#         )	
-++		
-+ 
-++if __name__ == "__main__":
-++	main()
-+ 
-diff --git a/checkpoints/feedforward/1/penn_dataset.py b/checkpoints/feedforward/1/penn_dataset.py
-index aa2f5a0..7f5a4fc 100644
---- a/checkpoints/feedforward/1/penn_dataset.py
-+++ b/checkpoints/feedforward/1/penn_dataset.py
-@@ -15,6 +15,7 @@ from forge import flags
- # aspects of data managmement
- flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
- flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-+flags.DEFINE_boolean("cross_validate",False,"Do K-fold cross-validation")
- 
- # Job management
- # flags.DEFINE_integer("batch size",5,"training batch size")
-@@ -109,15 +110,15 @@ def load(config):
-         
-         # set up training DataLoader
-         train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, n_train),num_workers=0,shuffle = True)
-+        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
- 
-         # set up test DataLoader
-         test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, n_test),num_workers=0,shuffle = True)
-+        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
- 
-         # set up val DataLoader
-         val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, n_val),num_workers=0,shuffle = True)
-+        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-         
- 
-         dataloaders = {'train':train_loader, 
-@@ -125,8 +126,12 @@ def load(config):
-                        'val':val_loader,
-                        'train_inds':train_ind,
-                        'test_inds':test_ind,
--                       'n_val':n_val
-+                       'n_val':n_val,
-+                       'test_headings':list(HEADINGS[test_ind])
-                       }
-         kf_dataloaders.append(dataloaders)
- 
-+        if not config.cross_validate:
-+        	break
-+
-     return kf_dataloaders
-diff --git a/georgehulsey_2024.pdf b/georgehulsey_2024.pdf
-deleted file mode 100644
-index 1ab17f6..0000000
-Binary files a/georgehulsey_2024.pdf and /dev/null differ
-diff --git a/penn_dataset.py b/penn_dataset.py
-index aa2f5a0..7f5a4fc 100644
---- a/penn_dataset.py
-+++ b/penn_dataset.py
-@@ -15,6 +15,7 @@ from forge import flags
- # aspects of data managmement
- flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
- flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-+flags.DEFINE_boolean("cross_validate",False,"Do K-fold cross-validation")
- 
- # Job management
- # flags.DEFINE_integer("batch size",5,"training batch size")
-@@ -109,15 +110,15 @@ def load(config):
-         
-         # set up training DataLoader
-         train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, n_train),num_workers=0,shuffle = True)
-+        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
- 
-         # set up test DataLoader
-         test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, n_test),num_workers=0,shuffle = True)
-+        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
- 
-         # set up val DataLoader
-         val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, n_val),num_workers=0,shuffle = True)
-+        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-         
- 
-         dataloaders = {'train':train_loader, 
-@@ -125,8 +126,12 @@ def load(config):
-                        'val':val_loader,
-                        'train_inds':train_ind,
-                        'test_inds':test_ind,
--                       'n_val':n_val
-+                       'n_val':n_val,
-+                       'test_headings':list(HEADINGS[test_ind])
-                       }
-         kf_dataloaders.append(dataloaders)
- 
-+        if not config.cross_validate:
-+        	break
-+
-     return kf_dataloaders
-diff --git a/testing.ipynb b/testing.ipynb
-index e5a167b..0110538 100644
---- a/testing.ipynb
-+++ b/testing.ipynb
-@@ -2,7 +2,7 @@
-  "cells": [
-   {
-    "cell_type": "code",
--   "execution_count": 1,
-+   "execution_count": 4,
-    "id": "4dee7ff1-01a4-4038-b493-9729ff3693f7",
-    "metadata": {},
-    "outputs": [],
-@@ -23,7 +23,7 @@
-   },
-   {
-    "cell_type": "code",
--   "execution_count": 2,
-+   "execution_count": 6,
-    "id": "cad0fdc8-5c35-4610-bba3-b71e60dc1b98",
-    "metadata": {},
-    "outputs": [],
-@@ -35,7 +35,7 @@
-   },
-   {
-    "cell_type": "code",
--   "execution_count": 3,
-+   "execution_count": 7,
-    "id": "ce1b936b-8a7c-426e-a3aa-3c1c38f645de",
-    "metadata": {},
-    "outputs": [
-@@ -54,8 +54,8 @@
-   },
-   {
-    "cell_type": "code",
--   "execution_count": 9,
--   "id": "e862b7e2-57f5-44bf-bcf1-a91160ba66cc",
-+   "execution_count": 5,
-+   "id": "4469cddf-4dac-4468-be88-241d440401c3",
-    "metadata": {},
-    "outputs": [
-     {
-@@ -67,35 +67,98 @@
-     }
-    ],
-    "source": [
--    "model = fet.load(\"basic_feedforward.py\",config)"
-+    "model,modelname = fet.load(\"basic_feedforward.py\",config)"
-    ]
-   },
-   {
-    "cell_type": "code",
--   "execution_count": 10,
--   "id": "07e0b160-d5d1-4e54-b4a7-ccaf2224598a",
-+   "execution_count": 13,
-+   "id": "7c9a9fe9-f5e8-456a-b964-4be13027725b",
-    "metadata": {},
-    "outputs": [
-     {
-      "data": {
-       "text/plain": [
--       "PerceptronNN(\n",
--       "  (fc1): Linear(in_features=39, out_features=128, bias=True)\n",
--       "  (fc2): Linear(in_features=128, out_features=64, bias=True)\n",
--       "  (fc3): Linear(in_features=64, out_features=64, bias=True)\n",
--       "  (fc4): Linear(in_features=64, out_features=2, bias=True)\n",
--       ")"
-+       "array([114170,    904])"
-       ]
-      },
--     "execution_count": 10,
-+     "execution_count": 13,
-      "metadata": {},
-      "output_type": "execute_result"
-     }
-    ],
-    "source": [
--    "model"
-+    "np.bincount(loaddat[0]['train'].dataset.all_labels)"
-    ]
-   },
-+  {
-+   "cell_type": "code",
-+   "execution_count": 1,
-+   "id": "e862b7e2-57f5-44bf-bcf1-a91160ba66cc",
-+   "metadata": {},
-+   "outputs": [
-+    {
-+     "ename": "FileNotFoundError",
-+     "evalue": "[Errno 2] Unable to open file (unable to open file: name = './checkpoints/feedforward/2/data_fold1/results_dict.h5', errno = 2, error message = 'No such file or directory', flags = 0, o_flags = 0)",
-+     "output_type": "error",
-+     "traceback": [
-+      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
-+      "\u001b[0;31mFileNotFoundError\u001b[0m                         Traceback (most recent call last)",
-+      "Cell \u001b[0;32mIn[1], line 5\u001b[0m\n\u001b[1;32m      3\u001b[0m file_path \u001b[38;5;241m=\u001b[39m \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124m./checkpoints/feedforward/2/data_fold1/results_dict.h5\u001b[39m\u001b[38;5;124m\"\u001b[39m\n\u001b[1;32m      4\u001b[0m \u001b[38;5;66;03m# Replace 'your_file.h5' with the actual path to your file\u001b[39;00m\n\u001b[0;32m----> 5\u001b[0m f \u001b[38;5;241m=\u001b[39m  \u001b[43mh5py\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mFile\u001b[49m\u001b[43m(\u001b[49m\u001b[43mfile_path\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[38;5;124;43mr\u001b[39;49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[43m)\u001b[49m \n\u001b[1;32m      7\u001b[0m     \u001b[38;5;66;03m# Get information about the data stored in the file\u001b[39;00m\n\u001b[1;32m      8\u001b[0m \u001b[38;5;28mprint\u001b[39m(\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mKeys:\u001b[39m\u001b[38;5;124m\"\u001b[39m, \u001b[38;5;28mlist\u001b[39m(f\u001b[38;5;241m.\u001b[39mkeys()))\n",
-+      "File \u001b[0;32m/Applications/miniconda3/envs/lietransformer/lib/python3.9/site-packages/h5py/_hl/files.py:562\u001b[0m, in \u001b[0;36mFile.__init__\u001b[0;34m(self, name, mode, driver, libver, userblock_size, swmr, rdcc_nslots, rdcc_nbytes, rdcc_w0, track_order, fs_strategy, fs_persist, fs_threshold, fs_page_size, page_buf_size, min_meta_keep, min_raw_keep, locking, alignment_threshold, alignment_interval, meta_block_size, **kwds)\u001b[0m\n\u001b[1;32m    553\u001b[0m     fapl \u001b[38;5;241m=\u001b[39m make_fapl(driver, libver, rdcc_nslots, rdcc_nbytes, rdcc_w0,\n\u001b[1;32m    554\u001b[0m                      locking, page_buf_size, min_meta_keep, min_raw_keep,\n\u001b[1;32m    555\u001b[0m                      alignment_threshold\u001b[38;5;241m=\u001b[39malignment_threshold,\n\u001b[1;32m    556\u001b[0m                      alignment_interval\u001b[38;5;241m=\u001b[39malignment_interval,\n\u001b[1;32m    557\u001b[0m                      meta_block_size\u001b[38;5;241m=\u001b[39mmeta_block_size,\n\u001b[1;32m    558\u001b[0m                      \u001b[38;5;241m*\u001b[39m\u001b[38;5;241m*\u001b[39mkwds)\n\u001b[1;32m    559\u001b[0m     fcpl \u001b[38;5;241m=\u001b[39m make_fcpl(track_order\u001b[38;5;241m=\u001b[39mtrack_order, fs_strategy\u001b[38;5;241m=\u001b[39mfs_strategy,\n\u001b[1;32m    560\u001b[0m                      fs_persist\u001b[38;5;241m=\u001b[39mfs_persist, fs_threshold\u001b[38;5;241m=\u001b[39mfs_threshold,\n\u001b[1;32m    561\u001b[0m                      fs_page_size\u001b[38;5;241m=\u001b[39mfs_page_size)\n\u001b[0;32m--> 562\u001b[0m     fid \u001b[38;5;241m=\u001b[39m \u001b[43mmake_fid\u001b[49m\u001b[43m(\u001b[49m\u001b[43mname\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mmode\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43muserblock_size\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mfapl\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mfcpl\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mswmr\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43mswmr\u001b[49m\u001b[43m)\u001b[49m\n\u001b[1;32m    564\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;28misinstance\u001b[39m(libver, \u001b[38;5;28mtuple\u001b[39m):\n\u001b[1;32m    565\u001b[0m     \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_libver \u001b[38;5;241m=\u001b[39m libver\n",
-+      "File \u001b[0;32m/Applications/miniconda3/envs/lietransformer/lib/python3.9/site-packages/h5py/_hl/files.py:235\u001b[0m, in \u001b[0;36mmake_fid\u001b[0;34m(name, mode, userblock_size, fapl, fcpl, swmr)\u001b[0m\n\u001b[1;32m    233\u001b[0m     \u001b[38;5;28;01mif\u001b[39;00m swmr \u001b[38;5;129;01mand\u001b[39;00m swmr_support:\n\u001b[1;32m    234\u001b[0m         flags \u001b[38;5;241m|\u001b[39m\u001b[38;5;241m=\u001b[39m h5f\u001b[38;5;241m.\u001b[39mACC_SWMR_READ\n\u001b[0;32m--> 235\u001b[0m     fid \u001b[38;5;241m=\u001b[39m \u001b[43mh5f\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mopen\u001b[49m\u001b[43m(\u001b[49m\u001b[43mname\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mflags\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mfapl\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43mfapl\u001b[49m\u001b[43m)\u001b[49m\n\u001b[1;32m    236\u001b[0m \u001b[38;5;28;01melif\u001b[39;00m mode \u001b[38;5;241m==\u001b[39m \u001b[38;5;124m'\u001b[39m\u001b[38;5;124mr+\u001b[39m\u001b[38;5;124m'\u001b[39m:\n\u001b[1;32m    237\u001b[0m     fid \u001b[38;5;241m=\u001b[39m h5f\u001b[38;5;241m.\u001b[39mopen(name, h5f\u001b[38;5;241m.\u001b[39mACC_RDWR, fapl\u001b[38;5;241m=\u001b[39mfapl)\n",
-+      "File \u001b[0;32mh5py/_objects.pyx:54\u001b[0m, in \u001b[0;36mh5py._objects.with_phil.wrapper\u001b[0;34m()\u001b[0m\n",
-+      "File \u001b[0;32mh5py/_objects.pyx:55\u001b[0m, in \u001b[0;36mh5py._objects.with_phil.wrapper\u001b[0;34m()\u001b[0m\n",
-+      "File \u001b[0;32mh5py/h5f.pyx:102\u001b[0m, in \u001b[0;36mh5py.h5f.open\u001b[0;34m()\u001b[0m\n",
-+      "\u001b[0;31mFileNotFoundError\u001b[0m: [Errno 2] Unable to open file (unable to open file: name = './checkpoints/feedforward/2/data_fold1/results_dict.h5', errno = 2, error message = 'No such file or directory', flags = 0, o_flags = 0)"
-+     ]
-+    }
-+   ],
-+   "source": [
-+    "import h5py\n",
-+    "\n",
-+    "file_path = \"./checkpoints/feedforward/2/data_fold1/results_dict.h5\"\n",
-+    "# Replace 'your_file.h5' with the actual path to your file\n",
-+    "f =  h5py.File(file_path, 'r') \n",
-+    "\n",
-+    "    # Get information about the data stored in the file\n",
-+    "print(\"Keys:\", list(f.keys()))  # List the top-level datasets and groups\n",
-+    "\n",
-+    "    # # Access a dataset by its name\n",
-+    "    # dataset_name = \"your_dataset_name\"\n",
-+    "    # if dataset_name in f:\n",
-+    "    #     dataset = f[dataset_name]\n",
-+    "    #     print(\"Dataset shape:\", dataset.shape)\n",
-+    "    #     print(\"Dataset dtype:\", dataset.dtype)\n",
-+    "\n",
-+    "    #     # Access the data as a NumPy array\n",
-+    "    #     data = dataset[:]  # Read the entire dataset\n",
-+    "\n",
-+    "    #     # You can now work with the data as needed, for example:\n",
-+    "    #     # Perform calculations, visualizations, etc.\n",
-+    "    # else:\n",
-+    "    #     print(f\"Dataset '{dataset_name}' not found in the file.\")"
-+   ]
-+  },
-+  {
-+   "cell_type": "code",
-+   "execution_count": 13,
-+   "id": "07e0b160-d5d1-4e54-b4a7-ccaf2224598a",
-+   "metadata": {},
-+   "outputs": [
-+    {
-+     "data": {
-+      "text/plain": [
-+       "<generator object Module.parameters at 0x3007207b0>"
-+      ]
-+     },
-+     "execution_count": 13,
-+     "metadata": {},
-+     "output_type": "execute_result"
-+    }
-+   ],
-+   "source": []
-+  },
-   {
-    "cell_type": "code",
-    "execution_count": null,
-diff --git a/train.py b/train.py
-index c266102..158d7d6 100644
---- a/train.py
-+++ b/train.py
-@@ -1,49 +1,458 @@
- from os import path as osp
-+import os
-+import numpy as np
-+import time
- 
- import torch
-+import torch.nn as nn
- import torch.nn.functional as F
- import torch.optim as optim
--
--import numpy as np
-+from torch.utils.tensorboard import SummaryWriter
- 
- import forge
- from forge import flags
- import forge.experiment_tools as fet
- 
-+from train_tools import (
-+	log_tensorboard,
-+	parse_reports,
-+	parse_reports_cpu,
-+	print_reports,
-+	load_checkpoint,
-+	save_checkpoint,
-+	nested_to,
-+	param_count,
-+)
-+
-+from copy import deepcopy
-+from attrdict import AttrDict
-+import deepdish as dd
-+from tqdm import tqdm
-+
-+# For reproducibility while researching, but might affect speed!
-+torch.backends.cudnn.deterministic = True
-+torch.backends.cudnn.benchmark = False
-+torch.manual_seed(0)
-+
- 
- # Job config
- flags.DEFINE_string('data_config', 'penn_dataset.py',
--                    'Path to a data config file.')
-+					'Path to a data config file.')
- flags.DEFINE_string('model_config', 'basic_feedforward.py',
--                    'Path to a model config file.')
-+					'Path to a model config file.')
- flags.DEFINE_string('results_dir', 'checkpoints',
--                    'Top directory for all experimental results.')
--flags.DEFINE_string('run_name', 'feedforward',
--                    'Name of this job and name of results folder.')
-+					'Top directory for all experimental results.')
-+flags.DEFINE_string('run_name', 'hyperparam_testing',
-+					'Name of this job and name of results folder.')
- flags.DEFINE_boolean('resume', False, 'Tries to resume a job if True.')
- 
- # Logging config
- flags.DEFINE_integer('report_loss_every', 50,
--                     'Number of iterations between reporting minibatch loss.')
--flags.DEFINE_integer('train_epochs', 20, 'Maximum number of training epochs.')
-+					 'Number of iterations between reporting minibatch loss.')
-+flags.DEFINE_integer('train_epochs', 30, 'Maximum number of training epochs.')
-+flags.DEFINE_integer(
-+	"save_check_points",
-+	10,
-+	"frequency with which to save checkpoints, in number of epoches.",
-+)
-+flags.DEFINE_boolean("log_train_values", True, "Logs train values if True.")
-+flags.DEFINE_integer(
-+	"total_evaluations",
-+	100,
-+	"Maximum number of evaluations on test and validation data during training.",
-+)
-+flags.DEFINE_boolean(
-+	"save_test_predictions",
-+	False,
-+	"Makes and saves test predictions on one or more test sets (e.g. 5-step and 100-step predictions) at the end of training.",
-+)
-+flags.DEFINE_boolean(
-+    "log_val_test", True, "Turns off computation of validation and test errors."
-+)
-+
-+flags.DEFINE_boolean('use_mps',False,"Use Metal Performance Shaders (M1) for training.")
- 
- # Experiment config
- flags.DEFINE_integer('batch_size', 100, 'Mini-batch size.')
--flags.DEFINE_float('learning_rate', 1e-5, 'SGD learning rate.')
-+flags.DEFINE_float("learning_rate", 1e-3, "Adam learning rate.")
-+flags.DEFINE_float("beta1", 0.9, "Adam Beta 1 parameter")
-+flags.DEFINE_float("beta2", 0.999, "Adam Beta 2 parameter")
- 
- # Specific config options
- flags.DEFINE_integer("input_size",39,"Input shape to model")
- 
-+#########################################################################################
-+
-+def evaluate(model, loader, device,fold = 0,headings = [],loss_func = nn.CrossEntropyLoss()):
-+	# this function does not account for class weights when evaluating cross-entropy loss.
-+	# however, they are accounted for when evaluating training loss
-+	reports = None
-+	for data in loader:
-+		labels = data['label']
-+		inputs = nested_to(data['data'],device,torch.float32)
-+		
-+		labels_tensor = torch.zeros((len(labels), 2))
-+		for i, label in enumerate(labels):
-+			labels_tensor[i, label] = 1
-+
-+		model_output = model(inputs) # evaluate model
-+
-+		loss = loss_func(model_output, labels_tensor) # compute loss
-+		outputs = AttrDict({"loss": loss, "prediction": model_output,'data_fold':fold})
-+		outputs.reports = AttrDict({"cross_entropy": loss})
-+
-+		if reports is None:
-+			reports = {k: v.detach().clone().cpu() for k, v in outputs.reports.items()}
-+		else:
-+			for k, v in outputs.reports.items():
-+				reports[k] += v.detach().clone().cpu()
-+
-+	for k, v in reports.items():
-+		reports[k] = v / len(
-+			loader
-+		)  # SZ: note this can be slightly incorrect if mini-batch sizes vary (if batch_size doesn't divide train_size), but approximately correct.
-+
-+	# reports['test_headings'] = np.array(headings)
-+
-+	return reports
-+
-+def main():
-+
-+	config = forge.config()
-+
-+	# Set device
-+	if torch.cuda.is_available():
-+		device = f"cuda:{config.device}"
-+		torch.cuda.set_device(device)
-+	else:
-+		device = "cpu" # can change this to MPS on M1 Macs
-+
-+	if config.use_mps:
-+		device = "mps"
-+
-+	# Load data
-+	data_name = "penn_data"
-+	kfold_loaders = fet.load(config.data_config, config)
-+
-+	# Load model
-+	model,model_name = fet.load(config.model_config, config)
-+	model = model.to(device)
-+
-+	# Prepare environment
-+	params_in_run_name = [
-+		("batch_size", "bs"),
-+		("learning_rate", "lr"),
-+		("n_train", "ntrain"),
-+		("include_coords",'inclx'),
-+		("input_size",'inpsize'),
-+		("cross_validate",'crval'),
-+		("train_epochs",'n_epochs'),
-+	]
-+
-+	run_name = ""  # config.run_name
-+	for config_param in params_in_run_name:
-+		attr = config_param[0]
-+		abbrev = config_param[1]
-+
-+		if hasattr(config, attr):
-+			run_name += abbrev
-+			run_name += str(getattr(config, attr))
-+			run_name += "_"
-+
-+	results_folder_name = osp.join(
-+		data_name,
-+		model_name,
-+		config.run_name,
-+		run_name,
-+	)
-+
-+	# Prepare environment
-+	logdir = osp.join(config.results_dir, results_folder_name.replace(".", "_"))
-+	logdir, resume_checkpoint = fet.init_checkpoint(
-+		logdir, config.data_config, config.model_config, config.resume)
-+
-+	print("Checkpoint directory:",logdir)
-+
-+	# Print flags
-+	fet.print_flags()
-+	# Print model info
-+	print(model)
-+
-+	# Setup optimizer
-+	model_params = model.parameters()
-+	opt_learning_rate = config.learning_rate
-+	model_opt = torch.optim.Adam(
-+		model_params, lr=opt_learning_rate, betas=(config.beta1, config.beta2)
-+	)
-+	scheduler = torch.optim.lr_scheduler.StepLR(model_opt, step_size=10, gamma=0.5)
-+	print("Model Optimizer:")
-+	print(model_opt)
-+
-+	# Try to restore model and optimizer from checkpoint
-+	if resume_checkpoint is not None:
-+		start_epoch = load_checkpoint(resume_checkpoint, model, model_opt)
-+	else:
-+		start_epoch = 1
-+
-+	n_folds = len(kfold_loaders)
-+	print("Doing {}-fold cross-validation.".format(n_folds))
-+
-+	# KFOLD TRAINING LOOP
-+	for k,loader_k in enumerate(kfold_loaders): # loop over data splits
-+
-+		print("Training fold {}...".format(k+1))
-+
-+		# load the training data
-+		train_loader = loader_k["train"]
-+		n_train = len(train_loader.dataset)
-+		train_batch_size = train_loader.batch_size
-+
-+		# load testing, validation
-+		test_loader = loader_k["test"]
-+		n_test = len(test_loader.dataset)
-+		val_loader = loader_k["val"]
-+		n_val = len(val_loader.dataset)
-+
-+		train_class_counts = np.bincount(train_loader.dataset.all_labels)
-+		train_total_counts = sum(train_class_counts)
-+		class_weight = torch.tensor(1.0 / train_class_counts) * train_total_counts / 2.0
-+
-+		loss_func = nn.CrossEntropyLoss(weight = class_weight) # define reweighted loss function
-+				
-+		# create folder for this data split
-+		fold_dir = osp.join(logdir,"data_fold{}".format(k+1))
-+		fold_dir_exists = osp.exists(fold_dir)
-+		if not fold_dir_exists:
-+			if config.resume:
-+				raise ValueError("Can't resume when the checkpoint/fold dir '{}' doesn't exist.".format(fold_dir))
-+			else:
-+				os.makedirs(fold_dir)
-+		checkpoint_name = osp.join(fold_dir, 'model_fold{}.ckpt'.format(k+1))
-+
-+		# keep track of which data is test data for a given Kfold data split
-+		test_headings = loader_k['test_headings']
-+		headingsFile = osp.join(fold_dir,"test_headings.txt")
-+		with open(headingsFile,'w') as headfile:
-+			for heading in test_headings:
-+				headfile.write(heading+'\n')
-+
-+		# print(checkpoint_name)
-+
-+		train_iter = (start_epoch - 1) * (
-+		len(train_loader.dataset) // train_batch_size
-+		) + 1
-+
-+		print("Starting training at epoch = {}, iter = {}".format(start_epoch, train_iter))
-+
-+		# Setup tensorboard writing
-+		summary_writer = SummaryWriter(logdir)
-+
-+		train_reports = []
-+		report_all = {}
-+		report_all_val = {}
-+
-+		# Saving model at epoch 0 before training
-+		print("saving model at epoch 0 before training ... ")
-+		save_checkpoint(checkpoint_name, 0, model, model_opt, loss=0.0)
-+		print("finished saving model at epoch 0 before training")
-+
-+		num_params = param_count(model)
-+		print(f"Number of model parameters: {num_params}")
-+
-+		# Training
-+		start_t = time.time()
-+
-+		total_train_iters = len(train_loader) * config.train_epochs
-+		iters_per_eval = max(1, int(total_train_iters / config.total_evaluations))
-+		# print('batch',train_batch_size)
-+		# print('ntrain',n_train)
-+		# assert (
-+		# 	n_train % min(train_batch_size, n_train) == 0
-+		# ), "Batch size doesn't divide dataset size. Can be inaccurate for loss computation (see below)."
-+
-+		training_failed = False
-+		best_val_loss_so_far = 1e7
-+
-+		for epoch in tqdm(range(start_epoch, config.train_epochs + 1)):
-+			model.train()
-+
-+			for batch_idx, data_dict in enumerate(train_loader): # Loop over batched data
-+
-+				labels = data_dict['label']
-+				data = data_dict['data']
-+
-+				# send data to device
-+				data = nested_to(data,device,torch.float32)
-+				# One-hot encode the data labels
-+				labels_tensor = torch.zeros((len(labels), 2))
-+				for i, label in enumerate(labels):
-+					labels_tensor[i, label] = 1
-+
-+				model_output = model(data) # evaluate model
-+
-+				loss = loss_func(model_output, labels_tensor) # compute loss
-+				outputs = AttrDict({"loss": loss, "prediction": model_output})
-+				outputs.reports = AttrDict({"cross_entropy": loss})
-+
-+				if torch.isnan(outputs.loss): # check for failure in training
-+					if not training_failed:
-+						epoch_of_nan = epoch
-+					if (epoch > epoch_of_nan + 1) and training_failed:
-+						raise ValueError("Loss Nan-ed.")
-+					training_failed = True
-+
-+				model_opt.zero_grad()
-+				outputs.loss.backward(retain_graph=False)
-+
-+				model_opt.step() # move optimizer forward
-+
-+				train_reports.append(parse_reports_cpu(outputs.reports))
-+
-+				if config.log_train_values:
-+					reports = parse_reports(outputs.reports)
-+					if batch_idx % config.report_loss_every == 0:
-+						log_tensorboard(summary_writer, train_iter, reports, "train/")
-+						print_reports(
-+							reports,
-+							start_t,
-+							epoch,
-+							batch_idx,
-+							len(train_loader.dataset) // train_batch_size,
-+							prefix="train",
-+						)
-+						log_tensorboard(
-+							summary_writer,
-+							train_iter,
-+							{"lr": model_opt.param_groups[0]["lr"]},
-+							"hyperparams/",
-+						)
-+				# Logging and evaluation
-+				if (
-+					train_iter % iters_per_eval == 0 or (train_iter == total_train_iters)
-+				) and config.log_val_test:  # batch_idx % config.evaluate_every == 0:
-+					model.eval()
-+					with torch.no_grad():
-+						reports = evaluate(model, test_loader, device,fold = k,headings = loader_k['test_headings'])
-+						# print("REPORTS",reports)
-+						reports = parse_reports(reports)
-+						reports["time"] = time.time() - start_t
-+						if report_all == {}:
-+							report_all = deepcopy(reports)
-+
-+							for d in reports.keys():
-+								report_all[d] = [report_all[d]]
-+						else:
-+							for d in reports.keys():
-+								report_all[d].append(reports[d])
-+
-+						log_tensorboard(summary_writer, train_iter, reports, "test/")
-+						print_reports(
-+							reports,
-+							start_t,
-+							epoch,
-+							batch_idx,
-+							len(train_loader.dataset) // config.batch_size,
-+							prefix="test",
-+						)
-+
-+						# repeat for validation data
-+						reports = evaluate(model, val_loader, device,fold = k,headings = loader_k['test_headings'])
-+						reports = parse_reports(reports)
-+						reports["time"] = time.time() - start_t
-+						if report_all_val == {}:
-+							report_all_val = deepcopy(reports)
-+
-+							for d in reports.keys():
-+								report_all_val[d] = [report_all_val[d]]
-+						else:
-+							for d in reports.keys():
-+								report_all_val[d].append(reports[d])
-+
-+						log_tensorboard(summary_writer, train_iter, reports, "val/")
-+						print_reports(
-+							reports,
-+							start_t,
-+							epoch,
-+							batch_idx,
-+							len(train_loader.dataset) // config.batch_size,
-+							prefix="val",
-+						)
-+
-+						if report_all_val["cross_entropy"][-1] < best_val_loss_so_far:
-+							save_checkpoint(
-+								checkpoint_name,
-+								f"early_stop",
-+								model,
-+								model_opt,
-+								loss=outputs.loss,
-+							)
-+							best_val_loss_so_far = report_all_val["cross_entropy"][-1]
-+
-+					model.train()
-+
-+				train_iter += 1
-+
-+			scheduler.step()
-+
-+			if epoch % config.save_check_points == 0:
-+				save_checkpoint(
-+					checkpoint_name, train_iter, model, model_opt, loss=outputs.loss
-+				)
-+		
-+		dd.io.save(fold_dir + "/results_dict_train.h5", train_reports)
-+		dd.io.save(fold_dir + "/results_dict.h5", report_all)
-+		dd.io.save(fold_dir + "/results_dict_val.h5", report_all_val)
-+
-+	# always save final model
-+	save_checkpoint(checkpoint_name, train_iter, model, model_opt, loss=outputs.loss)
-+
-+	
-+	if config.save_test_predictions:
-+		pass
-+		# print("Starting to make model predictions on test sets for *final model*.")
-+		# for chunk_len in [5, 100]:
-+		#     start_t_preds = time.time()
-+		#     data_config = SimpleNamespace(
-+		#         **{
-+		#             **config.__dict__["__flags"],
-+		#             **{"chunk_len": chunk_len, "batch_size": 500},
-+		#         }
-+		#     )
-+		#     dataloaders, data_name = fet.load(config.data_config, config=data_config)
-+		#     test_loader_preds = dataloaders["test"]
-+
-+		#     torch.cuda.empty_cache()
-+		#     with torch.no_grad():
-+		#         preds = []
-+		#         true = []
-+		#         num_datapoints = 0
-+		#         for idx, d in enumerate(test_loader_preds):
-+		#             true.append(d[-1])
-+		#             d = nested_to(d, device, torch.float32)
-+		#             outputs = model(d)
-+
-+		#             pred_zs = outputs.prediction
-+		#             preds.append(pred_zs)
-+
-+		#             num_datapoints += len(pred_zs)
-+
-+		#             if num_datapoints >= 2000:
-+		#                 break
- 
--config = forge.config()
-+		#         preds = torch.cat(preds, dim=0).cpu()
-+		#         true = torch.cat(true, dim=0).cpu()
- 
--# Prepare environment
--logdir = osp.join(config.results_dir, config.run_name)
--logdir, resume_checkpoint = fet.init_checkpoint(
--    logdir, config.data_config, config.model_config, config.resume)
--checkpoint_name = osp.join(logdir, 'model.ckpt')
-+		#         save_dir = osp.join(logdir, f"traj_preds_{chunk_len}_steps_2k_test.pt")
-+		#         torch.save(preds, save_dir)
- 
-+		#         save_dir = osp.join(logdir, f"traj_true_{chunk_len}_steps_2k_test.pt")
-+		#         torch.save(true, save_dir)
- 
--print(logdir)
-+		#         print(
-+		#             f"Completed making test predictions for chunk_len = {chunk_len} in {time.time() - start_t_preds:.2f} seconds."
-+		#         )	
-+		
- 
-+if __name__ == "__main__":
-+	main()
- 
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/3/penn_dataset.py b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/3/penn_dataset.py
deleted file mode 100644
index 7f5a4fc..0000000
--- a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs30_/3/penn_dataset.py
+++ /dev/null
@@ -1,137 +0,0 @@
-import os
-import torch
-import pandas as pd
-import numpy as np
-
-from torchvision import datasets, transforms
-from torch.utils.data import Dataset, DataLoader
-from sklearn.model_selection import RepeatedKFold
-
-from os import path as osp
-import forge
-from forge import flags
-
-
-# aspects of data managmement
-flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
-flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-flags.DEFINE_boolean("cross_validate",False,"Do K-fold cross-validation")
-
-# Job management
-# flags.DEFINE_integer("batch size",5,"training batch size")
-flags.DEFINE_float("train_split",0.8,'Fraction of data to use for training.')
-flags.DEFINE_integer("n_repeats",1,"Times to repeat K-fold cross-validation")
-flags.DEFINE_integer("split_seed",1,"Seed for KFold split (integer for reproducibility")
-
-# "wavelengths between 0.05 and 1 mm in 0.025 mm increments."
-LSPACE = np.arange(0.05,1.05,0.025) # corresponds to 39 non-coord columns of data
-L_INDS = None
-
-DATAFOLDER = './penn_data'
-
-HEADINGS = np.array(['aaa0043','aaa0044','aaa0060','aaa0061','aaa0063','aaa0064','aaa0066','aaa0069','aaa0086','aaa0087','aaa_0051','aaa_0053','aaa_0054','aaa_0059','aaa_0071','aaa_0072'])
-
-
-class PennData(Dataset):
-
-    def __init__(self,path_to_data,headings,k_inds = None,include_coords = True,rescale = True,spectra_prefix = "kvals_fuse_rotate_",label_prefix = 'labels_fuse_rotate_'):
-        
-        self.data_dir = path_to_data
-        self.headings = headings
-
-        df_list = []
-        label_list = []
-        for heading in self.headings: # for each datafile heading,
-            data_name = osp.join(self.data_dir,spectra_prefix + heading+'.csv') # read kvals
-            df_temp = pd.read_csv(data_name,header=None)
-            df_list.append(df_temp)
-
-            label_name = osp.join(self.data_dir,label_prefix + heading + '.csv') # read labels
-            label_temp = pd.read_csv(label_name,header=None, names=['label'])
-            label_list.append(label_temp)
-
-        df = pd.concat(df_list, ignore_index=True)
-
-        labels = pd.concat(label_list, ignore_index=True)
-        df = pd.concat([labels, df], axis="columns") # Append labels to data
-
-        all_labels = df['label'].to_numpy()
-        all_data = df.iloc[:,1:].to_numpy()
-
-        if rescale: # rescale (normalize) wavelength intensity data
-            lambdas = all_data[:,2:] # wavelengths
-            lam_std = np.std(lambdas, axis=0)  # Calculate standard deviation along columns
-            lam_mean = np.mean(lambdas, axis=0)  # Calculate mean along columns
-            lambdas_rescaled = (lambdas - lam_mean) / lam_std 
-            all_data[:,2:] = lambdas_rescaled
-
-        if not include_coords: # removes x,y coordinates from data
-            all_data = all_data[:,2:]
-        
-        if k_inds != None: # in this case, only use subset of wavelengths
-            all_data = all_data[:,np.array(k_inds)]
-
-        self.all_data = all_data
-        self.all_labels = all_labels
-
-    def __len__(self):
-        return len(self.all_data)
-
-    def __getitem__(self,i):
-        state = {'label':self.all_labels[i],'data':self.all_data[i]}
-        return state
-
-    def __getstate__(self):
-        state = {
-            'data': self.all_data,
-            'label': self.all_labels,
-                }
-        return state
-
-    def __setstate__(self, state):
-        # Set the object's state from the provided dictionary
-        self.all_data = state['data']
-        self.all_labels = state['label']
-        
-
-
-def load(config):
-
-    n_splits = int(len(HEADINGS)/((1-config.train_split)*len(HEADINGS)))
-
-    kf = RepeatedKFold(n_splits = n_splits, n_repeats = config.n_repeats, random_state = config.split_seed) # K-fold cross validation
-
-    kf_dataloaders = []
-
-    for i, (train_ind, test_ind) in enumerate(kf.split(HEADINGS)): # for each K-fold split, 
-        n_val = len(test_ind)//2
-        n_test = len(test_ind)-n_val   
-        n_train = len(train_ind)
-        
-        # set up training DataLoader
-        train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
-
-        # set up test DataLoader
-        test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
-
-        # set up val DataLoader
-        val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-        
-
-        dataloaders = {'train':train_loader, 
-                       'test':test_loader,
-                       'val':val_loader,
-                       'train_inds':train_ind,
-                       'test_inds':test_ind,
-                       'n_val':n_val,
-                       'test_headings':list(HEADINGS[test_ind])
-                      }
-        kf_dataloaders.append(dataloaders)
-
-        if not config.cross_validate:
-        	break
-
-    return kf_dataloaders
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/__pycache__/basic_feedforward.cpython-39.pyc b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/__pycache__/basic_feedforward.cpython-39.pyc
deleted file mode 100644
index 01b7042..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/__pycache__/basic_feedforward.cpython-39.pyc and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/__pycache__/penn_dataset.cpython-39.pyc b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/__pycache__/penn_dataset.cpython-39.pyc
deleted file mode 100644
index 4779fab..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/__pycache__/penn_dataset.cpython-39.pyc and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/basic_feedforward.py b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/basic_feedforward.py
deleted file mode 100644
index cdd5158..0000000
--- a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/basic_feedforward.py
+++ /dev/null
@@ -1,42 +0,0 @@
-import torch
-import torch.nn as nn
-import torch.nn.functional as F
-import numpy as np
-
-from forge import flags
-
-# flags.DEFINE_boolean(
-#     "model_with_dict",
-#     True,
-#     "Makes model output predictions in dictionary instead of directly."
-# )
-
-class PerceptronNN(nn.Module):
-    def __init__(self, input_size, num_labels):
-        super(PerceptronNN, self).__init__()
-        # Define the layers
-        self.fc1 = nn.Linear(input_size, 128)  # First dense layer
-        self.fc2 = nn.Linear(128, 64)         # Second dense layer
-        # self.fc23 = nn.Linear(64,64)
-        self.fc3 = nn.Linear(64, 64)          # Third dense layer
-        self.fc4 = nn.Linear(64, num_labels)  # Output layer
-        # self.softmax = nn.Softmax(dim=1)
-
-    def forward(self, x):
-        # Forward pass through the network
-        x = F.relu(self.fc1(x))  # Activation function between layers
-        x = F.relu(self.fc2(x))
-        # x = F.relu(self.fc23(x))
-        x = F.relu(self.fc3(x))
-        x = self.fc4(x)  # No activation, this will be included in the loss function
-        # x = self.softmax(x)
-        return x
-
-def load(config):
-
-    # n_channels = 1
-    n_features = config.input_size
-    
-    mlp = PerceptronNN(n_features,2)
-    
-    return mlp, "feedforward"
\ No newline at end of file
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold1/model_fold1.ckpt-0 b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold1/model_fold1.ckpt-0
deleted file mode 100644
index 52120eb..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold1/model_fold1.ckpt-0 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold1/model_fold1.ckpt-11511 b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold1/model_fold1.ckpt-11511
deleted file mode 100644
index c07bbf7..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold1/model_fold1.ckpt-11511 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold1/model_fold1.ckpt-23021 b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold1/model_fold1.ckpt-23021
deleted file mode 100644
index 673537d..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold1/model_fold1.ckpt-23021 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold1/model_fold1.ckpt-34531 b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold1/model_fold1.ckpt-34531
deleted file mode 100644
index 8a8908b..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold1/model_fold1.ckpt-34531 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold1/model_fold1.ckpt-early_stop b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold1/model_fold1.ckpt-early_stop
deleted file mode 100644
index 2bc3fc7..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold1/model_fold1.ckpt-early_stop and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold1/results_dict.h5 b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold1/results_dict.h5
deleted file mode 100644
index 83bde77..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold1/results_dict.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold1/results_dict_train.h5 b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold1/results_dict_train.h5
deleted file mode 100644
index 2ede2c2..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold1/results_dict_train.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold1/results_dict_val.h5 b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold1/results_dict_val.h5
deleted file mode 100644
index a367230..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold1/results_dict_val.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold1/test_headings.txt b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold1/test_headings.txt
deleted file mode 100644
index 05c4825..0000000
--- a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold1/test_headings.txt
+++ /dev/null
@@ -1,4 +0,0 @@
-aaa0060
-aaa0061
-aaa0069
-aaa_0059
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold2/model_fold2.ckpt-0 b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold2/model_fold2.ckpt-0
deleted file mode 100644
index 636d841..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold2/model_fold2.ckpt-0 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold2/model_fold2.ckpt-12131 b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold2/model_fold2.ckpt-12131
deleted file mode 100644
index a70bf0c..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold2/model_fold2.ckpt-12131 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold2/model_fold2.ckpt-24261 b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold2/model_fold2.ckpt-24261
deleted file mode 100644
index 3a5749d..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold2/model_fold2.ckpt-24261 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold2/model_fold2.ckpt-36391 b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold2/model_fold2.ckpt-36391
deleted file mode 100644
index b607887..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold2/model_fold2.ckpt-36391 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold2/model_fold2.ckpt-early_stop b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold2/model_fold2.ckpt-early_stop
deleted file mode 100644
index a1447f3..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold2/model_fold2.ckpt-early_stop and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold2/results_dict.h5 b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold2/results_dict.h5
deleted file mode 100644
index 4d1f690..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold2/results_dict.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold2/results_dict_train.h5 b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold2/results_dict_train.h5
deleted file mode 100644
index cdacd1a..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold2/results_dict_train.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold2/results_dict_val.h5 b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold2/results_dict_val.h5
deleted file mode 100644
index 732bbbf..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold2/results_dict_val.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold2/test_headings.txt b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold2/test_headings.txt
deleted file mode 100644
index b87ab5e..0000000
--- a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold2/test_headings.txt
+++ /dev/null
@@ -1,3 +0,0 @@
-aaa0063
-aaa0066
-aaa_0051
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold3/model_fold3.ckpt-0 b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold3/model_fold3.ckpt-0
deleted file mode 100644
index 30fd2be..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold3/model_fold3.ckpt-0 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold3/model_fold3.ckpt-12751 b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold3/model_fold3.ckpt-12751
deleted file mode 100644
index 467bfb4..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold3/model_fold3.ckpt-12751 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold3/model_fold3.ckpt-25501 b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold3/model_fold3.ckpt-25501
deleted file mode 100644
index 975074b..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold3/model_fold3.ckpt-25501 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold3/model_fold3.ckpt-38251 b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold3/model_fold3.ckpt-38251
deleted file mode 100644
index 5268e0d..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold3/model_fold3.ckpt-38251 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold3/model_fold3.ckpt-early_stop b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold3/model_fold3.ckpt-early_stop
deleted file mode 100644
index 30ca2f4..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold3/model_fold3.ckpt-early_stop and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold3/results_dict.h5 b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold3/results_dict.h5
deleted file mode 100644
index 3b7dd92..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold3/results_dict.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold3/results_dict_train.h5 b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold3/results_dict_train.h5
deleted file mode 100644
index 7658165..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold3/results_dict_train.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold3/results_dict_val.h5 b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold3/results_dict_val.h5
deleted file mode 100644
index a41a1c1..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold3/results_dict_val.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold3/test_headings.txt b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold3/test_headings.txt
deleted file mode 100644
index 8417193..0000000
--- a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold3/test_headings.txt
+++ /dev/null
@@ -1,3 +0,0 @@
-aaa0043
-aaa0044
-aaa_0071
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold4/model_fold4.ckpt-0 b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold4/model_fold4.ckpt-0
deleted file mode 100644
index 656f3ad..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold4/model_fold4.ckpt-0 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold4/model_fold4.ckpt-12721 b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold4/model_fold4.ckpt-12721
deleted file mode 100644
index 4c56644..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold4/model_fold4.ckpt-12721 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold4/model_fold4.ckpt-25441 b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold4/model_fold4.ckpt-25441
deleted file mode 100644
index 672f077..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold4/model_fold4.ckpt-25441 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold4/model_fold4.ckpt-38161 b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold4/model_fold4.ckpt-38161
deleted file mode 100644
index aef00a7..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold4/model_fold4.ckpt-38161 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold4/model_fold4.ckpt-early_stop b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold4/model_fold4.ckpt-early_stop
deleted file mode 100644
index f3b3785..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold4/model_fold4.ckpt-early_stop and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold4/results_dict.h5 b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold4/results_dict.h5
deleted file mode 100644
index 97c4db9..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold4/results_dict.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold4/results_dict_train.h5 b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold4/results_dict_train.h5
deleted file mode 100644
index 081d412..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold4/results_dict_train.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold4/results_dict_val.h5 b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold4/results_dict_val.h5
deleted file mode 100644
index 4ec1efc..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold4/results_dict_val.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold4/test_headings.txt b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold4/test_headings.txt
deleted file mode 100644
index ad5063c..0000000
--- a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold4/test_headings.txt
+++ /dev/null
@@ -1,3 +0,0 @@
-aaa0086
-aaa0087
-aaa_0072
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold5/model_fold5.ckpt-0 b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold5/model_fold5.ckpt-0
deleted file mode 100644
index 7022ce7..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold5/model_fold5.ckpt-0 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold5/model_fold5.ckpt-12241 b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold5/model_fold5.ckpt-12241
deleted file mode 100644
index 53e30ad..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold5/model_fold5.ckpt-12241 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold5/model_fold5.ckpt-24481 b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold5/model_fold5.ckpt-24481
deleted file mode 100644
index 258593b..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold5/model_fold5.ckpt-24481 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold5/model_fold5.ckpt-36721 b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold5/model_fold5.ckpt-36721
deleted file mode 100644
index 1f669b0..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold5/model_fold5.ckpt-36721 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold5/model_fold5.ckpt-early_stop b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold5/model_fold5.ckpt-early_stop
deleted file mode 100644
index 0ec8c04..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold5/model_fold5.ckpt-early_stop and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold5/results_dict.h5 b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold5/results_dict.h5
deleted file mode 100644
index f6f3032..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold5/results_dict.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold5/results_dict_train.h5 b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold5/results_dict_train.h5
deleted file mode 100644
index 825cce2..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold5/results_dict_train.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold5/results_dict_val.h5 b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold5/results_dict_val.h5
deleted file mode 100644
index baec64c..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold5/results_dict_val.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold5/test_headings.txt b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold5/test_headings.txt
deleted file mode 100644
index a4e6319..0000000
--- a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/data_fold5/test_headings.txt
+++ /dev/null
@@ -1,3 +0,0 @@
-aaa0064
-aaa_0053
-aaa_0054
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/events.out.tfevents.1709686825.MacBook-Pro-4.local.3248.0 b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/events.out.tfevents.1709686825.MacBook-Pro-4.local.3248.0
deleted file mode 100644
index 71d686d..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/events.out.tfevents.1709686825.MacBook-Pro-4.local.3248.0 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/events.out.tfevents.1709686884.MacBook-Pro-4.local.3248.1 b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/events.out.tfevents.1709686884.MacBook-Pro-4.local.3248.1
deleted file mode 100644
index 6f8ed57..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/events.out.tfevents.1709686884.MacBook-Pro-4.local.3248.1 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/events.out.tfevents.1709686943.MacBook-Pro-4.local.3248.2 b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/events.out.tfevents.1709686943.MacBook-Pro-4.local.3248.2
deleted file mode 100644
index 013cb8b..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/events.out.tfevents.1709686943.MacBook-Pro-4.local.3248.2 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/events.out.tfevents.1709686999.MacBook-Pro-4.local.3248.3 b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/events.out.tfevents.1709686999.MacBook-Pro-4.local.3248.3
deleted file mode 100644
index 2f53f14..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/events.out.tfevents.1709686999.MacBook-Pro-4.local.3248.3 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/events.out.tfevents.1709687056.MacBook-Pro-4.local.3248.4 b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/events.out.tfevents.1709687056.MacBook-Pro-4.local.3248.4
deleted file mode 100644
index c9d3ca3..0000000
Binary files a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/events.out.tfevents.1709687056.MacBook-Pro-4.local.3248.4 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/flags.json b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/flags.json
deleted file mode 100644
index fe1bc9f..0000000
--- a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/flags.json
+++ /dev/null
@@ -1,27 +0,0 @@
-{
-    "batch_size": 100,
-    "beta1": 0.9,
-    "beta2": 0.999,
-    "cross_validate": true,
-    "data_config": "penn_dataset.py",
-    "git_commit": "7416bf730b356aabfe0df644240e40948a8196bb",
-    "include_coords": false,
-    "input_size": 39,
-    "learning_rate": 0.001,
-    "log_train_values": true,
-    "log_val_test": true,
-    "model_config": "basic_feedforward.py",
-    "n_repeats": 1,
-    "report_loss_every": 50,
-    "rescale": true,
-    "results_dir": "checkpoints",
-    "resume": false,
-    "run_name": "hyperparam_testing",
-    "save_check_points": 10,
-    "save_test_predictions": false,
-    "split_seed": 1,
-    "total_evaluations": 100,
-    "train_epochs": 30,
-    "train_split": 0.8,
-    "use_mps": false
-}
\ No newline at end of file
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/git_diff.txt b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/git_diff.txt
deleted file mode 100644
index 8bb4f23..0000000
--- a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/git_diff.txt
+++ /dev/null
@@ -1,1775 +0,0 @@
-Tue Mar 5 17:00:25 PST 2024
-diff --git a/.DS_Store b/.DS_Store
-index e2836a8..bf7630a 100644
-Binary files a/.DS_Store and b/.DS_Store differ
-diff --git a/.ipynb_checkpoints/basic_feedforward-checkpoint.py b/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-index 688c282..0c4bcd1 100644
---- a/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-+++ b/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-@@ -5,6 +5,12 @@ import numpy as np
- 
- from forge import flags
- 
-+flags.DEFINE_boolean(
-+    "model_with_dict",
-+    True,
-+    "Makes model output predictions in dictionary instead of directly."
-+)
-+
- class PerceptronNN(nn.Module):
-     def __init__(self, input_size, num_labels):
-         super(PerceptronNN, self).__init__()
-@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-+        self.softmax = nn.Softmax(dim=1)
- 
-     def forward(self, x):
-         # Forward pass through the network
-@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-         x = F.relu(self.fc2(x))
-         x = F.relu(self.fc3(x))
-         x = self.fc4(x)  # No activation, this will be included in the loss function
-+        x = self.softmax(x)
-         return x
- 
- def load(config):
-@@ -29,4 +37,4 @@ def load(config):
-     
-     mlp = PerceptronNN(n_features,2)
-     
--    return mlp
-\ No newline at end of file
-+    return mlp, "feedforward"
-\ No newline at end of file
-diff --git a/__pycache__/basic_feedforward.cpython-39.pyc b/__pycache__/basic_feedforward.cpython-39.pyc
-index f541140..dddecf8 100644
-Binary files a/__pycache__/basic_feedforward.cpython-39.pyc and b/__pycache__/basic_feedforward.cpython-39.pyc differ
-diff --git a/__pycache__/penn_dataset.cpython-39.pyc b/__pycache__/penn_dataset.cpython-39.pyc
-index 0d7a4de..ecb5bc2 100644
-Binary files a/__pycache__/penn_dataset.cpython-39.pyc and b/__pycache__/penn_dataset.cpython-39.pyc differ
-diff --git a/basic_feedforward.py b/basic_feedforward.py
-index 688c282..cdd5158 100644
---- a/basic_feedforward.py
-+++ b/basic_feedforward.py
-@@ -5,21 +5,31 @@ import numpy as np
- 
- from forge import flags
- 
-+# flags.DEFINE_boolean(
-+#     "model_with_dict",
-+#     True,
-+#     "Makes model output predictions in dictionary instead of directly."
-+# )
-+
- class PerceptronNN(nn.Module):
-     def __init__(self, input_size, num_labels):
-         super(PerceptronNN, self).__init__()
-         # Define the layers
-         self.fc1 = nn.Linear(input_size, 128)  # First dense layer
-         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-+        # self.fc23 = nn.Linear(64,64)
-         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-+        # self.softmax = nn.Softmax(dim=1)
- 
-     def forward(self, x):
-         # Forward pass through the network
-         x = F.relu(self.fc1(x))  # Activation function between layers
-         x = F.relu(self.fc2(x))
-+        # x = F.relu(self.fc23(x))
-         x = F.relu(self.fc3(x))
-         x = self.fc4(x)  # No activation, this will be included in the loss function
-+        # x = self.softmax(x)
-         return x
- 
- def load(config):
-@@ -29,4 +39,4 @@ def load(config):
-     
-     mlp = PerceptronNN(n_features,2)
-     
--    return mlp
-\ No newline at end of file
-+    return mlp, "feedforward"
-\ No newline at end of file
-diff --git a/checkpoints/feedforward/1/basic_feedforward.py b/checkpoints/feedforward/1/basic_feedforward.py
-index 688c282..3a65525 100644
---- a/checkpoints/feedforward/1/basic_feedforward.py
-+++ b/checkpoints/feedforward/1/basic_feedforward.py
-@@ -5,6 +5,12 @@ import numpy as np
- 
- from forge import flags
- 
-+# flags.DEFINE_boolean(
-+#     "model_with_dict",
-+#     True,
-+#     "Makes model output predictions in dictionary instead of directly."
-+# )
-+
- class PerceptronNN(nn.Module):
-     def __init__(self, input_size, num_labels):
-         super(PerceptronNN, self).__init__()
-@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-+        self.softmax = nn.Softmax(dim=1)
- 
-     def forward(self, x):
-         # Forward pass through the network
-@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-         x = F.relu(self.fc2(x))
-         x = F.relu(self.fc3(x))
-         x = self.fc4(x)  # No activation, this will be included in the loss function
-+        x = self.softmax(x)
-         return x
- 
- def load(config):
-@@ -29,4 +37,4 @@ def load(config):
-     
-     mlp = PerceptronNN(n_features,2)
-     
--    return mlp
-\ No newline at end of file
-+    return mlp, "feedforward"
-\ No newline at end of file
-diff --git a/checkpoints/feedforward/1/flags.json b/checkpoints/feedforward/1/flags.json
-index 1d000c3..889a6ea 100644
---- a/checkpoints/feedforward/1/flags.json
-+++ b/checkpoints/feedforward/1/flags.json
-@@ -1,9 +1,15 @@
- {
-     "batch_size": 100,
-+    "beta1": 0.9,
-+    "beta2": 0.999,
-+    "cross_validate": false,
-     "data_config": "penn_dataset.py",
-+    "git_commit": "7416bf730b356aabfe0df644240e40948a8196bb",
-     "include_coords": false,
-     "input_size": 39,
--    "learning_rate": 1e-05,
-+    "learning_rate": 0.0001,
-+    "log_train_values": true,
-+    "log_val_test": true,
-     "model_config": "basic_feedforward.py",
-     "n_repeats": 1,
-     "report_loss_every": 50,
-@@ -11,7 +17,10 @@
-     "results_dir": "checkpoints",
-     "resume": false,
-     "run_name": "feedforward",
-+    "save_check_points": 50,
-+    "save_test_predictions": false,
-     "split_seed": 1,
--    "train_epochs": 20,
-+    "total_evaluations": 100,
-+    "train_epochs": 100,
-     "train_split": 0.8
- }
-\ No newline at end of file
-diff --git a/checkpoints/feedforward/1/git_diff.txt b/checkpoints/feedforward/1/git_diff.txt
-index 7b37e6f..ec23707 100644
---- a/checkpoints/feedforward/1/git_diff.txt
-+++ b/checkpoints/feedforward/1/git_diff.txt
-@@ -1 +1,873 @@
--Mon Mar 4 11:45:48 PST 2024
-+Mon Mar 4 16:34:02 PST 2024
-+diff --git a/.DS_Store b/.DS_Store
-+index e2836a8..7e3fa32 100644
-+Binary files a/.DS_Store and b/.DS_Store differ
-+diff --git a/.ipynb_checkpoints/basic_feedforward-checkpoint.py b/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-+index 688c282..0c4bcd1 100644
-+--- a/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-++++ b/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-+@@ -5,6 +5,12 @@ import numpy as np
-+ 
-+ from forge import flags
-+ 
-++flags.DEFINE_boolean(
-++    "model_with_dict",
-++    True,
-++    "Makes model output predictions in dictionary instead of directly."
-++)
-++
-+ class PerceptronNN(nn.Module):
-+     def __init__(self, input_size, num_labels):
-+         super(PerceptronNN, self).__init__()
-+@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-+         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-+         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-+         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-++        self.softmax = nn.Softmax(dim=1)
-+ 
-+     def forward(self, x):
-+         # Forward pass through the network
-+@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-+         x = F.relu(self.fc2(x))
-+         x = F.relu(self.fc3(x))
-+         x = self.fc4(x)  # No activation, this will be included in the loss function
-++        x = self.softmax(x)
-+         return x
-+ 
-+ def load(config):
-+@@ -29,4 +37,4 @@ def load(config):
-+     
-+     mlp = PerceptronNN(n_features,2)
-+     
-+-    return mlp
-+\ No newline at end of file
-++    return mlp, "feedforward"
-+\ No newline at end of file
-+diff --git a/__pycache__/basic_feedforward.cpython-39.pyc b/__pycache__/basic_feedforward.cpython-39.pyc
-+index f541140..5ad96de 100644
-+Binary files a/__pycache__/basic_feedforward.cpython-39.pyc and b/__pycache__/basic_feedforward.cpython-39.pyc differ
-+diff --git a/__pycache__/penn_dataset.cpython-39.pyc b/__pycache__/penn_dataset.cpython-39.pyc
-+index 0d7a4de..19121eb 100644
-+Binary files a/__pycache__/penn_dataset.cpython-39.pyc and b/__pycache__/penn_dataset.cpython-39.pyc differ
-+diff --git a/basic_feedforward.py b/basic_feedforward.py
-+index 688c282..3a65525 100644
-+--- a/basic_feedforward.py
-++++ b/basic_feedforward.py
-+@@ -5,6 +5,12 @@ import numpy as np
-+ 
-+ from forge import flags
-+ 
-++# flags.DEFINE_boolean(
-++#     "model_with_dict",
-++#     True,
-++#     "Makes model output predictions in dictionary instead of directly."
-++# )
-++
-+ class PerceptronNN(nn.Module):
-+     def __init__(self, input_size, num_labels):
-+         super(PerceptronNN, self).__init__()
-+@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-+         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-+         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-+         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-++        self.softmax = nn.Softmax(dim=1)
-+ 
-+     def forward(self, x):
-+         # Forward pass through the network
-+@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-+         x = F.relu(self.fc2(x))
-+         x = F.relu(self.fc3(x))
-+         x = self.fc4(x)  # No activation, this will be included in the loss function
-++        x = self.softmax(x)
-+         return x
-+ 
-+ def load(config):
-+@@ -29,4 +37,4 @@ def load(config):
-+     
-+     mlp = PerceptronNN(n_features,2)
-+     
-+-    return mlp
-+\ No newline at end of file
-++    return mlp, "feedforward"
-+\ No newline at end of file
-+diff --git a/checkpoints/feedforward/1/basic_feedforward.py b/checkpoints/feedforward/1/basic_feedforward.py
-+index 688c282..3a65525 100644
-+--- a/checkpoints/feedforward/1/basic_feedforward.py
-++++ b/checkpoints/feedforward/1/basic_feedforward.py
-+@@ -5,6 +5,12 @@ import numpy as np
-+ 
-+ from forge import flags
-+ 
-++# flags.DEFINE_boolean(
-++#     "model_with_dict",
-++#     True,
-++#     "Makes model output predictions in dictionary instead of directly."
-++# )
-++
-+ class PerceptronNN(nn.Module):
-+     def __init__(self, input_size, num_labels):
-+         super(PerceptronNN, self).__init__()
-+@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-+         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-+         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-+         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-++        self.softmax = nn.Softmax(dim=1)
-+ 
-+     def forward(self, x):
-+         # Forward pass through the network
-+@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-+         x = F.relu(self.fc2(x))
-+         x = F.relu(self.fc3(x))
-+         x = self.fc4(x)  # No activation, this will be included in the loss function
-++        x = self.softmax(x)
-+         return x
-+ 
-+ def load(config):
-+@@ -29,4 +37,4 @@ def load(config):
-+     
-+     mlp = PerceptronNN(n_features,2)
-+     
-+-    return mlp
-+\ No newline at end of file
-++    return mlp, "feedforward"
-+\ No newline at end of file
-+diff --git a/checkpoints/feedforward/1/flags.json b/checkpoints/feedforward/1/flags.json
-+index 1d000c3..889a6ea 100644
-+--- a/checkpoints/feedforward/1/flags.json
-++++ b/checkpoints/feedforward/1/flags.json
-+@@ -1,9 +1,15 @@
-+ {
-+     "batch_size": 100,
-++    "beta1": 0.9,
-++    "beta2": 0.999,
-++    "cross_validate": false,
-+     "data_config": "penn_dataset.py",
-++    "git_commit": "7416bf730b356aabfe0df644240e40948a8196bb",
-+     "include_coords": false,
-+     "input_size": 39,
-+-    "learning_rate": 1e-05,
-++    "learning_rate": 0.0001,
-++    "log_train_values": true,
-++    "log_val_test": true,
-+     "model_config": "basic_feedforward.py",
-+     "n_repeats": 1,
-+     "report_loss_every": 50,
-+@@ -11,7 +17,10 @@
-+     "results_dir": "checkpoints",
-+     "resume": false,
-+     "run_name": "feedforward",
-++    "save_check_points": 50,
-++    "save_test_predictions": false,
-+     "split_seed": 1,
-+-    "train_epochs": 20,
-++    "total_evaluations": 100,
-++    "train_epochs": 100,
-+     "train_split": 0.8
-+ }
-+\ No newline at end of file
-+diff --git a/checkpoints/feedforward/1/git_diff.txt b/checkpoints/feedforward/1/git_diff.txt
-+index 7b37e6f..5c561db 100644
-+--- a/checkpoints/feedforward/1/git_diff.txt
-++++ b/checkpoints/feedforward/1/git_diff.txt
-+@@ -1 +1 @@
-+-Mon Mar 4 11:45:48 PST 2024
-++Mon Mar 4 16:34:02 PST 2024
-+diff --git a/checkpoints/feedforward/1/penn_dataset.py b/checkpoints/feedforward/1/penn_dataset.py
-+index aa2f5a0..7f5a4fc 100644
-+--- a/checkpoints/feedforward/1/penn_dataset.py
-++++ b/checkpoints/feedforward/1/penn_dataset.py
-+@@ -15,6 +15,7 @@ from forge import flags
-+ # aspects of data managmement
-+ flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
-+ flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-++flags.DEFINE_boolean("cross_validate",False,"Do K-fold cross-validation")
-+ 
-+ # Job management
-+ # flags.DEFINE_integer("batch size",5,"training batch size")
-+@@ -109,15 +110,15 @@ def load(config):
-+         
-+         # set up training DataLoader
-+         train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, n_train),num_workers=0,shuffle = True)
-++        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
-+ 
-+         # set up test DataLoader
-+         test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, n_test),num_workers=0,shuffle = True)
-++        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
-+ 
-+         # set up val DataLoader
-+         val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, n_val),num_workers=0,shuffle = True)
-++        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-+         
-+ 
-+         dataloaders = {'train':train_loader, 
-+@@ -125,8 +126,12 @@ def load(config):
-+                        'val':val_loader,
-+                        'train_inds':train_ind,
-+                        'test_inds':test_ind,
-+-                       'n_val':n_val
-++                       'n_val':n_val,
-++                       'test_headings':list(HEADINGS[test_ind])
-+                       }
-+         kf_dataloaders.append(dataloaders)
-+ 
-++        if not config.cross_validate:
-++        	break
-++
-+     return kf_dataloaders
-+diff --git a/penn_dataset.py b/penn_dataset.py
-+index aa2f5a0..7f5a4fc 100644
-+--- a/penn_dataset.py
-++++ b/penn_dataset.py
-+@@ -15,6 +15,7 @@ from forge import flags
-+ # aspects of data managmement
-+ flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
-+ flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-++flags.DEFINE_boolean("cross_validate",False,"Do K-fold cross-validation")
-+ 
-+ # Job management
-+ # flags.DEFINE_integer("batch size",5,"training batch size")
-+@@ -109,15 +110,15 @@ def load(config):
-+         
-+         # set up training DataLoader
-+         train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, n_train),num_workers=0,shuffle = True)
-++        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
-+ 
-+         # set up test DataLoader
-+         test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, n_test),num_workers=0,shuffle = True)
-++        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
-+ 
-+         # set up val DataLoader
-+         val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, n_val),num_workers=0,shuffle = True)
-++        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-+         
-+ 
-+         dataloaders = {'train':train_loader, 
-+@@ -125,8 +126,12 @@ def load(config):
-+                        'val':val_loader,
-+                        'train_inds':train_ind,
-+                        'test_inds':test_ind,
-+-                       'n_val':n_val
-++                       'n_val':n_val,
-++                       'test_headings':list(HEADINGS[test_ind])
-+                       }
-+         kf_dataloaders.append(dataloaders)
-+ 
-++        if not config.cross_validate:
-++        	break
-++
-+     return kf_dataloaders
-+diff --git a/testing.ipynb b/testing.ipynb
-+index e5a167b..a928d8d 100644
-+--- a/testing.ipynb
-++++ b/testing.ipynb
-+@@ -2,7 +2,7 @@
-+  "cells": [
-+   {
-+    "cell_type": "code",
-+-   "execution_count": 1,
-++   "execution_count": 2,
-+    "id": "4dee7ff1-01a4-4038-b493-9729ff3693f7",
-+    "metadata": {},
-+    "outputs": [],
-+@@ -23,19 +23,19 @@
-+   },
-+   {
-+    "cell_type": "code",
-+-   "execution_count": 2,
-++   "execution_count": 3,
-+    "id": "cad0fdc8-5c35-4610-bba3-b71e60dc1b98",
-+    "metadata": {},
-+    "outputs": [],
-+    "source": [
-+-    "flags.DEFINE_integer(\"batch_size\", 100, \"Mini-batch size.\")\n",
-++    "flags.DEFINE_integer(\"batch_size\", 10, \"Mini-batch size.\")\n",
-+     "\n",
-+     "flags.DEFINE_integer(\"input_size\",39,\"Input shape to model\")"
-+    ]
-+   },
-+   {
-+    "cell_type": "code",
-+-   "execution_count": 3,
-++   "execution_count": 4,
-+    "id": "ce1b936b-8a7c-426e-a3aa-3c1c38f645de",
-+    "metadata": {},
-+    "outputs": [
-+@@ -54,8 +54,8 @@
-+   },
-+   {
-+    "cell_type": "code",
-+-   "execution_count": 9,
-+-   "id": "e862b7e2-57f5-44bf-bcf1-a91160ba66cc",
-++   "execution_count": 5,
-++   "id": "4469cddf-4dac-4468-be88-241d440401c3",
-+    "metadata": {},
-+    "outputs": [
-+     {
-+@@ -67,35 +67,89 @@
-+     }
-+    ],
-+    "source": [
-+-    "model = fet.load(\"basic_feedforward.py\",config)"
-++    "model,modelname = fet.load(\"basic_feedforward.py\",config)"
-+    ]
-+   },
-+   {
-+    "cell_type": "code",
-+-   "execution_count": 10,
-+-   "id": "07e0b160-d5d1-4e54-b4a7-ccaf2224598a",
-++   "execution_count": 17,
-++   "id": "7c9a9fe9-f5e8-456a-b964-4be13027725b",
-+    "metadata": {},
-+    "outputs": [
-+     {
-+      "data": {
-+       "text/plain": [
-+-       "PerceptronNN(\n",
-+-       "  (fc1): Linear(in_features=39, out_features=128, bias=True)\n",
-+-       "  (fc2): Linear(in_features=128, out_features=64, bias=True)\n",
-+-       "  (fc3): Linear(in_features=64, out_features=64, bias=True)\n",
-+-       "  (fc4): Linear(in_features=64, out_features=2, bias=True)\n",
-+-       ")"
-++       "['aaa0060', 'aaa0061', 'aaa0069', 'aaa_0059']"
-+       ]
-+      },
-+-     "execution_count": 10,
-++     "execution_count": 17,
-+      "metadata": {},
-+      "output_type": "execute_result"
-+     }
-+    ],
-+    "source": [
-+-    "model"
-++    "loaddat[0]['test_headings']"
-++   ]
-++  },
-++  {
-++   "cell_type": "code",
-++   "execution_count": 19,
-++   "id": "e862b7e2-57f5-44bf-bcf1-a91160ba66cc",
-++   "metadata": {},
-++   "outputs": [
-++    {
-++     "name": "stdout",
-++     "output_type": "stream",
-++     "text": [
-++      "Keys: ['cross_entropy', 'time']\n"
-++     ]
-++    }
-++   ],
-++   "source": [
-++    "import h5py\n",
-++    "\n",
-++    "file_path = \"./checkpoints/feedforward/2/data_fold1/results_dict.h5\"\n",
-++    "# Replace 'your_file.h5' with the actual path to your file\n",
-++    "f =  h5py.File(file_path, 'r') \n",
-++    "\n",
-++    "    # Get information about the data stored in the file\n",
-++    "print(\"Keys:\", list(f.keys()))  # List the top-level datasets and groups\n",
-++    "\n",
-++    "    # # Access a dataset by its name\n",
-++    "    # dataset_name = \"your_dataset_name\"\n",
-++    "    # if dataset_name in f:\n",
-++    "    #     dataset = f[dataset_name]\n",
-++    "    #     print(\"Dataset shape:\", dataset.shape)\n",
-++    "    #     print(\"Dataset dtype:\", dataset.dtype)\n",
-++    "\n",
-++    "    #     # Access the data as a NumPy array\n",
-++    "    #     data = dataset[:]  # Read the entire dataset\n",
-++    "\n",
-++    "    #     # You can now work with the data as needed, for example:\n",
-++    "    #     # Perform calculations, visualizations, etc.\n",
-++    "    # else:\n",
-++    "    #     print(f\"Dataset '{dataset_name}' not found in the file.\")"
-+    ]
-+   },
-++  {
-++   "cell_type": "code",
-++   "execution_count": 13,
-++   "id": "07e0b160-d5d1-4e54-b4a7-ccaf2224598a",
-++   "metadata": {},
-++   "outputs": [
-++    {
-++     "data": {
-++      "text/plain": [
-++       "<generator object Module.parameters at 0x3007207b0>"
-++      ]
-++     },
-++     "execution_count": 13,
-++     "metadata": {},
-++     "output_type": "execute_result"
-++    }
-++   ],
-++   "source": []
-++  },
-+   {
-+    "cell_type": "code",
-+    "execution_count": null,
-+diff --git a/train.py b/train.py
-+index c266102..516bfa9 100644
-+--- a/train.py
-++++ b/train.py
-+@@ -1,49 +1,440 @@
-+ from os import path as osp
-++import os
-++import numpy as np
-++import time
-+ 
-+ import torch
-++import torch.nn as nn
-+ import torch.nn.functional as F
-+ import torch.optim as optim
-+-
-+-import numpy as np
-++from torch.utils.tensorboard import SummaryWriter
-+ 
-+ import forge
-+ from forge import flags
-+ import forge.experiment_tools as fet
-+ 
-++from train_tools import (
-++	log_tensorboard,
-++	parse_reports,
-++	parse_reports_cpu,
-++	print_reports,
-++	load_checkpoint,
-++	save_checkpoint,
-++	nested_to,
-++	param_count,
-++)
-++
-++from copy import deepcopy
-++from attrdict import AttrDict
-++import deepdish as dd
-++from tqdm import tqdm
-++
-++# For reproducibility while researching, but might affect speed!
-++torch.backends.cudnn.deterministic = True
-++torch.backends.cudnn.benchmark = False
-++torch.manual_seed(0)
-++
-+ 
-+ # Job config
-+ flags.DEFINE_string('data_config', 'penn_dataset.py',
-+-                    'Path to a data config file.')
-++					'Path to a data config file.')
-+ flags.DEFINE_string('model_config', 'basic_feedforward.py',
-+-                    'Path to a model config file.')
-++					'Path to a model config file.')
-+ flags.DEFINE_string('results_dir', 'checkpoints',
-+-                    'Top directory for all experimental results.')
-++					'Top directory for all experimental results.')
-+ flags.DEFINE_string('run_name', 'feedforward',
-+-                    'Name of this job and name of results folder.')
-++					'Name of this job and name of results folder.')
-+ flags.DEFINE_boolean('resume', False, 'Tries to resume a job if True.')
-+ 
-+ # Logging config
-+ flags.DEFINE_integer('report_loss_every', 50,
-+-                     'Number of iterations between reporting minibatch loss.')
-+-flags.DEFINE_integer('train_epochs', 20, 'Maximum number of training epochs.')
-++					 'Number of iterations between reporting minibatch loss.')
-++flags.DEFINE_integer('train_epochs', 100, 'Maximum number of training epochs.')
-++flags.DEFINE_integer(
-++	"save_check_points",
-++	50,
-++	"frequency with which to save checkpoints, in number of epoches.",
-++)
-++flags.DEFINE_boolean("log_train_values", True, "Logs train values if True.")
-++flags.DEFINE_integer(
-++	"total_evaluations",
-++	100,
-++	"Maximum number of evaluations on test and validation data during training.",
-++)
-++flags.DEFINE_boolean(
-++	"save_test_predictions",
-++	False,
-++	"Makes and saves test predictions on one or more test sets (e.g. 5-step and 100-step predictions) at the end of training.",
-++)
-++flags.DEFINE_boolean(
-++    "log_val_test", True, "Turns off computation of validation and test errors."
-++)
-+ 
-+ # Experiment config
-+ flags.DEFINE_integer('batch_size', 100, 'Mini-batch size.')
-+-flags.DEFINE_float('learning_rate', 1e-5, 'SGD learning rate.')
-++flags.DEFINE_float("learning_rate", 1e-4, "Adam learning rate.")
-++flags.DEFINE_float("beta1", 0.9, "Adam Beta 1 parameter")
-++flags.DEFINE_float("beta2", 0.999, "Adam Beta 2 parameter")
-+ 
-+ # Specific config options
-+ flags.DEFINE_integer("input_size",39,"Input shape to model")
-+ 
-++#########################################################################################
-++
-++def evaluate(model, loader, device,fold = 0,headings = [],loss_func = nn.CrossEntropyLoss()):
-++	reports = None
-++	for data in loader:
-++		labels = data['label']
-++		inputs = nested_to(data['data'],device,torch.float32)
-++		
-++		labels_tensor = torch.zeros((len(labels), 2))
-++		for i, label in enumerate(labels):
-++			labels_tensor[i, label] = 1
-++
-++		model_output = model(inputs) # evaluate model
-++
-++		loss = loss_func(model_output, labels_tensor) # compute loss
-++		outputs = AttrDict({"loss": loss, "prediction": model_output,'data_fold':fold})
-++		outputs.reports = AttrDict({"cross_entropy": loss})
-++
-++		if reports is None:
-++			reports = {k: v.detach().clone().cpu() for k, v in outputs.reports.items()}
-++		else:
-++			for k, v in outputs.reports.items():
-++				reports[k] += v.detach().clone().cpu()
-++
-++	for k, v in reports.items():
-++		reports[k] = v / len(
-++			loader
-++		)  # SZ: note this can be slightly incorrect if mini-batch sizes vary (if batch_size doesn't divide train_size), but approximately correct.
-++
-++	# reports['test_headings'] = np.array(headings)
-++
-++	return reports
-++
-++def main():
-++
-++	config = forge.config()
-++
-++	# Set device
-++	if torch.cuda.is_available():
-++		device = f"cuda:{config.device}"
-++		torch.cuda.set_device(device)
-++	else:
-++		device = "cpu" # can change this to MPS on M1 Macs
-++
-++	# Load data
-++	data_name = "penn_data"
-++	kfold_loaders = fet.load(config.data_config, config)
-++
-++	# Load model
-++	model,model_name = fet.load(config.model_config, config)
-++	model = model.to(device)
-++
-++	loss_func = nn.CrossEntropyLoss()
-++
-++	# Prepare environment
-++	params_in_run_name = [
-++		("batch_size", "bs"),
-++		("learning_rate", "lr"),
-++		("n_train", "ntrain")
-++	]
-++
-++	run_name = ""  # config.run_name
-++	for config_param in params_in_run_name:
-++		attr = config_param[0]
-++		abbrev = config_param[1]
-++
-++		if hasattr(config, attr):
-++			run_name += abbrev
-++			run_name += str(getattr(config, attr))
-++			run_name += "_"
-++
-++	results_folder_name = osp.join(
-++		data_name,
-++		model_name,
-++		config.run_name,
-++		run_name,
-++	)
-++
-++	# Prepare environment
-++	logdir = osp.join(config.results_dir, config.run_name)
-++	logdir, resume_checkpoint = fet.init_checkpoint(
-++		logdir, config.data_config, config.model_config, config.resume)
-++
-++	print("Checkpoint directory:",logdir)
-++
-++	# Print flags
-++	fet.print_flags()
-++	# Print model info
-++	print(model)
-++
-++	# Setup optimizer
-++	model_params = model.parameters()
-++	opt_learning_rate = config.learning_rate
-++	model_opt = torch.optim.Adam(
-++		model_params, lr=opt_learning_rate, betas=(config.beta1, config.beta2)
-++	)
-++	print("Model Optimizer:")
-++	print(model_opt)
-++
-++	# Try to restore model and optimizer from checkpoint
-++	if resume_checkpoint is not None:
-++		start_epoch = load_checkpoint(resume_checkpoint, model, model_opt)
-++	else:
-++		start_epoch = 1
-++
-++	n_folds = len(kfold_loaders)
-++	print("Doing {}-fold cross-validation.".format(n_folds))
-++
-++	# KFOLD TRAINING LOOP
-++	for k,loader_k in enumerate(kfold_loaders): # loop over data splits
-++
-++		print("Training fold {}...".format(k+1))
-++
-++		# load the training data
-++		train_loader = loader_k["train"]
-++		n_train = len(train_loader.dataset)
-++		train_batch_size = train_loader.batch_size
-++
-++		# load testing, validation
-++		test_loader = loader_k["test"]
-++		n_test = len(test_loader.dataset)
-++		val_loader = loader_k["val"]
-++		n_val = len(val_loader.dataset)
-++		
-++		# create folder for this data split
-++		fold_dir = osp.join(logdir,"data_fold{}".format(k+1))
-++		fold_dir_exists = osp.exists(fold_dir)
-++		if not fold_dir_exists:
-++			if config.resume:
-++				raise ValueError("Can't resume when the checkpoint/fold dir '{}' doesn't exist.".format(fold_dir))
-++			else:
-++				os.makedirs(fold_dir)
-++		checkpoint_name = osp.join(fold_dir, 'model_fold{}.ckpt'.format(k+1))
-++
-++		# keep track of which data is test data for a given Kfold data split
-++		test_headings = loader_k['test_headings']
-++		headingsFile = osp.join(fold_dir,"test_headings.txt")
-++		with open(headingsFile,'w') as headfile:
-++			for heading in test_headings:
-++				headfile.write(heading+'\n')
-++
-++		# print(checkpoint_name)
-++
-++		train_iter = (start_epoch - 1) * (
-++		len(train_loader.dataset) // train_batch_size
-++		) + 1
-++
-++		print("Starting training at epoch = {}, iter = {}".format(start_epoch, train_iter))
-++
-++		# Setup tensorboard writing
-++		summary_writer = SummaryWriter(logdir)
-++
-++		train_reports = []
-++		report_all = {}
-++		report_all_val = {}
-++
-++		# Saving model at epoch 0 before training
-++		print("saving model at epoch 0 before training ... ")
-++		save_checkpoint(checkpoint_name, 0, model, model_opt, loss=0.0)
-++		print("finished saving model at epoch 0 before training")
-++
-++		num_params = param_count(model)
-++		print(f"Number of model parameters: {num_params}")
-++
-++		# Training
-++		start_t = time.time()
-++
-++		total_train_iters = len(train_loader) * config.train_epochs
-++		iters_per_eval = max(1, int(total_train_iters / config.total_evaluations))
-++		# print('batch',train_batch_size)
-++		# print('ntrain',n_train)
-++		# assert (
-++		# 	n_train % min(train_batch_size, n_train) == 0
-++		# ), "Batch size doesn't divide dataset size. Can be inaccurate for loss computation (see below)."
-++
-++		training_failed = False
-++		best_val_loss_so_far = 1e7
-++
-++		for epoch in tqdm(range(start_epoch, config.train_epochs + 1)):
-++			model.train()
-++
-++			for batch_idx, data_dict in enumerate(train_loader): # Loop over batched data
-++
-++				labels = data_dict['label']
-++				data = data_dict['data']
-++
-++				# send data to device
-++				data = nested_to(data,device,torch.float32)
-++				# One-hot encode the data labels
-++				labels_tensor = torch.zeros((len(labels), 2))
-++				for i, label in enumerate(labels):
-++					labels_tensor[i, label] = 1
-++
-++				model_output = model(data) # evaluate model
-++
-++				loss = loss_func(model_output, labels_tensor) # compute loss
-++				outputs = AttrDict({"loss": loss, "prediction": model_output})
-++				outputs.reports = AttrDict({"cross_entropy": loss})
-++
-++				if torch.isnan(outputs.loss): # check for failure in training
-++					if not training_failed:
-++						epoch_of_nan = epoch
-++					if (epoch > epoch_of_nan + 1) and training_failed:
-++						raise ValueError("Loss Nan-ed.")
-++					training_failed = True
-++
-++				model_opt.zero_grad()
-++				outputs.loss.backward(retain_graph=False)
-++
-++				model_opt.step() # move optimizer forward
-++
-++				train_reports.append(parse_reports_cpu(outputs.reports))
-++
-++				if config.log_train_values:
-++					reports = parse_reports(outputs.reports)
-++					if batch_idx % config.report_loss_every == 0:
-++						log_tensorboard(summary_writer, train_iter, reports, "train/")
-++						print_reports(
-++							reports,
-++							start_t,
-++							epoch,
-++							batch_idx,
-++							len(train_loader.dataset) // train_batch_size,
-++							prefix="train",
-++						)
-++						log_tensorboard(
-++							summary_writer,
-++							train_iter,
-++							{"lr": model_opt.param_groups[0]["lr"]},
-++							"hyperparams/",
-++						)
-++				# Logging and evaluation
-++				if (
-++					train_iter % iters_per_eval == 0 or (train_iter == total_train_iters)
-++				) and config.log_val_test:  # batch_idx % config.evaluate_every == 0:
-++					model.eval()
-++					with torch.no_grad():
-++						reports = evaluate(model, test_loader, device,fold = k,headings = loader_k['test_headings'])
-++						# print("REPORTS",reports)
-++						reports = parse_reports(reports)
-++						reports["time"] = time.time() - start_t
-++						if report_all == {}:
-++							report_all = deepcopy(reports)
-++
-++							for d in reports.keys():
-++								report_all[d] = [report_all[d]]
-++						else:
-++							for d in reports.keys():
-++								report_all[d].append(reports[d])
-++
-++						log_tensorboard(summary_writer, train_iter, reports, "test/")
-++						print_reports(
-++							reports,
-++							start_t,
-++							epoch,
-++							batch_idx,
-++							len(train_loader.dataset) // config.batch_size,
-++							prefix="test",
-++						)
-++
-++						# repeat for validation data
-++						reports = evaluate(model, val_loader, device,fold = k,headings = loader_k['test_headings'])
-++						reports = parse_reports(reports)
-++						reports["time"] = time.time() - start_t
-++						if report_all_val == {}:
-++							report_all_val = deepcopy(reports)
-++
-++							for d in reports.keys():
-++								report_all_val[d] = [report_all_val[d]]
-++						else:
-++							for d in reports.keys():
-++								report_all_val[d].append(reports[d])
-++
-++						log_tensorboard(summary_writer, train_iter, reports, "val/")
-++						print_reports(
-++							reports,
-++							start_t,
-++							epoch,
-++							batch_idx,
-++							len(train_loader.dataset) // config.batch_size,
-++							prefix="val",
-++						)
-++
-++						if report_all_val["cross_entropy"][-1] < best_val_loss_so_far:
-++							save_checkpoint(
-++								checkpoint_name,
-++								f"early_stop",
-++								model,
-++								model_opt,
-++								loss=outputs.loss,
-++							)
-++							best_val_loss_so_far = report_all_val["cross_entropy"][-1]
-++
-++					model.train()
-++
-++				train_iter += 1
-++
-++			if epoch % config.save_check_points == 0:
-++				save_checkpoint(
-++					checkpoint_name, train_iter, model, model_opt, loss=outputs.loss
-++				)
-++
-++		dd.io.save(fold_dir + "/results_dict_train.h5", train_reports)
-++		dd.io.save(fold_dir + "/results_dict.h5", report_all)
-++		dd.io.save(fold_dir + "/results_dict_val.h5", report_all_val)
-++
-++	# always save final model
-++	save_checkpoint(checkpoint_name, train_iter, model, model_opt, loss=outputs.loss)
-++
-++	
-++	if config.save_test_predictions:
-++		pass
-++		# print("Starting to make model predictions on test sets for *final model*.")
-++		# for chunk_len in [5, 100]:
-++		#     start_t_preds = time.time()
-++		#     data_config = SimpleNamespace(
-++		#         **{
-++		#             **config.__dict__["__flags"],
-++		#             **{"chunk_len": chunk_len, "batch_size": 500},
-++		#         }
-++		#     )
-++		#     dataloaders, data_name = fet.load(config.data_config, config=data_config)
-++		#     test_loader_preds = dataloaders["test"]
-++
-++		#     torch.cuda.empty_cache()
-++		#     with torch.no_grad():
-++		#         preds = []
-++		#         true = []
-++		#         num_datapoints = 0
-++		#         for idx, d in enumerate(test_loader_preds):
-++		#             true.append(d[-1])
-++		#             d = nested_to(d, device, torch.float32)
-++		#             outputs = model(d)
-++
-++		#             pred_zs = outputs.prediction
-++		#             preds.append(pred_zs)
-++
-++		#             num_datapoints += len(pred_zs)
-++
-++		#             if num_datapoints >= 2000:
-++		#                 break
-+ 
-+-config = forge.config()
-++		#         preds = torch.cat(preds, dim=0).cpu()
-++		#         true = torch.cat(true, dim=0).cpu()
-+ 
-+-# Prepare environment
-+-logdir = osp.join(config.results_dir, config.run_name)
-+-logdir, resume_checkpoint = fet.init_checkpoint(
-+-    logdir, config.data_config, config.model_config, config.resume)
-+-checkpoint_name = osp.join(logdir, 'model.ckpt')
-++		#         save_dir = osp.join(logdir, f"traj_preds_{chunk_len}_steps_2k_test.pt")
-++		#         torch.save(preds, save_dir)
-+ 
-++		#         save_dir = osp.join(logdir, f"traj_true_{chunk_len}_steps_2k_test.pt")
-++		#         torch.save(true, save_dir)
-+ 
-+-print(logdir)
-++		#         print(
-++		#             f"Completed making test predictions for chunk_len = {chunk_len} in {time.time() - start_t_preds:.2f} seconds."
-++		#         )	
-++		
-+ 
-++if __name__ == "__main__":
-++	main()
-+ 
-diff --git a/checkpoints/feedforward/1/penn_dataset.py b/checkpoints/feedforward/1/penn_dataset.py
-index aa2f5a0..7f5a4fc 100644
---- a/checkpoints/feedforward/1/penn_dataset.py
-+++ b/checkpoints/feedforward/1/penn_dataset.py
-@@ -15,6 +15,7 @@ from forge import flags
- # aspects of data managmement
- flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
- flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-+flags.DEFINE_boolean("cross_validate",False,"Do K-fold cross-validation")
- 
- # Job management
- # flags.DEFINE_integer("batch size",5,"training batch size")
-@@ -109,15 +110,15 @@ def load(config):
-         
-         # set up training DataLoader
-         train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, n_train),num_workers=0,shuffle = True)
-+        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
- 
-         # set up test DataLoader
-         test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, n_test),num_workers=0,shuffle = True)
-+        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
- 
-         # set up val DataLoader
-         val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, n_val),num_workers=0,shuffle = True)
-+        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-         
- 
-         dataloaders = {'train':train_loader, 
-@@ -125,8 +126,12 @@ def load(config):
-                        'val':val_loader,
-                        'train_inds':train_ind,
-                        'test_inds':test_ind,
--                       'n_val':n_val
-+                       'n_val':n_val,
-+                       'test_headings':list(HEADINGS[test_ind])
-                       }
-         kf_dataloaders.append(dataloaders)
- 
-+        if not config.cross_validate:
-+        	break
-+
-     return kf_dataloaders
-diff --git a/georgehulsey_2024.pdf b/georgehulsey_2024.pdf
-deleted file mode 100644
-index 1ab17f6..0000000
-Binary files a/georgehulsey_2024.pdf and /dev/null differ
-diff --git a/penn_dataset.py b/penn_dataset.py
-index aa2f5a0..46c8e52 100644
---- a/penn_dataset.py
-+++ b/penn_dataset.py
-@@ -15,6 +15,7 @@ from forge import flags
- # aspects of data managmement
- flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
- flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-+flags.DEFINE_boolean("cross_validate",True,"Do K-fold cross-validation")
- 
- # Job management
- # flags.DEFINE_integer("batch size",5,"training batch size")
-@@ -109,15 +110,15 @@ def load(config):
-         
-         # set up training DataLoader
-         train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, n_train),num_workers=0,shuffle = True)
-+        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
- 
-         # set up test DataLoader
-         test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, n_test),num_workers=0,shuffle = True)
-+        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
- 
-         # set up val DataLoader
-         val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, n_val),num_workers=0,shuffle = True)
-+        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-         
- 
-         dataloaders = {'train':train_loader, 
-@@ -125,8 +126,12 @@ def load(config):
-                        'val':val_loader,
-                        'train_inds':train_ind,
-                        'test_inds':test_ind,
--                       'n_val':n_val
-+                       'n_val':n_val,
-+                       'test_headings':list(HEADINGS[test_ind])
-                       }
-         kf_dataloaders.append(dataloaders)
- 
-+        if not config.cross_validate:
-+        	break
-+
-     return kf_dataloaders
-diff --git a/testing.ipynb b/testing.ipynb
-index e5a167b..0110538 100644
---- a/testing.ipynb
-+++ b/testing.ipynb
-@@ -2,7 +2,7 @@
-  "cells": [
-   {
-    "cell_type": "code",
--   "execution_count": 1,
-+   "execution_count": 4,
-    "id": "4dee7ff1-01a4-4038-b493-9729ff3693f7",
-    "metadata": {},
-    "outputs": [],
-@@ -23,7 +23,7 @@
-   },
-   {
-    "cell_type": "code",
--   "execution_count": 2,
-+   "execution_count": 6,
-    "id": "cad0fdc8-5c35-4610-bba3-b71e60dc1b98",
-    "metadata": {},
-    "outputs": [],
-@@ -35,7 +35,7 @@
-   },
-   {
-    "cell_type": "code",
--   "execution_count": 3,
-+   "execution_count": 7,
-    "id": "ce1b936b-8a7c-426e-a3aa-3c1c38f645de",
-    "metadata": {},
-    "outputs": [
-@@ -54,8 +54,8 @@
-   },
-   {
-    "cell_type": "code",
--   "execution_count": 9,
--   "id": "e862b7e2-57f5-44bf-bcf1-a91160ba66cc",
-+   "execution_count": 5,
-+   "id": "4469cddf-4dac-4468-be88-241d440401c3",
-    "metadata": {},
-    "outputs": [
-     {
-@@ -67,35 +67,98 @@
-     }
-    ],
-    "source": [
--    "model = fet.load(\"basic_feedforward.py\",config)"
-+    "model,modelname = fet.load(\"basic_feedforward.py\",config)"
-    ]
-   },
-   {
-    "cell_type": "code",
--   "execution_count": 10,
--   "id": "07e0b160-d5d1-4e54-b4a7-ccaf2224598a",
-+   "execution_count": 13,
-+   "id": "7c9a9fe9-f5e8-456a-b964-4be13027725b",
-    "metadata": {},
-    "outputs": [
-     {
-      "data": {
-       "text/plain": [
--       "PerceptronNN(\n",
--       "  (fc1): Linear(in_features=39, out_features=128, bias=True)\n",
--       "  (fc2): Linear(in_features=128, out_features=64, bias=True)\n",
--       "  (fc3): Linear(in_features=64, out_features=64, bias=True)\n",
--       "  (fc4): Linear(in_features=64, out_features=2, bias=True)\n",
--       ")"
-+       "array([114170,    904])"
-       ]
-      },
--     "execution_count": 10,
-+     "execution_count": 13,
-      "metadata": {},
-      "output_type": "execute_result"
-     }
-    ],
-    "source": [
--    "model"
-+    "np.bincount(loaddat[0]['train'].dataset.all_labels)"
-    ]
-   },
-+  {
-+   "cell_type": "code",
-+   "execution_count": 1,
-+   "id": "e862b7e2-57f5-44bf-bcf1-a91160ba66cc",
-+   "metadata": {},
-+   "outputs": [
-+    {
-+     "ename": "FileNotFoundError",
-+     "evalue": "[Errno 2] Unable to open file (unable to open file: name = './checkpoints/feedforward/2/data_fold1/results_dict.h5', errno = 2, error message = 'No such file or directory', flags = 0, o_flags = 0)",
-+     "output_type": "error",
-+     "traceback": [
-+      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
-+      "\u001b[0;31mFileNotFoundError\u001b[0m                         Traceback (most recent call last)",
-+      "Cell \u001b[0;32mIn[1], line 5\u001b[0m\n\u001b[1;32m      3\u001b[0m file_path \u001b[38;5;241m=\u001b[39m \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124m./checkpoints/feedforward/2/data_fold1/results_dict.h5\u001b[39m\u001b[38;5;124m\"\u001b[39m\n\u001b[1;32m      4\u001b[0m \u001b[38;5;66;03m# Replace 'your_file.h5' with the actual path to your file\u001b[39;00m\n\u001b[0;32m----> 5\u001b[0m f \u001b[38;5;241m=\u001b[39m  \u001b[43mh5py\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mFile\u001b[49m\u001b[43m(\u001b[49m\u001b[43mfile_path\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[38;5;124;43mr\u001b[39;49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[43m)\u001b[49m \n\u001b[1;32m      7\u001b[0m     \u001b[38;5;66;03m# Get information about the data stored in the file\u001b[39;00m\n\u001b[1;32m      8\u001b[0m \u001b[38;5;28mprint\u001b[39m(\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mKeys:\u001b[39m\u001b[38;5;124m\"\u001b[39m, \u001b[38;5;28mlist\u001b[39m(f\u001b[38;5;241m.\u001b[39mkeys()))\n",
-+      "File \u001b[0;32m/Applications/miniconda3/envs/lietransformer/lib/python3.9/site-packages/h5py/_hl/files.py:562\u001b[0m, in \u001b[0;36mFile.__init__\u001b[0;34m(self, name, mode, driver, libver, userblock_size, swmr, rdcc_nslots, rdcc_nbytes, rdcc_w0, track_order, fs_strategy, fs_persist, fs_threshold, fs_page_size, page_buf_size, min_meta_keep, min_raw_keep, locking, alignment_threshold, alignment_interval, meta_block_size, **kwds)\u001b[0m\n\u001b[1;32m    553\u001b[0m     fapl \u001b[38;5;241m=\u001b[39m make_fapl(driver, libver, rdcc_nslots, rdcc_nbytes, rdcc_w0,\n\u001b[1;32m    554\u001b[0m                      locking, page_buf_size, min_meta_keep, min_raw_keep,\n\u001b[1;32m    555\u001b[0m                      alignment_threshold\u001b[38;5;241m=\u001b[39malignment_threshold,\n\u001b[1;32m    556\u001b[0m                      alignment_interval\u001b[38;5;241m=\u001b[39malignment_interval,\n\u001b[1;32m    557\u001b[0m                      meta_block_size\u001b[38;5;241m=\u001b[39mmeta_block_size,\n\u001b[1;32m    558\u001b[0m                      \u001b[38;5;241m*\u001b[39m\u001b[38;5;241m*\u001b[39mkwds)\n\u001b[1;32m    559\u001b[0m     fcpl \u001b[38;5;241m=\u001b[39m make_fcpl(track_order\u001b[38;5;241m=\u001b[39mtrack_order, fs_strategy\u001b[38;5;241m=\u001b[39mfs_strategy,\n\u001b[1;32m    560\u001b[0m                      fs_persist\u001b[38;5;241m=\u001b[39mfs_persist, fs_threshold\u001b[38;5;241m=\u001b[39mfs_threshold,\n\u001b[1;32m    561\u001b[0m                      fs_page_size\u001b[38;5;241m=\u001b[39mfs_page_size)\n\u001b[0;32m--> 562\u001b[0m     fid \u001b[38;5;241m=\u001b[39m \u001b[43mmake_fid\u001b[49m\u001b[43m(\u001b[49m\u001b[43mname\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mmode\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43muserblock_size\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mfapl\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mfcpl\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mswmr\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43mswmr\u001b[49m\u001b[43m)\u001b[49m\n\u001b[1;32m    564\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;28misinstance\u001b[39m(libver, \u001b[38;5;28mtuple\u001b[39m):\n\u001b[1;32m    565\u001b[0m     \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_libver \u001b[38;5;241m=\u001b[39m libver\n",
-+      "File \u001b[0;32m/Applications/miniconda3/envs/lietransformer/lib/python3.9/site-packages/h5py/_hl/files.py:235\u001b[0m, in \u001b[0;36mmake_fid\u001b[0;34m(name, mode, userblock_size, fapl, fcpl, swmr)\u001b[0m\n\u001b[1;32m    233\u001b[0m     \u001b[38;5;28;01mif\u001b[39;00m swmr \u001b[38;5;129;01mand\u001b[39;00m swmr_support:\n\u001b[1;32m    234\u001b[0m         flags \u001b[38;5;241m|\u001b[39m\u001b[38;5;241m=\u001b[39m h5f\u001b[38;5;241m.\u001b[39mACC_SWMR_READ\n\u001b[0;32m--> 235\u001b[0m     fid \u001b[38;5;241m=\u001b[39m \u001b[43mh5f\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mopen\u001b[49m\u001b[43m(\u001b[49m\u001b[43mname\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mflags\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mfapl\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43mfapl\u001b[49m\u001b[43m)\u001b[49m\n\u001b[1;32m    236\u001b[0m \u001b[38;5;28;01melif\u001b[39;00m mode \u001b[38;5;241m==\u001b[39m \u001b[38;5;124m'\u001b[39m\u001b[38;5;124mr+\u001b[39m\u001b[38;5;124m'\u001b[39m:\n\u001b[1;32m    237\u001b[0m     fid \u001b[38;5;241m=\u001b[39m h5f\u001b[38;5;241m.\u001b[39mopen(name, h5f\u001b[38;5;241m.\u001b[39mACC_RDWR, fapl\u001b[38;5;241m=\u001b[39mfapl)\n",
-+      "File \u001b[0;32mh5py/_objects.pyx:54\u001b[0m, in \u001b[0;36mh5py._objects.with_phil.wrapper\u001b[0;34m()\u001b[0m\n",
-+      "File \u001b[0;32mh5py/_objects.pyx:55\u001b[0m, in \u001b[0;36mh5py._objects.with_phil.wrapper\u001b[0;34m()\u001b[0m\n",
-+      "File \u001b[0;32mh5py/h5f.pyx:102\u001b[0m, in \u001b[0;36mh5py.h5f.open\u001b[0;34m()\u001b[0m\n",
-+      "\u001b[0;31mFileNotFoundError\u001b[0m: [Errno 2] Unable to open file (unable to open file: name = './checkpoints/feedforward/2/data_fold1/results_dict.h5', errno = 2, error message = 'No such file or directory', flags = 0, o_flags = 0)"
-+     ]
-+    }
-+   ],
-+   "source": [
-+    "import h5py\n",
-+    "\n",
-+    "file_path = \"./checkpoints/feedforward/2/data_fold1/results_dict.h5\"\n",
-+    "# Replace 'your_file.h5' with the actual path to your file\n",
-+    "f =  h5py.File(file_path, 'r') \n",
-+    "\n",
-+    "    # Get information about the data stored in the file\n",
-+    "print(\"Keys:\", list(f.keys()))  # List the top-level datasets and groups\n",
-+    "\n",
-+    "    # # Access a dataset by its name\n",
-+    "    # dataset_name = \"your_dataset_name\"\n",
-+    "    # if dataset_name in f:\n",
-+    "    #     dataset = f[dataset_name]\n",
-+    "    #     print(\"Dataset shape:\", dataset.shape)\n",
-+    "    #     print(\"Dataset dtype:\", dataset.dtype)\n",
-+    "\n",
-+    "    #     # Access the data as a NumPy array\n",
-+    "    #     data = dataset[:]  # Read the entire dataset\n",
-+    "\n",
-+    "    #     # You can now work with the data as needed, for example:\n",
-+    "    #     # Perform calculations, visualizations, etc.\n",
-+    "    # else:\n",
-+    "    #     print(f\"Dataset '{dataset_name}' not found in the file.\")"
-+   ]
-+  },
-+  {
-+   "cell_type": "code",
-+   "execution_count": 13,
-+   "id": "07e0b160-d5d1-4e54-b4a7-ccaf2224598a",
-+   "metadata": {},
-+   "outputs": [
-+    {
-+     "data": {
-+      "text/plain": [
-+       "<generator object Module.parameters at 0x3007207b0>"
-+      ]
-+     },
-+     "execution_count": 13,
-+     "metadata": {},
-+     "output_type": "execute_result"
-+    }
-+   ],
-+   "source": []
-+  },
-   {
-    "cell_type": "code",
-    "execution_count": null,
-diff --git a/train.py b/train.py
-index c266102..158d7d6 100644
---- a/train.py
-+++ b/train.py
-@@ -1,49 +1,458 @@
- from os import path as osp
-+import os
-+import numpy as np
-+import time
- 
- import torch
-+import torch.nn as nn
- import torch.nn.functional as F
- import torch.optim as optim
--
--import numpy as np
-+from torch.utils.tensorboard import SummaryWriter
- 
- import forge
- from forge import flags
- import forge.experiment_tools as fet
- 
-+from train_tools import (
-+	log_tensorboard,
-+	parse_reports,
-+	parse_reports_cpu,
-+	print_reports,
-+	load_checkpoint,
-+	save_checkpoint,
-+	nested_to,
-+	param_count,
-+)
-+
-+from copy import deepcopy
-+from attrdict import AttrDict
-+import deepdish as dd
-+from tqdm import tqdm
-+
-+# For reproducibility while researching, but might affect speed!
-+torch.backends.cudnn.deterministic = True
-+torch.backends.cudnn.benchmark = False
-+torch.manual_seed(0)
-+
- 
- # Job config
- flags.DEFINE_string('data_config', 'penn_dataset.py',
--                    'Path to a data config file.')
-+					'Path to a data config file.')
- flags.DEFINE_string('model_config', 'basic_feedforward.py',
--                    'Path to a model config file.')
-+					'Path to a model config file.')
- flags.DEFINE_string('results_dir', 'checkpoints',
--                    'Top directory for all experimental results.')
--flags.DEFINE_string('run_name', 'feedforward',
--                    'Name of this job and name of results folder.')
-+					'Top directory for all experimental results.')
-+flags.DEFINE_string('run_name', 'hyperparam_testing',
-+					'Name of this job and name of results folder.')
- flags.DEFINE_boolean('resume', False, 'Tries to resume a job if True.')
- 
- # Logging config
- flags.DEFINE_integer('report_loss_every', 50,
--                     'Number of iterations between reporting minibatch loss.')
--flags.DEFINE_integer('train_epochs', 20, 'Maximum number of training epochs.')
-+					 'Number of iterations between reporting minibatch loss.')
-+flags.DEFINE_integer('train_epochs', 30, 'Maximum number of training epochs.')
-+flags.DEFINE_integer(
-+	"save_check_points",
-+	10,
-+	"frequency with which to save checkpoints, in number of epoches.",
-+)
-+flags.DEFINE_boolean("log_train_values", True, "Logs train values if True.")
-+flags.DEFINE_integer(
-+	"total_evaluations",
-+	100,
-+	"Maximum number of evaluations on test and validation data during training.",
-+)
-+flags.DEFINE_boolean(
-+	"save_test_predictions",
-+	False,
-+	"Makes and saves test predictions on one or more test sets (e.g. 5-step and 100-step predictions) at the end of training.",
-+)
-+flags.DEFINE_boolean(
-+    "log_val_test", True, "Turns off computation of validation and test errors."
-+)
-+
-+flags.DEFINE_boolean('use_mps',False,"Use Metal Performance Shaders (M1) for training.")
- 
- # Experiment config
- flags.DEFINE_integer('batch_size', 100, 'Mini-batch size.')
--flags.DEFINE_float('learning_rate', 1e-5, 'SGD learning rate.')
-+flags.DEFINE_float("learning_rate", 1e-3, "Adam learning rate.")
-+flags.DEFINE_float("beta1", 0.9, "Adam Beta 1 parameter")
-+flags.DEFINE_float("beta2", 0.999, "Adam Beta 2 parameter")
- 
- # Specific config options
- flags.DEFINE_integer("input_size",39,"Input shape to model")
- 
-+#########################################################################################
-+
-+def evaluate(model, loader, device,fold = 0,headings = [],loss_func = nn.CrossEntropyLoss()):
-+	# this function does not account for class weights when evaluating cross-entropy loss.
-+	# however, they are accounted for when evaluating training loss
-+	reports = None
-+	for data in loader:
-+		labels = data['label']
-+		inputs = nested_to(data['data'],device,torch.float32)
-+		
-+		labels_tensor = torch.zeros((len(labels), 2))
-+		for i, label in enumerate(labels):
-+			labels_tensor[i, label] = 1
-+
-+		model_output = model(inputs) # evaluate model
-+
-+		loss = loss_func(model_output, labels_tensor) # compute loss
-+		outputs = AttrDict({"loss": loss, "prediction": model_output,'data_fold':fold})
-+		outputs.reports = AttrDict({"cross_entropy": loss})
-+
-+		if reports is None:
-+			reports = {k: v.detach().clone().cpu() for k, v in outputs.reports.items()}
-+		else:
-+			for k, v in outputs.reports.items():
-+				reports[k] += v.detach().clone().cpu()
-+
-+	for k, v in reports.items():
-+		reports[k] = v / len(
-+			loader
-+		)  # SZ: note this can be slightly incorrect if mini-batch sizes vary (if batch_size doesn't divide train_size), but approximately correct.
-+
-+	# reports['test_headings'] = np.array(headings)
-+
-+	return reports
-+
-+def main():
-+
-+	config = forge.config()
-+
-+	# Set device
-+	if torch.cuda.is_available():
-+		device = f"cuda:{config.device}"
-+		torch.cuda.set_device(device)
-+	else:
-+		device = "cpu" # can change this to MPS on M1 Macs
-+
-+	if config.use_mps:
-+		device = "mps"
-+
-+	# Load data
-+	data_name = "penn_data"
-+	kfold_loaders = fet.load(config.data_config, config)
-+
-+	# Load model
-+	model,model_name = fet.load(config.model_config, config)
-+	model = model.to(device)
-+
-+	# Prepare environment
-+	params_in_run_name = [
-+		("batch_size", "bs"),
-+		("learning_rate", "lr"),
-+		("n_train", "ntrain"),
-+		("include_coords",'inclx'),
-+		("input_size",'inpsize'),
-+		("cross_validate",'crval'),
-+		("train_epochs",'n_epochs'),
-+	]
-+
-+	run_name = ""  # config.run_name
-+	for config_param in params_in_run_name:
-+		attr = config_param[0]
-+		abbrev = config_param[1]
-+
-+		if hasattr(config, attr):
-+			run_name += abbrev
-+			run_name += str(getattr(config, attr))
-+			run_name += "_"
-+
-+	results_folder_name = osp.join(
-+		data_name,
-+		model_name,
-+		config.run_name,
-+		run_name,
-+	)
-+
-+	# Prepare environment
-+	logdir = osp.join(config.results_dir, results_folder_name.replace(".", "_"))
-+	logdir, resume_checkpoint = fet.init_checkpoint(
-+		logdir, config.data_config, config.model_config, config.resume)
-+
-+	print("Checkpoint directory:",logdir)
-+
-+	# Print flags
-+	fet.print_flags()
-+	# Print model info
-+	print(model)
-+
-+	# Setup optimizer
-+	model_params = model.parameters()
-+	opt_learning_rate = config.learning_rate
-+	model_opt = torch.optim.Adam(
-+		model_params, lr=opt_learning_rate, betas=(config.beta1, config.beta2)
-+	)
-+	scheduler = torch.optim.lr_scheduler.StepLR(model_opt, step_size=10, gamma=0.5)
-+	print("Model Optimizer:")
-+	print(model_opt)
-+
-+	# Try to restore model and optimizer from checkpoint
-+	if resume_checkpoint is not None:
-+		start_epoch = load_checkpoint(resume_checkpoint, model, model_opt)
-+	else:
-+		start_epoch = 1
-+
-+	n_folds = len(kfold_loaders)
-+	print("Doing {}-fold cross-validation.".format(n_folds))
-+
-+	# KFOLD TRAINING LOOP
-+	for k,loader_k in enumerate(kfold_loaders): # loop over data splits
-+
-+		print("Training fold {}...".format(k+1))
-+
-+		# load the training data
-+		train_loader = loader_k["train"]
-+		n_train = len(train_loader.dataset)
-+		train_batch_size = train_loader.batch_size
-+
-+		# load testing, validation
-+		test_loader = loader_k["test"]
-+		n_test = len(test_loader.dataset)
-+		val_loader = loader_k["val"]
-+		n_val = len(val_loader.dataset)
-+
-+		train_class_counts = np.bincount(train_loader.dataset.all_labels)
-+		train_total_counts = sum(train_class_counts)
-+		class_weight = torch.tensor(1.0 / train_class_counts) * train_total_counts / 2.0
-+
-+		loss_func = nn.CrossEntropyLoss(weight = class_weight) # define reweighted loss function
-+				
-+		# create folder for this data split
-+		fold_dir = osp.join(logdir,"data_fold{}".format(k+1))
-+		fold_dir_exists = osp.exists(fold_dir)
-+		if not fold_dir_exists:
-+			if config.resume:
-+				raise ValueError("Can't resume when the checkpoint/fold dir '{}' doesn't exist.".format(fold_dir))
-+			else:
-+				os.makedirs(fold_dir)
-+		checkpoint_name = osp.join(fold_dir, 'model_fold{}.ckpt'.format(k+1))
-+
-+		# keep track of which data is test data for a given Kfold data split
-+		test_headings = loader_k['test_headings']
-+		headingsFile = osp.join(fold_dir,"test_headings.txt")
-+		with open(headingsFile,'w') as headfile:
-+			for heading in test_headings:
-+				headfile.write(heading+'\n')
-+
-+		# print(checkpoint_name)
-+
-+		train_iter = (start_epoch - 1) * (
-+		len(train_loader.dataset) // train_batch_size
-+		) + 1
-+
-+		print("Starting training at epoch = {}, iter = {}".format(start_epoch, train_iter))
-+
-+		# Setup tensorboard writing
-+		summary_writer = SummaryWriter(logdir)
-+
-+		train_reports = []
-+		report_all = {}
-+		report_all_val = {}
-+
-+		# Saving model at epoch 0 before training
-+		print("saving model at epoch 0 before training ... ")
-+		save_checkpoint(checkpoint_name, 0, model, model_opt, loss=0.0)
-+		print("finished saving model at epoch 0 before training")
-+
-+		num_params = param_count(model)
-+		print(f"Number of model parameters: {num_params}")
-+
-+		# Training
-+		start_t = time.time()
-+
-+		total_train_iters = len(train_loader) * config.train_epochs
-+		iters_per_eval = max(1, int(total_train_iters / config.total_evaluations))
-+		# print('batch',train_batch_size)
-+		# print('ntrain',n_train)
-+		# assert (
-+		# 	n_train % min(train_batch_size, n_train) == 0
-+		# ), "Batch size doesn't divide dataset size. Can be inaccurate for loss computation (see below)."
-+
-+		training_failed = False
-+		best_val_loss_so_far = 1e7
-+
-+		for epoch in tqdm(range(start_epoch, config.train_epochs + 1)):
-+			model.train()
-+
-+			for batch_idx, data_dict in enumerate(train_loader): # Loop over batched data
-+
-+				labels = data_dict['label']
-+				data = data_dict['data']
-+
-+				# send data to device
-+				data = nested_to(data,device,torch.float32)
-+				# One-hot encode the data labels
-+				labels_tensor = torch.zeros((len(labels), 2))
-+				for i, label in enumerate(labels):
-+					labels_tensor[i, label] = 1
-+
-+				model_output = model(data) # evaluate model
-+
-+				loss = loss_func(model_output, labels_tensor) # compute loss
-+				outputs = AttrDict({"loss": loss, "prediction": model_output})
-+				outputs.reports = AttrDict({"cross_entropy": loss})
-+
-+				if torch.isnan(outputs.loss): # check for failure in training
-+					if not training_failed:
-+						epoch_of_nan = epoch
-+					if (epoch > epoch_of_nan + 1) and training_failed:
-+						raise ValueError("Loss Nan-ed.")
-+					training_failed = True
-+
-+				model_opt.zero_grad()
-+				outputs.loss.backward(retain_graph=False)
-+
-+				model_opt.step() # move optimizer forward
-+
-+				train_reports.append(parse_reports_cpu(outputs.reports))
-+
-+				if config.log_train_values:
-+					reports = parse_reports(outputs.reports)
-+					if batch_idx % config.report_loss_every == 0:
-+						log_tensorboard(summary_writer, train_iter, reports, "train/")
-+						print_reports(
-+							reports,
-+							start_t,
-+							epoch,
-+							batch_idx,
-+							len(train_loader.dataset) // train_batch_size,
-+							prefix="train",
-+						)
-+						log_tensorboard(
-+							summary_writer,
-+							train_iter,
-+							{"lr": model_opt.param_groups[0]["lr"]},
-+							"hyperparams/",
-+						)
-+				# Logging and evaluation
-+				if (
-+					train_iter % iters_per_eval == 0 or (train_iter == total_train_iters)
-+				) and config.log_val_test:  # batch_idx % config.evaluate_every == 0:
-+					model.eval()
-+					with torch.no_grad():
-+						reports = evaluate(model, test_loader, device,fold = k,headings = loader_k['test_headings'])
-+						# print("REPORTS",reports)
-+						reports = parse_reports(reports)
-+						reports["time"] = time.time() - start_t
-+						if report_all == {}:
-+							report_all = deepcopy(reports)
-+
-+							for d in reports.keys():
-+								report_all[d] = [report_all[d]]
-+						else:
-+							for d in reports.keys():
-+								report_all[d].append(reports[d])
-+
-+						log_tensorboard(summary_writer, train_iter, reports, "test/")
-+						print_reports(
-+							reports,
-+							start_t,
-+							epoch,
-+							batch_idx,
-+							len(train_loader.dataset) // config.batch_size,
-+							prefix="test",
-+						)
-+
-+						# repeat for validation data
-+						reports = evaluate(model, val_loader, device,fold = k,headings = loader_k['test_headings'])
-+						reports = parse_reports(reports)
-+						reports["time"] = time.time() - start_t
-+						if report_all_val == {}:
-+							report_all_val = deepcopy(reports)
-+
-+							for d in reports.keys():
-+								report_all_val[d] = [report_all_val[d]]
-+						else:
-+							for d in reports.keys():
-+								report_all_val[d].append(reports[d])
-+
-+						log_tensorboard(summary_writer, train_iter, reports, "val/")
-+						print_reports(
-+							reports,
-+							start_t,
-+							epoch,
-+							batch_idx,
-+							len(train_loader.dataset) // config.batch_size,
-+							prefix="val",
-+						)
-+
-+						if report_all_val["cross_entropy"][-1] < best_val_loss_so_far:
-+							save_checkpoint(
-+								checkpoint_name,
-+								f"early_stop",
-+								model,
-+								model_opt,
-+								loss=outputs.loss,
-+							)
-+							best_val_loss_so_far = report_all_val["cross_entropy"][-1]
-+
-+					model.train()
-+
-+				train_iter += 1
-+
-+			scheduler.step()
-+
-+			if epoch % config.save_check_points == 0:
-+				save_checkpoint(
-+					checkpoint_name, train_iter, model, model_opt, loss=outputs.loss
-+				)
-+		
-+		dd.io.save(fold_dir + "/results_dict_train.h5", train_reports)
-+		dd.io.save(fold_dir + "/results_dict.h5", report_all)
-+		dd.io.save(fold_dir + "/results_dict_val.h5", report_all_val)
-+
-+	# always save final model
-+	save_checkpoint(checkpoint_name, train_iter, model, model_opt, loss=outputs.loss)
-+
-+	
-+	if config.save_test_predictions:
-+		pass
-+		# print("Starting to make model predictions on test sets for *final model*.")
-+		# for chunk_len in [5, 100]:
-+		#     start_t_preds = time.time()
-+		#     data_config = SimpleNamespace(
-+		#         **{
-+		#             **config.__dict__["__flags"],
-+		#             **{"chunk_len": chunk_len, "batch_size": 500},
-+		#         }
-+		#     )
-+		#     dataloaders, data_name = fet.load(config.data_config, config=data_config)
-+		#     test_loader_preds = dataloaders["test"]
-+
-+		#     torch.cuda.empty_cache()
-+		#     with torch.no_grad():
-+		#         preds = []
-+		#         true = []
-+		#         num_datapoints = 0
-+		#         for idx, d in enumerate(test_loader_preds):
-+		#             true.append(d[-1])
-+		#             d = nested_to(d, device, torch.float32)
-+		#             outputs = model(d)
-+
-+		#             pred_zs = outputs.prediction
-+		#             preds.append(pred_zs)
-+
-+		#             num_datapoints += len(pred_zs)
-+
-+		#             if num_datapoints >= 2000:
-+		#                 break
- 
--config = forge.config()
-+		#         preds = torch.cat(preds, dim=0).cpu()
-+		#         true = torch.cat(true, dim=0).cpu()
- 
--# Prepare environment
--logdir = osp.join(config.results_dir, config.run_name)
--logdir, resume_checkpoint = fet.init_checkpoint(
--    logdir, config.data_config, config.model_config, config.resume)
--checkpoint_name = osp.join(logdir, 'model.ckpt')
-+		#         save_dir = osp.join(logdir, f"traj_preds_{chunk_len}_steps_2k_test.pt")
-+		#         torch.save(preds, save_dir)
- 
-+		#         save_dir = osp.join(logdir, f"traj_true_{chunk_len}_steps_2k_test.pt")
-+		#         torch.save(true, save_dir)
- 
--print(logdir)
-+		#         print(
-+		#             f"Completed making test predictions for chunk_len = {chunk_len} in {time.time() - start_t_preds:.2f} seconds."
-+		#         )	
-+		
- 
-+if __name__ == "__main__":
-+	main()
- 
diff --git a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/penn_dataset.py b/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/penn_dataset.py
deleted file mode 100644
index 46c8e52..0000000
--- a/checkpoints/penn_data/feedforward/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs30_/1/penn_dataset.py
+++ /dev/null
@@ -1,137 +0,0 @@
-import os
-import torch
-import pandas as pd
-import numpy as np
-
-from torchvision import datasets, transforms
-from torch.utils.data import Dataset, DataLoader
-from sklearn.model_selection import RepeatedKFold
-
-from os import path as osp
-import forge
-from forge import flags
-
-
-# aspects of data managmement
-flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
-flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-flags.DEFINE_boolean("cross_validate",True,"Do K-fold cross-validation")
-
-# Job management
-# flags.DEFINE_integer("batch size",5,"training batch size")
-flags.DEFINE_float("train_split",0.8,'Fraction of data to use for training.')
-flags.DEFINE_integer("n_repeats",1,"Times to repeat K-fold cross-validation")
-flags.DEFINE_integer("split_seed",1,"Seed for KFold split (integer for reproducibility")
-
-# "wavelengths between 0.05 and 1 mm in 0.025 mm increments."
-LSPACE = np.arange(0.05,1.05,0.025) # corresponds to 39 non-coord columns of data
-L_INDS = None
-
-DATAFOLDER = './penn_data'
-
-HEADINGS = np.array(['aaa0043','aaa0044','aaa0060','aaa0061','aaa0063','aaa0064','aaa0066','aaa0069','aaa0086','aaa0087','aaa_0051','aaa_0053','aaa_0054','aaa_0059','aaa_0071','aaa_0072'])
-
-
-class PennData(Dataset):
-
-    def __init__(self,path_to_data,headings,k_inds = None,include_coords = True,rescale = True,spectra_prefix = "kvals_fuse_rotate_",label_prefix = 'labels_fuse_rotate_'):
-        
-        self.data_dir = path_to_data
-        self.headings = headings
-
-        df_list = []
-        label_list = []
-        for heading in self.headings: # for each datafile heading,
-            data_name = osp.join(self.data_dir,spectra_prefix + heading+'.csv') # read kvals
-            df_temp = pd.read_csv(data_name,header=None)
-            df_list.append(df_temp)
-
-            label_name = osp.join(self.data_dir,label_prefix + heading + '.csv') # read labels
-            label_temp = pd.read_csv(label_name,header=None, names=['label'])
-            label_list.append(label_temp)
-
-        df = pd.concat(df_list, ignore_index=True)
-
-        labels = pd.concat(label_list, ignore_index=True)
-        df = pd.concat([labels, df], axis="columns") # Append labels to data
-
-        all_labels = df['label'].to_numpy()
-        all_data = df.iloc[:,1:].to_numpy()
-
-        if rescale: # rescale (normalize) wavelength intensity data
-            lambdas = all_data[:,2:] # wavelengths
-            lam_std = np.std(lambdas, axis=0)  # Calculate standard deviation along columns
-            lam_mean = np.mean(lambdas, axis=0)  # Calculate mean along columns
-            lambdas_rescaled = (lambdas - lam_mean) / lam_std 
-            all_data[:,2:] = lambdas_rescaled
-
-        if not include_coords: # removes x,y coordinates from data
-            all_data = all_data[:,2:]
-        
-        if k_inds != None: # in this case, only use subset of wavelengths
-            all_data = all_data[:,np.array(k_inds)]
-
-        self.all_data = all_data
-        self.all_labels = all_labels
-
-    def __len__(self):
-        return len(self.all_data)
-
-    def __getitem__(self,i):
-        state = {'label':self.all_labels[i],'data':self.all_data[i]}
-        return state
-
-    def __getstate__(self):
-        state = {
-            'data': self.all_data,
-            'label': self.all_labels,
-                }
-        return state
-
-    def __setstate__(self, state):
-        # Set the object's state from the provided dictionary
-        self.all_data = state['data']
-        self.all_labels = state['label']
-        
-
-
-def load(config):
-
-    n_splits = int(len(HEADINGS)/((1-config.train_split)*len(HEADINGS)))
-
-    kf = RepeatedKFold(n_splits = n_splits, n_repeats = config.n_repeats, random_state = config.split_seed) # K-fold cross validation
-
-    kf_dataloaders = []
-
-    for i, (train_ind, test_ind) in enumerate(kf.split(HEADINGS)): # for each K-fold split, 
-        n_val = len(test_ind)//2
-        n_test = len(test_ind)-n_val   
-        n_train = len(train_ind)
-        
-        # set up training DataLoader
-        train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
-
-        # set up test DataLoader
-        test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
-
-        # set up val DataLoader
-        val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-        
-
-        dataloaders = {'train':train_loader, 
-                       'test':test_loader,
-                       'val':val_loader,
-                       'train_inds':train_ind,
-                       'test_inds':test_ind,
-                       'n_val':n_val,
-                       'test_headings':list(HEADINGS[test_ind])
-                      }
-        kf_dataloaders.append(dataloaders)
-
-        if not config.cross_validate:
-        	break
-
-    return kf_dataloaders
diff --git a/checkpoints/penn_data/feedforward/plotting/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/__pycache__/basic_feedforward.cpython-39.pyc b/checkpoints/penn_data/feedforward/plotting/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/__pycache__/basic_feedforward.cpython-39.pyc
deleted file mode 100644
index 71fb2ce..0000000
Binary files a/checkpoints/penn_data/feedforward/plotting/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/__pycache__/basic_feedforward.cpython-39.pyc and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/plotting/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/__pycache__/penn_dataset.cpython-39.pyc b/checkpoints/penn_data/feedforward/plotting/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/__pycache__/penn_dataset.cpython-39.pyc
deleted file mode 100644
index dece3e2..0000000
Binary files a/checkpoints/penn_data/feedforward/plotting/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/__pycache__/penn_dataset.cpython-39.pyc and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/plotting/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/basic_feedforward.py b/checkpoints/penn_data/feedforward/plotting/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/basic_feedforward.py
deleted file mode 100644
index cdd5158..0000000
--- a/checkpoints/penn_data/feedforward/plotting/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/basic_feedforward.py
+++ /dev/null
@@ -1,42 +0,0 @@
-import torch
-import torch.nn as nn
-import torch.nn.functional as F
-import numpy as np
-
-from forge import flags
-
-# flags.DEFINE_boolean(
-#     "model_with_dict",
-#     True,
-#     "Makes model output predictions in dictionary instead of directly."
-# )
-
-class PerceptronNN(nn.Module):
-    def __init__(self, input_size, num_labels):
-        super(PerceptronNN, self).__init__()
-        # Define the layers
-        self.fc1 = nn.Linear(input_size, 128)  # First dense layer
-        self.fc2 = nn.Linear(128, 64)         # Second dense layer
-        # self.fc23 = nn.Linear(64,64)
-        self.fc3 = nn.Linear(64, 64)          # Third dense layer
-        self.fc4 = nn.Linear(64, num_labels)  # Output layer
-        # self.softmax = nn.Softmax(dim=1)
-
-    def forward(self, x):
-        # Forward pass through the network
-        x = F.relu(self.fc1(x))  # Activation function between layers
-        x = F.relu(self.fc2(x))
-        # x = F.relu(self.fc23(x))
-        x = F.relu(self.fc3(x))
-        x = self.fc4(x)  # No activation, this will be included in the loss function
-        # x = self.softmax(x)
-        return x
-
-def load(config):
-
-    # n_channels = 1
-    n_features = config.input_size
-    
-    mlp = PerceptronNN(n_features,2)
-    
-    return mlp, "feedforward"
\ No newline at end of file
diff --git a/checkpoints/penn_data/feedforward/plotting/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/data_fold1/model_fold1.ckpt-0 b/checkpoints/penn_data/feedforward/plotting/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/data_fold1/model_fold1.ckpt-0
deleted file mode 100644
index 4f96e04..0000000
Binary files a/checkpoints/penn_data/feedforward/plotting/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/data_fold1/model_fold1.ckpt-0 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/plotting/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/data_fold1/model_fold1.ckpt-115101 b/checkpoints/penn_data/feedforward/plotting/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/data_fold1/model_fold1.ckpt-115101
deleted file mode 100644
index 9ad2f1c..0000000
Binary files a/checkpoints/penn_data/feedforward/plotting/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/data_fold1/model_fold1.ckpt-115101 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/plotting/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/data_fold1/model_fold1.ckpt-57551 b/checkpoints/penn_data/feedforward/plotting/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/data_fold1/model_fold1.ckpt-57551
deleted file mode 100644
index 8328545..0000000
Binary files a/checkpoints/penn_data/feedforward/plotting/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/data_fold1/model_fold1.ckpt-57551 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/plotting/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/data_fold1/model_fold1.ckpt-early_stop b/checkpoints/penn_data/feedforward/plotting/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/data_fold1/model_fold1.ckpt-early_stop
deleted file mode 100644
index 038fc0c..0000000
Binary files a/checkpoints/penn_data/feedforward/plotting/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/data_fold1/model_fold1.ckpt-early_stop and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/plotting/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/data_fold1/results_dict.h5 b/checkpoints/penn_data/feedforward/plotting/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/data_fold1/results_dict.h5
deleted file mode 100644
index ae627ae..0000000
Binary files a/checkpoints/penn_data/feedforward/plotting/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/data_fold1/results_dict.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/plotting/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/data_fold1/results_dict_train.h5 b/checkpoints/penn_data/feedforward/plotting/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/data_fold1/results_dict_train.h5
deleted file mode 100644
index 55b2151..0000000
Binary files a/checkpoints/penn_data/feedforward/plotting/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/data_fold1/results_dict_train.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/plotting/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/data_fold1/results_dict_val.h5 b/checkpoints/penn_data/feedforward/plotting/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/data_fold1/results_dict_val.h5
deleted file mode 100644
index 3e6c788..0000000
Binary files a/checkpoints/penn_data/feedforward/plotting/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/data_fold1/results_dict_val.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/plotting/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/data_fold1/test_headings.txt b/checkpoints/penn_data/feedforward/plotting/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/data_fold1/test_headings.txt
deleted file mode 100644
index 05c4825..0000000
--- a/checkpoints/penn_data/feedforward/plotting/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/data_fold1/test_headings.txt
+++ /dev/null
@@ -1,4 +0,0 @@
-aaa0060
-aaa0061
-aaa0069
-aaa_0059
diff --git a/checkpoints/penn_data/feedforward/plotting/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/events.out.tfevents.1709678914.MacBook-Pro-4.local.1475.0 b/checkpoints/penn_data/feedforward/plotting/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/events.out.tfevents.1709678914.MacBook-Pro-4.local.1475.0
deleted file mode 100644
index e610ddd..0000000
Binary files a/checkpoints/penn_data/feedforward/plotting/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/events.out.tfevents.1709678914.MacBook-Pro-4.local.1475.0 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/plotting/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/flags.json b/checkpoints/penn_data/feedforward/plotting/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/flags.json
deleted file mode 100644
index 9e3b59a..0000000
--- a/checkpoints/penn_data/feedforward/plotting/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/flags.json
+++ /dev/null
@@ -1,27 +0,0 @@
-{
-    "batch_size": 100,
-    "beta1": 0.9,
-    "beta2": 0.999,
-    "cross_validate": false,
-    "data_config": "penn_dataset.py",
-    "git_commit": "7416bf730b356aabfe0df644240e40948a8196bb",
-    "include_coords": false,
-    "input_size": 39,
-    "learning_rate": 0.001,
-    "log_train_values": true,
-    "log_val_test": true,
-    "model_config": "basic_feedforward.py",
-    "n_repeats": 1,
-    "report_loss_every": 50,
-    "rescale": true,
-    "results_dir": "checkpoints",
-    "resume": false,
-    "run_name": "plotting",
-    "save_check_points": 50,
-    "save_test_predictions": false,
-    "split_seed": 1,
-    "total_evaluations": 100,
-    "train_epochs": 100,
-    "train_split": 0.8,
-    "use_mps": false
-}
\ No newline at end of file
diff --git a/checkpoints/penn_data/feedforward/plotting/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/git_diff.txt b/checkpoints/penn_data/feedforward/plotting/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/git_diff.txt
deleted file mode 100644
index 393f601..0000000
--- a/checkpoints/penn_data/feedforward/plotting/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/git_diff.txt
+++ /dev/null
@@ -1,1772 +0,0 @@
-Tue Mar 5 14:48:34 PST 2024
-diff --git a/.DS_Store b/.DS_Store
-index e2836a8..c46cff7 100644
-Binary files a/.DS_Store and b/.DS_Store differ
-diff --git a/.ipynb_checkpoints/basic_feedforward-checkpoint.py b/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-index 688c282..0c4bcd1 100644
---- a/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-+++ b/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-@@ -5,6 +5,12 @@ import numpy as np
- 
- from forge import flags
- 
-+flags.DEFINE_boolean(
-+    "model_with_dict",
-+    True,
-+    "Makes model output predictions in dictionary instead of directly."
-+)
-+
- class PerceptronNN(nn.Module):
-     def __init__(self, input_size, num_labels):
-         super(PerceptronNN, self).__init__()
-@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-+        self.softmax = nn.Softmax(dim=1)
- 
-     def forward(self, x):
-         # Forward pass through the network
-@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-         x = F.relu(self.fc2(x))
-         x = F.relu(self.fc3(x))
-         x = self.fc4(x)  # No activation, this will be included in the loss function
-+        x = self.softmax(x)
-         return x
- 
- def load(config):
-@@ -29,4 +37,4 @@ def load(config):
-     
-     mlp = PerceptronNN(n_features,2)
-     
--    return mlp
-\ No newline at end of file
-+    return mlp, "feedforward"
-\ No newline at end of file
-diff --git a/__pycache__/basic_feedforward.cpython-39.pyc b/__pycache__/basic_feedforward.cpython-39.pyc
-index f541140..dddecf8 100644
-Binary files a/__pycache__/basic_feedforward.cpython-39.pyc and b/__pycache__/basic_feedforward.cpython-39.pyc differ
-diff --git a/__pycache__/penn_dataset.cpython-39.pyc b/__pycache__/penn_dataset.cpython-39.pyc
-index 0d7a4de..19121eb 100644
-Binary files a/__pycache__/penn_dataset.cpython-39.pyc and b/__pycache__/penn_dataset.cpython-39.pyc differ
-diff --git a/basic_feedforward.py b/basic_feedforward.py
-index 688c282..cdd5158 100644
---- a/basic_feedforward.py
-+++ b/basic_feedforward.py
-@@ -5,21 +5,31 @@ import numpy as np
- 
- from forge import flags
- 
-+# flags.DEFINE_boolean(
-+#     "model_with_dict",
-+#     True,
-+#     "Makes model output predictions in dictionary instead of directly."
-+# )
-+
- class PerceptronNN(nn.Module):
-     def __init__(self, input_size, num_labels):
-         super(PerceptronNN, self).__init__()
-         # Define the layers
-         self.fc1 = nn.Linear(input_size, 128)  # First dense layer
-         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-+        # self.fc23 = nn.Linear(64,64)
-         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-+        # self.softmax = nn.Softmax(dim=1)
- 
-     def forward(self, x):
-         # Forward pass through the network
-         x = F.relu(self.fc1(x))  # Activation function between layers
-         x = F.relu(self.fc2(x))
-+        # x = F.relu(self.fc23(x))
-         x = F.relu(self.fc3(x))
-         x = self.fc4(x)  # No activation, this will be included in the loss function
-+        # x = self.softmax(x)
-         return x
- 
- def load(config):
-@@ -29,4 +39,4 @@ def load(config):
-     
-     mlp = PerceptronNN(n_features,2)
-     
--    return mlp
-\ No newline at end of file
-+    return mlp, "feedforward"
-\ No newline at end of file
-diff --git a/checkpoints/feedforward/1/basic_feedforward.py b/checkpoints/feedforward/1/basic_feedforward.py
-index 688c282..3a65525 100644
---- a/checkpoints/feedforward/1/basic_feedforward.py
-+++ b/checkpoints/feedforward/1/basic_feedforward.py
-@@ -5,6 +5,12 @@ import numpy as np
- 
- from forge import flags
- 
-+# flags.DEFINE_boolean(
-+#     "model_with_dict",
-+#     True,
-+#     "Makes model output predictions in dictionary instead of directly."
-+# )
-+
- class PerceptronNN(nn.Module):
-     def __init__(self, input_size, num_labels):
-         super(PerceptronNN, self).__init__()
-@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-+        self.softmax = nn.Softmax(dim=1)
- 
-     def forward(self, x):
-         # Forward pass through the network
-@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-         x = F.relu(self.fc2(x))
-         x = F.relu(self.fc3(x))
-         x = self.fc4(x)  # No activation, this will be included in the loss function
-+        x = self.softmax(x)
-         return x
- 
- def load(config):
-@@ -29,4 +37,4 @@ def load(config):
-     
-     mlp = PerceptronNN(n_features,2)
-     
--    return mlp
-\ No newline at end of file
-+    return mlp, "feedforward"
-\ No newline at end of file
-diff --git a/checkpoints/feedforward/1/flags.json b/checkpoints/feedforward/1/flags.json
-index 1d000c3..889a6ea 100644
---- a/checkpoints/feedforward/1/flags.json
-+++ b/checkpoints/feedforward/1/flags.json
-@@ -1,9 +1,15 @@
- {
-     "batch_size": 100,
-+    "beta1": 0.9,
-+    "beta2": 0.999,
-+    "cross_validate": false,
-     "data_config": "penn_dataset.py",
-+    "git_commit": "7416bf730b356aabfe0df644240e40948a8196bb",
-     "include_coords": false,
-     "input_size": 39,
--    "learning_rate": 1e-05,
-+    "learning_rate": 0.0001,
-+    "log_train_values": true,
-+    "log_val_test": true,
-     "model_config": "basic_feedforward.py",
-     "n_repeats": 1,
-     "report_loss_every": 50,
-@@ -11,7 +17,10 @@
-     "results_dir": "checkpoints",
-     "resume": false,
-     "run_name": "feedforward",
-+    "save_check_points": 50,
-+    "save_test_predictions": false,
-     "split_seed": 1,
--    "train_epochs": 20,
-+    "total_evaluations": 100,
-+    "train_epochs": 100,
-     "train_split": 0.8
- }
-\ No newline at end of file
-diff --git a/checkpoints/feedforward/1/git_diff.txt b/checkpoints/feedforward/1/git_diff.txt
-index 7b37e6f..ec23707 100644
---- a/checkpoints/feedforward/1/git_diff.txt
-+++ b/checkpoints/feedforward/1/git_diff.txt
-@@ -1 +1,873 @@
--Mon Mar 4 11:45:48 PST 2024
-+Mon Mar 4 16:34:02 PST 2024
-+diff --git a/.DS_Store b/.DS_Store
-+index e2836a8..7e3fa32 100644
-+Binary files a/.DS_Store and b/.DS_Store differ
-+diff --git a/.ipynb_checkpoints/basic_feedforward-checkpoint.py b/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-+index 688c282..0c4bcd1 100644
-+--- a/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-++++ b/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-+@@ -5,6 +5,12 @@ import numpy as np
-+ 
-+ from forge import flags
-+ 
-++flags.DEFINE_boolean(
-++    "model_with_dict",
-++    True,
-++    "Makes model output predictions in dictionary instead of directly."
-++)
-++
-+ class PerceptronNN(nn.Module):
-+     def __init__(self, input_size, num_labels):
-+         super(PerceptronNN, self).__init__()
-+@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-+         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-+         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-+         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-++        self.softmax = nn.Softmax(dim=1)
-+ 
-+     def forward(self, x):
-+         # Forward pass through the network
-+@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-+         x = F.relu(self.fc2(x))
-+         x = F.relu(self.fc3(x))
-+         x = self.fc4(x)  # No activation, this will be included in the loss function
-++        x = self.softmax(x)
-+         return x
-+ 
-+ def load(config):
-+@@ -29,4 +37,4 @@ def load(config):
-+     
-+     mlp = PerceptronNN(n_features,2)
-+     
-+-    return mlp
-+\ No newline at end of file
-++    return mlp, "feedforward"
-+\ No newline at end of file
-+diff --git a/__pycache__/basic_feedforward.cpython-39.pyc b/__pycache__/basic_feedforward.cpython-39.pyc
-+index f541140..5ad96de 100644
-+Binary files a/__pycache__/basic_feedforward.cpython-39.pyc and b/__pycache__/basic_feedforward.cpython-39.pyc differ
-+diff --git a/__pycache__/penn_dataset.cpython-39.pyc b/__pycache__/penn_dataset.cpython-39.pyc
-+index 0d7a4de..19121eb 100644
-+Binary files a/__pycache__/penn_dataset.cpython-39.pyc and b/__pycache__/penn_dataset.cpython-39.pyc differ
-+diff --git a/basic_feedforward.py b/basic_feedforward.py
-+index 688c282..3a65525 100644
-+--- a/basic_feedforward.py
-++++ b/basic_feedforward.py
-+@@ -5,6 +5,12 @@ import numpy as np
-+ 
-+ from forge import flags
-+ 
-++# flags.DEFINE_boolean(
-++#     "model_with_dict",
-++#     True,
-++#     "Makes model output predictions in dictionary instead of directly."
-++# )
-++
-+ class PerceptronNN(nn.Module):
-+     def __init__(self, input_size, num_labels):
-+         super(PerceptronNN, self).__init__()
-+@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-+         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-+         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-+         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-++        self.softmax = nn.Softmax(dim=1)
-+ 
-+     def forward(self, x):
-+         # Forward pass through the network
-+@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-+         x = F.relu(self.fc2(x))
-+         x = F.relu(self.fc3(x))
-+         x = self.fc4(x)  # No activation, this will be included in the loss function
-++        x = self.softmax(x)
-+         return x
-+ 
-+ def load(config):
-+@@ -29,4 +37,4 @@ def load(config):
-+     
-+     mlp = PerceptronNN(n_features,2)
-+     
-+-    return mlp
-+\ No newline at end of file
-++    return mlp, "feedforward"
-+\ No newline at end of file
-+diff --git a/checkpoints/feedforward/1/basic_feedforward.py b/checkpoints/feedforward/1/basic_feedforward.py
-+index 688c282..3a65525 100644
-+--- a/checkpoints/feedforward/1/basic_feedforward.py
-++++ b/checkpoints/feedforward/1/basic_feedforward.py
-+@@ -5,6 +5,12 @@ import numpy as np
-+ 
-+ from forge import flags
-+ 
-++# flags.DEFINE_boolean(
-++#     "model_with_dict",
-++#     True,
-++#     "Makes model output predictions in dictionary instead of directly."
-++# )
-++
-+ class PerceptronNN(nn.Module):
-+     def __init__(self, input_size, num_labels):
-+         super(PerceptronNN, self).__init__()
-+@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-+         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-+         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-+         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-++        self.softmax = nn.Softmax(dim=1)
-+ 
-+     def forward(self, x):
-+         # Forward pass through the network
-+@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-+         x = F.relu(self.fc2(x))
-+         x = F.relu(self.fc3(x))
-+         x = self.fc4(x)  # No activation, this will be included in the loss function
-++        x = self.softmax(x)
-+         return x
-+ 
-+ def load(config):
-+@@ -29,4 +37,4 @@ def load(config):
-+     
-+     mlp = PerceptronNN(n_features,2)
-+     
-+-    return mlp
-+\ No newline at end of file
-++    return mlp, "feedforward"
-+\ No newline at end of file
-+diff --git a/checkpoints/feedforward/1/flags.json b/checkpoints/feedforward/1/flags.json
-+index 1d000c3..889a6ea 100644
-+--- a/checkpoints/feedforward/1/flags.json
-++++ b/checkpoints/feedforward/1/flags.json
-+@@ -1,9 +1,15 @@
-+ {
-+     "batch_size": 100,
-++    "beta1": 0.9,
-++    "beta2": 0.999,
-++    "cross_validate": false,
-+     "data_config": "penn_dataset.py",
-++    "git_commit": "7416bf730b356aabfe0df644240e40948a8196bb",
-+     "include_coords": false,
-+     "input_size": 39,
-+-    "learning_rate": 1e-05,
-++    "learning_rate": 0.0001,
-++    "log_train_values": true,
-++    "log_val_test": true,
-+     "model_config": "basic_feedforward.py",
-+     "n_repeats": 1,
-+     "report_loss_every": 50,
-+@@ -11,7 +17,10 @@
-+     "results_dir": "checkpoints",
-+     "resume": false,
-+     "run_name": "feedforward",
-++    "save_check_points": 50,
-++    "save_test_predictions": false,
-+     "split_seed": 1,
-+-    "train_epochs": 20,
-++    "total_evaluations": 100,
-++    "train_epochs": 100,
-+     "train_split": 0.8
-+ }
-+\ No newline at end of file
-+diff --git a/checkpoints/feedforward/1/git_diff.txt b/checkpoints/feedforward/1/git_diff.txt
-+index 7b37e6f..5c561db 100644
-+--- a/checkpoints/feedforward/1/git_diff.txt
-++++ b/checkpoints/feedforward/1/git_diff.txt
-+@@ -1 +1 @@
-+-Mon Mar 4 11:45:48 PST 2024
-++Mon Mar 4 16:34:02 PST 2024
-+diff --git a/checkpoints/feedforward/1/penn_dataset.py b/checkpoints/feedforward/1/penn_dataset.py
-+index aa2f5a0..7f5a4fc 100644
-+--- a/checkpoints/feedforward/1/penn_dataset.py
-++++ b/checkpoints/feedforward/1/penn_dataset.py
-+@@ -15,6 +15,7 @@ from forge import flags
-+ # aspects of data managmement
-+ flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
-+ flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-++flags.DEFINE_boolean("cross_validate",False,"Do K-fold cross-validation")
-+ 
-+ # Job management
-+ # flags.DEFINE_integer("batch size",5,"training batch size")
-+@@ -109,15 +110,15 @@ def load(config):
-+         
-+         # set up training DataLoader
-+         train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, n_train),num_workers=0,shuffle = True)
-++        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
-+ 
-+         # set up test DataLoader
-+         test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, n_test),num_workers=0,shuffle = True)
-++        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
-+ 
-+         # set up val DataLoader
-+         val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, n_val),num_workers=0,shuffle = True)
-++        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-+         
-+ 
-+         dataloaders = {'train':train_loader, 
-+@@ -125,8 +126,12 @@ def load(config):
-+                        'val':val_loader,
-+                        'train_inds':train_ind,
-+                        'test_inds':test_ind,
-+-                       'n_val':n_val
-++                       'n_val':n_val,
-++                       'test_headings':list(HEADINGS[test_ind])
-+                       }
-+         kf_dataloaders.append(dataloaders)
-+ 
-++        if not config.cross_validate:
-++        	break
-++
-+     return kf_dataloaders
-+diff --git a/penn_dataset.py b/penn_dataset.py
-+index aa2f5a0..7f5a4fc 100644
-+--- a/penn_dataset.py
-++++ b/penn_dataset.py
-+@@ -15,6 +15,7 @@ from forge import flags
-+ # aspects of data managmement
-+ flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
-+ flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-++flags.DEFINE_boolean("cross_validate",False,"Do K-fold cross-validation")
-+ 
-+ # Job management
-+ # flags.DEFINE_integer("batch size",5,"training batch size")
-+@@ -109,15 +110,15 @@ def load(config):
-+         
-+         # set up training DataLoader
-+         train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, n_train),num_workers=0,shuffle = True)
-++        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
-+ 
-+         # set up test DataLoader
-+         test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, n_test),num_workers=0,shuffle = True)
-++        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
-+ 
-+         # set up val DataLoader
-+         val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, n_val),num_workers=0,shuffle = True)
-++        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-+         
-+ 
-+         dataloaders = {'train':train_loader, 
-+@@ -125,8 +126,12 @@ def load(config):
-+                        'val':val_loader,
-+                        'train_inds':train_ind,
-+                        'test_inds':test_ind,
-+-                       'n_val':n_val
-++                       'n_val':n_val,
-++                       'test_headings':list(HEADINGS[test_ind])
-+                       }
-+         kf_dataloaders.append(dataloaders)
-+ 
-++        if not config.cross_validate:
-++        	break
-++
-+     return kf_dataloaders
-+diff --git a/testing.ipynb b/testing.ipynb
-+index e5a167b..a928d8d 100644
-+--- a/testing.ipynb
-++++ b/testing.ipynb
-+@@ -2,7 +2,7 @@
-+  "cells": [
-+   {
-+    "cell_type": "code",
-+-   "execution_count": 1,
-++   "execution_count": 2,
-+    "id": "4dee7ff1-01a4-4038-b493-9729ff3693f7",
-+    "metadata": {},
-+    "outputs": [],
-+@@ -23,19 +23,19 @@
-+   },
-+   {
-+    "cell_type": "code",
-+-   "execution_count": 2,
-++   "execution_count": 3,
-+    "id": "cad0fdc8-5c35-4610-bba3-b71e60dc1b98",
-+    "metadata": {},
-+    "outputs": [],
-+    "source": [
-+-    "flags.DEFINE_integer(\"batch_size\", 100, \"Mini-batch size.\")\n",
-++    "flags.DEFINE_integer(\"batch_size\", 10, \"Mini-batch size.\")\n",
-+     "\n",
-+     "flags.DEFINE_integer(\"input_size\",39,\"Input shape to model\")"
-+    ]
-+   },
-+   {
-+    "cell_type": "code",
-+-   "execution_count": 3,
-++   "execution_count": 4,
-+    "id": "ce1b936b-8a7c-426e-a3aa-3c1c38f645de",
-+    "metadata": {},
-+    "outputs": [
-+@@ -54,8 +54,8 @@
-+   },
-+   {
-+    "cell_type": "code",
-+-   "execution_count": 9,
-+-   "id": "e862b7e2-57f5-44bf-bcf1-a91160ba66cc",
-++   "execution_count": 5,
-++   "id": "4469cddf-4dac-4468-be88-241d440401c3",
-+    "metadata": {},
-+    "outputs": [
-+     {
-+@@ -67,35 +67,89 @@
-+     }
-+    ],
-+    "source": [
-+-    "model = fet.load(\"basic_feedforward.py\",config)"
-++    "model,modelname = fet.load(\"basic_feedforward.py\",config)"
-+    ]
-+   },
-+   {
-+    "cell_type": "code",
-+-   "execution_count": 10,
-+-   "id": "07e0b160-d5d1-4e54-b4a7-ccaf2224598a",
-++   "execution_count": 17,
-++   "id": "7c9a9fe9-f5e8-456a-b964-4be13027725b",
-+    "metadata": {},
-+    "outputs": [
-+     {
-+      "data": {
-+       "text/plain": [
-+-       "PerceptronNN(\n",
-+-       "  (fc1): Linear(in_features=39, out_features=128, bias=True)\n",
-+-       "  (fc2): Linear(in_features=128, out_features=64, bias=True)\n",
-+-       "  (fc3): Linear(in_features=64, out_features=64, bias=True)\n",
-+-       "  (fc4): Linear(in_features=64, out_features=2, bias=True)\n",
-+-       ")"
-++       "['aaa0060', 'aaa0061', 'aaa0069', 'aaa_0059']"
-+       ]
-+      },
-+-     "execution_count": 10,
-++     "execution_count": 17,
-+      "metadata": {},
-+      "output_type": "execute_result"
-+     }
-+    ],
-+    "source": [
-+-    "model"
-++    "loaddat[0]['test_headings']"
-++   ]
-++  },
-++  {
-++   "cell_type": "code",
-++   "execution_count": 19,
-++   "id": "e862b7e2-57f5-44bf-bcf1-a91160ba66cc",
-++   "metadata": {},
-++   "outputs": [
-++    {
-++     "name": "stdout",
-++     "output_type": "stream",
-++     "text": [
-++      "Keys: ['cross_entropy', 'time']\n"
-++     ]
-++    }
-++   ],
-++   "source": [
-++    "import h5py\n",
-++    "\n",
-++    "file_path = \"./checkpoints/feedforward/2/data_fold1/results_dict.h5\"\n",
-++    "# Replace 'your_file.h5' with the actual path to your file\n",
-++    "f =  h5py.File(file_path, 'r') \n",
-++    "\n",
-++    "    # Get information about the data stored in the file\n",
-++    "print(\"Keys:\", list(f.keys()))  # List the top-level datasets and groups\n",
-++    "\n",
-++    "    # # Access a dataset by its name\n",
-++    "    # dataset_name = \"your_dataset_name\"\n",
-++    "    # if dataset_name in f:\n",
-++    "    #     dataset = f[dataset_name]\n",
-++    "    #     print(\"Dataset shape:\", dataset.shape)\n",
-++    "    #     print(\"Dataset dtype:\", dataset.dtype)\n",
-++    "\n",
-++    "    #     # Access the data as a NumPy array\n",
-++    "    #     data = dataset[:]  # Read the entire dataset\n",
-++    "\n",
-++    "    #     # You can now work with the data as needed, for example:\n",
-++    "    #     # Perform calculations, visualizations, etc.\n",
-++    "    # else:\n",
-++    "    #     print(f\"Dataset '{dataset_name}' not found in the file.\")"
-+    ]
-+   },
-++  {
-++   "cell_type": "code",
-++   "execution_count": 13,
-++   "id": "07e0b160-d5d1-4e54-b4a7-ccaf2224598a",
-++   "metadata": {},
-++   "outputs": [
-++    {
-++     "data": {
-++      "text/plain": [
-++       "<generator object Module.parameters at 0x3007207b0>"
-++      ]
-++     },
-++     "execution_count": 13,
-++     "metadata": {},
-++     "output_type": "execute_result"
-++    }
-++   ],
-++   "source": []
-++  },
-+   {
-+    "cell_type": "code",
-+    "execution_count": null,
-+diff --git a/train.py b/train.py
-+index c266102..516bfa9 100644
-+--- a/train.py
-++++ b/train.py
-+@@ -1,49 +1,440 @@
-+ from os import path as osp
-++import os
-++import numpy as np
-++import time
-+ 
-+ import torch
-++import torch.nn as nn
-+ import torch.nn.functional as F
-+ import torch.optim as optim
-+-
-+-import numpy as np
-++from torch.utils.tensorboard import SummaryWriter
-+ 
-+ import forge
-+ from forge import flags
-+ import forge.experiment_tools as fet
-+ 
-++from train_tools import (
-++	log_tensorboard,
-++	parse_reports,
-++	parse_reports_cpu,
-++	print_reports,
-++	load_checkpoint,
-++	save_checkpoint,
-++	nested_to,
-++	param_count,
-++)
-++
-++from copy import deepcopy
-++from attrdict import AttrDict
-++import deepdish as dd
-++from tqdm import tqdm
-++
-++# For reproducibility while researching, but might affect speed!
-++torch.backends.cudnn.deterministic = True
-++torch.backends.cudnn.benchmark = False
-++torch.manual_seed(0)
-++
-+ 
-+ # Job config
-+ flags.DEFINE_string('data_config', 'penn_dataset.py',
-+-                    'Path to a data config file.')
-++					'Path to a data config file.')
-+ flags.DEFINE_string('model_config', 'basic_feedforward.py',
-+-                    'Path to a model config file.')
-++					'Path to a model config file.')
-+ flags.DEFINE_string('results_dir', 'checkpoints',
-+-                    'Top directory for all experimental results.')
-++					'Top directory for all experimental results.')
-+ flags.DEFINE_string('run_name', 'feedforward',
-+-                    'Name of this job and name of results folder.')
-++					'Name of this job and name of results folder.')
-+ flags.DEFINE_boolean('resume', False, 'Tries to resume a job if True.')
-+ 
-+ # Logging config
-+ flags.DEFINE_integer('report_loss_every', 50,
-+-                     'Number of iterations between reporting minibatch loss.')
-+-flags.DEFINE_integer('train_epochs', 20, 'Maximum number of training epochs.')
-++					 'Number of iterations between reporting minibatch loss.')
-++flags.DEFINE_integer('train_epochs', 100, 'Maximum number of training epochs.')
-++flags.DEFINE_integer(
-++	"save_check_points",
-++	50,
-++	"frequency with which to save checkpoints, in number of epoches.",
-++)
-++flags.DEFINE_boolean("log_train_values", True, "Logs train values if True.")
-++flags.DEFINE_integer(
-++	"total_evaluations",
-++	100,
-++	"Maximum number of evaluations on test and validation data during training.",
-++)
-++flags.DEFINE_boolean(
-++	"save_test_predictions",
-++	False,
-++	"Makes and saves test predictions on one or more test sets (e.g. 5-step and 100-step predictions) at the end of training.",
-++)
-++flags.DEFINE_boolean(
-++    "log_val_test", True, "Turns off computation of validation and test errors."
-++)
-+ 
-+ # Experiment config
-+ flags.DEFINE_integer('batch_size', 100, 'Mini-batch size.')
-+-flags.DEFINE_float('learning_rate', 1e-5, 'SGD learning rate.')
-++flags.DEFINE_float("learning_rate", 1e-4, "Adam learning rate.")
-++flags.DEFINE_float("beta1", 0.9, "Adam Beta 1 parameter")
-++flags.DEFINE_float("beta2", 0.999, "Adam Beta 2 parameter")
-+ 
-+ # Specific config options
-+ flags.DEFINE_integer("input_size",39,"Input shape to model")
-+ 
-++#########################################################################################
-++
-++def evaluate(model, loader, device,fold = 0,headings = [],loss_func = nn.CrossEntropyLoss()):
-++	reports = None
-++	for data in loader:
-++		labels = data['label']
-++		inputs = nested_to(data['data'],device,torch.float32)
-++		
-++		labels_tensor = torch.zeros((len(labels), 2))
-++		for i, label in enumerate(labels):
-++			labels_tensor[i, label] = 1
-++
-++		model_output = model(inputs) # evaluate model
-++
-++		loss = loss_func(model_output, labels_tensor) # compute loss
-++		outputs = AttrDict({"loss": loss, "prediction": model_output,'data_fold':fold})
-++		outputs.reports = AttrDict({"cross_entropy": loss})
-++
-++		if reports is None:
-++			reports = {k: v.detach().clone().cpu() for k, v in outputs.reports.items()}
-++		else:
-++			for k, v in outputs.reports.items():
-++				reports[k] += v.detach().clone().cpu()
-++
-++	for k, v in reports.items():
-++		reports[k] = v / len(
-++			loader
-++		)  # SZ: note this can be slightly incorrect if mini-batch sizes vary (if batch_size doesn't divide train_size), but approximately correct.
-++
-++	# reports['test_headings'] = np.array(headings)
-++
-++	return reports
-++
-++def main():
-++
-++	config = forge.config()
-++
-++	# Set device
-++	if torch.cuda.is_available():
-++		device = f"cuda:{config.device}"
-++		torch.cuda.set_device(device)
-++	else:
-++		device = "cpu" # can change this to MPS on M1 Macs
-++
-++	# Load data
-++	data_name = "penn_data"
-++	kfold_loaders = fet.load(config.data_config, config)
-++
-++	# Load model
-++	model,model_name = fet.load(config.model_config, config)
-++	model = model.to(device)
-++
-++	loss_func = nn.CrossEntropyLoss()
-++
-++	# Prepare environment
-++	params_in_run_name = [
-++		("batch_size", "bs"),
-++		("learning_rate", "lr"),
-++		("n_train", "ntrain")
-++	]
-++
-++	run_name = ""  # config.run_name
-++	for config_param in params_in_run_name:
-++		attr = config_param[0]
-++		abbrev = config_param[1]
-++
-++		if hasattr(config, attr):
-++			run_name += abbrev
-++			run_name += str(getattr(config, attr))
-++			run_name += "_"
-++
-++	results_folder_name = osp.join(
-++		data_name,
-++		model_name,
-++		config.run_name,
-++		run_name,
-++	)
-++
-++	# Prepare environment
-++	logdir = osp.join(config.results_dir, config.run_name)
-++	logdir, resume_checkpoint = fet.init_checkpoint(
-++		logdir, config.data_config, config.model_config, config.resume)
-++
-++	print("Checkpoint directory:",logdir)
-++
-++	# Print flags
-++	fet.print_flags()
-++	# Print model info
-++	print(model)
-++
-++	# Setup optimizer
-++	model_params = model.parameters()
-++	opt_learning_rate = config.learning_rate
-++	model_opt = torch.optim.Adam(
-++		model_params, lr=opt_learning_rate, betas=(config.beta1, config.beta2)
-++	)
-++	print("Model Optimizer:")
-++	print(model_opt)
-++
-++	# Try to restore model and optimizer from checkpoint
-++	if resume_checkpoint is not None:
-++		start_epoch = load_checkpoint(resume_checkpoint, model, model_opt)
-++	else:
-++		start_epoch = 1
-++
-++	n_folds = len(kfold_loaders)
-++	print("Doing {}-fold cross-validation.".format(n_folds))
-++
-++	# KFOLD TRAINING LOOP
-++	for k,loader_k in enumerate(kfold_loaders): # loop over data splits
-++
-++		print("Training fold {}...".format(k+1))
-++
-++		# load the training data
-++		train_loader = loader_k["train"]
-++		n_train = len(train_loader.dataset)
-++		train_batch_size = train_loader.batch_size
-++
-++		# load testing, validation
-++		test_loader = loader_k["test"]
-++		n_test = len(test_loader.dataset)
-++		val_loader = loader_k["val"]
-++		n_val = len(val_loader.dataset)
-++		
-++		# create folder for this data split
-++		fold_dir = osp.join(logdir,"data_fold{}".format(k+1))
-++		fold_dir_exists = osp.exists(fold_dir)
-++		if not fold_dir_exists:
-++			if config.resume:
-++				raise ValueError("Can't resume when the checkpoint/fold dir '{}' doesn't exist.".format(fold_dir))
-++			else:
-++				os.makedirs(fold_dir)
-++		checkpoint_name = osp.join(fold_dir, 'model_fold{}.ckpt'.format(k+1))
-++
-++		# keep track of which data is test data for a given Kfold data split
-++		test_headings = loader_k['test_headings']
-++		headingsFile = osp.join(fold_dir,"test_headings.txt")
-++		with open(headingsFile,'w') as headfile:
-++			for heading in test_headings:
-++				headfile.write(heading+'\n')
-++
-++		# print(checkpoint_name)
-++
-++		train_iter = (start_epoch - 1) * (
-++		len(train_loader.dataset) // train_batch_size
-++		) + 1
-++
-++		print("Starting training at epoch = {}, iter = {}".format(start_epoch, train_iter))
-++
-++		# Setup tensorboard writing
-++		summary_writer = SummaryWriter(logdir)
-++
-++		train_reports = []
-++		report_all = {}
-++		report_all_val = {}
-++
-++		# Saving model at epoch 0 before training
-++		print("saving model at epoch 0 before training ... ")
-++		save_checkpoint(checkpoint_name, 0, model, model_opt, loss=0.0)
-++		print("finished saving model at epoch 0 before training")
-++
-++		num_params = param_count(model)
-++		print(f"Number of model parameters: {num_params}")
-++
-++		# Training
-++		start_t = time.time()
-++
-++		total_train_iters = len(train_loader) * config.train_epochs
-++		iters_per_eval = max(1, int(total_train_iters / config.total_evaluations))
-++		# print('batch',train_batch_size)
-++		# print('ntrain',n_train)
-++		# assert (
-++		# 	n_train % min(train_batch_size, n_train) == 0
-++		# ), "Batch size doesn't divide dataset size. Can be inaccurate for loss computation (see below)."
-++
-++		training_failed = False
-++		best_val_loss_so_far = 1e7
-++
-++		for epoch in tqdm(range(start_epoch, config.train_epochs + 1)):
-++			model.train()
-++
-++			for batch_idx, data_dict in enumerate(train_loader): # Loop over batched data
-++
-++				labels = data_dict['label']
-++				data = data_dict['data']
-++
-++				# send data to device
-++				data = nested_to(data,device,torch.float32)
-++				# One-hot encode the data labels
-++				labels_tensor = torch.zeros((len(labels), 2))
-++				for i, label in enumerate(labels):
-++					labels_tensor[i, label] = 1
-++
-++				model_output = model(data) # evaluate model
-++
-++				loss = loss_func(model_output, labels_tensor) # compute loss
-++				outputs = AttrDict({"loss": loss, "prediction": model_output})
-++				outputs.reports = AttrDict({"cross_entropy": loss})
-++
-++				if torch.isnan(outputs.loss): # check for failure in training
-++					if not training_failed:
-++						epoch_of_nan = epoch
-++					if (epoch > epoch_of_nan + 1) and training_failed:
-++						raise ValueError("Loss Nan-ed.")
-++					training_failed = True
-++
-++				model_opt.zero_grad()
-++				outputs.loss.backward(retain_graph=False)
-++
-++				model_opt.step() # move optimizer forward
-++
-++				train_reports.append(parse_reports_cpu(outputs.reports))
-++
-++				if config.log_train_values:
-++					reports = parse_reports(outputs.reports)
-++					if batch_idx % config.report_loss_every == 0:
-++						log_tensorboard(summary_writer, train_iter, reports, "train/")
-++						print_reports(
-++							reports,
-++							start_t,
-++							epoch,
-++							batch_idx,
-++							len(train_loader.dataset) // train_batch_size,
-++							prefix="train",
-++						)
-++						log_tensorboard(
-++							summary_writer,
-++							train_iter,
-++							{"lr": model_opt.param_groups[0]["lr"]},
-++							"hyperparams/",
-++						)
-++				# Logging and evaluation
-++				if (
-++					train_iter % iters_per_eval == 0 or (train_iter == total_train_iters)
-++				) and config.log_val_test:  # batch_idx % config.evaluate_every == 0:
-++					model.eval()
-++					with torch.no_grad():
-++						reports = evaluate(model, test_loader, device,fold = k,headings = loader_k['test_headings'])
-++						# print("REPORTS",reports)
-++						reports = parse_reports(reports)
-++						reports["time"] = time.time() - start_t
-++						if report_all == {}:
-++							report_all = deepcopy(reports)
-++
-++							for d in reports.keys():
-++								report_all[d] = [report_all[d]]
-++						else:
-++							for d in reports.keys():
-++								report_all[d].append(reports[d])
-++
-++						log_tensorboard(summary_writer, train_iter, reports, "test/")
-++						print_reports(
-++							reports,
-++							start_t,
-++							epoch,
-++							batch_idx,
-++							len(train_loader.dataset) // config.batch_size,
-++							prefix="test",
-++						)
-++
-++						# repeat for validation data
-++						reports = evaluate(model, val_loader, device,fold = k,headings = loader_k['test_headings'])
-++						reports = parse_reports(reports)
-++						reports["time"] = time.time() - start_t
-++						if report_all_val == {}:
-++							report_all_val = deepcopy(reports)
-++
-++							for d in reports.keys():
-++								report_all_val[d] = [report_all_val[d]]
-++						else:
-++							for d in reports.keys():
-++								report_all_val[d].append(reports[d])
-++
-++						log_tensorboard(summary_writer, train_iter, reports, "val/")
-++						print_reports(
-++							reports,
-++							start_t,
-++							epoch,
-++							batch_idx,
-++							len(train_loader.dataset) // config.batch_size,
-++							prefix="val",
-++						)
-++
-++						if report_all_val["cross_entropy"][-1] < best_val_loss_so_far:
-++							save_checkpoint(
-++								checkpoint_name,
-++								f"early_stop",
-++								model,
-++								model_opt,
-++								loss=outputs.loss,
-++							)
-++							best_val_loss_so_far = report_all_val["cross_entropy"][-1]
-++
-++					model.train()
-++
-++				train_iter += 1
-++
-++			if epoch % config.save_check_points == 0:
-++				save_checkpoint(
-++					checkpoint_name, train_iter, model, model_opt, loss=outputs.loss
-++				)
-++
-++		dd.io.save(fold_dir + "/results_dict_train.h5", train_reports)
-++		dd.io.save(fold_dir + "/results_dict.h5", report_all)
-++		dd.io.save(fold_dir + "/results_dict_val.h5", report_all_val)
-++
-++	# always save final model
-++	save_checkpoint(checkpoint_name, train_iter, model, model_opt, loss=outputs.loss)
-++
-++	
-++	if config.save_test_predictions:
-++		pass
-++		# print("Starting to make model predictions on test sets for *final model*.")
-++		# for chunk_len in [5, 100]:
-++		#     start_t_preds = time.time()
-++		#     data_config = SimpleNamespace(
-++		#         **{
-++		#             **config.__dict__["__flags"],
-++		#             **{"chunk_len": chunk_len, "batch_size": 500},
-++		#         }
-++		#     )
-++		#     dataloaders, data_name = fet.load(config.data_config, config=data_config)
-++		#     test_loader_preds = dataloaders["test"]
-++
-++		#     torch.cuda.empty_cache()
-++		#     with torch.no_grad():
-++		#         preds = []
-++		#         true = []
-++		#         num_datapoints = 0
-++		#         for idx, d in enumerate(test_loader_preds):
-++		#             true.append(d[-1])
-++		#             d = nested_to(d, device, torch.float32)
-++		#             outputs = model(d)
-++
-++		#             pred_zs = outputs.prediction
-++		#             preds.append(pred_zs)
-++
-++		#             num_datapoints += len(pred_zs)
-++
-++		#             if num_datapoints >= 2000:
-++		#                 break
-+ 
-+-config = forge.config()
-++		#         preds = torch.cat(preds, dim=0).cpu()
-++		#         true = torch.cat(true, dim=0).cpu()
-+ 
-+-# Prepare environment
-+-logdir = osp.join(config.results_dir, config.run_name)
-+-logdir, resume_checkpoint = fet.init_checkpoint(
-+-    logdir, config.data_config, config.model_config, config.resume)
-+-checkpoint_name = osp.join(logdir, 'model.ckpt')
-++		#         save_dir = osp.join(logdir, f"traj_preds_{chunk_len}_steps_2k_test.pt")
-++		#         torch.save(preds, save_dir)
-+ 
-++		#         save_dir = osp.join(logdir, f"traj_true_{chunk_len}_steps_2k_test.pt")
-++		#         torch.save(true, save_dir)
-+ 
-+-print(logdir)
-++		#         print(
-++		#             f"Completed making test predictions for chunk_len = {chunk_len} in {time.time() - start_t_preds:.2f} seconds."
-++		#         )	
-++		
-+ 
-++if __name__ == "__main__":
-++	main()
-+ 
-diff --git a/checkpoints/feedforward/1/penn_dataset.py b/checkpoints/feedforward/1/penn_dataset.py
-index aa2f5a0..7f5a4fc 100644
---- a/checkpoints/feedforward/1/penn_dataset.py
-+++ b/checkpoints/feedforward/1/penn_dataset.py
-@@ -15,6 +15,7 @@ from forge import flags
- # aspects of data managmement
- flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
- flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-+flags.DEFINE_boolean("cross_validate",False,"Do K-fold cross-validation")
- 
- # Job management
- # flags.DEFINE_integer("batch size",5,"training batch size")
-@@ -109,15 +110,15 @@ def load(config):
-         
-         # set up training DataLoader
-         train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, n_train),num_workers=0,shuffle = True)
-+        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
- 
-         # set up test DataLoader
-         test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, n_test),num_workers=0,shuffle = True)
-+        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
- 
-         # set up val DataLoader
-         val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, n_val),num_workers=0,shuffle = True)
-+        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-         
- 
-         dataloaders = {'train':train_loader, 
-@@ -125,8 +126,12 @@ def load(config):
-                        'val':val_loader,
-                        'train_inds':train_ind,
-                        'test_inds':test_ind,
--                       'n_val':n_val
-+                       'n_val':n_val,
-+                       'test_headings':list(HEADINGS[test_ind])
-                       }
-         kf_dataloaders.append(dataloaders)
- 
-+        if not config.cross_validate:
-+        	break
-+
-     return kf_dataloaders
-diff --git a/georgehulsey_2024.pdf b/georgehulsey_2024.pdf
-deleted file mode 100644
-index 1ab17f6..0000000
-Binary files a/georgehulsey_2024.pdf and /dev/null differ
-diff --git a/penn_dataset.py b/penn_dataset.py
-index aa2f5a0..7f5a4fc 100644
---- a/penn_dataset.py
-+++ b/penn_dataset.py
-@@ -15,6 +15,7 @@ from forge import flags
- # aspects of data managmement
- flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
- flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-+flags.DEFINE_boolean("cross_validate",False,"Do K-fold cross-validation")
- 
- # Job management
- # flags.DEFINE_integer("batch size",5,"training batch size")
-@@ -109,15 +110,15 @@ def load(config):
-         
-         # set up training DataLoader
-         train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, n_train),num_workers=0,shuffle = True)
-+        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
- 
-         # set up test DataLoader
-         test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, n_test),num_workers=0,shuffle = True)
-+        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
- 
-         # set up val DataLoader
-         val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, n_val),num_workers=0,shuffle = True)
-+        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-         
- 
-         dataloaders = {'train':train_loader, 
-@@ -125,8 +126,12 @@ def load(config):
-                        'val':val_loader,
-                        'train_inds':train_ind,
-                        'test_inds':test_ind,
--                       'n_val':n_val
-+                       'n_val':n_val,
-+                       'test_headings':list(HEADINGS[test_ind])
-                       }
-         kf_dataloaders.append(dataloaders)
- 
-+        if not config.cross_validate:
-+        	break
-+
-     return kf_dataloaders
-diff --git a/testing.ipynb b/testing.ipynb
-index e5a167b..0110538 100644
---- a/testing.ipynb
-+++ b/testing.ipynb
-@@ -2,7 +2,7 @@
-  "cells": [
-   {
-    "cell_type": "code",
--   "execution_count": 1,
-+   "execution_count": 4,
-    "id": "4dee7ff1-01a4-4038-b493-9729ff3693f7",
-    "metadata": {},
-    "outputs": [],
-@@ -23,7 +23,7 @@
-   },
-   {
-    "cell_type": "code",
--   "execution_count": 2,
-+   "execution_count": 6,
-    "id": "cad0fdc8-5c35-4610-bba3-b71e60dc1b98",
-    "metadata": {},
-    "outputs": [],
-@@ -35,7 +35,7 @@
-   },
-   {
-    "cell_type": "code",
--   "execution_count": 3,
-+   "execution_count": 7,
-    "id": "ce1b936b-8a7c-426e-a3aa-3c1c38f645de",
-    "metadata": {},
-    "outputs": [
-@@ -54,8 +54,8 @@
-   },
-   {
-    "cell_type": "code",
--   "execution_count": 9,
--   "id": "e862b7e2-57f5-44bf-bcf1-a91160ba66cc",
-+   "execution_count": 5,
-+   "id": "4469cddf-4dac-4468-be88-241d440401c3",
-    "metadata": {},
-    "outputs": [
-     {
-@@ -67,35 +67,98 @@
-     }
-    ],
-    "source": [
--    "model = fet.load(\"basic_feedforward.py\",config)"
-+    "model,modelname = fet.load(\"basic_feedforward.py\",config)"
-    ]
-   },
-   {
-    "cell_type": "code",
--   "execution_count": 10,
--   "id": "07e0b160-d5d1-4e54-b4a7-ccaf2224598a",
-+   "execution_count": 13,
-+   "id": "7c9a9fe9-f5e8-456a-b964-4be13027725b",
-    "metadata": {},
-    "outputs": [
-     {
-      "data": {
-       "text/plain": [
--       "PerceptronNN(\n",
--       "  (fc1): Linear(in_features=39, out_features=128, bias=True)\n",
--       "  (fc2): Linear(in_features=128, out_features=64, bias=True)\n",
--       "  (fc3): Linear(in_features=64, out_features=64, bias=True)\n",
--       "  (fc4): Linear(in_features=64, out_features=2, bias=True)\n",
--       ")"
-+       "array([114170,    904])"
-       ]
-      },
--     "execution_count": 10,
-+     "execution_count": 13,
-      "metadata": {},
-      "output_type": "execute_result"
-     }
-    ],
-    "source": [
--    "model"
-+    "np.bincount(loaddat[0]['train'].dataset.all_labels)"
-    ]
-   },
-+  {
-+   "cell_type": "code",
-+   "execution_count": 1,
-+   "id": "e862b7e2-57f5-44bf-bcf1-a91160ba66cc",
-+   "metadata": {},
-+   "outputs": [
-+    {
-+     "ename": "FileNotFoundError",
-+     "evalue": "[Errno 2] Unable to open file (unable to open file: name = './checkpoints/feedforward/2/data_fold1/results_dict.h5', errno = 2, error message = 'No such file or directory', flags = 0, o_flags = 0)",
-+     "output_type": "error",
-+     "traceback": [
-+      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
-+      "\u001b[0;31mFileNotFoundError\u001b[0m                         Traceback (most recent call last)",
-+      "Cell \u001b[0;32mIn[1], line 5\u001b[0m\n\u001b[1;32m      3\u001b[0m file_path \u001b[38;5;241m=\u001b[39m \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124m./checkpoints/feedforward/2/data_fold1/results_dict.h5\u001b[39m\u001b[38;5;124m\"\u001b[39m\n\u001b[1;32m      4\u001b[0m \u001b[38;5;66;03m# Replace 'your_file.h5' with the actual path to your file\u001b[39;00m\n\u001b[0;32m----> 5\u001b[0m f \u001b[38;5;241m=\u001b[39m  \u001b[43mh5py\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mFile\u001b[49m\u001b[43m(\u001b[49m\u001b[43mfile_path\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[38;5;124;43mr\u001b[39;49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[43m)\u001b[49m \n\u001b[1;32m      7\u001b[0m     \u001b[38;5;66;03m# Get information about the data stored in the file\u001b[39;00m\n\u001b[1;32m      8\u001b[0m \u001b[38;5;28mprint\u001b[39m(\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mKeys:\u001b[39m\u001b[38;5;124m\"\u001b[39m, \u001b[38;5;28mlist\u001b[39m(f\u001b[38;5;241m.\u001b[39mkeys()))\n",
-+      "File \u001b[0;32m/Applications/miniconda3/envs/lietransformer/lib/python3.9/site-packages/h5py/_hl/files.py:562\u001b[0m, in \u001b[0;36mFile.__init__\u001b[0;34m(self, name, mode, driver, libver, userblock_size, swmr, rdcc_nslots, rdcc_nbytes, rdcc_w0, track_order, fs_strategy, fs_persist, fs_threshold, fs_page_size, page_buf_size, min_meta_keep, min_raw_keep, locking, alignment_threshold, alignment_interval, meta_block_size, **kwds)\u001b[0m\n\u001b[1;32m    553\u001b[0m     fapl \u001b[38;5;241m=\u001b[39m make_fapl(driver, libver, rdcc_nslots, rdcc_nbytes, rdcc_w0,\n\u001b[1;32m    554\u001b[0m                      locking, page_buf_size, min_meta_keep, min_raw_keep,\n\u001b[1;32m    555\u001b[0m                      alignment_threshold\u001b[38;5;241m=\u001b[39malignment_threshold,\n\u001b[1;32m    556\u001b[0m                      alignment_interval\u001b[38;5;241m=\u001b[39malignment_interval,\n\u001b[1;32m    557\u001b[0m                      meta_block_size\u001b[38;5;241m=\u001b[39mmeta_block_size,\n\u001b[1;32m    558\u001b[0m                      \u001b[38;5;241m*\u001b[39m\u001b[38;5;241m*\u001b[39mkwds)\n\u001b[1;32m    559\u001b[0m     fcpl \u001b[38;5;241m=\u001b[39m make_fcpl(track_order\u001b[38;5;241m=\u001b[39mtrack_order, fs_strategy\u001b[38;5;241m=\u001b[39mfs_strategy,\n\u001b[1;32m    560\u001b[0m                      fs_persist\u001b[38;5;241m=\u001b[39mfs_persist, fs_threshold\u001b[38;5;241m=\u001b[39mfs_threshold,\n\u001b[1;32m    561\u001b[0m                      fs_page_size\u001b[38;5;241m=\u001b[39mfs_page_size)\n\u001b[0;32m--> 562\u001b[0m     fid \u001b[38;5;241m=\u001b[39m \u001b[43mmake_fid\u001b[49m\u001b[43m(\u001b[49m\u001b[43mname\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mmode\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43muserblock_size\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mfapl\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mfcpl\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mswmr\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43mswmr\u001b[49m\u001b[43m)\u001b[49m\n\u001b[1;32m    564\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;28misinstance\u001b[39m(libver, \u001b[38;5;28mtuple\u001b[39m):\n\u001b[1;32m    565\u001b[0m     \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_libver \u001b[38;5;241m=\u001b[39m libver\n",
-+      "File \u001b[0;32m/Applications/miniconda3/envs/lietransformer/lib/python3.9/site-packages/h5py/_hl/files.py:235\u001b[0m, in \u001b[0;36mmake_fid\u001b[0;34m(name, mode, userblock_size, fapl, fcpl, swmr)\u001b[0m\n\u001b[1;32m    233\u001b[0m     \u001b[38;5;28;01mif\u001b[39;00m swmr \u001b[38;5;129;01mand\u001b[39;00m swmr_support:\n\u001b[1;32m    234\u001b[0m         flags \u001b[38;5;241m|\u001b[39m\u001b[38;5;241m=\u001b[39m h5f\u001b[38;5;241m.\u001b[39mACC_SWMR_READ\n\u001b[0;32m--> 235\u001b[0m     fid \u001b[38;5;241m=\u001b[39m \u001b[43mh5f\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mopen\u001b[49m\u001b[43m(\u001b[49m\u001b[43mname\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mflags\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mfapl\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43mfapl\u001b[49m\u001b[43m)\u001b[49m\n\u001b[1;32m    236\u001b[0m \u001b[38;5;28;01melif\u001b[39;00m mode \u001b[38;5;241m==\u001b[39m \u001b[38;5;124m'\u001b[39m\u001b[38;5;124mr+\u001b[39m\u001b[38;5;124m'\u001b[39m:\n\u001b[1;32m    237\u001b[0m     fid \u001b[38;5;241m=\u001b[39m h5f\u001b[38;5;241m.\u001b[39mopen(name, h5f\u001b[38;5;241m.\u001b[39mACC_RDWR, fapl\u001b[38;5;241m=\u001b[39mfapl)\n",
-+      "File \u001b[0;32mh5py/_objects.pyx:54\u001b[0m, in \u001b[0;36mh5py._objects.with_phil.wrapper\u001b[0;34m()\u001b[0m\n",
-+      "File \u001b[0;32mh5py/_objects.pyx:55\u001b[0m, in \u001b[0;36mh5py._objects.with_phil.wrapper\u001b[0;34m()\u001b[0m\n",
-+      "File \u001b[0;32mh5py/h5f.pyx:102\u001b[0m, in \u001b[0;36mh5py.h5f.open\u001b[0;34m()\u001b[0m\n",
-+      "\u001b[0;31mFileNotFoundError\u001b[0m: [Errno 2] Unable to open file (unable to open file: name = './checkpoints/feedforward/2/data_fold1/results_dict.h5', errno = 2, error message = 'No such file or directory', flags = 0, o_flags = 0)"
-+     ]
-+    }
-+   ],
-+   "source": [
-+    "import h5py\n",
-+    "\n",
-+    "file_path = \"./checkpoints/feedforward/2/data_fold1/results_dict.h5\"\n",
-+    "# Replace 'your_file.h5' with the actual path to your file\n",
-+    "f =  h5py.File(file_path, 'r') \n",
-+    "\n",
-+    "    # Get information about the data stored in the file\n",
-+    "print(\"Keys:\", list(f.keys()))  # List the top-level datasets and groups\n",
-+    "\n",
-+    "    # # Access a dataset by its name\n",
-+    "    # dataset_name = \"your_dataset_name\"\n",
-+    "    # if dataset_name in f:\n",
-+    "    #     dataset = f[dataset_name]\n",
-+    "    #     print(\"Dataset shape:\", dataset.shape)\n",
-+    "    #     print(\"Dataset dtype:\", dataset.dtype)\n",
-+    "\n",
-+    "    #     # Access the data as a NumPy array\n",
-+    "    #     data = dataset[:]  # Read the entire dataset\n",
-+    "\n",
-+    "    #     # You can now work with the data as needed, for example:\n",
-+    "    #     # Perform calculations, visualizations, etc.\n",
-+    "    # else:\n",
-+    "    #     print(f\"Dataset '{dataset_name}' not found in the file.\")"
-+   ]
-+  },
-+  {
-+   "cell_type": "code",
-+   "execution_count": 13,
-+   "id": "07e0b160-d5d1-4e54-b4a7-ccaf2224598a",
-+   "metadata": {},
-+   "outputs": [
-+    {
-+     "data": {
-+      "text/plain": [
-+       "<generator object Module.parameters at 0x3007207b0>"
-+      ]
-+     },
-+     "execution_count": 13,
-+     "metadata": {},
-+     "output_type": "execute_result"
-+    }
-+   ],
-+   "source": []
-+  },
-   {
-    "cell_type": "code",
-    "execution_count": null,
-diff --git a/train.py b/train.py
-index c266102..432d504 100644
---- a/train.py
-+++ b/train.py
-@@ -1,49 +1,455 @@
- from os import path as osp
-+import os
-+import numpy as np
-+import time
- 
- import torch
-+import torch.nn as nn
- import torch.nn.functional as F
- import torch.optim as optim
--
--import numpy as np
-+from torch.utils.tensorboard import SummaryWriter
- 
- import forge
- from forge import flags
- import forge.experiment_tools as fet
- 
-+from train_tools import (
-+	log_tensorboard,
-+	parse_reports,
-+	parse_reports_cpu,
-+	print_reports,
-+	load_checkpoint,
-+	save_checkpoint,
-+	nested_to,
-+	param_count,
-+)
-+
-+from copy import deepcopy
-+from attrdict import AttrDict
-+import deepdish as dd
-+from tqdm import tqdm
-+
-+# For reproducibility while researching, but might affect speed!
-+torch.backends.cudnn.deterministic = True
-+torch.backends.cudnn.benchmark = False
-+torch.manual_seed(0)
-+
- 
- # Job config
- flags.DEFINE_string('data_config', 'penn_dataset.py',
--                    'Path to a data config file.')
-+					'Path to a data config file.')
- flags.DEFINE_string('model_config', 'basic_feedforward.py',
--                    'Path to a model config file.')
-+					'Path to a model config file.')
- flags.DEFINE_string('results_dir', 'checkpoints',
--                    'Top directory for all experimental results.')
--flags.DEFINE_string('run_name', 'feedforward',
--                    'Name of this job and name of results folder.')
-+					'Top directory for all experimental results.')
-+flags.DEFINE_string('run_name', 'testing',
-+					'Name of this job and name of results folder.')
- flags.DEFINE_boolean('resume', False, 'Tries to resume a job if True.')
- 
- # Logging config
- flags.DEFINE_integer('report_loss_every', 50,
--                     'Number of iterations between reporting minibatch loss.')
--flags.DEFINE_integer('train_epochs', 20, 'Maximum number of training epochs.')
-+					 'Number of iterations between reporting minibatch loss.')
-+flags.DEFINE_integer('train_epochs', 10, 'Maximum number of training epochs.')
-+flags.DEFINE_integer(
-+	"save_check_points",
-+	50,
-+	"frequency with which to save checkpoints, in number of epoches.",
-+)
-+flags.DEFINE_boolean("log_train_values", True, "Logs train values if True.")
-+flags.DEFINE_integer(
-+	"total_evaluations",
-+	100,
-+	"Maximum number of evaluations on test and validation data during training.",
-+)
-+flags.DEFINE_boolean(
-+	"save_test_predictions",
-+	False,
-+	"Makes and saves test predictions on one or more test sets (e.g. 5-step and 100-step predictions) at the end of training.",
-+)
-+flags.DEFINE_boolean(
-+    "log_val_test", True, "Turns off computation of validation and test errors."
-+)
-+
-+flags.DEFINE_boolean('use_mps',False,"Use Metal Performance Shaders (M1) for training.")
- 
- # Experiment config
- flags.DEFINE_integer('batch_size', 100, 'Mini-batch size.')
--flags.DEFINE_float('learning_rate', 1e-5, 'SGD learning rate.')
-+flags.DEFINE_float("learning_rate", 1e-3, "Adam learning rate.")
-+flags.DEFINE_float("beta1", 0.9, "Adam Beta 1 parameter")
-+flags.DEFINE_float("beta2", 0.999, "Adam Beta 2 parameter")
- 
- # Specific config options
- flags.DEFINE_integer("input_size",39,"Input shape to model")
- 
-+#########################################################################################
-+
-+def evaluate(model, loader, device,fold = 0,headings = [],loss_func = nn.CrossEntropyLoss()):
-+	# this function does not account for class weights when evaluating cross-entropy loss.
-+	# however, they are accounted for when evaluating training loss
-+	reports = None
-+	for data in loader:
-+		labels = data['label']
-+		inputs = nested_to(data['data'],device,torch.float32)
-+		
-+		labels_tensor = torch.zeros((len(labels), 2))
-+		for i, label in enumerate(labels):
-+			labels_tensor[i, label] = 1
-+
-+		model_output = model(inputs) # evaluate model
-+
-+		loss = loss_func(model_output, labels_tensor) # compute loss
-+		outputs = AttrDict({"loss": loss, "prediction": model_output,'data_fold':fold})
-+		outputs.reports = AttrDict({"cross_entropy": loss})
-+
-+		if reports is None:
-+			reports = {k: v.detach().clone().cpu() for k, v in outputs.reports.items()}
-+		else:
-+			for k, v in outputs.reports.items():
-+				reports[k] += v.detach().clone().cpu()
-+
-+	for k, v in reports.items():
-+		reports[k] = v / len(
-+			loader
-+		)  # SZ: note this can be slightly incorrect if mini-batch sizes vary (if batch_size doesn't divide train_size), but approximately correct.
-+
-+	# reports['test_headings'] = np.array(headings)
-+
-+	return reports
-+
-+def main():
-+
-+	config = forge.config()
-+
-+	# Set device
-+	if torch.cuda.is_available():
-+		device = f"cuda:{config.device}"
-+		torch.cuda.set_device(device)
-+	else:
-+		device = "cpu" # can change this to MPS on M1 Macs
-+
-+	if config.use_mps:
-+		device = "mps"
-+
-+	# Load data
-+	data_name = "penn_data"
-+	kfold_loaders = fet.load(config.data_config, config)
-+
-+	# Load model
-+	model,model_name = fet.load(config.model_config, config)
-+	model = model.to(device)
-+
-+	# Prepare environment
-+	params_in_run_name = [
-+		("batch_size", "bs"),
-+		("learning_rate", "lr"),
-+		("n_train", "ntrain"),
-+		("include_coords",'inclx'),
-+		("input_size",'inpsize'),
-+		("cross_validate",'crval'),
-+		("train_epochs",'n_epochs'),
-+	]
-+
-+	run_name = ""  # config.run_name
-+	for config_param in params_in_run_name:
-+		attr = config_param[0]
-+		abbrev = config_param[1]
-+
-+		if hasattr(config, attr):
-+			run_name += abbrev
-+			run_name += str(getattr(config, attr))
-+			run_name += "_"
-+
-+	results_folder_name = osp.join(
-+		data_name,
-+		model_name,
-+		config.run_name,
-+		run_name,
-+	)
-+
-+	# Prepare environment
-+	logdir = osp.join(config.results_dir, results_folder_name.replace(".", "_"))
-+	logdir, resume_checkpoint = fet.init_checkpoint(
-+		logdir, config.data_config, config.model_config, config.resume)
-+
-+	print("Checkpoint directory:",logdir)
-+
-+	# Print flags
-+	fet.print_flags()
-+	# Print model info
-+	print(model)
-+
-+	# Setup optimizer
-+	model_params = model.parameters()
-+	opt_learning_rate = config.learning_rate
-+	model_opt = torch.optim.Adam(
-+		model_params, lr=opt_learning_rate, betas=(config.beta1, config.beta2)
-+	)
-+	print("Model Optimizer:")
-+	print(model_opt)
-+
-+	# Try to restore model and optimizer from checkpoint
-+	if resume_checkpoint is not None:
-+		start_epoch = load_checkpoint(resume_checkpoint, model, model_opt)
-+	else:
-+		start_epoch = 1
-+
-+	n_folds = len(kfold_loaders)
-+	print("Doing {}-fold cross-validation.".format(n_folds))
-+
-+	# KFOLD TRAINING LOOP
-+	for k,loader_k in enumerate(kfold_loaders): # loop over data splits
-+
-+		print("Training fold {}...".format(k+1))
-+
-+		# load the training data
-+		train_loader = loader_k["train"]
-+		n_train = len(train_loader.dataset)
-+		train_batch_size = train_loader.batch_size
-+
-+		# load testing, validation
-+		test_loader = loader_k["test"]
-+		n_test = len(test_loader.dataset)
-+		val_loader = loader_k["val"]
-+		n_val = len(val_loader.dataset)
-+
-+		train_class_counts = np.bincount(train_loader.dataset.all_labels)
-+		train_total_counts = sum(train_class_counts)
-+		class_weight = torch.tensor(1.0 / train_class_counts) * train_total_counts / 2.0
-+
-+		loss_func = nn.CrossEntropyLoss(weight = class_weight) # define reweighted loss function
-+				
-+		# create folder for this data split
-+		fold_dir = osp.join(logdir,"data_fold{}".format(k+1))
-+		fold_dir_exists = osp.exists(fold_dir)
-+		if not fold_dir_exists:
-+			if config.resume:
-+				raise ValueError("Can't resume when the checkpoint/fold dir '{}' doesn't exist.".format(fold_dir))
-+			else:
-+				os.makedirs(fold_dir)
-+		checkpoint_name = osp.join(fold_dir, 'model_fold{}.ckpt'.format(k+1))
-+
-+		# keep track of which data is test data for a given Kfold data split
-+		test_headings = loader_k['test_headings']
-+		headingsFile = osp.join(fold_dir,"test_headings.txt")
-+		with open(headingsFile,'w') as headfile:
-+			for heading in test_headings:
-+				headfile.write(heading+'\n')
-+
-+		# print(checkpoint_name)
-+
-+		train_iter = (start_epoch - 1) * (
-+		len(train_loader.dataset) // train_batch_size
-+		) + 1
-+
-+		print("Starting training at epoch = {}, iter = {}".format(start_epoch, train_iter))
-+
-+		# Setup tensorboard writing
-+		summary_writer = SummaryWriter(logdir)
-+
-+		train_reports = []
-+		report_all = {}
-+		report_all_val = {}
-+
-+		# Saving model at epoch 0 before training
-+		print("saving model at epoch 0 before training ... ")
-+		save_checkpoint(checkpoint_name, 0, model, model_opt, loss=0.0)
-+		print("finished saving model at epoch 0 before training")
-+
-+		num_params = param_count(model)
-+		print(f"Number of model parameters: {num_params}")
-+
-+		# Training
-+		start_t = time.time()
-+
-+		total_train_iters = len(train_loader) * config.train_epochs
-+		iters_per_eval = max(1, int(total_train_iters / config.total_evaluations))
-+		# print('batch',train_batch_size)
-+		# print('ntrain',n_train)
-+		# assert (
-+		# 	n_train % min(train_batch_size, n_train) == 0
-+		# ), "Batch size doesn't divide dataset size. Can be inaccurate for loss computation (see below)."
-+
-+		training_failed = False
-+		best_val_loss_so_far = 1e7
-+
-+		for epoch in tqdm(range(start_epoch, config.train_epochs + 1)):
-+			model.train()
-+
-+			for batch_idx, data_dict in enumerate(train_loader): # Loop over batched data
-+
-+				labels = data_dict['label']
-+				data = data_dict['data']
-+
-+				# send data to device
-+				data = nested_to(data,device,torch.float32)
-+				# One-hot encode the data labels
-+				labels_tensor = torch.zeros((len(labels), 2))
-+				for i, label in enumerate(labels):
-+					labels_tensor[i, label] = 1
-+
-+				model_output = model(data) # evaluate model
-+
-+				loss = loss_func(model_output, labels_tensor) # compute loss
-+				outputs = AttrDict({"loss": loss, "prediction": model_output})
-+				outputs.reports = AttrDict({"cross_entropy": loss})
-+
-+				if torch.isnan(outputs.loss): # check for failure in training
-+					if not training_failed:
-+						epoch_of_nan = epoch
-+					if (epoch > epoch_of_nan + 1) and training_failed:
-+						raise ValueError("Loss Nan-ed.")
-+					training_failed = True
-+
-+				model_opt.zero_grad()
-+				outputs.loss.backward(retain_graph=False)
-+
-+				model_opt.step() # move optimizer forward
-+
-+				train_reports.append(parse_reports_cpu(outputs.reports))
-+
-+				if config.log_train_values:
-+					reports = parse_reports(outputs.reports)
-+					if batch_idx % config.report_loss_every == 0:
-+						log_tensorboard(summary_writer, train_iter, reports, "train/")
-+						print_reports(
-+							reports,
-+							start_t,
-+							epoch,
-+							batch_idx,
-+							len(train_loader.dataset) // train_batch_size,
-+							prefix="train",
-+						)
-+						log_tensorboard(
-+							summary_writer,
-+							train_iter,
-+							{"lr": model_opt.param_groups[0]["lr"]},
-+							"hyperparams/",
-+						)
-+				# Logging and evaluation
-+				if (
-+					train_iter % iters_per_eval == 0 or (train_iter == total_train_iters)
-+				) and config.log_val_test:  # batch_idx % config.evaluate_every == 0:
-+					model.eval()
-+					with torch.no_grad():
-+						reports = evaluate(model, test_loader, device,fold = k,headings = loader_k['test_headings'])
-+						# print("REPORTS",reports)
-+						reports = parse_reports(reports)
-+						reports["time"] = time.time() - start_t
-+						if report_all == {}:
-+							report_all = deepcopy(reports)
-+
-+							for d in reports.keys():
-+								report_all[d] = [report_all[d]]
-+						else:
-+							for d in reports.keys():
-+								report_all[d].append(reports[d])
-+
-+						log_tensorboard(summary_writer, train_iter, reports, "test/")
-+						print_reports(
-+							reports,
-+							start_t,
-+							epoch,
-+							batch_idx,
-+							len(train_loader.dataset) // config.batch_size,
-+							prefix="test",
-+						)
-+
-+						# repeat for validation data
-+						reports = evaluate(model, val_loader, device,fold = k,headings = loader_k['test_headings'])
-+						reports = parse_reports(reports)
-+						reports["time"] = time.time() - start_t
-+						if report_all_val == {}:
-+							report_all_val = deepcopy(reports)
-+
-+							for d in reports.keys():
-+								report_all_val[d] = [report_all_val[d]]
-+						else:
-+							for d in reports.keys():
-+								report_all_val[d].append(reports[d])
-+
-+						log_tensorboard(summary_writer, train_iter, reports, "val/")
-+						print_reports(
-+							reports,
-+							start_t,
-+							epoch,
-+							batch_idx,
-+							len(train_loader.dataset) // config.batch_size,
-+							prefix="val",
-+						)
-+
-+						if report_all_val["cross_entropy"][-1] < best_val_loss_so_far:
-+							save_checkpoint(
-+								checkpoint_name,
-+								f"early_stop",
-+								model,
-+								model_opt,
-+								loss=outputs.loss,
-+							)
-+							best_val_loss_so_far = report_all_val["cross_entropy"][-1]
-+
-+					model.train()
-+
-+				train_iter += 1
-+
-+			if epoch % config.save_check_points == 0:
-+				save_checkpoint(
-+					checkpoint_name, train_iter, model, model_opt, loss=outputs.loss
-+				)
-+		
-+		dd.io.save(fold_dir + "/results_dict_train.h5", train_reports)
-+		dd.io.save(fold_dir + "/results_dict.h5", report_all)
-+		dd.io.save(fold_dir + "/results_dict_val.h5", report_all_val)
-+
-+	# always save final model
-+	save_checkpoint(checkpoint_name, train_iter, model, model_opt, loss=outputs.loss)
-+
-+	
-+	if config.save_test_predictions:
-+		pass
-+		# print("Starting to make model predictions on test sets for *final model*.")
-+		# for chunk_len in [5, 100]:
-+		#     start_t_preds = time.time()
-+		#     data_config = SimpleNamespace(
-+		#         **{
-+		#             **config.__dict__["__flags"],
-+		#             **{"chunk_len": chunk_len, "batch_size": 500},
-+		#         }
-+		#     )
-+		#     dataloaders, data_name = fet.load(config.data_config, config=data_config)
-+		#     test_loader_preds = dataloaders["test"]
-+
-+		#     torch.cuda.empty_cache()
-+		#     with torch.no_grad():
-+		#         preds = []
-+		#         true = []
-+		#         num_datapoints = 0
-+		#         for idx, d in enumerate(test_loader_preds):
-+		#             true.append(d[-1])
-+		#             d = nested_to(d, device, torch.float32)
-+		#             outputs = model(d)
-+
-+		#             pred_zs = outputs.prediction
-+		#             preds.append(pred_zs)
-+
-+		#             num_datapoints += len(pred_zs)
-+
-+		#             if num_datapoints >= 2000:
-+		#                 break
- 
--config = forge.config()
-+		#         preds = torch.cat(preds, dim=0).cpu()
-+		#         true = torch.cat(true, dim=0).cpu()
- 
--# Prepare environment
--logdir = osp.join(config.results_dir, config.run_name)
--logdir, resume_checkpoint = fet.init_checkpoint(
--    logdir, config.data_config, config.model_config, config.resume)
--checkpoint_name = osp.join(logdir, 'model.ckpt')
-+		#         save_dir = osp.join(logdir, f"traj_preds_{chunk_len}_steps_2k_test.pt")
-+		#         torch.save(preds, save_dir)
- 
-+		#         save_dir = osp.join(logdir, f"traj_true_{chunk_len}_steps_2k_test.pt")
-+		#         torch.save(true, save_dir)
- 
--print(logdir)
-+		#         print(
-+		#             f"Completed making test predictions for chunk_len = {chunk_len} in {time.time() - start_t_preds:.2f} seconds."
-+		#         )	
-+		
- 
-+if __name__ == "__main__":
-+	main()
- 
diff --git a/checkpoints/penn_data/feedforward/plotting/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/penn_dataset.py b/checkpoints/penn_data/feedforward/plotting/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/penn_dataset.py
deleted file mode 100644
index 7f5a4fc..0000000
--- a/checkpoints/penn_data/feedforward/plotting/bs100_lr0_001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/penn_dataset.py
+++ /dev/null
@@ -1,137 +0,0 @@
-import os
-import torch
-import pandas as pd
-import numpy as np
-
-from torchvision import datasets, transforms
-from torch.utils.data import Dataset, DataLoader
-from sklearn.model_selection import RepeatedKFold
-
-from os import path as osp
-import forge
-from forge import flags
-
-
-# aspects of data managmement
-flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
-flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-flags.DEFINE_boolean("cross_validate",False,"Do K-fold cross-validation")
-
-# Job management
-# flags.DEFINE_integer("batch size",5,"training batch size")
-flags.DEFINE_float("train_split",0.8,'Fraction of data to use for training.')
-flags.DEFINE_integer("n_repeats",1,"Times to repeat K-fold cross-validation")
-flags.DEFINE_integer("split_seed",1,"Seed for KFold split (integer for reproducibility")
-
-# "wavelengths between 0.05 and 1 mm in 0.025 mm increments."
-LSPACE = np.arange(0.05,1.05,0.025) # corresponds to 39 non-coord columns of data
-L_INDS = None
-
-DATAFOLDER = './penn_data'
-
-HEADINGS = np.array(['aaa0043','aaa0044','aaa0060','aaa0061','aaa0063','aaa0064','aaa0066','aaa0069','aaa0086','aaa0087','aaa_0051','aaa_0053','aaa_0054','aaa_0059','aaa_0071','aaa_0072'])
-
-
-class PennData(Dataset):
-
-    def __init__(self,path_to_data,headings,k_inds = None,include_coords = True,rescale = True,spectra_prefix = "kvals_fuse_rotate_",label_prefix = 'labels_fuse_rotate_'):
-        
-        self.data_dir = path_to_data
-        self.headings = headings
-
-        df_list = []
-        label_list = []
-        for heading in self.headings: # for each datafile heading,
-            data_name = osp.join(self.data_dir,spectra_prefix + heading+'.csv') # read kvals
-            df_temp = pd.read_csv(data_name,header=None)
-            df_list.append(df_temp)
-
-            label_name = osp.join(self.data_dir,label_prefix + heading + '.csv') # read labels
-            label_temp = pd.read_csv(label_name,header=None, names=['label'])
-            label_list.append(label_temp)
-
-        df = pd.concat(df_list, ignore_index=True)
-
-        labels = pd.concat(label_list, ignore_index=True)
-        df = pd.concat([labels, df], axis="columns") # Append labels to data
-
-        all_labels = df['label'].to_numpy()
-        all_data = df.iloc[:,1:].to_numpy()
-
-        if rescale: # rescale (normalize) wavelength intensity data
-            lambdas = all_data[:,2:] # wavelengths
-            lam_std = np.std(lambdas, axis=0)  # Calculate standard deviation along columns
-            lam_mean = np.mean(lambdas, axis=0)  # Calculate mean along columns
-            lambdas_rescaled = (lambdas - lam_mean) / lam_std 
-            all_data[:,2:] = lambdas_rescaled
-
-        if not include_coords: # removes x,y coordinates from data
-            all_data = all_data[:,2:]
-        
-        if k_inds != None: # in this case, only use subset of wavelengths
-            all_data = all_data[:,np.array(k_inds)]
-
-        self.all_data = all_data
-        self.all_labels = all_labels
-
-    def __len__(self):
-        return len(self.all_data)
-
-    def __getitem__(self,i):
-        state = {'label':self.all_labels[i],'data':self.all_data[i]}
-        return state
-
-    def __getstate__(self):
-        state = {
-            'data': self.all_data,
-            'label': self.all_labels,
-                }
-        return state
-
-    def __setstate__(self, state):
-        # Set the object's state from the provided dictionary
-        self.all_data = state['data']
-        self.all_labels = state['label']
-        
-
-
-def load(config):
-
-    n_splits = int(len(HEADINGS)/((1-config.train_split)*len(HEADINGS)))
-
-    kf = RepeatedKFold(n_splits = n_splits, n_repeats = config.n_repeats, random_state = config.split_seed) # K-fold cross validation
-
-    kf_dataloaders = []
-
-    for i, (train_ind, test_ind) in enumerate(kf.split(HEADINGS)): # for each K-fold split, 
-        n_val = len(test_ind)//2
-        n_test = len(test_ind)-n_val   
-        n_train = len(train_ind)
-        
-        # set up training DataLoader
-        train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
-
-        # set up test DataLoader
-        test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
-
-        # set up val DataLoader
-        val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-        
-
-        dataloaders = {'train':train_loader, 
-                       'test':test_loader,
-                       'val':val_loader,
-                       'train_inds':train_ind,
-                       'test_inds':test_ind,
-                       'n_val':n_val,
-                       'test_headings':list(HEADINGS[test_ind])
-                      }
-        kf_dataloaders.append(dataloaders)
-
-        if not config.cross_validate:
-        	break
-
-    return kf_dataloaders
diff --git a/checkpoints/penn_data/feedforward/testing/.DS_Store b/checkpoints/penn_data/feedforward/testing/.DS_Store
deleted file mode 100644
index f1ae3e6..0000000
Binary files a/checkpoints/penn_data/feedforward/testing/.DS_Store and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_/.DS_Store b/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_/.DS_Store
deleted file mode 100644
index 25e0e51..0000000
Binary files a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_/.DS_Store and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_/1/basic_feedforward.py b/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_/1/basic_feedforward.py
deleted file mode 100644
index b8c3962..0000000
--- a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_/1/basic_feedforward.py
+++ /dev/null
@@ -1,42 +0,0 @@
-import torch
-import torch.nn as nn
-import torch.nn.functional as F
-import numpy as np
-
-from forge import flags
-
-# flags.DEFINE_boolean(
-#     "model_with_dict",
-#     True,
-#     "Makes model output predictions in dictionary instead of directly."
-# )
-
-class PerceptronNN(nn.Module):
-    def __init__(self, input_size, num_labels):
-        super(PerceptronNN, self).__init__()
-        # Define the layers
-        self.fc1 = nn.Linear(input_size, 128)  # First dense layer
-        self.fc2 = nn.Linear(128, 64)         # Second dense layer
-        self.fc23 = nn.Linear(64,64)
-        self.fc3 = nn.Linear(64, 64)          # Third dense layer
-        self.fc4 = nn.Linear(64, num_labels)  # Output layer
-        # self.softmax = nn.Softmax(dim=1)
-
-    def forward(self, x):
-        # Forward pass through the network
-        x = F.relu(self.fc1(x))  # Activation function between layers
-        x = F.relu(self.fc2(x))
-        x = F.relu(self.fc23(x))
-        x = F.relu(self.fc3(x))
-        x = self.fc4(x)  # No activation, this will be included in the loss function
-        # x = self.softmax(x)
-        return x
-
-def load(config):
-
-    # n_channels = 1
-    n_features = config.input_size
-    
-    mlp = PerceptronNN(n_features,2)
-    
-    return mlp, "feedforward"
\ No newline at end of file
diff --git a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_/1/flags.json b/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_/1/flags.json
deleted file mode 100644
index 889a6ea..0000000
--- a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_/1/flags.json
+++ /dev/null
@@ -1,26 +0,0 @@
-{
-    "batch_size": 100,
-    "beta1": 0.9,
-    "beta2": 0.999,
-    "cross_validate": false,
-    "data_config": "penn_dataset.py",
-    "git_commit": "7416bf730b356aabfe0df644240e40948a8196bb",
-    "include_coords": false,
-    "input_size": 39,
-    "learning_rate": 0.0001,
-    "log_train_values": true,
-    "log_val_test": true,
-    "model_config": "basic_feedforward.py",
-    "n_repeats": 1,
-    "report_loss_every": 50,
-    "rescale": true,
-    "results_dir": "checkpoints",
-    "resume": false,
-    "run_name": "feedforward",
-    "save_check_points": 50,
-    "save_test_predictions": false,
-    "split_seed": 1,
-    "total_evaluations": 100,
-    "train_epochs": 100,
-    "train_split": 0.8
-}
\ No newline at end of file
diff --git a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_/1/git_diff.txt b/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_/1/git_diff.txt
deleted file mode 100644
index 69a94ea..0000000
--- a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_/1/git_diff.txt
+++ /dev/null
@@ -1,1763 +0,0 @@
-Tue Mar 5 10:33:21 PST 2024
-diff --git a/.DS_Store b/.DS_Store
-index e2836a8..ad06094 100644
-Binary files a/.DS_Store and b/.DS_Store differ
-diff --git a/.ipynb_checkpoints/basic_feedforward-checkpoint.py b/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-index 688c282..0c4bcd1 100644
---- a/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-+++ b/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-@@ -5,6 +5,12 @@ import numpy as np
- 
- from forge import flags
- 
-+flags.DEFINE_boolean(
-+    "model_with_dict",
-+    True,
-+    "Makes model output predictions in dictionary instead of directly."
-+)
-+
- class PerceptronNN(nn.Module):
-     def __init__(self, input_size, num_labels):
-         super(PerceptronNN, self).__init__()
-@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-+        self.softmax = nn.Softmax(dim=1)
- 
-     def forward(self, x):
-         # Forward pass through the network
-@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-         x = F.relu(self.fc2(x))
-         x = F.relu(self.fc3(x))
-         x = self.fc4(x)  # No activation, this will be included in the loss function
-+        x = self.softmax(x)
-         return x
- 
- def load(config):
-@@ -29,4 +37,4 @@ def load(config):
-     
-     mlp = PerceptronNN(n_features,2)
-     
--    return mlp
-\ No newline at end of file
-+    return mlp, "feedforward"
-\ No newline at end of file
-diff --git a/__pycache__/basic_feedforward.cpython-39.pyc b/__pycache__/basic_feedforward.cpython-39.pyc
-index f541140..0e2c7e5 100644
-Binary files a/__pycache__/basic_feedforward.cpython-39.pyc and b/__pycache__/basic_feedforward.cpython-39.pyc differ
-diff --git a/__pycache__/penn_dataset.cpython-39.pyc b/__pycache__/penn_dataset.cpython-39.pyc
-index 0d7a4de..19121eb 100644
-Binary files a/__pycache__/penn_dataset.cpython-39.pyc and b/__pycache__/penn_dataset.cpython-39.pyc differ
-diff --git a/basic_feedforward.py b/basic_feedforward.py
-index 688c282..b8c3962 100644
---- a/basic_feedforward.py
-+++ b/basic_feedforward.py
-@@ -5,21 +5,31 @@ import numpy as np
- 
- from forge import flags
- 
-+# flags.DEFINE_boolean(
-+#     "model_with_dict",
-+#     True,
-+#     "Makes model output predictions in dictionary instead of directly."
-+# )
-+
- class PerceptronNN(nn.Module):
-     def __init__(self, input_size, num_labels):
-         super(PerceptronNN, self).__init__()
-         # Define the layers
-         self.fc1 = nn.Linear(input_size, 128)  # First dense layer
-         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-+        self.fc23 = nn.Linear(64,64)
-         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-+        # self.softmax = nn.Softmax(dim=1)
- 
-     def forward(self, x):
-         # Forward pass through the network
-         x = F.relu(self.fc1(x))  # Activation function between layers
-         x = F.relu(self.fc2(x))
-+        x = F.relu(self.fc23(x))
-         x = F.relu(self.fc3(x))
-         x = self.fc4(x)  # No activation, this will be included in the loss function
-+        # x = self.softmax(x)
-         return x
- 
- def load(config):
-@@ -29,4 +39,4 @@ def load(config):
-     
-     mlp = PerceptronNN(n_features,2)
-     
--    return mlp
-\ No newline at end of file
-+    return mlp, "feedforward"
-\ No newline at end of file
-diff --git a/checkpoints/feedforward/1/basic_feedforward.py b/checkpoints/feedforward/1/basic_feedforward.py
-index 688c282..3a65525 100644
---- a/checkpoints/feedforward/1/basic_feedforward.py
-+++ b/checkpoints/feedforward/1/basic_feedforward.py
-@@ -5,6 +5,12 @@ import numpy as np
- 
- from forge import flags
- 
-+# flags.DEFINE_boolean(
-+#     "model_with_dict",
-+#     True,
-+#     "Makes model output predictions in dictionary instead of directly."
-+# )
-+
- class PerceptronNN(nn.Module):
-     def __init__(self, input_size, num_labels):
-         super(PerceptronNN, self).__init__()
-@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-+        self.softmax = nn.Softmax(dim=1)
- 
-     def forward(self, x):
-         # Forward pass through the network
-@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-         x = F.relu(self.fc2(x))
-         x = F.relu(self.fc3(x))
-         x = self.fc4(x)  # No activation, this will be included in the loss function
-+        x = self.softmax(x)
-         return x
- 
- def load(config):
-@@ -29,4 +37,4 @@ def load(config):
-     
-     mlp = PerceptronNN(n_features,2)
-     
--    return mlp
-\ No newline at end of file
-+    return mlp, "feedforward"
-\ No newline at end of file
-diff --git a/checkpoints/feedforward/1/flags.json b/checkpoints/feedforward/1/flags.json
-index 1d000c3..889a6ea 100644
---- a/checkpoints/feedforward/1/flags.json
-+++ b/checkpoints/feedforward/1/flags.json
-@@ -1,9 +1,15 @@
- {
-     "batch_size": 100,
-+    "beta1": 0.9,
-+    "beta2": 0.999,
-+    "cross_validate": false,
-     "data_config": "penn_dataset.py",
-+    "git_commit": "7416bf730b356aabfe0df644240e40948a8196bb",
-     "include_coords": false,
-     "input_size": 39,
--    "learning_rate": 1e-05,
-+    "learning_rate": 0.0001,
-+    "log_train_values": true,
-+    "log_val_test": true,
-     "model_config": "basic_feedforward.py",
-     "n_repeats": 1,
-     "report_loss_every": 50,
-@@ -11,7 +17,10 @@
-     "results_dir": "checkpoints",
-     "resume": false,
-     "run_name": "feedforward",
-+    "save_check_points": 50,
-+    "save_test_predictions": false,
-     "split_seed": 1,
--    "train_epochs": 20,
-+    "total_evaluations": 100,
-+    "train_epochs": 100,
-     "train_split": 0.8
- }
-\ No newline at end of file
-diff --git a/checkpoints/feedforward/1/git_diff.txt b/checkpoints/feedforward/1/git_diff.txt
-index 7b37e6f..ec23707 100644
---- a/checkpoints/feedforward/1/git_diff.txt
-+++ b/checkpoints/feedforward/1/git_diff.txt
-@@ -1 +1,873 @@
--Mon Mar 4 11:45:48 PST 2024
-+Mon Mar 4 16:34:02 PST 2024
-+diff --git a/.DS_Store b/.DS_Store
-+index e2836a8..7e3fa32 100644
-+Binary files a/.DS_Store and b/.DS_Store differ
-+diff --git a/.ipynb_checkpoints/basic_feedforward-checkpoint.py b/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-+index 688c282..0c4bcd1 100644
-+--- a/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-++++ b/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-+@@ -5,6 +5,12 @@ import numpy as np
-+ 
-+ from forge import flags
-+ 
-++flags.DEFINE_boolean(
-++    "model_with_dict",
-++    True,
-++    "Makes model output predictions in dictionary instead of directly."
-++)
-++
-+ class PerceptronNN(nn.Module):
-+     def __init__(self, input_size, num_labels):
-+         super(PerceptronNN, self).__init__()
-+@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-+         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-+         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-+         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-++        self.softmax = nn.Softmax(dim=1)
-+ 
-+     def forward(self, x):
-+         # Forward pass through the network
-+@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-+         x = F.relu(self.fc2(x))
-+         x = F.relu(self.fc3(x))
-+         x = self.fc4(x)  # No activation, this will be included in the loss function
-++        x = self.softmax(x)
-+         return x
-+ 
-+ def load(config):
-+@@ -29,4 +37,4 @@ def load(config):
-+     
-+     mlp = PerceptronNN(n_features,2)
-+     
-+-    return mlp
-+\ No newline at end of file
-++    return mlp, "feedforward"
-+\ No newline at end of file
-+diff --git a/__pycache__/basic_feedforward.cpython-39.pyc b/__pycache__/basic_feedforward.cpython-39.pyc
-+index f541140..5ad96de 100644
-+Binary files a/__pycache__/basic_feedforward.cpython-39.pyc and b/__pycache__/basic_feedforward.cpython-39.pyc differ
-+diff --git a/__pycache__/penn_dataset.cpython-39.pyc b/__pycache__/penn_dataset.cpython-39.pyc
-+index 0d7a4de..19121eb 100644
-+Binary files a/__pycache__/penn_dataset.cpython-39.pyc and b/__pycache__/penn_dataset.cpython-39.pyc differ
-+diff --git a/basic_feedforward.py b/basic_feedforward.py
-+index 688c282..3a65525 100644
-+--- a/basic_feedforward.py
-++++ b/basic_feedforward.py
-+@@ -5,6 +5,12 @@ import numpy as np
-+ 
-+ from forge import flags
-+ 
-++# flags.DEFINE_boolean(
-++#     "model_with_dict",
-++#     True,
-++#     "Makes model output predictions in dictionary instead of directly."
-++# )
-++
-+ class PerceptronNN(nn.Module):
-+     def __init__(self, input_size, num_labels):
-+         super(PerceptronNN, self).__init__()
-+@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-+         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-+         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-+         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-++        self.softmax = nn.Softmax(dim=1)
-+ 
-+     def forward(self, x):
-+         # Forward pass through the network
-+@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-+         x = F.relu(self.fc2(x))
-+         x = F.relu(self.fc3(x))
-+         x = self.fc4(x)  # No activation, this will be included in the loss function
-++        x = self.softmax(x)
-+         return x
-+ 
-+ def load(config):
-+@@ -29,4 +37,4 @@ def load(config):
-+     
-+     mlp = PerceptronNN(n_features,2)
-+     
-+-    return mlp
-+\ No newline at end of file
-++    return mlp, "feedforward"
-+\ No newline at end of file
-+diff --git a/checkpoints/feedforward/1/basic_feedforward.py b/checkpoints/feedforward/1/basic_feedforward.py
-+index 688c282..3a65525 100644
-+--- a/checkpoints/feedforward/1/basic_feedforward.py
-++++ b/checkpoints/feedforward/1/basic_feedforward.py
-+@@ -5,6 +5,12 @@ import numpy as np
-+ 
-+ from forge import flags
-+ 
-++# flags.DEFINE_boolean(
-++#     "model_with_dict",
-++#     True,
-++#     "Makes model output predictions in dictionary instead of directly."
-++# )
-++
-+ class PerceptronNN(nn.Module):
-+     def __init__(self, input_size, num_labels):
-+         super(PerceptronNN, self).__init__()
-+@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-+         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-+         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-+         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-++        self.softmax = nn.Softmax(dim=1)
-+ 
-+     def forward(self, x):
-+         # Forward pass through the network
-+@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-+         x = F.relu(self.fc2(x))
-+         x = F.relu(self.fc3(x))
-+         x = self.fc4(x)  # No activation, this will be included in the loss function
-++        x = self.softmax(x)
-+         return x
-+ 
-+ def load(config):
-+@@ -29,4 +37,4 @@ def load(config):
-+     
-+     mlp = PerceptronNN(n_features,2)
-+     
-+-    return mlp
-+\ No newline at end of file
-++    return mlp, "feedforward"
-+\ No newline at end of file
-+diff --git a/checkpoints/feedforward/1/flags.json b/checkpoints/feedforward/1/flags.json
-+index 1d000c3..889a6ea 100644
-+--- a/checkpoints/feedforward/1/flags.json
-++++ b/checkpoints/feedforward/1/flags.json
-+@@ -1,9 +1,15 @@
-+ {
-+     "batch_size": 100,
-++    "beta1": 0.9,
-++    "beta2": 0.999,
-++    "cross_validate": false,
-+     "data_config": "penn_dataset.py",
-++    "git_commit": "7416bf730b356aabfe0df644240e40948a8196bb",
-+     "include_coords": false,
-+     "input_size": 39,
-+-    "learning_rate": 1e-05,
-++    "learning_rate": 0.0001,
-++    "log_train_values": true,
-++    "log_val_test": true,
-+     "model_config": "basic_feedforward.py",
-+     "n_repeats": 1,
-+     "report_loss_every": 50,
-+@@ -11,7 +17,10 @@
-+     "results_dir": "checkpoints",
-+     "resume": false,
-+     "run_name": "feedforward",
-++    "save_check_points": 50,
-++    "save_test_predictions": false,
-+     "split_seed": 1,
-+-    "train_epochs": 20,
-++    "total_evaluations": 100,
-++    "train_epochs": 100,
-+     "train_split": 0.8
-+ }
-+\ No newline at end of file
-+diff --git a/checkpoints/feedforward/1/git_diff.txt b/checkpoints/feedforward/1/git_diff.txt
-+index 7b37e6f..5c561db 100644
-+--- a/checkpoints/feedforward/1/git_diff.txt
-++++ b/checkpoints/feedforward/1/git_diff.txt
-+@@ -1 +1 @@
-+-Mon Mar 4 11:45:48 PST 2024
-++Mon Mar 4 16:34:02 PST 2024
-+diff --git a/checkpoints/feedforward/1/penn_dataset.py b/checkpoints/feedforward/1/penn_dataset.py
-+index aa2f5a0..7f5a4fc 100644
-+--- a/checkpoints/feedforward/1/penn_dataset.py
-++++ b/checkpoints/feedforward/1/penn_dataset.py
-+@@ -15,6 +15,7 @@ from forge import flags
-+ # aspects of data managmement
-+ flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
-+ flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-++flags.DEFINE_boolean("cross_validate",False,"Do K-fold cross-validation")
-+ 
-+ # Job management
-+ # flags.DEFINE_integer("batch size",5,"training batch size")
-+@@ -109,15 +110,15 @@ def load(config):
-+         
-+         # set up training DataLoader
-+         train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, n_train),num_workers=0,shuffle = True)
-++        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
-+ 
-+         # set up test DataLoader
-+         test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, n_test),num_workers=0,shuffle = True)
-++        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
-+ 
-+         # set up val DataLoader
-+         val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, n_val),num_workers=0,shuffle = True)
-++        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-+         
-+ 
-+         dataloaders = {'train':train_loader, 
-+@@ -125,8 +126,12 @@ def load(config):
-+                        'val':val_loader,
-+                        'train_inds':train_ind,
-+                        'test_inds':test_ind,
-+-                       'n_val':n_val
-++                       'n_val':n_val,
-++                       'test_headings':list(HEADINGS[test_ind])
-+                       }
-+         kf_dataloaders.append(dataloaders)
-+ 
-++        if not config.cross_validate:
-++        	break
-++
-+     return kf_dataloaders
-+diff --git a/penn_dataset.py b/penn_dataset.py
-+index aa2f5a0..7f5a4fc 100644
-+--- a/penn_dataset.py
-++++ b/penn_dataset.py
-+@@ -15,6 +15,7 @@ from forge import flags
-+ # aspects of data managmement
-+ flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
-+ flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-++flags.DEFINE_boolean("cross_validate",False,"Do K-fold cross-validation")
-+ 
-+ # Job management
-+ # flags.DEFINE_integer("batch size",5,"training batch size")
-+@@ -109,15 +110,15 @@ def load(config):
-+         
-+         # set up training DataLoader
-+         train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, n_train),num_workers=0,shuffle = True)
-++        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
-+ 
-+         # set up test DataLoader
-+         test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, n_test),num_workers=0,shuffle = True)
-++        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
-+ 
-+         # set up val DataLoader
-+         val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, n_val),num_workers=0,shuffle = True)
-++        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-+         
-+ 
-+         dataloaders = {'train':train_loader, 
-+@@ -125,8 +126,12 @@ def load(config):
-+                        'val':val_loader,
-+                        'train_inds':train_ind,
-+                        'test_inds':test_ind,
-+-                       'n_val':n_val
-++                       'n_val':n_val,
-++                       'test_headings':list(HEADINGS[test_ind])
-+                       }
-+         kf_dataloaders.append(dataloaders)
-+ 
-++        if not config.cross_validate:
-++        	break
-++
-+     return kf_dataloaders
-+diff --git a/testing.ipynb b/testing.ipynb
-+index e5a167b..a928d8d 100644
-+--- a/testing.ipynb
-++++ b/testing.ipynb
-+@@ -2,7 +2,7 @@
-+  "cells": [
-+   {
-+    "cell_type": "code",
-+-   "execution_count": 1,
-++   "execution_count": 2,
-+    "id": "4dee7ff1-01a4-4038-b493-9729ff3693f7",
-+    "metadata": {},
-+    "outputs": [],
-+@@ -23,19 +23,19 @@
-+   },
-+   {
-+    "cell_type": "code",
-+-   "execution_count": 2,
-++   "execution_count": 3,
-+    "id": "cad0fdc8-5c35-4610-bba3-b71e60dc1b98",
-+    "metadata": {},
-+    "outputs": [],
-+    "source": [
-+-    "flags.DEFINE_integer(\"batch_size\", 100, \"Mini-batch size.\")\n",
-++    "flags.DEFINE_integer(\"batch_size\", 10, \"Mini-batch size.\")\n",
-+     "\n",
-+     "flags.DEFINE_integer(\"input_size\",39,\"Input shape to model\")"
-+    ]
-+   },
-+   {
-+    "cell_type": "code",
-+-   "execution_count": 3,
-++   "execution_count": 4,
-+    "id": "ce1b936b-8a7c-426e-a3aa-3c1c38f645de",
-+    "metadata": {},
-+    "outputs": [
-+@@ -54,8 +54,8 @@
-+   },
-+   {
-+    "cell_type": "code",
-+-   "execution_count": 9,
-+-   "id": "e862b7e2-57f5-44bf-bcf1-a91160ba66cc",
-++   "execution_count": 5,
-++   "id": "4469cddf-4dac-4468-be88-241d440401c3",
-+    "metadata": {},
-+    "outputs": [
-+     {
-+@@ -67,35 +67,89 @@
-+     }
-+    ],
-+    "source": [
-+-    "model = fet.load(\"basic_feedforward.py\",config)"
-++    "model,modelname = fet.load(\"basic_feedforward.py\",config)"
-+    ]
-+   },
-+   {
-+    "cell_type": "code",
-+-   "execution_count": 10,
-+-   "id": "07e0b160-d5d1-4e54-b4a7-ccaf2224598a",
-++   "execution_count": 17,
-++   "id": "7c9a9fe9-f5e8-456a-b964-4be13027725b",
-+    "metadata": {},
-+    "outputs": [
-+     {
-+      "data": {
-+       "text/plain": [
-+-       "PerceptronNN(\n",
-+-       "  (fc1): Linear(in_features=39, out_features=128, bias=True)\n",
-+-       "  (fc2): Linear(in_features=128, out_features=64, bias=True)\n",
-+-       "  (fc3): Linear(in_features=64, out_features=64, bias=True)\n",
-+-       "  (fc4): Linear(in_features=64, out_features=2, bias=True)\n",
-+-       ")"
-++       "['aaa0060', 'aaa0061', 'aaa0069', 'aaa_0059']"
-+       ]
-+      },
-+-     "execution_count": 10,
-++     "execution_count": 17,
-+      "metadata": {},
-+      "output_type": "execute_result"
-+     }
-+    ],
-+    "source": [
-+-    "model"
-++    "loaddat[0]['test_headings']"
-++   ]
-++  },
-++  {
-++   "cell_type": "code",
-++   "execution_count": 19,
-++   "id": "e862b7e2-57f5-44bf-bcf1-a91160ba66cc",
-++   "metadata": {},
-++   "outputs": [
-++    {
-++     "name": "stdout",
-++     "output_type": "stream",
-++     "text": [
-++      "Keys: ['cross_entropy', 'time']\n"
-++     ]
-++    }
-++   ],
-++   "source": [
-++    "import h5py\n",
-++    "\n",
-++    "file_path = \"./checkpoints/feedforward/2/data_fold1/results_dict.h5\"\n",
-++    "# Replace 'your_file.h5' with the actual path to your file\n",
-++    "f =  h5py.File(file_path, 'r') \n",
-++    "\n",
-++    "    # Get information about the data stored in the file\n",
-++    "print(\"Keys:\", list(f.keys()))  # List the top-level datasets and groups\n",
-++    "\n",
-++    "    # # Access a dataset by its name\n",
-++    "    # dataset_name = \"your_dataset_name\"\n",
-++    "    # if dataset_name in f:\n",
-++    "    #     dataset = f[dataset_name]\n",
-++    "    #     print(\"Dataset shape:\", dataset.shape)\n",
-++    "    #     print(\"Dataset dtype:\", dataset.dtype)\n",
-++    "\n",
-++    "    #     # Access the data as a NumPy array\n",
-++    "    #     data = dataset[:]  # Read the entire dataset\n",
-++    "\n",
-++    "    #     # You can now work with the data as needed, for example:\n",
-++    "    #     # Perform calculations, visualizations, etc.\n",
-++    "    # else:\n",
-++    "    #     print(f\"Dataset '{dataset_name}' not found in the file.\")"
-+    ]
-+   },
-++  {
-++   "cell_type": "code",
-++   "execution_count": 13,
-++   "id": "07e0b160-d5d1-4e54-b4a7-ccaf2224598a",
-++   "metadata": {},
-++   "outputs": [
-++    {
-++     "data": {
-++      "text/plain": [
-++       "<generator object Module.parameters at 0x3007207b0>"
-++      ]
-++     },
-++     "execution_count": 13,
-++     "metadata": {},
-++     "output_type": "execute_result"
-++    }
-++   ],
-++   "source": []
-++  },
-+   {
-+    "cell_type": "code",
-+    "execution_count": null,
-+diff --git a/train.py b/train.py
-+index c266102..516bfa9 100644
-+--- a/train.py
-++++ b/train.py
-+@@ -1,49 +1,440 @@
-+ from os import path as osp
-++import os
-++import numpy as np
-++import time
-+ 
-+ import torch
-++import torch.nn as nn
-+ import torch.nn.functional as F
-+ import torch.optim as optim
-+-
-+-import numpy as np
-++from torch.utils.tensorboard import SummaryWriter
-+ 
-+ import forge
-+ from forge import flags
-+ import forge.experiment_tools as fet
-+ 
-++from train_tools import (
-++	log_tensorboard,
-++	parse_reports,
-++	parse_reports_cpu,
-++	print_reports,
-++	load_checkpoint,
-++	save_checkpoint,
-++	nested_to,
-++	param_count,
-++)
-++
-++from copy import deepcopy
-++from attrdict import AttrDict
-++import deepdish as dd
-++from tqdm import tqdm
-++
-++# For reproducibility while researching, but might affect speed!
-++torch.backends.cudnn.deterministic = True
-++torch.backends.cudnn.benchmark = False
-++torch.manual_seed(0)
-++
-+ 
-+ # Job config
-+ flags.DEFINE_string('data_config', 'penn_dataset.py',
-+-                    'Path to a data config file.')
-++					'Path to a data config file.')
-+ flags.DEFINE_string('model_config', 'basic_feedforward.py',
-+-                    'Path to a model config file.')
-++					'Path to a model config file.')
-+ flags.DEFINE_string('results_dir', 'checkpoints',
-+-                    'Top directory for all experimental results.')
-++					'Top directory for all experimental results.')
-+ flags.DEFINE_string('run_name', 'feedforward',
-+-                    'Name of this job and name of results folder.')
-++					'Name of this job and name of results folder.')
-+ flags.DEFINE_boolean('resume', False, 'Tries to resume a job if True.')
-+ 
-+ # Logging config
-+ flags.DEFINE_integer('report_loss_every', 50,
-+-                     'Number of iterations between reporting minibatch loss.')
-+-flags.DEFINE_integer('train_epochs', 20, 'Maximum number of training epochs.')
-++					 'Number of iterations between reporting minibatch loss.')
-++flags.DEFINE_integer('train_epochs', 100, 'Maximum number of training epochs.')
-++flags.DEFINE_integer(
-++	"save_check_points",
-++	50,
-++	"frequency with which to save checkpoints, in number of epoches.",
-++)
-++flags.DEFINE_boolean("log_train_values", True, "Logs train values if True.")
-++flags.DEFINE_integer(
-++	"total_evaluations",
-++	100,
-++	"Maximum number of evaluations on test and validation data during training.",
-++)
-++flags.DEFINE_boolean(
-++	"save_test_predictions",
-++	False,
-++	"Makes and saves test predictions on one or more test sets (e.g. 5-step and 100-step predictions) at the end of training.",
-++)
-++flags.DEFINE_boolean(
-++    "log_val_test", True, "Turns off computation of validation and test errors."
-++)
-+ 
-+ # Experiment config
-+ flags.DEFINE_integer('batch_size', 100, 'Mini-batch size.')
-+-flags.DEFINE_float('learning_rate', 1e-5, 'SGD learning rate.')
-++flags.DEFINE_float("learning_rate", 1e-4, "Adam learning rate.")
-++flags.DEFINE_float("beta1", 0.9, "Adam Beta 1 parameter")
-++flags.DEFINE_float("beta2", 0.999, "Adam Beta 2 parameter")
-+ 
-+ # Specific config options
-+ flags.DEFINE_integer("input_size",39,"Input shape to model")
-+ 
-++#########################################################################################
-++
-++def evaluate(model, loader, device,fold = 0,headings = [],loss_func = nn.CrossEntropyLoss()):
-++	reports = None
-++	for data in loader:
-++		labels = data['label']
-++		inputs = nested_to(data['data'],device,torch.float32)
-++		
-++		labels_tensor = torch.zeros((len(labels), 2))
-++		for i, label in enumerate(labels):
-++			labels_tensor[i, label] = 1
-++
-++		model_output = model(inputs) # evaluate model
-++
-++		loss = loss_func(model_output, labels_tensor) # compute loss
-++		outputs = AttrDict({"loss": loss, "prediction": model_output,'data_fold':fold})
-++		outputs.reports = AttrDict({"cross_entropy": loss})
-++
-++		if reports is None:
-++			reports = {k: v.detach().clone().cpu() for k, v in outputs.reports.items()}
-++		else:
-++			for k, v in outputs.reports.items():
-++				reports[k] += v.detach().clone().cpu()
-++
-++	for k, v in reports.items():
-++		reports[k] = v / len(
-++			loader
-++		)  # SZ: note this can be slightly incorrect if mini-batch sizes vary (if batch_size doesn't divide train_size), but approximately correct.
-++
-++	# reports['test_headings'] = np.array(headings)
-++
-++	return reports
-++
-++def main():
-++
-++	config = forge.config()
-++
-++	# Set device
-++	if torch.cuda.is_available():
-++		device = f"cuda:{config.device}"
-++		torch.cuda.set_device(device)
-++	else:
-++		device = "cpu" # can change this to MPS on M1 Macs
-++
-++	# Load data
-++	data_name = "penn_data"
-++	kfold_loaders = fet.load(config.data_config, config)
-++
-++	# Load model
-++	model,model_name = fet.load(config.model_config, config)
-++	model = model.to(device)
-++
-++	loss_func = nn.CrossEntropyLoss()
-++
-++	# Prepare environment
-++	params_in_run_name = [
-++		("batch_size", "bs"),
-++		("learning_rate", "lr"),
-++		("n_train", "ntrain")
-++	]
-++
-++	run_name = ""  # config.run_name
-++	for config_param in params_in_run_name:
-++		attr = config_param[0]
-++		abbrev = config_param[1]
-++
-++		if hasattr(config, attr):
-++			run_name += abbrev
-++			run_name += str(getattr(config, attr))
-++			run_name += "_"
-++
-++	results_folder_name = osp.join(
-++		data_name,
-++		model_name,
-++		config.run_name,
-++		run_name,
-++	)
-++
-++	# Prepare environment
-++	logdir = osp.join(config.results_dir, config.run_name)
-++	logdir, resume_checkpoint = fet.init_checkpoint(
-++		logdir, config.data_config, config.model_config, config.resume)
-++
-++	print("Checkpoint directory:",logdir)
-++
-++	# Print flags
-++	fet.print_flags()
-++	# Print model info
-++	print(model)
-++
-++	# Setup optimizer
-++	model_params = model.parameters()
-++	opt_learning_rate = config.learning_rate
-++	model_opt = torch.optim.Adam(
-++		model_params, lr=opt_learning_rate, betas=(config.beta1, config.beta2)
-++	)
-++	print("Model Optimizer:")
-++	print(model_opt)
-++
-++	# Try to restore model and optimizer from checkpoint
-++	if resume_checkpoint is not None:
-++		start_epoch = load_checkpoint(resume_checkpoint, model, model_opt)
-++	else:
-++		start_epoch = 1
-++
-++	n_folds = len(kfold_loaders)
-++	print("Doing {}-fold cross-validation.".format(n_folds))
-++
-++	# KFOLD TRAINING LOOP
-++	for k,loader_k in enumerate(kfold_loaders): # loop over data splits
-++
-++		print("Training fold {}...".format(k+1))
-++
-++		# load the training data
-++		train_loader = loader_k["train"]
-++		n_train = len(train_loader.dataset)
-++		train_batch_size = train_loader.batch_size
-++
-++		# load testing, validation
-++		test_loader = loader_k["test"]
-++		n_test = len(test_loader.dataset)
-++		val_loader = loader_k["val"]
-++		n_val = len(val_loader.dataset)
-++		
-++		# create folder for this data split
-++		fold_dir = osp.join(logdir,"data_fold{}".format(k+1))
-++		fold_dir_exists = osp.exists(fold_dir)
-++		if not fold_dir_exists:
-++			if config.resume:
-++				raise ValueError("Can't resume when the checkpoint/fold dir '{}' doesn't exist.".format(fold_dir))
-++			else:
-++				os.makedirs(fold_dir)
-++		checkpoint_name = osp.join(fold_dir, 'model_fold{}.ckpt'.format(k+1))
-++
-++		# keep track of which data is test data for a given Kfold data split
-++		test_headings = loader_k['test_headings']
-++		headingsFile = osp.join(fold_dir,"test_headings.txt")
-++		with open(headingsFile,'w') as headfile:
-++			for heading in test_headings:
-++				headfile.write(heading+'\n')
-++
-++		# print(checkpoint_name)
-++
-++		train_iter = (start_epoch - 1) * (
-++		len(train_loader.dataset) // train_batch_size
-++		) + 1
-++
-++		print("Starting training at epoch = {}, iter = {}".format(start_epoch, train_iter))
-++
-++		# Setup tensorboard writing
-++		summary_writer = SummaryWriter(logdir)
-++
-++		train_reports = []
-++		report_all = {}
-++		report_all_val = {}
-++
-++		# Saving model at epoch 0 before training
-++		print("saving model at epoch 0 before training ... ")
-++		save_checkpoint(checkpoint_name, 0, model, model_opt, loss=0.0)
-++		print("finished saving model at epoch 0 before training")
-++
-++		num_params = param_count(model)
-++		print(f"Number of model parameters: {num_params}")
-++
-++		# Training
-++		start_t = time.time()
-++
-++		total_train_iters = len(train_loader) * config.train_epochs
-++		iters_per_eval = max(1, int(total_train_iters / config.total_evaluations))
-++		# print('batch',train_batch_size)
-++		# print('ntrain',n_train)
-++		# assert (
-++		# 	n_train % min(train_batch_size, n_train) == 0
-++		# ), "Batch size doesn't divide dataset size. Can be inaccurate for loss computation (see below)."
-++
-++		training_failed = False
-++		best_val_loss_so_far = 1e7
-++
-++		for epoch in tqdm(range(start_epoch, config.train_epochs + 1)):
-++			model.train()
-++
-++			for batch_idx, data_dict in enumerate(train_loader): # Loop over batched data
-++
-++				labels = data_dict['label']
-++				data = data_dict['data']
-++
-++				# send data to device
-++				data = nested_to(data,device,torch.float32)
-++				# One-hot encode the data labels
-++				labels_tensor = torch.zeros((len(labels), 2))
-++				for i, label in enumerate(labels):
-++					labels_tensor[i, label] = 1
-++
-++				model_output = model(data) # evaluate model
-++
-++				loss = loss_func(model_output, labels_tensor) # compute loss
-++				outputs = AttrDict({"loss": loss, "prediction": model_output})
-++				outputs.reports = AttrDict({"cross_entropy": loss})
-++
-++				if torch.isnan(outputs.loss): # check for failure in training
-++					if not training_failed:
-++						epoch_of_nan = epoch
-++					if (epoch > epoch_of_nan + 1) and training_failed:
-++						raise ValueError("Loss Nan-ed.")
-++					training_failed = True
-++
-++				model_opt.zero_grad()
-++				outputs.loss.backward(retain_graph=False)
-++
-++				model_opt.step() # move optimizer forward
-++
-++				train_reports.append(parse_reports_cpu(outputs.reports))
-++
-++				if config.log_train_values:
-++					reports = parse_reports(outputs.reports)
-++					if batch_idx % config.report_loss_every == 0:
-++						log_tensorboard(summary_writer, train_iter, reports, "train/")
-++						print_reports(
-++							reports,
-++							start_t,
-++							epoch,
-++							batch_idx,
-++							len(train_loader.dataset) // train_batch_size,
-++							prefix="train",
-++						)
-++						log_tensorboard(
-++							summary_writer,
-++							train_iter,
-++							{"lr": model_opt.param_groups[0]["lr"]},
-++							"hyperparams/",
-++						)
-++				# Logging and evaluation
-++				if (
-++					train_iter % iters_per_eval == 0 or (train_iter == total_train_iters)
-++				) and config.log_val_test:  # batch_idx % config.evaluate_every == 0:
-++					model.eval()
-++					with torch.no_grad():
-++						reports = evaluate(model, test_loader, device,fold = k,headings = loader_k['test_headings'])
-++						# print("REPORTS",reports)
-++						reports = parse_reports(reports)
-++						reports["time"] = time.time() - start_t
-++						if report_all == {}:
-++							report_all = deepcopy(reports)
-++
-++							for d in reports.keys():
-++								report_all[d] = [report_all[d]]
-++						else:
-++							for d in reports.keys():
-++								report_all[d].append(reports[d])
-++
-++						log_tensorboard(summary_writer, train_iter, reports, "test/")
-++						print_reports(
-++							reports,
-++							start_t,
-++							epoch,
-++							batch_idx,
-++							len(train_loader.dataset) // config.batch_size,
-++							prefix="test",
-++						)
-++
-++						# repeat for validation data
-++						reports = evaluate(model, val_loader, device,fold = k,headings = loader_k['test_headings'])
-++						reports = parse_reports(reports)
-++						reports["time"] = time.time() - start_t
-++						if report_all_val == {}:
-++							report_all_val = deepcopy(reports)
-++
-++							for d in reports.keys():
-++								report_all_val[d] = [report_all_val[d]]
-++						else:
-++							for d in reports.keys():
-++								report_all_val[d].append(reports[d])
-++
-++						log_tensorboard(summary_writer, train_iter, reports, "val/")
-++						print_reports(
-++							reports,
-++							start_t,
-++							epoch,
-++							batch_idx,
-++							len(train_loader.dataset) // config.batch_size,
-++							prefix="val",
-++						)
-++
-++						if report_all_val["cross_entropy"][-1] < best_val_loss_so_far:
-++							save_checkpoint(
-++								checkpoint_name,
-++								f"early_stop",
-++								model,
-++								model_opt,
-++								loss=outputs.loss,
-++							)
-++							best_val_loss_so_far = report_all_val["cross_entropy"][-1]
-++
-++					model.train()
-++
-++				train_iter += 1
-++
-++			if epoch % config.save_check_points == 0:
-++				save_checkpoint(
-++					checkpoint_name, train_iter, model, model_opt, loss=outputs.loss
-++				)
-++
-++		dd.io.save(fold_dir + "/results_dict_train.h5", train_reports)
-++		dd.io.save(fold_dir + "/results_dict.h5", report_all)
-++		dd.io.save(fold_dir + "/results_dict_val.h5", report_all_val)
-++
-++	# always save final model
-++	save_checkpoint(checkpoint_name, train_iter, model, model_opt, loss=outputs.loss)
-++
-++	
-++	if config.save_test_predictions:
-++		pass
-++		# print("Starting to make model predictions on test sets for *final model*.")
-++		# for chunk_len in [5, 100]:
-++		#     start_t_preds = time.time()
-++		#     data_config = SimpleNamespace(
-++		#         **{
-++		#             **config.__dict__["__flags"],
-++		#             **{"chunk_len": chunk_len, "batch_size": 500},
-++		#         }
-++		#     )
-++		#     dataloaders, data_name = fet.load(config.data_config, config=data_config)
-++		#     test_loader_preds = dataloaders["test"]
-++
-++		#     torch.cuda.empty_cache()
-++		#     with torch.no_grad():
-++		#         preds = []
-++		#         true = []
-++		#         num_datapoints = 0
-++		#         for idx, d in enumerate(test_loader_preds):
-++		#             true.append(d[-1])
-++		#             d = nested_to(d, device, torch.float32)
-++		#             outputs = model(d)
-++
-++		#             pred_zs = outputs.prediction
-++		#             preds.append(pred_zs)
-++
-++		#             num_datapoints += len(pred_zs)
-++
-++		#             if num_datapoints >= 2000:
-++		#                 break
-+ 
-+-config = forge.config()
-++		#         preds = torch.cat(preds, dim=0).cpu()
-++		#         true = torch.cat(true, dim=0).cpu()
-+ 
-+-# Prepare environment
-+-logdir = osp.join(config.results_dir, config.run_name)
-+-logdir, resume_checkpoint = fet.init_checkpoint(
-+-    logdir, config.data_config, config.model_config, config.resume)
-+-checkpoint_name = osp.join(logdir, 'model.ckpt')
-++		#         save_dir = osp.join(logdir, f"traj_preds_{chunk_len}_steps_2k_test.pt")
-++		#         torch.save(preds, save_dir)
-+ 
-++		#         save_dir = osp.join(logdir, f"traj_true_{chunk_len}_steps_2k_test.pt")
-++		#         torch.save(true, save_dir)
-+ 
-+-print(logdir)
-++		#         print(
-++		#             f"Completed making test predictions for chunk_len = {chunk_len} in {time.time() - start_t_preds:.2f} seconds."
-++		#         )	
-++		
-+ 
-++if __name__ == "__main__":
-++	main()
-+ 
-diff --git a/checkpoints/feedforward/1/penn_dataset.py b/checkpoints/feedforward/1/penn_dataset.py
-index aa2f5a0..7f5a4fc 100644
---- a/checkpoints/feedforward/1/penn_dataset.py
-+++ b/checkpoints/feedforward/1/penn_dataset.py
-@@ -15,6 +15,7 @@ from forge import flags
- # aspects of data managmement
- flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
- flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-+flags.DEFINE_boolean("cross_validate",False,"Do K-fold cross-validation")
- 
- # Job management
- # flags.DEFINE_integer("batch size",5,"training batch size")
-@@ -109,15 +110,15 @@ def load(config):
-         
-         # set up training DataLoader
-         train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, n_train),num_workers=0,shuffle = True)
-+        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
- 
-         # set up test DataLoader
-         test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, n_test),num_workers=0,shuffle = True)
-+        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
- 
-         # set up val DataLoader
-         val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, n_val),num_workers=0,shuffle = True)
-+        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-         
- 
-         dataloaders = {'train':train_loader, 
-@@ -125,8 +126,12 @@ def load(config):
-                        'val':val_loader,
-                        'train_inds':train_ind,
-                        'test_inds':test_ind,
--                       'n_val':n_val
-+                       'n_val':n_val,
-+                       'test_headings':list(HEADINGS[test_ind])
-                       }
-         kf_dataloaders.append(dataloaders)
- 
-+        if not config.cross_validate:
-+        	break
-+
-     return kf_dataloaders
-diff --git a/georgehulsey_2024.pdf b/georgehulsey_2024.pdf
-deleted file mode 100644
-index 1ab17f6..0000000
-Binary files a/georgehulsey_2024.pdf and /dev/null differ
-diff --git a/penn_dataset.py b/penn_dataset.py
-index aa2f5a0..7f5a4fc 100644
---- a/penn_dataset.py
-+++ b/penn_dataset.py
-@@ -15,6 +15,7 @@ from forge import flags
- # aspects of data managmement
- flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
- flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-+flags.DEFINE_boolean("cross_validate",False,"Do K-fold cross-validation")
- 
- # Job management
- # flags.DEFINE_integer("batch size",5,"training batch size")
-@@ -109,15 +110,15 @@ def load(config):
-         
-         # set up training DataLoader
-         train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, n_train),num_workers=0,shuffle = True)
-+        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
- 
-         # set up test DataLoader
-         test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, n_test),num_workers=0,shuffle = True)
-+        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
- 
-         # set up val DataLoader
-         val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, n_val),num_workers=0,shuffle = True)
-+        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-         
- 
-         dataloaders = {'train':train_loader, 
-@@ -125,8 +126,12 @@ def load(config):
-                        'val':val_loader,
-                        'train_inds':train_ind,
-                        'test_inds':test_ind,
--                       'n_val':n_val
-+                       'n_val':n_val,
-+                       'test_headings':list(HEADINGS[test_ind])
-                       }
-         kf_dataloaders.append(dataloaders)
- 
-+        if not config.cross_validate:
-+        	break
-+
-     return kf_dataloaders
-diff --git a/testing.ipynb b/testing.ipynb
-index e5a167b..0110538 100644
---- a/testing.ipynb
-+++ b/testing.ipynb
-@@ -2,7 +2,7 @@
-  "cells": [
-   {
-    "cell_type": "code",
--   "execution_count": 1,
-+   "execution_count": 4,
-    "id": "4dee7ff1-01a4-4038-b493-9729ff3693f7",
-    "metadata": {},
-    "outputs": [],
-@@ -23,7 +23,7 @@
-   },
-   {
-    "cell_type": "code",
--   "execution_count": 2,
-+   "execution_count": 6,
-    "id": "cad0fdc8-5c35-4610-bba3-b71e60dc1b98",
-    "metadata": {},
-    "outputs": [],
-@@ -35,7 +35,7 @@
-   },
-   {
-    "cell_type": "code",
--   "execution_count": 3,
-+   "execution_count": 7,
-    "id": "ce1b936b-8a7c-426e-a3aa-3c1c38f645de",
-    "metadata": {},
-    "outputs": [
-@@ -54,8 +54,8 @@
-   },
-   {
-    "cell_type": "code",
--   "execution_count": 9,
--   "id": "e862b7e2-57f5-44bf-bcf1-a91160ba66cc",
-+   "execution_count": 5,
-+   "id": "4469cddf-4dac-4468-be88-241d440401c3",
-    "metadata": {},
-    "outputs": [
-     {
-@@ -67,35 +67,98 @@
-     }
-    ],
-    "source": [
--    "model = fet.load(\"basic_feedforward.py\",config)"
-+    "model,modelname = fet.load(\"basic_feedforward.py\",config)"
-    ]
-   },
-   {
-    "cell_type": "code",
--   "execution_count": 10,
--   "id": "07e0b160-d5d1-4e54-b4a7-ccaf2224598a",
-+   "execution_count": 13,
-+   "id": "7c9a9fe9-f5e8-456a-b964-4be13027725b",
-    "metadata": {},
-    "outputs": [
-     {
-      "data": {
-       "text/plain": [
--       "PerceptronNN(\n",
--       "  (fc1): Linear(in_features=39, out_features=128, bias=True)\n",
--       "  (fc2): Linear(in_features=128, out_features=64, bias=True)\n",
--       "  (fc3): Linear(in_features=64, out_features=64, bias=True)\n",
--       "  (fc4): Linear(in_features=64, out_features=2, bias=True)\n",
--       ")"
-+       "array([114170,    904])"
-       ]
-      },
--     "execution_count": 10,
-+     "execution_count": 13,
-      "metadata": {},
-      "output_type": "execute_result"
-     }
-    ],
-    "source": [
--    "model"
-+    "np.bincount(loaddat[0]['train'].dataset.all_labels)"
-    ]
-   },
-+  {
-+   "cell_type": "code",
-+   "execution_count": 1,
-+   "id": "e862b7e2-57f5-44bf-bcf1-a91160ba66cc",
-+   "metadata": {},
-+   "outputs": [
-+    {
-+     "ename": "FileNotFoundError",
-+     "evalue": "[Errno 2] Unable to open file (unable to open file: name = './checkpoints/feedforward/2/data_fold1/results_dict.h5', errno = 2, error message = 'No such file or directory', flags = 0, o_flags = 0)",
-+     "output_type": "error",
-+     "traceback": [
-+      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
-+      "\u001b[0;31mFileNotFoundError\u001b[0m                         Traceback (most recent call last)",
-+      "Cell \u001b[0;32mIn[1], line 5\u001b[0m\n\u001b[1;32m      3\u001b[0m file_path \u001b[38;5;241m=\u001b[39m \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124m./checkpoints/feedforward/2/data_fold1/results_dict.h5\u001b[39m\u001b[38;5;124m\"\u001b[39m\n\u001b[1;32m      4\u001b[0m \u001b[38;5;66;03m# Replace 'your_file.h5' with the actual path to your file\u001b[39;00m\n\u001b[0;32m----> 5\u001b[0m f \u001b[38;5;241m=\u001b[39m  \u001b[43mh5py\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mFile\u001b[49m\u001b[43m(\u001b[49m\u001b[43mfile_path\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[38;5;124;43mr\u001b[39;49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[43m)\u001b[49m \n\u001b[1;32m      7\u001b[0m     \u001b[38;5;66;03m# Get information about the data stored in the file\u001b[39;00m\n\u001b[1;32m      8\u001b[0m \u001b[38;5;28mprint\u001b[39m(\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mKeys:\u001b[39m\u001b[38;5;124m\"\u001b[39m, \u001b[38;5;28mlist\u001b[39m(f\u001b[38;5;241m.\u001b[39mkeys()))\n",
-+      "File \u001b[0;32m/Applications/miniconda3/envs/lietransformer/lib/python3.9/site-packages/h5py/_hl/files.py:562\u001b[0m, in \u001b[0;36mFile.__init__\u001b[0;34m(self, name, mode, driver, libver, userblock_size, swmr, rdcc_nslots, rdcc_nbytes, rdcc_w0, track_order, fs_strategy, fs_persist, fs_threshold, fs_page_size, page_buf_size, min_meta_keep, min_raw_keep, locking, alignment_threshold, alignment_interval, meta_block_size, **kwds)\u001b[0m\n\u001b[1;32m    553\u001b[0m     fapl \u001b[38;5;241m=\u001b[39m make_fapl(driver, libver, rdcc_nslots, rdcc_nbytes, rdcc_w0,\n\u001b[1;32m    554\u001b[0m                      locking, page_buf_size, min_meta_keep, min_raw_keep,\n\u001b[1;32m    555\u001b[0m                      alignment_threshold\u001b[38;5;241m=\u001b[39malignment_threshold,\n\u001b[1;32m    556\u001b[0m                      alignment_interval\u001b[38;5;241m=\u001b[39malignment_interval,\n\u001b[1;32m    557\u001b[0m                      meta_block_size\u001b[38;5;241m=\u001b[39mmeta_block_size,\n\u001b[1;32m    558\u001b[0m                      \u001b[38;5;241m*\u001b[39m\u001b[38;5;241m*\u001b[39mkwds)\n\u001b[1;32m    559\u001b[0m     fcpl \u001b[38;5;241m=\u001b[39m make_fcpl(track_order\u001b[38;5;241m=\u001b[39mtrack_order, fs_strategy\u001b[38;5;241m=\u001b[39mfs_strategy,\n\u001b[1;32m    560\u001b[0m                      fs_persist\u001b[38;5;241m=\u001b[39mfs_persist, fs_threshold\u001b[38;5;241m=\u001b[39mfs_threshold,\n\u001b[1;32m    561\u001b[0m                      fs_page_size\u001b[38;5;241m=\u001b[39mfs_page_size)\n\u001b[0;32m--> 562\u001b[0m     fid \u001b[38;5;241m=\u001b[39m \u001b[43mmake_fid\u001b[49m\u001b[43m(\u001b[49m\u001b[43mname\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mmode\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43muserblock_size\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mfapl\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mfcpl\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mswmr\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43mswmr\u001b[49m\u001b[43m)\u001b[49m\n\u001b[1;32m    564\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;28misinstance\u001b[39m(libver, \u001b[38;5;28mtuple\u001b[39m):\n\u001b[1;32m    565\u001b[0m     \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_libver \u001b[38;5;241m=\u001b[39m libver\n",
-+      "File \u001b[0;32m/Applications/miniconda3/envs/lietransformer/lib/python3.9/site-packages/h5py/_hl/files.py:235\u001b[0m, in \u001b[0;36mmake_fid\u001b[0;34m(name, mode, userblock_size, fapl, fcpl, swmr)\u001b[0m\n\u001b[1;32m    233\u001b[0m     \u001b[38;5;28;01mif\u001b[39;00m swmr \u001b[38;5;129;01mand\u001b[39;00m swmr_support:\n\u001b[1;32m    234\u001b[0m         flags \u001b[38;5;241m|\u001b[39m\u001b[38;5;241m=\u001b[39m h5f\u001b[38;5;241m.\u001b[39mACC_SWMR_READ\n\u001b[0;32m--> 235\u001b[0m     fid \u001b[38;5;241m=\u001b[39m \u001b[43mh5f\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mopen\u001b[49m\u001b[43m(\u001b[49m\u001b[43mname\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mflags\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mfapl\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43mfapl\u001b[49m\u001b[43m)\u001b[49m\n\u001b[1;32m    236\u001b[0m \u001b[38;5;28;01melif\u001b[39;00m mode \u001b[38;5;241m==\u001b[39m \u001b[38;5;124m'\u001b[39m\u001b[38;5;124mr+\u001b[39m\u001b[38;5;124m'\u001b[39m:\n\u001b[1;32m    237\u001b[0m     fid \u001b[38;5;241m=\u001b[39m h5f\u001b[38;5;241m.\u001b[39mopen(name, h5f\u001b[38;5;241m.\u001b[39mACC_RDWR, fapl\u001b[38;5;241m=\u001b[39mfapl)\n",
-+      "File \u001b[0;32mh5py/_objects.pyx:54\u001b[0m, in \u001b[0;36mh5py._objects.with_phil.wrapper\u001b[0;34m()\u001b[0m\n",
-+      "File \u001b[0;32mh5py/_objects.pyx:55\u001b[0m, in \u001b[0;36mh5py._objects.with_phil.wrapper\u001b[0;34m()\u001b[0m\n",
-+      "File \u001b[0;32mh5py/h5f.pyx:102\u001b[0m, in \u001b[0;36mh5py.h5f.open\u001b[0;34m()\u001b[0m\n",
-+      "\u001b[0;31mFileNotFoundError\u001b[0m: [Errno 2] Unable to open file (unable to open file: name = './checkpoints/feedforward/2/data_fold1/results_dict.h5', errno = 2, error message = 'No such file or directory', flags = 0, o_flags = 0)"
-+     ]
-+    }
-+   ],
-+   "source": [
-+    "import h5py\n",
-+    "\n",
-+    "file_path = \"./checkpoints/feedforward/2/data_fold1/results_dict.h5\"\n",
-+    "# Replace 'your_file.h5' with the actual path to your file\n",
-+    "f =  h5py.File(file_path, 'r') \n",
-+    "\n",
-+    "    # Get information about the data stored in the file\n",
-+    "print(\"Keys:\", list(f.keys()))  # List the top-level datasets and groups\n",
-+    "\n",
-+    "    # # Access a dataset by its name\n",
-+    "    # dataset_name = \"your_dataset_name\"\n",
-+    "    # if dataset_name in f:\n",
-+    "    #     dataset = f[dataset_name]\n",
-+    "    #     print(\"Dataset shape:\", dataset.shape)\n",
-+    "    #     print(\"Dataset dtype:\", dataset.dtype)\n",
-+    "\n",
-+    "    #     # Access the data as a NumPy array\n",
-+    "    #     data = dataset[:]  # Read the entire dataset\n",
-+    "\n",
-+    "    #     # You can now work with the data as needed, for example:\n",
-+    "    #     # Perform calculations, visualizations, etc.\n",
-+    "    # else:\n",
-+    "    #     print(f\"Dataset '{dataset_name}' not found in the file.\")"
-+   ]
-+  },
-+  {
-+   "cell_type": "code",
-+   "execution_count": 13,
-+   "id": "07e0b160-d5d1-4e54-b4a7-ccaf2224598a",
-+   "metadata": {},
-+   "outputs": [
-+    {
-+     "data": {
-+      "text/plain": [
-+       "<generator object Module.parameters at 0x3007207b0>"
-+      ]
-+     },
-+     "execution_count": 13,
-+     "metadata": {},
-+     "output_type": "execute_result"
-+    }
-+   ],
-+   "source": []
-+  },
-   {
-    "cell_type": "code",
-    "execution_count": null,
-diff --git a/train.py b/train.py
-index c266102..e6d593e 100644
---- a/train.py
-+++ b/train.py
-@@ -1,49 +1,447 @@
- from os import path as osp
-+import os
-+import numpy as np
-+import time
- 
- import torch
-+import torch.nn as nn
- import torch.nn.functional as F
- import torch.optim as optim
--
--import numpy as np
-+from torch.utils.tensorboard import SummaryWriter
- 
- import forge
- from forge import flags
- import forge.experiment_tools as fet
- 
-+from train_tools import (
-+	log_tensorboard,
-+	parse_reports,
-+	parse_reports_cpu,
-+	print_reports,
-+	load_checkpoint,
-+	save_checkpoint,
-+	nested_to,
-+	param_count,
-+)
-+
-+from copy import deepcopy
-+from attrdict import AttrDict
-+import deepdish as dd
-+from tqdm import tqdm
-+
-+# For reproducibility while researching, but might affect speed!
-+torch.backends.cudnn.deterministic = True
-+torch.backends.cudnn.benchmark = False
-+torch.manual_seed(0)
-+
- 
- # Job config
- flags.DEFINE_string('data_config', 'penn_dataset.py',
--                    'Path to a data config file.')
-+					'Path to a data config file.')
- flags.DEFINE_string('model_config', 'basic_feedforward.py',
--                    'Path to a model config file.')
-+					'Path to a model config file.')
- flags.DEFINE_string('results_dir', 'checkpoints',
--                    'Top directory for all experimental results.')
-+					'Top directory for all experimental results.')
- flags.DEFINE_string('run_name', 'feedforward',
--                    'Name of this job and name of results folder.')
-+					'Name of this job and name of results folder.')
- flags.DEFINE_boolean('resume', False, 'Tries to resume a job if True.')
- 
- # Logging config
- flags.DEFINE_integer('report_loss_every', 50,
--                     'Number of iterations between reporting minibatch loss.')
--flags.DEFINE_integer('train_epochs', 20, 'Maximum number of training epochs.')
-+					 'Number of iterations between reporting minibatch loss.')
-+flags.DEFINE_integer('train_epochs', 100, 'Maximum number of training epochs.')
-+flags.DEFINE_integer(
-+	"save_check_points",
-+	50,
-+	"frequency with which to save checkpoints, in number of epoches.",
-+)
-+flags.DEFINE_boolean("log_train_values", True, "Logs train values if True.")
-+flags.DEFINE_integer(
-+	"total_evaluations",
-+	100,
-+	"Maximum number of evaluations on test and validation data during training.",
-+)
-+flags.DEFINE_boolean(
-+	"save_test_predictions",
-+	False,
-+	"Makes and saves test predictions on one or more test sets (e.g. 5-step and 100-step predictions) at the end of training.",
-+)
-+flags.DEFINE_boolean(
-+    "log_val_test", True, "Turns off computation of validation and test errors."
-+)
- 
- # Experiment config
- flags.DEFINE_integer('batch_size', 100, 'Mini-batch size.')
--flags.DEFINE_float('learning_rate', 1e-5, 'SGD learning rate.')
-+flags.DEFINE_float("learning_rate", 1e-4, "Adam learning rate.")
-+flags.DEFINE_float("beta1", 0.9, "Adam Beta 1 parameter")
-+flags.DEFINE_float("beta2", 0.999, "Adam Beta 2 parameter")
- 
- # Specific config options
- flags.DEFINE_integer("input_size",39,"Input shape to model")
- 
-+#########################################################################################
-+
-+def evaluate(model, loader, device,fold = 0,headings = [],loss_func = nn.CrossEntropyLoss()):
-+	reports = None
-+	for data in loader:
-+		labels = data['label']
-+		inputs = nested_to(data['data'],device,torch.float32)
-+		
-+		labels_tensor = torch.zeros((len(labels), 2))
-+		for i, label in enumerate(labels):
-+			labels_tensor[i, label] = 1
-+
-+		model_output = model(inputs) # evaluate model
-+
-+		loss = loss_func(model_output, labels_tensor) # compute loss
-+		outputs = AttrDict({"loss": loss, "prediction": model_output,'data_fold':fold})
-+		outputs.reports = AttrDict({"cross_entropy": loss})
-+
-+		if reports is None:
-+			reports = {k: v.detach().clone().cpu() for k, v in outputs.reports.items()}
-+		else:
-+			for k, v in outputs.reports.items():
-+				reports[k] += v.detach().clone().cpu()
-+
-+	for k, v in reports.items():
-+		reports[k] = v / len(
-+			loader
-+		)  # SZ: note this can be slightly incorrect if mini-batch sizes vary (if batch_size doesn't divide train_size), but approximately correct.
-+
-+	# reports['test_headings'] = np.array(headings)
-+
-+	return reports
-+
-+def main():
-+
-+	config = forge.config()
-+
-+	# Set device
-+	if torch.cuda.is_available():
-+		device = f"cuda:{config.device}"
-+		torch.cuda.set_device(device)
-+	else:
-+		device = "cpu" # can change this to MPS on M1 Macs
-+
-+	# Load data
-+	data_name = "penn_data"
-+	kfold_loaders = fet.load(config.data_config, config)
-+
-+	# Load model
-+	model,model_name = fet.load(config.model_config, config)
-+	model = model.to(device)
-+
-+	# Prepare environment
-+	params_in_run_name = [
-+		("batch_size", "bs"),
-+		("learning_rate", "lr"),
-+		("n_train", "ntrain"),
-+		("include_coords",'inclx'),
-+		("input_size",'inpsize'),
-+		("cross_validate",'crval')
-+	]
-+
-+	run_name = ""  # config.run_name
-+	for config_param in params_in_run_name:
-+		attr = config_param[0]
-+		abbrev = config_param[1]
-+
-+		if hasattr(config, attr):
-+			run_name += abbrev
-+			run_name += str(getattr(config, attr))
-+			run_name += "_"
-+
-+	results_folder_name = osp.join(
-+		data_name,
-+		model_name,
-+		config.run_name,
-+		run_name,
-+	)
-+
-+	# Prepare environment
-+	logdir = osp.join(config.results_dir, results_folder_name.replace(".", "_"))
-+	logdir, resume_checkpoint = fet.init_checkpoint(
-+		logdir, config.data_config, config.model_config, config.resume)
-+
-+	print("Checkpoint directory:",logdir)
-+
-+	# Print flags
-+	fet.print_flags()
-+	# Print model info
-+	print(model)
-+
-+	# Setup optimizer
-+	model_params = model.parameters()
-+	opt_learning_rate = config.learning_rate
-+	model_opt = torch.optim.Adam(
-+		model_params, lr=opt_learning_rate, betas=(config.beta1, config.beta2)
-+	)
-+	print("Model Optimizer:")
-+	print(model_opt)
-+
-+	# Try to restore model and optimizer from checkpoint
-+	if resume_checkpoint is not None:
-+		start_epoch = load_checkpoint(resume_checkpoint, model, model_opt)
-+	else:
-+		start_epoch = 1
-+
-+	n_folds = len(kfold_loaders)
-+	print("Doing {}-fold cross-validation.".format(n_folds))
-+
-+	# KFOLD TRAINING LOOP
-+	for k,loader_k in enumerate(kfold_loaders): # loop over data splits
-+
-+		print("Training fold {}...".format(k+1))
-+
-+		# load the training data
-+		train_loader = loader_k["train"]
-+		n_train = len(train_loader.dataset)
-+		train_batch_size = train_loader.batch_size
-+
-+		# load testing, validation
-+		test_loader = loader_k["test"]
-+		n_test = len(test_loader.dataset)
-+		val_loader = loader_k["val"]
-+		n_val = len(val_loader.dataset)
-+
-+		train_class_counts = np.bincount(train_loader.dataset.all_labels)
-+		train_total_counts = sum(train_class_counts)
-+		class_weight = torch.tensor(1.0 / train_class_counts) * train_total_count / 2.0
-+
-+		loss_func = nn.CrossEntropyLoss(weight = class_weight) # define reweighted loss function
-+				
-+		# create folder for this data split
-+		fold_dir = osp.join(logdir,"data_fold{}".format(k+1))
-+		fold_dir_exists = osp.exists(fold_dir)
-+		if not fold_dir_exists:
-+			if config.resume:
-+				raise ValueError("Can't resume when the checkpoint/fold dir '{}' doesn't exist.".format(fold_dir))
-+			else:
-+				os.makedirs(fold_dir)
-+		checkpoint_name = osp.join(fold_dir, 'model_fold{}.ckpt'.format(k+1))
-+
-+		# keep track of which data is test data for a given Kfold data split
-+		test_headings = loader_k['test_headings']
-+		headingsFile = osp.join(fold_dir,"test_headings.txt")
-+		with open(headingsFile,'w') as headfile:
-+			for heading in test_headings:
-+				headfile.write(heading+'\n')
-+
-+		# print(checkpoint_name)
-+
-+		train_iter = (start_epoch - 1) * (
-+		len(train_loader.dataset) // train_batch_size
-+		) + 1
-+
-+		print("Starting training at epoch = {}, iter = {}".format(start_epoch, train_iter))
-+
-+		# Setup tensorboard writing
-+		summary_writer = SummaryWriter(logdir)
-+
-+		train_reports = []
-+		report_all = {}
-+		report_all_val = {}
-+
-+		# Saving model at epoch 0 before training
-+		print("saving model at epoch 0 before training ... ")
-+		save_checkpoint(checkpoint_name, 0, model, model_opt, loss=0.0)
-+		print("finished saving model at epoch 0 before training")
-+
-+		num_params = param_count(model)
-+		print(f"Number of model parameters: {num_params}")
-+
-+		# Training
-+		start_t = time.time()
-+
-+		total_train_iters = len(train_loader) * config.train_epochs
-+		iters_per_eval = max(1, int(total_train_iters / config.total_evaluations))
-+		# print('batch',train_batch_size)
-+		# print('ntrain',n_train)
-+		# assert (
-+		# 	n_train % min(train_batch_size, n_train) == 0
-+		# ), "Batch size doesn't divide dataset size. Can be inaccurate for loss computation (see below)."
-+
-+		training_failed = False
-+		best_val_loss_so_far = 1e7
-+
-+		for epoch in tqdm(range(start_epoch, config.train_epochs + 1)):
-+			model.train()
-+
-+			for batch_idx, data_dict in enumerate(train_loader): # Loop over batched data
-+
-+				labels = data_dict['label']
-+				data = data_dict['data']
-+
-+				# send data to device
-+				data = nested_to(data,device,torch.float32)
-+				# One-hot encode the data labels
-+				labels_tensor = torch.zeros((len(labels), 2))
-+				for i, label in enumerate(labels):
-+					labels_tensor[i, label] = 1
-+
-+				model_output = model(data) # evaluate model
-+
-+				loss = loss_func(model_output, labels_tensor) # compute loss
-+				outputs = AttrDict({"loss": loss, "prediction": model_output})
-+				outputs.reports = AttrDict({"cross_entropy": loss})
-+
-+				if torch.isnan(outputs.loss): # check for failure in training
-+					if not training_failed:
-+						epoch_of_nan = epoch
-+					if (epoch > epoch_of_nan + 1) and training_failed:
-+						raise ValueError("Loss Nan-ed.")
-+					training_failed = True
-+
-+				model_opt.zero_grad()
-+				outputs.loss.backward(retain_graph=False)
-+
-+				model_opt.step() # move optimizer forward
-+
-+				train_reports.append(parse_reports_cpu(outputs.reports))
-+
-+				if config.log_train_values:
-+					reports = parse_reports(outputs.reports)
-+					if batch_idx % config.report_loss_every == 0:
-+						log_tensorboard(summary_writer, train_iter, reports, "train/")
-+						print_reports(
-+							reports,
-+							start_t,
-+							epoch,
-+							batch_idx,
-+							len(train_loader.dataset) // train_batch_size,
-+							prefix="train",
-+						)
-+						log_tensorboard(
-+							summary_writer,
-+							train_iter,
-+							{"lr": model_opt.param_groups[0]["lr"]},
-+							"hyperparams/",
-+						)
-+				# Logging and evaluation
-+				if (
-+					train_iter % iters_per_eval == 0 or (train_iter == total_train_iters)
-+				) and config.log_val_test:  # batch_idx % config.evaluate_every == 0:
-+					model.eval()
-+					with torch.no_grad():
-+						reports = evaluate(model, test_loader, device,fold = k,headings = loader_k['test_headings'])
-+						# print("REPORTS",reports)
-+						reports = parse_reports(reports)
-+						reports["time"] = time.time() - start_t
-+						if report_all == {}:
-+							report_all = deepcopy(reports)
-+
-+							for d in reports.keys():
-+								report_all[d] = [report_all[d]]
-+						else:
-+							for d in reports.keys():
-+								report_all[d].append(reports[d])
-+
-+						log_tensorboard(summary_writer, train_iter, reports, "test/")
-+						print_reports(
-+							reports,
-+							start_t,
-+							epoch,
-+							batch_idx,
-+							len(train_loader.dataset) // config.batch_size,
-+							prefix="test",
-+						)
-+
-+						# repeat for validation data
-+						reports = evaluate(model, val_loader, device,fold = k,headings = loader_k['test_headings'])
-+						reports = parse_reports(reports)
-+						reports["time"] = time.time() - start_t
-+						if report_all_val == {}:
-+							report_all_val = deepcopy(reports)
-+
-+							for d in reports.keys():
-+								report_all_val[d] = [report_all_val[d]]
-+						else:
-+							for d in reports.keys():
-+								report_all_val[d].append(reports[d])
-+
-+						log_tensorboard(summary_writer, train_iter, reports, "val/")
-+						print_reports(
-+							reports,
-+							start_t,
-+							epoch,
-+							batch_idx,
-+							len(train_loader.dataset) // config.batch_size,
-+							prefix="val",
-+						)
-+
-+						if report_all_val["cross_entropy"][-1] < best_val_loss_so_far:
-+							save_checkpoint(
-+								checkpoint_name,
-+								f"early_stop",
-+								model,
-+								model_opt,
-+								loss=outputs.loss,
-+							)
-+							best_val_loss_so_far = report_all_val["cross_entropy"][-1]
-+
-+					model.train()
-+
-+				train_iter += 1
-+
-+			if epoch % config.save_check_points == 0:
-+				save_checkpoint(
-+					checkpoint_name, train_iter, model, model_opt, loss=outputs.loss
-+				)
-+
-+		dd.io.save(fold_dir + "/results_dict_train.h5", train_reports)
-+		dd.io.save(fold_dir + "/results_dict.h5", report_all)
-+		dd.io.save(fold_dir + "/results_dict_val.h5", report_all_val)
-+
-+	# always save final model
-+	save_checkpoint(checkpoint_name, train_iter, model, model_opt, loss=outputs.loss)
-+
-+	
-+	if config.save_test_predictions:
-+		pass
-+		# print("Starting to make model predictions on test sets for *final model*.")
-+		# for chunk_len in [5, 100]:
-+		#     start_t_preds = time.time()
-+		#     data_config = SimpleNamespace(
-+		#         **{
-+		#             **config.__dict__["__flags"],
-+		#             **{"chunk_len": chunk_len, "batch_size": 500},
-+		#         }
-+		#     )
-+		#     dataloaders, data_name = fet.load(config.data_config, config=data_config)
-+		#     test_loader_preds = dataloaders["test"]
-+
-+		#     torch.cuda.empty_cache()
-+		#     with torch.no_grad():
-+		#         preds = []
-+		#         true = []
-+		#         num_datapoints = 0
-+		#         for idx, d in enumerate(test_loader_preds):
-+		#             true.append(d[-1])
-+		#             d = nested_to(d, device, torch.float32)
-+		#             outputs = model(d)
-+
-+		#             pred_zs = outputs.prediction
-+		#             preds.append(pred_zs)
-+
-+		#             num_datapoints += len(pred_zs)
-+
-+		#             if num_datapoints >= 2000:
-+		#                 break
- 
--config = forge.config()
-+		#         preds = torch.cat(preds, dim=0).cpu()
-+		#         true = torch.cat(true, dim=0).cpu()
- 
--# Prepare environment
--logdir = osp.join(config.results_dir, config.run_name)
--logdir, resume_checkpoint = fet.init_checkpoint(
--    logdir, config.data_config, config.model_config, config.resume)
--checkpoint_name = osp.join(logdir, 'model.ckpt')
-+		#         save_dir = osp.join(logdir, f"traj_preds_{chunk_len}_steps_2k_test.pt")
-+		#         torch.save(preds, save_dir)
- 
-+		#         save_dir = osp.join(logdir, f"traj_true_{chunk_len}_steps_2k_test.pt")
-+		#         torch.save(true, save_dir)
- 
--print(logdir)
-+		#         print(
-+		#             f"Completed making test predictions for chunk_len = {chunk_len} in {time.time() - start_t_preds:.2f} seconds."
-+		#         )	
-+		
- 
-+if __name__ == "__main__":
-+	main()
- 
diff --git a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_/1/penn_dataset.py b/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_/1/penn_dataset.py
deleted file mode 100644
index 7f5a4fc..0000000
--- a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_/1/penn_dataset.py
+++ /dev/null
@@ -1,137 +0,0 @@
-import os
-import torch
-import pandas as pd
-import numpy as np
-
-from torchvision import datasets, transforms
-from torch.utils.data import Dataset, DataLoader
-from sklearn.model_selection import RepeatedKFold
-
-from os import path as osp
-import forge
-from forge import flags
-
-
-# aspects of data managmement
-flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
-flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-flags.DEFINE_boolean("cross_validate",False,"Do K-fold cross-validation")
-
-# Job management
-# flags.DEFINE_integer("batch size",5,"training batch size")
-flags.DEFINE_float("train_split",0.8,'Fraction of data to use for training.')
-flags.DEFINE_integer("n_repeats",1,"Times to repeat K-fold cross-validation")
-flags.DEFINE_integer("split_seed",1,"Seed for KFold split (integer for reproducibility")
-
-# "wavelengths between 0.05 and 1 mm in 0.025 mm increments."
-LSPACE = np.arange(0.05,1.05,0.025) # corresponds to 39 non-coord columns of data
-L_INDS = None
-
-DATAFOLDER = './penn_data'
-
-HEADINGS = np.array(['aaa0043','aaa0044','aaa0060','aaa0061','aaa0063','aaa0064','aaa0066','aaa0069','aaa0086','aaa0087','aaa_0051','aaa_0053','aaa_0054','aaa_0059','aaa_0071','aaa_0072'])
-
-
-class PennData(Dataset):
-
-    def __init__(self,path_to_data,headings,k_inds = None,include_coords = True,rescale = True,spectra_prefix = "kvals_fuse_rotate_",label_prefix = 'labels_fuse_rotate_'):
-        
-        self.data_dir = path_to_data
-        self.headings = headings
-
-        df_list = []
-        label_list = []
-        for heading in self.headings: # for each datafile heading,
-            data_name = osp.join(self.data_dir,spectra_prefix + heading+'.csv') # read kvals
-            df_temp = pd.read_csv(data_name,header=None)
-            df_list.append(df_temp)
-
-            label_name = osp.join(self.data_dir,label_prefix + heading + '.csv') # read labels
-            label_temp = pd.read_csv(label_name,header=None, names=['label'])
-            label_list.append(label_temp)
-
-        df = pd.concat(df_list, ignore_index=True)
-
-        labels = pd.concat(label_list, ignore_index=True)
-        df = pd.concat([labels, df], axis="columns") # Append labels to data
-
-        all_labels = df['label'].to_numpy()
-        all_data = df.iloc[:,1:].to_numpy()
-
-        if rescale: # rescale (normalize) wavelength intensity data
-            lambdas = all_data[:,2:] # wavelengths
-            lam_std = np.std(lambdas, axis=0)  # Calculate standard deviation along columns
-            lam_mean = np.mean(lambdas, axis=0)  # Calculate mean along columns
-            lambdas_rescaled = (lambdas - lam_mean) / lam_std 
-            all_data[:,2:] = lambdas_rescaled
-
-        if not include_coords: # removes x,y coordinates from data
-            all_data = all_data[:,2:]
-        
-        if k_inds != None: # in this case, only use subset of wavelengths
-            all_data = all_data[:,np.array(k_inds)]
-
-        self.all_data = all_data
-        self.all_labels = all_labels
-
-    def __len__(self):
-        return len(self.all_data)
-
-    def __getitem__(self,i):
-        state = {'label':self.all_labels[i],'data':self.all_data[i]}
-        return state
-
-    def __getstate__(self):
-        state = {
-            'data': self.all_data,
-            'label': self.all_labels,
-                }
-        return state
-
-    def __setstate__(self, state):
-        # Set the object's state from the provided dictionary
-        self.all_data = state['data']
-        self.all_labels = state['label']
-        
-
-
-def load(config):
-
-    n_splits = int(len(HEADINGS)/((1-config.train_split)*len(HEADINGS)))
-
-    kf = RepeatedKFold(n_splits = n_splits, n_repeats = config.n_repeats, random_state = config.split_seed) # K-fold cross validation
-
-    kf_dataloaders = []
-
-    for i, (train_ind, test_ind) in enumerate(kf.split(HEADINGS)): # for each K-fold split, 
-        n_val = len(test_ind)//2
-        n_test = len(test_ind)-n_val   
-        n_train = len(train_ind)
-        
-        # set up training DataLoader
-        train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
-
-        # set up test DataLoader
-        test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
-
-        # set up val DataLoader
-        val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-        
-
-        dataloaders = {'train':train_loader, 
-                       'test':test_loader,
-                       'val':val_loader,
-                       'train_inds':train_ind,
-                       'test_inds':test_ind,
-                       'n_val':n_val,
-                       'test_headings':list(HEADINGS[test_ind])
-                      }
-        kf_dataloaders.append(dataloaders)
-
-        if not config.cross_validate:
-        	break
-
-    return kf_dataloaders
diff --git a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_/2/.DS_Store b/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_/2/.DS_Store
deleted file mode 100644
index 482a2ef..0000000
Binary files a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_/2/.DS_Store and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_/2/basic_feedforward.py b/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_/2/basic_feedforward.py
deleted file mode 100644
index b8c3962..0000000
--- a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_/2/basic_feedforward.py
+++ /dev/null
@@ -1,42 +0,0 @@
-import torch
-import torch.nn as nn
-import torch.nn.functional as F
-import numpy as np
-
-from forge import flags
-
-# flags.DEFINE_boolean(
-#     "model_with_dict",
-#     True,
-#     "Makes model output predictions in dictionary instead of directly."
-# )
-
-class PerceptronNN(nn.Module):
-    def __init__(self, input_size, num_labels):
-        super(PerceptronNN, self).__init__()
-        # Define the layers
-        self.fc1 = nn.Linear(input_size, 128)  # First dense layer
-        self.fc2 = nn.Linear(128, 64)         # Second dense layer
-        self.fc23 = nn.Linear(64,64)
-        self.fc3 = nn.Linear(64, 64)          # Third dense layer
-        self.fc4 = nn.Linear(64, num_labels)  # Output layer
-        # self.softmax = nn.Softmax(dim=1)
-
-    def forward(self, x):
-        # Forward pass through the network
-        x = F.relu(self.fc1(x))  # Activation function between layers
-        x = F.relu(self.fc2(x))
-        x = F.relu(self.fc23(x))
-        x = F.relu(self.fc3(x))
-        x = self.fc4(x)  # No activation, this will be included in the loss function
-        # x = self.softmax(x)
-        return x
-
-def load(config):
-
-    # n_channels = 1
-    n_features = config.input_size
-    
-    mlp = PerceptronNN(n_features,2)
-    
-    return mlp, "feedforward"
\ No newline at end of file
diff --git a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_/2/data_fold1/model_fold1.ckpt-0 b/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_/2/data_fold1/model_fold1.ckpt-0
deleted file mode 100644
index 24b3d19..0000000
Binary files a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_/2/data_fold1/model_fold1.ckpt-0 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_/2/data_fold1/model_fold1.ckpt-115101 b/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_/2/data_fold1/model_fold1.ckpt-115101
deleted file mode 100644
index 8d093d7..0000000
Binary files a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_/2/data_fold1/model_fold1.ckpt-115101 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_/2/data_fold1/model_fold1.ckpt-57551 b/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_/2/data_fold1/model_fold1.ckpt-57551
deleted file mode 100644
index 00876b2..0000000
Binary files a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_/2/data_fold1/model_fold1.ckpt-57551 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_/2/data_fold1/model_fold1.ckpt-early_stop b/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_/2/data_fold1/model_fold1.ckpt-early_stop
deleted file mode 100644
index c6f01aa..0000000
Binary files a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_/2/data_fold1/model_fold1.ckpt-early_stop and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_/2/data_fold1/results_dict.h5 b/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_/2/data_fold1/results_dict.h5
deleted file mode 100644
index f7e0af9..0000000
Binary files a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_/2/data_fold1/results_dict.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_/2/data_fold1/results_dict_train.h5 b/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_/2/data_fold1/results_dict_train.h5
deleted file mode 100644
index e575627..0000000
Binary files a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_/2/data_fold1/results_dict_train.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_/2/data_fold1/results_dict_val.h5 b/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_/2/data_fold1/results_dict_val.h5
deleted file mode 100644
index a4e2a70..0000000
Binary files a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_/2/data_fold1/results_dict_val.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_/2/data_fold1/test_headings.txt b/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_/2/data_fold1/test_headings.txt
deleted file mode 100644
index 05c4825..0000000
--- a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_/2/data_fold1/test_headings.txt
+++ /dev/null
@@ -1,4 +0,0 @@
-aaa0060
-aaa0061
-aaa0069
-aaa_0059
diff --git a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_/2/events.out.tfevents.1709663626.MacBook-Pro-4.local.5907.0 b/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_/2/events.out.tfevents.1709663626.MacBook-Pro-4.local.5907.0
deleted file mode 100644
index 13f4159..0000000
Binary files a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_/2/events.out.tfevents.1709663626.MacBook-Pro-4.local.5907.0 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_/2/flags.json b/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_/2/flags.json
deleted file mode 100644
index 889a6ea..0000000
--- a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_/2/flags.json
+++ /dev/null
@@ -1,26 +0,0 @@
-{
-    "batch_size": 100,
-    "beta1": 0.9,
-    "beta2": 0.999,
-    "cross_validate": false,
-    "data_config": "penn_dataset.py",
-    "git_commit": "7416bf730b356aabfe0df644240e40948a8196bb",
-    "include_coords": false,
-    "input_size": 39,
-    "learning_rate": 0.0001,
-    "log_train_values": true,
-    "log_val_test": true,
-    "model_config": "basic_feedforward.py",
-    "n_repeats": 1,
-    "report_loss_every": 50,
-    "rescale": true,
-    "results_dir": "checkpoints",
-    "resume": false,
-    "run_name": "feedforward",
-    "save_check_points": 50,
-    "save_test_predictions": false,
-    "split_seed": 1,
-    "total_evaluations": 100,
-    "train_epochs": 100,
-    "train_split": 0.8
-}
\ No newline at end of file
diff --git a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_/2/git_diff.txt b/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_/2/git_diff.txt
deleted file mode 100644
index e438729..0000000
--- a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_/2/git_diff.txt
+++ /dev/null
@@ -1,1763 +0,0 @@
-Tue Mar 5 10:33:46 PST 2024
-diff --git a/.DS_Store b/.DS_Store
-index e2836a8..ad06094 100644
-Binary files a/.DS_Store and b/.DS_Store differ
-diff --git a/.ipynb_checkpoints/basic_feedforward-checkpoint.py b/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-index 688c282..0c4bcd1 100644
---- a/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-+++ b/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-@@ -5,6 +5,12 @@ import numpy as np
- 
- from forge import flags
- 
-+flags.DEFINE_boolean(
-+    "model_with_dict",
-+    True,
-+    "Makes model output predictions in dictionary instead of directly."
-+)
-+
- class PerceptronNN(nn.Module):
-     def __init__(self, input_size, num_labels):
-         super(PerceptronNN, self).__init__()
-@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-+        self.softmax = nn.Softmax(dim=1)
- 
-     def forward(self, x):
-         # Forward pass through the network
-@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-         x = F.relu(self.fc2(x))
-         x = F.relu(self.fc3(x))
-         x = self.fc4(x)  # No activation, this will be included in the loss function
-+        x = self.softmax(x)
-         return x
- 
- def load(config):
-@@ -29,4 +37,4 @@ def load(config):
-     
-     mlp = PerceptronNN(n_features,2)
-     
--    return mlp
-\ No newline at end of file
-+    return mlp, "feedforward"
-\ No newline at end of file
-diff --git a/__pycache__/basic_feedforward.cpython-39.pyc b/__pycache__/basic_feedforward.cpython-39.pyc
-index f541140..0e2c7e5 100644
-Binary files a/__pycache__/basic_feedforward.cpython-39.pyc and b/__pycache__/basic_feedforward.cpython-39.pyc differ
-diff --git a/__pycache__/penn_dataset.cpython-39.pyc b/__pycache__/penn_dataset.cpython-39.pyc
-index 0d7a4de..19121eb 100644
-Binary files a/__pycache__/penn_dataset.cpython-39.pyc and b/__pycache__/penn_dataset.cpython-39.pyc differ
-diff --git a/basic_feedforward.py b/basic_feedforward.py
-index 688c282..b8c3962 100644
---- a/basic_feedforward.py
-+++ b/basic_feedforward.py
-@@ -5,21 +5,31 @@ import numpy as np
- 
- from forge import flags
- 
-+# flags.DEFINE_boolean(
-+#     "model_with_dict",
-+#     True,
-+#     "Makes model output predictions in dictionary instead of directly."
-+# )
-+
- class PerceptronNN(nn.Module):
-     def __init__(self, input_size, num_labels):
-         super(PerceptronNN, self).__init__()
-         # Define the layers
-         self.fc1 = nn.Linear(input_size, 128)  # First dense layer
-         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-+        self.fc23 = nn.Linear(64,64)
-         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-+        # self.softmax = nn.Softmax(dim=1)
- 
-     def forward(self, x):
-         # Forward pass through the network
-         x = F.relu(self.fc1(x))  # Activation function between layers
-         x = F.relu(self.fc2(x))
-+        x = F.relu(self.fc23(x))
-         x = F.relu(self.fc3(x))
-         x = self.fc4(x)  # No activation, this will be included in the loss function
-+        # x = self.softmax(x)
-         return x
- 
- def load(config):
-@@ -29,4 +39,4 @@ def load(config):
-     
-     mlp = PerceptronNN(n_features,2)
-     
--    return mlp
-\ No newline at end of file
-+    return mlp, "feedforward"
-\ No newline at end of file
-diff --git a/checkpoints/feedforward/1/basic_feedforward.py b/checkpoints/feedforward/1/basic_feedforward.py
-index 688c282..3a65525 100644
---- a/checkpoints/feedforward/1/basic_feedforward.py
-+++ b/checkpoints/feedforward/1/basic_feedforward.py
-@@ -5,6 +5,12 @@ import numpy as np
- 
- from forge import flags
- 
-+# flags.DEFINE_boolean(
-+#     "model_with_dict",
-+#     True,
-+#     "Makes model output predictions in dictionary instead of directly."
-+# )
-+
- class PerceptronNN(nn.Module):
-     def __init__(self, input_size, num_labels):
-         super(PerceptronNN, self).__init__()
-@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-+        self.softmax = nn.Softmax(dim=1)
- 
-     def forward(self, x):
-         # Forward pass through the network
-@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-         x = F.relu(self.fc2(x))
-         x = F.relu(self.fc3(x))
-         x = self.fc4(x)  # No activation, this will be included in the loss function
-+        x = self.softmax(x)
-         return x
- 
- def load(config):
-@@ -29,4 +37,4 @@ def load(config):
-     
-     mlp = PerceptronNN(n_features,2)
-     
--    return mlp
-\ No newline at end of file
-+    return mlp, "feedforward"
-\ No newline at end of file
-diff --git a/checkpoints/feedforward/1/flags.json b/checkpoints/feedforward/1/flags.json
-index 1d000c3..889a6ea 100644
---- a/checkpoints/feedforward/1/flags.json
-+++ b/checkpoints/feedforward/1/flags.json
-@@ -1,9 +1,15 @@
- {
-     "batch_size": 100,
-+    "beta1": 0.9,
-+    "beta2": 0.999,
-+    "cross_validate": false,
-     "data_config": "penn_dataset.py",
-+    "git_commit": "7416bf730b356aabfe0df644240e40948a8196bb",
-     "include_coords": false,
-     "input_size": 39,
--    "learning_rate": 1e-05,
-+    "learning_rate": 0.0001,
-+    "log_train_values": true,
-+    "log_val_test": true,
-     "model_config": "basic_feedforward.py",
-     "n_repeats": 1,
-     "report_loss_every": 50,
-@@ -11,7 +17,10 @@
-     "results_dir": "checkpoints",
-     "resume": false,
-     "run_name": "feedforward",
-+    "save_check_points": 50,
-+    "save_test_predictions": false,
-     "split_seed": 1,
--    "train_epochs": 20,
-+    "total_evaluations": 100,
-+    "train_epochs": 100,
-     "train_split": 0.8
- }
-\ No newline at end of file
-diff --git a/checkpoints/feedforward/1/git_diff.txt b/checkpoints/feedforward/1/git_diff.txt
-index 7b37e6f..ec23707 100644
---- a/checkpoints/feedforward/1/git_diff.txt
-+++ b/checkpoints/feedforward/1/git_diff.txt
-@@ -1 +1,873 @@
--Mon Mar 4 11:45:48 PST 2024
-+Mon Mar 4 16:34:02 PST 2024
-+diff --git a/.DS_Store b/.DS_Store
-+index e2836a8..7e3fa32 100644
-+Binary files a/.DS_Store and b/.DS_Store differ
-+diff --git a/.ipynb_checkpoints/basic_feedforward-checkpoint.py b/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-+index 688c282..0c4bcd1 100644
-+--- a/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-++++ b/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-+@@ -5,6 +5,12 @@ import numpy as np
-+ 
-+ from forge import flags
-+ 
-++flags.DEFINE_boolean(
-++    "model_with_dict",
-++    True,
-++    "Makes model output predictions in dictionary instead of directly."
-++)
-++
-+ class PerceptronNN(nn.Module):
-+     def __init__(self, input_size, num_labels):
-+         super(PerceptronNN, self).__init__()
-+@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-+         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-+         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-+         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-++        self.softmax = nn.Softmax(dim=1)
-+ 
-+     def forward(self, x):
-+         # Forward pass through the network
-+@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-+         x = F.relu(self.fc2(x))
-+         x = F.relu(self.fc3(x))
-+         x = self.fc4(x)  # No activation, this will be included in the loss function
-++        x = self.softmax(x)
-+         return x
-+ 
-+ def load(config):
-+@@ -29,4 +37,4 @@ def load(config):
-+     
-+     mlp = PerceptronNN(n_features,2)
-+     
-+-    return mlp
-+\ No newline at end of file
-++    return mlp, "feedforward"
-+\ No newline at end of file
-+diff --git a/__pycache__/basic_feedforward.cpython-39.pyc b/__pycache__/basic_feedforward.cpython-39.pyc
-+index f541140..5ad96de 100644
-+Binary files a/__pycache__/basic_feedforward.cpython-39.pyc and b/__pycache__/basic_feedforward.cpython-39.pyc differ
-+diff --git a/__pycache__/penn_dataset.cpython-39.pyc b/__pycache__/penn_dataset.cpython-39.pyc
-+index 0d7a4de..19121eb 100644
-+Binary files a/__pycache__/penn_dataset.cpython-39.pyc and b/__pycache__/penn_dataset.cpython-39.pyc differ
-+diff --git a/basic_feedforward.py b/basic_feedforward.py
-+index 688c282..3a65525 100644
-+--- a/basic_feedforward.py
-++++ b/basic_feedforward.py
-+@@ -5,6 +5,12 @@ import numpy as np
-+ 
-+ from forge import flags
-+ 
-++# flags.DEFINE_boolean(
-++#     "model_with_dict",
-++#     True,
-++#     "Makes model output predictions in dictionary instead of directly."
-++# )
-++
-+ class PerceptronNN(nn.Module):
-+     def __init__(self, input_size, num_labels):
-+         super(PerceptronNN, self).__init__()
-+@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-+         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-+         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-+         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-++        self.softmax = nn.Softmax(dim=1)
-+ 
-+     def forward(self, x):
-+         # Forward pass through the network
-+@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-+         x = F.relu(self.fc2(x))
-+         x = F.relu(self.fc3(x))
-+         x = self.fc4(x)  # No activation, this will be included in the loss function
-++        x = self.softmax(x)
-+         return x
-+ 
-+ def load(config):
-+@@ -29,4 +37,4 @@ def load(config):
-+     
-+     mlp = PerceptronNN(n_features,2)
-+     
-+-    return mlp
-+\ No newline at end of file
-++    return mlp, "feedforward"
-+\ No newline at end of file
-+diff --git a/checkpoints/feedforward/1/basic_feedforward.py b/checkpoints/feedforward/1/basic_feedforward.py
-+index 688c282..3a65525 100644
-+--- a/checkpoints/feedforward/1/basic_feedforward.py
-++++ b/checkpoints/feedforward/1/basic_feedforward.py
-+@@ -5,6 +5,12 @@ import numpy as np
-+ 
-+ from forge import flags
-+ 
-++# flags.DEFINE_boolean(
-++#     "model_with_dict",
-++#     True,
-++#     "Makes model output predictions in dictionary instead of directly."
-++# )
-++
-+ class PerceptronNN(nn.Module):
-+     def __init__(self, input_size, num_labels):
-+         super(PerceptronNN, self).__init__()
-+@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-+         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-+         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-+         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-++        self.softmax = nn.Softmax(dim=1)
-+ 
-+     def forward(self, x):
-+         # Forward pass through the network
-+@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-+         x = F.relu(self.fc2(x))
-+         x = F.relu(self.fc3(x))
-+         x = self.fc4(x)  # No activation, this will be included in the loss function
-++        x = self.softmax(x)
-+         return x
-+ 
-+ def load(config):
-+@@ -29,4 +37,4 @@ def load(config):
-+     
-+     mlp = PerceptronNN(n_features,2)
-+     
-+-    return mlp
-+\ No newline at end of file
-++    return mlp, "feedforward"
-+\ No newline at end of file
-+diff --git a/checkpoints/feedforward/1/flags.json b/checkpoints/feedforward/1/flags.json
-+index 1d000c3..889a6ea 100644
-+--- a/checkpoints/feedforward/1/flags.json
-++++ b/checkpoints/feedforward/1/flags.json
-+@@ -1,9 +1,15 @@
-+ {
-+     "batch_size": 100,
-++    "beta1": 0.9,
-++    "beta2": 0.999,
-++    "cross_validate": false,
-+     "data_config": "penn_dataset.py",
-++    "git_commit": "7416bf730b356aabfe0df644240e40948a8196bb",
-+     "include_coords": false,
-+     "input_size": 39,
-+-    "learning_rate": 1e-05,
-++    "learning_rate": 0.0001,
-++    "log_train_values": true,
-++    "log_val_test": true,
-+     "model_config": "basic_feedforward.py",
-+     "n_repeats": 1,
-+     "report_loss_every": 50,
-+@@ -11,7 +17,10 @@
-+     "results_dir": "checkpoints",
-+     "resume": false,
-+     "run_name": "feedforward",
-++    "save_check_points": 50,
-++    "save_test_predictions": false,
-+     "split_seed": 1,
-+-    "train_epochs": 20,
-++    "total_evaluations": 100,
-++    "train_epochs": 100,
-+     "train_split": 0.8
-+ }
-+\ No newline at end of file
-+diff --git a/checkpoints/feedforward/1/git_diff.txt b/checkpoints/feedforward/1/git_diff.txt
-+index 7b37e6f..5c561db 100644
-+--- a/checkpoints/feedforward/1/git_diff.txt
-++++ b/checkpoints/feedforward/1/git_diff.txt
-+@@ -1 +1 @@
-+-Mon Mar 4 11:45:48 PST 2024
-++Mon Mar 4 16:34:02 PST 2024
-+diff --git a/checkpoints/feedforward/1/penn_dataset.py b/checkpoints/feedforward/1/penn_dataset.py
-+index aa2f5a0..7f5a4fc 100644
-+--- a/checkpoints/feedforward/1/penn_dataset.py
-++++ b/checkpoints/feedforward/1/penn_dataset.py
-+@@ -15,6 +15,7 @@ from forge import flags
-+ # aspects of data managmement
-+ flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
-+ flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-++flags.DEFINE_boolean("cross_validate",False,"Do K-fold cross-validation")
-+ 
-+ # Job management
-+ # flags.DEFINE_integer("batch size",5,"training batch size")
-+@@ -109,15 +110,15 @@ def load(config):
-+         
-+         # set up training DataLoader
-+         train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, n_train),num_workers=0,shuffle = True)
-++        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
-+ 
-+         # set up test DataLoader
-+         test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, n_test),num_workers=0,shuffle = True)
-++        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
-+ 
-+         # set up val DataLoader
-+         val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, n_val),num_workers=0,shuffle = True)
-++        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-+         
-+ 
-+         dataloaders = {'train':train_loader, 
-+@@ -125,8 +126,12 @@ def load(config):
-+                        'val':val_loader,
-+                        'train_inds':train_ind,
-+                        'test_inds':test_ind,
-+-                       'n_val':n_val
-++                       'n_val':n_val,
-++                       'test_headings':list(HEADINGS[test_ind])
-+                       }
-+         kf_dataloaders.append(dataloaders)
-+ 
-++        if not config.cross_validate:
-++        	break
-++
-+     return kf_dataloaders
-+diff --git a/penn_dataset.py b/penn_dataset.py
-+index aa2f5a0..7f5a4fc 100644
-+--- a/penn_dataset.py
-++++ b/penn_dataset.py
-+@@ -15,6 +15,7 @@ from forge import flags
-+ # aspects of data managmement
-+ flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
-+ flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-++flags.DEFINE_boolean("cross_validate",False,"Do K-fold cross-validation")
-+ 
-+ # Job management
-+ # flags.DEFINE_integer("batch size",5,"training batch size")
-+@@ -109,15 +110,15 @@ def load(config):
-+         
-+         # set up training DataLoader
-+         train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, n_train),num_workers=0,shuffle = True)
-++        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
-+ 
-+         # set up test DataLoader
-+         test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, n_test),num_workers=0,shuffle = True)
-++        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
-+ 
-+         # set up val DataLoader
-+         val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, n_val),num_workers=0,shuffle = True)
-++        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-+         
-+ 
-+         dataloaders = {'train':train_loader, 
-+@@ -125,8 +126,12 @@ def load(config):
-+                        'val':val_loader,
-+                        'train_inds':train_ind,
-+                        'test_inds':test_ind,
-+-                       'n_val':n_val
-++                       'n_val':n_val,
-++                       'test_headings':list(HEADINGS[test_ind])
-+                       }
-+         kf_dataloaders.append(dataloaders)
-+ 
-++        if not config.cross_validate:
-++        	break
-++
-+     return kf_dataloaders
-+diff --git a/testing.ipynb b/testing.ipynb
-+index e5a167b..a928d8d 100644
-+--- a/testing.ipynb
-++++ b/testing.ipynb
-+@@ -2,7 +2,7 @@
-+  "cells": [
-+   {
-+    "cell_type": "code",
-+-   "execution_count": 1,
-++   "execution_count": 2,
-+    "id": "4dee7ff1-01a4-4038-b493-9729ff3693f7",
-+    "metadata": {},
-+    "outputs": [],
-+@@ -23,19 +23,19 @@
-+   },
-+   {
-+    "cell_type": "code",
-+-   "execution_count": 2,
-++   "execution_count": 3,
-+    "id": "cad0fdc8-5c35-4610-bba3-b71e60dc1b98",
-+    "metadata": {},
-+    "outputs": [],
-+    "source": [
-+-    "flags.DEFINE_integer(\"batch_size\", 100, \"Mini-batch size.\")\n",
-++    "flags.DEFINE_integer(\"batch_size\", 10, \"Mini-batch size.\")\n",
-+     "\n",
-+     "flags.DEFINE_integer(\"input_size\",39,\"Input shape to model\")"
-+    ]
-+   },
-+   {
-+    "cell_type": "code",
-+-   "execution_count": 3,
-++   "execution_count": 4,
-+    "id": "ce1b936b-8a7c-426e-a3aa-3c1c38f645de",
-+    "metadata": {},
-+    "outputs": [
-+@@ -54,8 +54,8 @@
-+   },
-+   {
-+    "cell_type": "code",
-+-   "execution_count": 9,
-+-   "id": "e862b7e2-57f5-44bf-bcf1-a91160ba66cc",
-++   "execution_count": 5,
-++   "id": "4469cddf-4dac-4468-be88-241d440401c3",
-+    "metadata": {},
-+    "outputs": [
-+     {
-+@@ -67,35 +67,89 @@
-+     }
-+    ],
-+    "source": [
-+-    "model = fet.load(\"basic_feedforward.py\",config)"
-++    "model,modelname = fet.load(\"basic_feedforward.py\",config)"
-+    ]
-+   },
-+   {
-+    "cell_type": "code",
-+-   "execution_count": 10,
-+-   "id": "07e0b160-d5d1-4e54-b4a7-ccaf2224598a",
-++   "execution_count": 17,
-++   "id": "7c9a9fe9-f5e8-456a-b964-4be13027725b",
-+    "metadata": {},
-+    "outputs": [
-+     {
-+      "data": {
-+       "text/plain": [
-+-       "PerceptronNN(\n",
-+-       "  (fc1): Linear(in_features=39, out_features=128, bias=True)\n",
-+-       "  (fc2): Linear(in_features=128, out_features=64, bias=True)\n",
-+-       "  (fc3): Linear(in_features=64, out_features=64, bias=True)\n",
-+-       "  (fc4): Linear(in_features=64, out_features=2, bias=True)\n",
-+-       ")"
-++       "['aaa0060', 'aaa0061', 'aaa0069', 'aaa_0059']"
-+       ]
-+      },
-+-     "execution_count": 10,
-++     "execution_count": 17,
-+      "metadata": {},
-+      "output_type": "execute_result"
-+     }
-+    ],
-+    "source": [
-+-    "model"
-++    "loaddat[0]['test_headings']"
-++   ]
-++  },
-++  {
-++   "cell_type": "code",
-++   "execution_count": 19,
-++   "id": "e862b7e2-57f5-44bf-bcf1-a91160ba66cc",
-++   "metadata": {},
-++   "outputs": [
-++    {
-++     "name": "stdout",
-++     "output_type": "stream",
-++     "text": [
-++      "Keys: ['cross_entropy', 'time']\n"
-++     ]
-++    }
-++   ],
-++   "source": [
-++    "import h5py\n",
-++    "\n",
-++    "file_path = \"./checkpoints/feedforward/2/data_fold1/results_dict.h5\"\n",
-++    "# Replace 'your_file.h5' with the actual path to your file\n",
-++    "f =  h5py.File(file_path, 'r') \n",
-++    "\n",
-++    "    # Get information about the data stored in the file\n",
-++    "print(\"Keys:\", list(f.keys()))  # List the top-level datasets and groups\n",
-++    "\n",
-++    "    # # Access a dataset by its name\n",
-++    "    # dataset_name = \"your_dataset_name\"\n",
-++    "    # if dataset_name in f:\n",
-++    "    #     dataset = f[dataset_name]\n",
-++    "    #     print(\"Dataset shape:\", dataset.shape)\n",
-++    "    #     print(\"Dataset dtype:\", dataset.dtype)\n",
-++    "\n",
-++    "    #     # Access the data as a NumPy array\n",
-++    "    #     data = dataset[:]  # Read the entire dataset\n",
-++    "\n",
-++    "    #     # You can now work with the data as needed, for example:\n",
-++    "    #     # Perform calculations, visualizations, etc.\n",
-++    "    # else:\n",
-++    "    #     print(f\"Dataset '{dataset_name}' not found in the file.\")"
-+    ]
-+   },
-++  {
-++   "cell_type": "code",
-++   "execution_count": 13,
-++   "id": "07e0b160-d5d1-4e54-b4a7-ccaf2224598a",
-++   "metadata": {},
-++   "outputs": [
-++    {
-++     "data": {
-++      "text/plain": [
-++       "<generator object Module.parameters at 0x3007207b0>"
-++      ]
-++     },
-++     "execution_count": 13,
-++     "metadata": {},
-++     "output_type": "execute_result"
-++    }
-++   ],
-++   "source": []
-++  },
-+   {
-+    "cell_type": "code",
-+    "execution_count": null,
-+diff --git a/train.py b/train.py
-+index c266102..516bfa9 100644
-+--- a/train.py
-++++ b/train.py
-+@@ -1,49 +1,440 @@
-+ from os import path as osp
-++import os
-++import numpy as np
-++import time
-+ 
-+ import torch
-++import torch.nn as nn
-+ import torch.nn.functional as F
-+ import torch.optim as optim
-+-
-+-import numpy as np
-++from torch.utils.tensorboard import SummaryWriter
-+ 
-+ import forge
-+ from forge import flags
-+ import forge.experiment_tools as fet
-+ 
-++from train_tools import (
-++	log_tensorboard,
-++	parse_reports,
-++	parse_reports_cpu,
-++	print_reports,
-++	load_checkpoint,
-++	save_checkpoint,
-++	nested_to,
-++	param_count,
-++)
-++
-++from copy import deepcopy
-++from attrdict import AttrDict
-++import deepdish as dd
-++from tqdm import tqdm
-++
-++# For reproducibility while researching, but might affect speed!
-++torch.backends.cudnn.deterministic = True
-++torch.backends.cudnn.benchmark = False
-++torch.manual_seed(0)
-++
-+ 
-+ # Job config
-+ flags.DEFINE_string('data_config', 'penn_dataset.py',
-+-                    'Path to a data config file.')
-++					'Path to a data config file.')
-+ flags.DEFINE_string('model_config', 'basic_feedforward.py',
-+-                    'Path to a model config file.')
-++					'Path to a model config file.')
-+ flags.DEFINE_string('results_dir', 'checkpoints',
-+-                    'Top directory for all experimental results.')
-++					'Top directory for all experimental results.')
-+ flags.DEFINE_string('run_name', 'feedforward',
-+-                    'Name of this job and name of results folder.')
-++					'Name of this job and name of results folder.')
-+ flags.DEFINE_boolean('resume', False, 'Tries to resume a job if True.')
-+ 
-+ # Logging config
-+ flags.DEFINE_integer('report_loss_every', 50,
-+-                     'Number of iterations between reporting minibatch loss.')
-+-flags.DEFINE_integer('train_epochs', 20, 'Maximum number of training epochs.')
-++					 'Number of iterations between reporting minibatch loss.')
-++flags.DEFINE_integer('train_epochs', 100, 'Maximum number of training epochs.')
-++flags.DEFINE_integer(
-++	"save_check_points",
-++	50,
-++	"frequency with which to save checkpoints, in number of epoches.",
-++)
-++flags.DEFINE_boolean("log_train_values", True, "Logs train values if True.")
-++flags.DEFINE_integer(
-++	"total_evaluations",
-++	100,
-++	"Maximum number of evaluations on test and validation data during training.",
-++)
-++flags.DEFINE_boolean(
-++	"save_test_predictions",
-++	False,
-++	"Makes and saves test predictions on one or more test sets (e.g. 5-step and 100-step predictions) at the end of training.",
-++)
-++flags.DEFINE_boolean(
-++    "log_val_test", True, "Turns off computation of validation and test errors."
-++)
-+ 
-+ # Experiment config
-+ flags.DEFINE_integer('batch_size', 100, 'Mini-batch size.')
-+-flags.DEFINE_float('learning_rate', 1e-5, 'SGD learning rate.')
-++flags.DEFINE_float("learning_rate", 1e-4, "Adam learning rate.")
-++flags.DEFINE_float("beta1", 0.9, "Adam Beta 1 parameter")
-++flags.DEFINE_float("beta2", 0.999, "Adam Beta 2 parameter")
-+ 
-+ # Specific config options
-+ flags.DEFINE_integer("input_size",39,"Input shape to model")
-+ 
-++#########################################################################################
-++
-++def evaluate(model, loader, device,fold = 0,headings = [],loss_func = nn.CrossEntropyLoss()):
-++	reports = None
-++	for data in loader:
-++		labels = data['label']
-++		inputs = nested_to(data['data'],device,torch.float32)
-++		
-++		labels_tensor = torch.zeros((len(labels), 2))
-++		for i, label in enumerate(labels):
-++			labels_tensor[i, label] = 1
-++
-++		model_output = model(inputs) # evaluate model
-++
-++		loss = loss_func(model_output, labels_tensor) # compute loss
-++		outputs = AttrDict({"loss": loss, "prediction": model_output,'data_fold':fold})
-++		outputs.reports = AttrDict({"cross_entropy": loss})
-++
-++		if reports is None:
-++			reports = {k: v.detach().clone().cpu() for k, v in outputs.reports.items()}
-++		else:
-++			for k, v in outputs.reports.items():
-++				reports[k] += v.detach().clone().cpu()
-++
-++	for k, v in reports.items():
-++		reports[k] = v / len(
-++			loader
-++		)  # SZ: note this can be slightly incorrect if mini-batch sizes vary (if batch_size doesn't divide train_size), but approximately correct.
-++
-++	# reports['test_headings'] = np.array(headings)
-++
-++	return reports
-++
-++def main():
-++
-++	config = forge.config()
-++
-++	# Set device
-++	if torch.cuda.is_available():
-++		device = f"cuda:{config.device}"
-++		torch.cuda.set_device(device)
-++	else:
-++		device = "cpu" # can change this to MPS on M1 Macs
-++
-++	# Load data
-++	data_name = "penn_data"
-++	kfold_loaders = fet.load(config.data_config, config)
-++
-++	# Load model
-++	model,model_name = fet.load(config.model_config, config)
-++	model = model.to(device)
-++
-++	loss_func = nn.CrossEntropyLoss()
-++
-++	# Prepare environment
-++	params_in_run_name = [
-++		("batch_size", "bs"),
-++		("learning_rate", "lr"),
-++		("n_train", "ntrain")
-++	]
-++
-++	run_name = ""  # config.run_name
-++	for config_param in params_in_run_name:
-++		attr = config_param[0]
-++		abbrev = config_param[1]
-++
-++		if hasattr(config, attr):
-++			run_name += abbrev
-++			run_name += str(getattr(config, attr))
-++			run_name += "_"
-++
-++	results_folder_name = osp.join(
-++		data_name,
-++		model_name,
-++		config.run_name,
-++		run_name,
-++	)
-++
-++	# Prepare environment
-++	logdir = osp.join(config.results_dir, config.run_name)
-++	logdir, resume_checkpoint = fet.init_checkpoint(
-++		logdir, config.data_config, config.model_config, config.resume)
-++
-++	print("Checkpoint directory:",logdir)
-++
-++	# Print flags
-++	fet.print_flags()
-++	# Print model info
-++	print(model)
-++
-++	# Setup optimizer
-++	model_params = model.parameters()
-++	opt_learning_rate = config.learning_rate
-++	model_opt = torch.optim.Adam(
-++		model_params, lr=opt_learning_rate, betas=(config.beta1, config.beta2)
-++	)
-++	print("Model Optimizer:")
-++	print(model_opt)
-++
-++	# Try to restore model and optimizer from checkpoint
-++	if resume_checkpoint is not None:
-++		start_epoch = load_checkpoint(resume_checkpoint, model, model_opt)
-++	else:
-++		start_epoch = 1
-++
-++	n_folds = len(kfold_loaders)
-++	print("Doing {}-fold cross-validation.".format(n_folds))
-++
-++	# KFOLD TRAINING LOOP
-++	for k,loader_k in enumerate(kfold_loaders): # loop over data splits
-++
-++		print("Training fold {}...".format(k+1))
-++
-++		# load the training data
-++		train_loader = loader_k["train"]
-++		n_train = len(train_loader.dataset)
-++		train_batch_size = train_loader.batch_size
-++
-++		# load testing, validation
-++		test_loader = loader_k["test"]
-++		n_test = len(test_loader.dataset)
-++		val_loader = loader_k["val"]
-++		n_val = len(val_loader.dataset)
-++		
-++		# create folder for this data split
-++		fold_dir = osp.join(logdir,"data_fold{}".format(k+1))
-++		fold_dir_exists = osp.exists(fold_dir)
-++		if not fold_dir_exists:
-++			if config.resume:
-++				raise ValueError("Can't resume when the checkpoint/fold dir '{}' doesn't exist.".format(fold_dir))
-++			else:
-++				os.makedirs(fold_dir)
-++		checkpoint_name = osp.join(fold_dir, 'model_fold{}.ckpt'.format(k+1))
-++
-++		# keep track of which data is test data for a given Kfold data split
-++		test_headings = loader_k['test_headings']
-++		headingsFile = osp.join(fold_dir,"test_headings.txt")
-++		with open(headingsFile,'w') as headfile:
-++			for heading in test_headings:
-++				headfile.write(heading+'\n')
-++
-++		# print(checkpoint_name)
-++
-++		train_iter = (start_epoch - 1) * (
-++		len(train_loader.dataset) // train_batch_size
-++		) + 1
-++
-++		print("Starting training at epoch = {}, iter = {}".format(start_epoch, train_iter))
-++
-++		# Setup tensorboard writing
-++		summary_writer = SummaryWriter(logdir)
-++
-++		train_reports = []
-++		report_all = {}
-++		report_all_val = {}
-++
-++		# Saving model at epoch 0 before training
-++		print("saving model at epoch 0 before training ... ")
-++		save_checkpoint(checkpoint_name, 0, model, model_opt, loss=0.0)
-++		print("finished saving model at epoch 0 before training")
-++
-++		num_params = param_count(model)
-++		print(f"Number of model parameters: {num_params}")
-++
-++		# Training
-++		start_t = time.time()
-++
-++		total_train_iters = len(train_loader) * config.train_epochs
-++		iters_per_eval = max(1, int(total_train_iters / config.total_evaluations))
-++		# print('batch',train_batch_size)
-++		# print('ntrain',n_train)
-++		# assert (
-++		# 	n_train % min(train_batch_size, n_train) == 0
-++		# ), "Batch size doesn't divide dataset size. Can be inaccurate for loss computation (see below)."
-++
-++		training_failed = False
-++		best_val_loss_so_far = 1e7
-++
-++		for epoch in tqdm(range(start_epoch, config.train_epochs + 1)):
-++			model.train()
-++
-++			for batch_idx, data_dict in enumerate(train_loader): # Loop over batched data
-++
-++				labels = data_dict['label']
-++				data = data_dict['data']
-++
-++				# send data to device
-++				data = nested_to(data,device,torch.float32)
-++				# One-hot encode the data labels
-++				labels_tensor = torch.zeros((len(labels), 2))
-++				for i, label in enumerate(labels):
-++					labels_tensor[i, label] = 1
-++
-++				model_output = model(data) # evaluate model
-++
-++				loss = loss_func(model_output, labels_tensor) # compute loss
-++				outputs = AttrDict({"loss": loss, "prediction": model_output})
-++				outputs.reports = AttrDict({"cross_entropy": loss})
-++
-++				if torch.isnan(outputs.loss): # check for failure in training
-++					if not training_failed:
-++						epoch_of_nan = epoch
-++					if (epoch > epoch_of_nan + 1) and training_failed:
-++						raise ValueError("Loss Nan-ed.")
-++					training_failed = True
-++
-++				model_opt.zero_grad()
-++				outputs.loss.backward(retain_graph=False)
-++
-++				model_opt.step() # move optimizer forward
-++
-++				train_reports.append(parse_reports_cpu(outputs.reports))
-++
-++				if config.log_train_values:
-++					reports = parse_reports(outputs.reports)
-++					if batch_idx % config.report_loss_every == 0:
-++						log_tensorboard(summary_writer, train_iter, reports, "train/")
-++						print_reports(
-++							reports,
-++							start_t,
-++							epoch,
-++							batch_idx,
-++							len(train_loader.dataset) // train_batch_size,
-++							prefix="train",
-++						)
-++						log_tensorboard(
-++							summary_writer,
-++							train_iter,
-++							{"lr": model_opt.param_groups[0]["lr"]},
-++							"hyperparams/",
-++						)
-++				# Logging and evaluation
-++				if (
-++					train_iter % iters_per_eval == 0 or (train_iter == total_train_iters)
-++				) and config.log_val_test:  # batch_idx % config.evaluate_every == 0:
-++					model.eval()
-++					with torch.no_grad():
-++						reports = evaluate(model, test_loader, device,fold = k,headings = loader_k['test_headings'])
-++						# print("REPORTS",reports)
-++						reports = parse_reports(reports)
-++						reports["time"] = time.time() - start_t
-++						if report_all == {}:
-++							report_all = deepcopy(reports)
-++
-++							for d in reports.keys():
-++								report_all[d] = [report_all[d]]
-++						else:
-++							for d in reports.keys():
-++								report_all[d].append(reports[d])
-++
-++						log_tensorboard(summary_writer, train_iter, reports, "test/")
-++						print_reports(
-++							reports,
-++							start_t,
-++							epoch,
-++							batch_idx,
-++							len(train_loader.dataset) // config.batch_size,
-++							prefix="test",
-++						)
-++
-++						# repeat for validation data
-++						reports = evaluate(model, val_loader, device,fold = k,headings = loader_k['test_headings'])
-++						reports = parse_reports(reports)
-++						reports["time"] = time.time() - start_t
-++						if report_all_val == {}:
-++							report_all_val = deepcopy(reports)
-++
-++							for d in reports.keys():
-++								report_all_val[d] = [report_all_val[d]]
-++						else:
-++							for d in reports.keys():
-++								report_all_val[d].append(reports[d])
-++
-++						log_tensorboard(summary_writer, train_iter, reports, "val/")
-++						print_reports(
-++							reports,
-++							start_t,
-++							epoch,
-++							batch_idx,
-++							len(train_loader.dataset) // config.batch_size,
-++							prefix="val",
-++						)
-++
-++						if report_all_val["cross_entropy"][-1] < best_val_loss_so_far:
-++							save_checkpoint(
-++								checkpoint_name,
-++								f"early_stop",
-++								model,
-++								model_opt,
-++								loss=outputs.loss,
-++							)
-++							best_val_loss_so_far = report_all_val["cross_entropy"][-1]
-++
-++					model.train()
-++
-++				train_iter += 1
-++
-++			if epoch % config.save_check_points == 0:
-++				save_checkpoint(
-++					checkpoint_name, train_iter, model, model_opt, loss=outputs.loss
-++				)
-++
-++		dd.io.save(fold_dir + "/results_dict_train.h5", train_reports)
-++		dd.io.save(fold_dir + "/results_dict.h5", report_all)
-++		dd.io.save(fold_dir + "/results_dict_val.h5", report_all_val)
-++
-++	# always save final model
-++	save_checkpoint(checkpoint_name, train_iter, model, model_opt, loss=outputs.loss)
-++
-++	
-++	if config.save_test_predictions:
-++		pass
-++		# print("Starting to make model predictions on test sets for *final model*.")
-++		# for chunk_len in [5, 100]:
-++		#     start_t_preds = time.time()
-++		#     data_config = SimpleNamespace(
-++		#         **{
-++		#             **config.__dict__["__flags"],
-++		#             **{"chunk_len": chunk_len, "batch_size": 500},
-++		#         }
-++		#     )
-++		#     dataloaders, data_name = fet.load(config.data_config, config=data_config)
-++		#     test_loader_preds = dataloaders["test"]
-++
-++		#     torch.cuda.empty_cache()
-++		#     with torch.no_grad():
-++		#         preds = []
-++		#         true = []
-++		#         num_datapoints = 0
-++		#         for idx, d in enumerate(test_loader_preds):
-++		#             true.append(d[-1])
-++		#             d = nested_to(d, device, torch.float32)
-++		#             outputs = model(d)
-++
-++		#             pred_zs = outputs.prediction
-++		#             preds.append(pred_zs)
-++
-++		#             num_datapoints += len(pred_zs)
-++
-++		#             if num_datapoints >= 2000:
-++		#                 break
-+ 
-+-config = forge.config()
-++		#         preds = torch.cat(preds, dim=0).cpu()
-++		#         true = torch.cat(true, dim=0).cpu()
-+ 
-+-# Prepare environment
-+-logdir = osp.join(config.results_dir, config.run_name)
-+-logdir, resume_checkpoint = fet.init_checkpoint(
-+-    logdir, config.data_config, config.model_config, config.resume)
-+-checkpoint_name = osp.join(logdir, 'model.ckpt')
-++		#         save_dir = osp.join(logdir, f"traj_preds_{chunk_len}_steps_2k_test.pt")
-++		#         torch.save(preds, save_dir)
-+ 
-++		#         save_dir = osp.join(logdir, f"traj_true_{chunk_len}_steps_2k_test.pt")
-++		#         torch.save(true, save_dir)
-+ 
-+-print(logdir)
-++		#         print(
-++		#             f"Completed making test predictions for chunk_len = {chunk_len} in {time.time() - start_t_preds:.2f} seconds."
-++		#         )	
-++		
-+ 
-++if __name__ == "__main__":
-++	main()
-+ 
-diff --git a/checkpoints/feedforward/1/penn_dataset.py b/checkpoints/feedforward/1/penn_dataset.py
-index aa2f5a0..7f5a4fc 100644
---- a/checkpoints/feedforward/1/penn_dataset.py
-+++ b/checkpoints/feedforward/1/penn_dataset.py
-@@ -15,6 +15,7 @@ from forge import flags
- # aspects of data managmement
- flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
- flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-+flags.DEFINE_boolean("cross_validate",False,"Do K-fold cross-validation")
- 
- # Job management
- # flags.DEFINE_integer("batch size",5,"training batch size")
-@@ -109,15 +110,15 @@ def load(config):
-         
-         # set up training DataLoader
-         train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, n_train),num_workers=0,shuffle = True)
-+        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
- 
-         # set up test DataLoader
-         test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, n_test),num_workers=0,shuffle = True)
-+        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
- 
-         # set up val DataLoader
-         val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, n_val),num_workers=0,shuffle = True)
-+        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-         
- 
-         dataloaders = {'train':train_loader, 
-@@ -125,8 +126,12 @@ def load(config):
-                        'val':val_loader,
-                        'train_inds':train_ind,
-                        'test_inds':test_ind,
--                       'n_val':n_val
-+                       'n_val':n_val,
-+                       'test_headings':list(HEADINGS[test_ind])
-                       }
-         kf_dataloaders.append(dataloaders)
- 
-+        if not config.cross_validate:
-+        	break
-+
-     return kf_dataloaders
-diff --git a/georgehulsey_2024.pdf b/georgehulsey_2024.pdf
-deleted file mode 100644
-index 1ab17f6..0000000
-Binary files a/georgehulsey_2024.pdf and /dev/null differ
-diff --git a/penn_dataset.py b/penn_dataset.py
-index aa2f5a0..7f5a4fc 100644
---- a/penn_dataset.py
-+++ b/penn_dataset.py
-@@ -15,6 +15,7 @@ from forge import flags
- # aspects of data managmement
- flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
- flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-+flags.DEFINE_boolean("cross_validate",False,"Do K-fold cross-validation")
- 
- # Job management
- # flags.DEFINE_integer("batch size",5,"training batch size")
-@@ -109,15 +110,15 @@ def load(config):
-         
-         # set up training DataLoader
-         train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, n_train),num_workers=0,shuffle = True)
-+        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
- 
-         # set up test DataLoader
-         test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, n_test),num_workers=0,shuffle = True)
-+        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
- 
-         # set up val DataLoader
-         val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, n_val),num_workers=0,shuffle = True)
-+        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-         
- 
-         dataloaders = {'train':train_loader, 
-@@ -125,8 +126,12 @@ def load(config):
-                        'val':val_loader,
-                        'train_inds':train_ind,
-                        'test_inds':test_ind,
--                       'n_val':n_val
-+                       'n_val':n_val,
-+                       'test_headings':list(HEADINGS[test_ind])
-                       }
-         kf_dataloaders.append(dataloaders)
- 
-+        if not config.cross_validate:
-+        	break
-+
-     return kf_dataloaders
-diff --git a/testing.ipynb b/testing.ipynb
-index e5a167b..0110538 100644
---- a/testing.ipynb
-+++ b/testing.ipynb
-@@ -2,7 +2,7 @@
-  "cells": [
-   {
-    "cell_type": "code",
--   "execution_count": 1,
-+   "execution_count": 4,
-    "id": "4dee7ff1-01a4-4038-b493-9729ff3693f7",
-    "metadata": {},
-    "outputs": [],
-@@ -23,7 +23,7 @@
-   },
-   {
-    "cell_type": "code",
--   "execution_count": 2,
-+   "execution_count": 6,
-    "id": "cad0fdc8-5c35-4610-bba3-b71e60dc1b98",
-    "metadata": {},
-    "outputs": [],
-@@ -35,7 +35,7 @@
-   },
-   {
-    "cell_type": "code",
--   "execution_count": 3,
-+   "execution_count": 7,
-    "id": "ce1b936b-8a7c-426e-a3aa-3c1c38f645de",
-    "metadata": {},
-    "outputs": [
-@@ -54,8 +54,8 @@
-   },
-   {
-    "cell_type": "code",
--   "execution_count": 9,
--   "id": "e862b7e2-57f5-44bf-bcf1-a91160ba66cc",
-+   "execution_count": 5,
-+   "id": "4469cddf-4dac-4468-be88-241d440401c3",
-    "metadata": {},
-    "outputs": [
-     {
-@@ -67,35 +67,98 @@
-     }
-    ],
-    "source": [
--    "model = fet.load(\"basic_feedforward.py\",config)"
-+    "model,modelname = fet.load(\"basic_feedforward.py\",config)"
-    ]
-   },
-   {
-    "cell_type": "code",
--   "execution_count": 10,
--   "id": "07e0b160-d5d1-4e54-b4a7-ccaf2224598a",
-+   "execution_count": 13,
-+   "id": "7c9a9fe9-f5e8-456a-b964-4be13027725b",
-    "metadata": {},
-    "outputs": [
-     {
-      "data": {
-       "text/plain": [
--       "PerceptronNN(\n",
--       "  (fc1): Linear(in_features=39, out_features=128, bias=True)\n",
--       "  (fc2): Linear(in_features=128, out_features=64, bias=True)\n",
--       "  (fc3): Linear(in_features=64, out_features=64, bias=True)\n",
--       "  (fc4): Linear(in_features=64, out_features=2, bias=True)\n",
--       ")"
-+       "array([114170,    904])"
-       ]
-      },
--     "execution_count": 10,
-+     "execution_count": 13,
-      "metadata": {},
-      "output_type": "execute_result"
-     }
-    ],
-    "source": [
--    "model"
-+    "np.bincount(loaddat[0]['train'].dataset.all_labels)"
-    ]
-   },
-+  {
-+   "cell_type": "code",
-+   "execution_count": 1,
-+   "id": "e862b7e2-57f5-44bf-bcf1-a91160ba66cc",
-+   "metadata": {},
-+   "outputs": [
-+    {
-+     "ename": "FileNotFoundError",
-+     "evalue": "[Errno 2] Unable to open file (unable to open file: name = './checkpoints/feedforward/2/data_fold1/results_dict.h5', errno = 2, error message = 'No such file or directory', flags = 0, o_flags = 0)",
-+     "output_type": "error",
-+     "traceback": [
-+      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
-+      "\u001b[0;31mFileNotFoundError\u001b[0m                         Traceback (most recent call last)",
-+      "Cell \u001b[0;32mIn[1], line 5\u001b[0m\n\u001b[1;32m      3\u001b[0m file_path \u001b[38;5;241m=\u001b[39m \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124m./checkpoints/feedforward/2/data_fold1/results_dict.h5\u001b[39m\u001b[38;5;124m\"\u001b[39m\n\u001b[1;32m      4\u001b[0m \u001b[38;5;66;03m# Replace 'your_file.h5' with the actual path to your file\u001b[39;00m\n\u001b[0;32m----> 5\u001b[0m f \u001b[38;5;241m=\u001b[39m  \u001b[43mh5py\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mFile\u001b[49m\u001b[43m(\u001b[49m\u001b[43mfile_path\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[38;5;124;43mr\u001b[39;49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[43m)\u001b[49m \n\u001b[1;32m      7\u001b[0m     \u001b[38;5;66;03m# Get information about the data stored in the file\u001b[39;00m\n\u001b[1;32m      8\u001b[0m \u001b[38;5;28mprint\u001b[39m(\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mKeys:\u001b[39m\u001b[38;5;124m\"\u001b[39m, \u001b[38;5;28mlist\u001b[39m(f\u001b[38;5;241m.\u001b[39mkeys()))\n",
-+      "File \u001b[0;32m/Applications/miniconda3/envs/lietransformer/lib/python3.9/site-packages/h5py/_hl/files.py:562\u001b[0m, in \u001b[0;36mFile.__init__\u001b[0;34m(self, name, mode, driver, libver, userblock_size, swmr, rdcc_nslots, rdcc_nbytes, rdcc_w0, track_order, fs_strategy, fs_persist, fs_threshold, fs_page_size, page_buf_size, min_meta_keep, min_raw_keep, locking, alignment_threshold, alignment_interval, meta_block_size, **kwds)\u001b[0m\n\u001b[1;32m    553\u001b[0m     fapl \u001b[38;5;241m=\u001b[39m make_fapl(driver, libver, rdcc_nslots, rdcc_nbytes, rdcc_w0,\n\u001b[1;32m    554\u001b[0m                      locking, page_buf_size, min_meta_keep, min_raw_keep,\n\u001b[1;32m    555\u001b[0m                      alignment_threshold\u001b[38;5;241m=\u001b[39malignment_threshold,\n\u001b[1;32m    556\u001b[0m                      alignment_interval\u001b[38;5;241m=\u001b[39malignment_interval,\n\u001b[1;32m    557\u001b[0m                      meta_block_size\u001b[38;5;241m=\u001b[39mmeta_block_size,\n\u001b[1;32m    558\u001b[0m                      \u001b[38;5;241m*\u001b[39m\u001b[38;5;241m*\u001b[39mkwds)\n\u001b[1;32m    559\u001b[0m     fcpl \u001b[38;5;241m=\u001b[39m make_fcpl(track_order\u001b[38;5;241m=\u001b[39mtrack_order, fs_strategy\u001b[38;5;241m=\u001b[39mfs_strategy,\n\u001b[1;32m    560\u001b[0m                      fs_persist\u001b[38;5;241m=\u001b[39mfs_persist, fs_threshold\u001b[38;5;241m=\u001b[39mfs_threshold,\n\u001b[1;32m    561\u001b[0m                      fs_page_size\u001b[38;5;241m=\u001b[39mfs_page_size)\n\u001b[0;32m--> 562\u001b[0m     fid \u001b[38;5;241m=\u001b[39m \u001b[43mmake_fid\u001b[49m\u001b[43m(\u001b[49m\u001b[43mname\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mmode\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43muserblock_size\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mfapl\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mfcpl\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mswmr\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43mswmr\u001b[49m\u001b[43m)\u001b[49m\n\u001b[1;32m    564\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;28misinstance\u001b[39m(libver, \u001b[38;5;28mtuple\u001b[39m):\n\u001b[1;32m    565\u001b[0m     \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_libver \u001b[38;5;241m=\u001b[39m libver\n",
-+      "File \u001b[0;32m/Applications/miniconda3/envs/lietransformer/lib/python3.9/site-packages/h5py/_hl/files.py:235\u001b[0m, in \u001b[0;36mmake_fid\u001b[0;34m(name, mode, userblock_size, fapl, fcpl, swmr)\u001b[0m\n\u001b[1;32m    233\u001b[0m     \u001b[38;5;28;01mif\u001b[39;00m swmr \u001b[38;5;129;01mand\u001b[39;00m swmr_support:\n\u001b[1;32m    234\u001b[0m         flags \u001b[38;5;241m|\u001b[39m\u001b[38;5;241m=\u001b[39m h5f\u001b[38;5;241m.\u001b[39mACC_SWMR_READ\n\u001b[0;32m--> 235\u001b[0m     fid \u001b[38;5;241m=\u001b[39m \u001b[43mh5f\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mopen\u001b[49m\u001b[43m(\u001b[49m\u001b[43mname\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mflags\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mfapl\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43mfapl\u001b[49m\u001b[43m)\u001b[49m\n\u001b[1;32m    236\u001b[0m \u001b[38;5;28;01melif\u001b[39;00m mode \u001b[38;5;241m==\u001b[39m \u001b[38;5;124m'\u001b[39m\u001b[38;5;124mr+\u001b[39m\u001b[38;5;124m'\u001b[39m:\n\u001b[1;32m    237\u001b[0m     fid \u001b[38;5;241m=\u001b[39m h5f\u001b[38;5;241m.\u001b[39mopen(name, h5f\u001b[38;5;241m.\u001b[39mACC_RDWR, fapl\u001b[38;5;241m=\u001b[39mfapl)\n",
-+      "File \u001b[0;32mh5py/_objects.pyx:54\u001b[0m, in \u001b[0;36mh5py._objects.with_phil.wrapper\u001b[0;34m()\u001b[0m\n",
-+      "File \u001b[0;32mh5py/_objects.pyx:55\u001b[0m, in \u001b[0;36mh5py._objects.with_phil.wrapper\u001b[0;34m()\u001b[0m\n",
-+      "File \u001b[0;32mh5py/h5f.pyx:102\u001b[0m, in \u001b[0;36mh5py.h5f.open\u001b[0;34m()\u001b[0m\n",
-+      "\u001b[0;31mFileNotFoundError\u001b[0m: [Errno 2] Unable to open file (unable to open file: name = './checkpoints/feedforward/2/data_fold1/results_dict.h5', errno = 2, error message = 'No such file or directory', flags = 0, o_flags = 0)"
-+     ]
-+    }
-+   ],
-+   "source": [
-+    "import h5py\n",
-+    "\n",
-+    "file_path = \"./checkpoints/feedforward/2/data_fold1/results_dict.h5\"\n",
-+    "# Replace 'your_file.h5' with the actual path to your file\n",
-+    "f =  h5py.File(file_path, 'r') \n",
-+    "\n",
-+    "    # Get information about the data stored in the file\n",
-+    "print(\"Keys:\", list(f.keys()))  # List the top-level datasets and groups\n",
-+    "\n",
-+    "    # # Access a dataset by its name\n",
-+    "    # dataset_name = \"your_dataset_name\"\n",
-+    "    # if dataset_name in f:\n",
-+    "    #     dataset = f[dataset_name]\n",
-+    "    #     print(\"Dataset shape:\", dataset.shape)\n",
-+    "    #     print(\"Dataset dtype:\", dataset.dtype)\n",
-+    "\n",
-+    "    #     # Access the data as a NumPy array\n",
-+    "    #     data = dataset[:]  # Read the entire dataset\n",
-+    "\n",
-+    "    #     # You can now work with the data as needed, for example:\n",
-+    "    #     # Perform calculations, visualizations, etc.\n",
-+    "    # else:\n",
-+    "    #     print(f\"Dataset '{dataset_name}' not found in the file.\")"
-+   ]
-+  },
-+  {
-+   "cell_type": "code",
-+   "execution_count": 13,
-+   "id": "07e0b160-d5d1-4e54-b4a7-ccaf2224598a",
-+   "metadata": {},
-+   "outputs": [
-+    {
-+     "data": {
-+      "text/plain": [
-+       "<generator object Module.parameters at 0x3007207b0>"
-+      ]
-+     },
-+     "execution_count": 13,
-+     "metadata": {},
-+     "output_type": "execute_result"
-+    }
-+   ],
-+   "source": []
-+  },
-   {
-    "cell_type": "code",
-    "execution_count": null,
-diff --git a/train.py b/train.py
-index c266102..afff727 100644
---- a/train.py
-+++ b/train.py
-@@ -1,49 +1,447 @@
- from os import path as osp
-+import os
-+import numpy as np
-+import time
- 
- import torch
-+import torch.nn as nn
- import torch.nn.functional as F
- import torch.optim as optim
--
--import numpy as np
-+from torch.utils.tensorboard import SummaryWriter
- 
- import forge
- from forge import flags
- import forge.experiment_tools as fet
- 
-+from train_tools import (
-+	log_tensorboard,
-+	parse_reports,
-+	parse_reports_cpu,
-+	print_reports,
-+	load_checkpoint,
-+	save_checkpoint,
-+	nested_to,
-+	param_count,
-+)
-+
-+from copy import deepcopy
-+from attrdict import AttrDict
-+import deepdish as dd
-+from tqdm import tqdm
-+
-+# For reproducibility while researching, but might affect speed!
-+torch.backends.cudnn.deterministic = True
-+torch.backends.cudnn.benchmark = False
-+torch.manual_seed(0)
-+
- 
- # Job config
- flags.DEFINE_string('data_config', 'penn_dataset.py',
--                    'Path to a data config file.')
-+					'Path to a data config file.')
- flags.DEFINE_string('model_config', 'basic_feedforward.py',
--                    'Path to a model config file.')
-+					'Path to a model config file.')
- flags.DEFINE_string('results_dir', 'checkpoints',
--                    'Top directory for all experimental results.')
-+					'Top directory for all experimental results.')
- flags.DEFINE_string('run_name', 'feedforward',
--                    'Name of this job and name of results folder.')
-+					'Name of this job and name of results folder.')
- flags.DEFINE_boolean('resume', False, 'Tries to resume a job if True.')
- 
- # Logging config
- flags.DEFINE_integer('report_loss_every', 50,
--                     'Number of iterations between reporting minibatch loss.')
--flags.DEFINE_integer('train_epochs', 20, 'Maximum number of training epochs.')
-+					 'Number of iterations between reporting minibatch loss.')
-+flags.DEFINE_integer('train_epochs', 100, 'Maximum number of training epochs.')
-+flags.DEFINE_integer(
-+	"save_check_points",
-+	50,
-+	"frequency with which to save checkpoints, in number of epoches.",
-+)
-+flags.DEFINE_boolean("log_train_values", True, "Logs train values if True.")
-+flags.DEFINE_integer(
-+	"total_evaluations",
-+	100,
-+	"Maximum number of evaluations on test and validation data during training.",
-+)
-+flags.DEFINE_boolean(
-+	"save_test_predictions",
-+	False,
-+	"Makes and saves test predictions on one or more test sets (e.g. 5-step and 100-step predictions) at the end of training.",
-+)
-+flags.DEFINE_boolean(
-+    "log_val_test", True, "Turns off computation of validation and test errors."
-+)
- 
- # Experiment config
- flags.DEFINE_integer('batch_size', 100, 'Mini-batch size.')
--flags.DEFINE_float('learning_rate', 1e-5, 'SGD learning rate.')
-+flags.DEFINE_float("learning_rate", 1e-4, "Adam learning rate.")
-+flags.DEFINE_float("beta1", 0.9, "Adam Beta 1 parameter")
-+flags.DEFINE_float("beta2", 0.999, "Adam Beta 2 parameter")
- 
- # Specific config options
- flags.DEFINE_integer("input_size",39,"Input shape to model")
- 
-+#########################################################################################
-+
-+def evaluate(model, loader, device,fold = 0,headings = [],loss_func = nn.CrossEntropyLoss()):
-+	reports = None
-+	for data in loader:
-+		labels = data['label']
-+		inputs = nested_to(data['data'],device,torch.float32)
-+		
-+		labels_tensor = torch.zeros((len(labels), 2))
-+		for i, label in enumerate(labels):
-+			labels_tensor[i, label] = 1
-+
-+		model_output = model(inputs) # evaluate model
-+
-+		loss = loss_func(model_output, labels_tensor) # compute loss
-+		outputs = AttrDict({"loss": loss, "prediction": model_output,'data_fold':fold})
-+		outputs.reports = AttrDict({"cross_entropy": loss})
-+
-+		if reports is None:
-+			reports = {k: v.detach().clone().cpu() for k, v in outputs.reports.items()}
-+		else:
-+			for k, v in outputs.reports.items():
-+				reports[k] += v.detach().clone().cpu()
-+
-+	for k, v in reports.items():
-+		reports[k] = v / len(
-+			loader
-+		)  # SZ: note this can be slightly incorrect if mini-batch sizes vary (if batch_size doesn't divide train_size), but approximately correct.
-+
-+	# reports['test_headings'] = np.array(headings)
-+
-+	return reports
-+
-+def main():
-+
-+	config = forge.config()
-+
-+	# Set device
-+	if torch.cuda.is_available():
-+		device = f"cuda:{config.device}"
-+		torch.cuda.set_device(device)
-+	else:
-+		device = "cpu" # can change this to MPS on M1 Macs
-+
-+	# Load data
-+	data_name = "penn_data"
-+	kfold_loaders = fet.load(config.data_config, config)
-+
-+	# Load model
-+	model,model_name = fet.load(config.model_config, config)
-+	model = model.to(device)
-+
-+	# Prepare environment
-+	params_in_run_name = [
-+		("batch_size", "bs"),
-+		("learning_rate", "lr"),
-+		("n_train", "ntrain"),
-+		("include_coords",'inclx'),
-+		("input_size",'inpsize'),
-+		("cross_validate",'crval')
-+	]
-+
-+	run_name = ""  # config.run_name
-+	for config_param in params_in_run_name:
-+		attr = config_param[0]
-+		abbrev = config_param[1]
-+
-+		if hasattr(config, attr):
-+			run_name += abbrev
-+			run_name += str(getattr(config, attr))
-+			run_name += "_"
-+
-+	results_folder_name = osp.join(
-+		data_name,
-+		model_name,
-+		config.run_name,
-+		run_name,
-+	)
-+
-+	# Prepare environment
-+	logdir = osp.join(config.results_dir, results_folder_name.replace(".", "_"))
-+	logdir, resume_checkpoint = fet.init_checkpoint(
-+		logdir, config.data_config, config.model_config, config.resume)
-+
-+	print("Checkpoint directory:",logdir)
-+
-+	# Print flags
-+	fet.print_flags()
-+	# Print model info
-+	print(model)
-+
-+	# Setup optimizer
-+	model_params = model.parameters()
-+	opt_learning_rate = config.learning_rate
-+	model_opt = torch.optim.Adam(
-+		model_params, lr=opt_learning_rate, betas=(config.beta1, config.beta2)
-+	)
-+	print("Model Optimizer:")
-+	print(model_opt)
-+
-+	# Try to restore model and optimizer from checkpoint
-+	if resume_checkpoint is not None:
-+		start_epoch = load_checkpoint(resume_checkpoint, model, model_opt)
-+	else:
-+		start_epoch = 1
-+
-+	n_folds = len(kfold_loaders)
-+	print("Doing {}-fold cross-validation.".format(n_folds))
-+
-+	# KFOLD TRAINING LOOP
-+	for k,loader_k in enumerate(kfold_loaders): # loop over data splits
-+
-+		print("Training fold {}...".format(k+1))
-+
-+		# load the training data
-+		train_loader = loader_k["train"]
-+		n_train = len(train_loader.dataset)
-+		train_batch_size = train_loader.batch_size
-+
-+		# load testing, validation
-+		test_loader = loader_k["test"]
-+		n_test = len(test_loader.dataset)
-+		val_loader = loader_k["val"]
-+		n_val = len(val_loader.dataset)
-+
-+		train_class_counts = np.bincount(train_loader.dataset.all_labels)
-+		train_total_counts = sum(train_class_counts)
-+		class_weight = torch.tensor(1.0 / train_class_counts) * train_total_counts / 2.0
-+
-+		loss_func = nn.CrossEntropyLoss(weight = class_weight) # define reweighted loss function
-+				
-+		# create folder for this data split
-+		fold_dir = osp.join(logdir,"data_fold{}".format(k+1))
-+		fold_dir_exists = osp.exists(fold_dir)
-+		if not fold_dir_exists:
-+			if config.resume:
-+				raise ValueError("Can't resume when the checkpoint/fold dir '{}' doesn't exist.".format(fold_dir))
-+			else:
-+				os.makedirs(fold_dir)
-+		checkpoint_name = osp.join(fold_dir, 'model_fold{}.ckpt'.format(k+1))
-+
-+		# keep track of which data is test data for a given Kfold data split
-+		test_headings = loader_k['test_headings']
-+		headingsFile = osp.join(fold_dir,"test_headings.txt")
-+		with open(headingsFile,'w') as headfile:
-+			for heading in test_headings:
-+				headfile.write(heading+'\n')
-+
-+		# print(checkpoint_name)
-+
-+		train_iter = (start_epoch - 1) * (
-+		len(train_loader.dataset) // train_batch_size
-+		) + 1
-+
-+		print("Starting training at epoch = {}, iter = {}".format(start_epoch, train_iter))
-+
-+		# Setup tensorboard writing
-+		summary_writer = SummaryWriter(logdir)
-+
-+		train_reports = []
-+		report_all = {}
-+		report_all_val = {}
-+
-+		# Saving model at epoch 0 before training
-+		print("saving model at epoch 0 before training ... ")
-+		save_checkpoint(checkpoint_name, 0, model, model_opt, loss=0.0)
-+		print("finished saving model at epoch 0 before training")
-+
-+		num_params = param_count(model)
-+		print(f"Number of model parameters: {num_params}")
-+
-+		# Training
-+		start_t = time.time()
-+
-+		total_train_iters = len(train_loader) * config.train_epochs
-+		iters_per_eval = max(1, int(total_train_iters / config.total_evaluations))
-+		# print('batch',train_batch_size)
-+		# print('ntrain',n_train)
-+		# assert (
-+		# 	n_train % min(train_batch_size, n_train) == 0
-+		# ), "Batch size doesn't divide dataset size. Can be inaccurate for loss computation (see below)."
-+
-+		training_failed = False
-+		best_val_loss_so_far = 1e7
-+
-+		for epoch in tqdm(range(start_epoch, config.train_epochs + 1)):
-+			model.train()
-+
-+			for batch_idx, data_dict in enumerate(train_loader): # Loop over batched data
-+
-+				labels = data_dict['label']
-+				data = data_dict['data']
-+
-+				# send data to device
-+				data = nested_to(data,device,torch.float32)
-+				# One-hot encode the data labels
-+				labels_tensor = torch.zeros((len(labels), 2))
-+				for i, label in enumerate(labels):
-+					labels_tensor[i, label] = 1
-+
-+				model_output = model(data) # evaluate model
-+
-+				loss = loss_func(model_output, labels_tensor) # compute loss
-+				outputs = AttrDict({"loss": loss, "prediction": model_output})
-+				outputs.reports = AttrDict({"cross_entropy": loss})
-+
-+				if torch.isnan(outputs.loss): # check for failure in training
-+					if not training_failed:
-+						epoch_of_nan = epoch
-+					if (epoch > epoch_of_nan + 1) and training_failed:
-+						raise ValueError("Loss Nan-ed.")
-+					training_failed = True
-+
-+				model_opt.zero_grad()
-+				outputs.loss.backward(retain_graph=False)
-+
-+				model_opt.step() # move optimizer forward
-+
-+				train_reports.append(parse_reports_cpu(outputs.reports))
-+
-+				if config.log_train_values:
-+					reports = parse_reports(outputs.reports)
-+					if batch_idx % config.report_loss_every == 0:
-+						log_tensorboard(summary_writer, train_iter, reports, "train/")
-+						print_reports(
-+							reports,
-+							start_t,
-+							epoch,
-+							batch_idx,
-+							len(train_loader.dataset) // train_batch_size,
-+							prefix="train",
-+						)
-+						log_tensorboard(
-+							summary_writer,
-+							train_iter,
-+							{"lr": model_opt.param_groups[0]["lr"]},
-+							"hyperparams/",
-+						)
-+				# Logging and evaluation
-+				if (
-+					train_iter % iters_per_eval == 0 or (train_iter == total_train_iters)
-+				) and config.log_val_test:  # batch_idx % config.evaluate_every == 0:
-+					model.eval()
-+					with torch.no_grad():
-+						reports = evaluate(model, test_loader, device,fold = k,headings = loader_k['test_headings'])
-+						# print("REPORTS",reports)
-+						reports = parse_reports(reports)
-+						reports["time"] = time.time() - start_t
-+						if report_all == {}:
-+							report_all = deepcopy(reports)
-+
-+							for d in reports.keys():
-+								report_all[d] = [report_all[d]]
-+						else:
-+							for d in reports.keys():
-+								report_all[d].append(reports[d])
-+
-+						log_tensorboard(summary_writer, train_iter, reports, "test/")
-+						print_reports(
-+							reports,
-+							start_t,
-+							epoch,
-+							batch_idx,
-+							len(train_loader.dataset) // config.batch_size,
-+							prefix="test",
-+						)
-+
-+						# repeat for validation data
-+						reports = evaluate(model, val_loader, device,fold = k,headings = loader_k['test_headings'])
-+						reports = parse_reports(reports)
-+						reports["time"] = time.time() - start_t
-+						if report_all_val == {}:
-+							report_all_val = deepcopy(reports)
-+
-+							for d in reports.keys():
-+								report_all_val[d] = [report_all_val[d]]
-+						else:
-+							for d in reports.keys():
-+								report_all_val[d].append(reports[d])
-+
-+						log_tensorboard(summary_writer, train_iter, reports, "val/")
-+						print_reports(
-+							reports,
-+							start_t,
-+							epoch,
-+							batch_idx,
-+							len(train_loader.dataset) // config.batch_size,
-+							prefix="val",
-+						)
-+
-+						if report_all_val["cross_entropy"][-1] < best_val_loss_so_far:
-+							save_checkpoint(
-+								checkpoint_name,
-+								f"early_stop",
-+								model,
-+								model_opt,
-+								loss=outputs.loss,
-+							)
-+							best_val_loss_so_far = report_all_val["cross_entropy"][-1]
-+
-+					model.train()
-+
-+				train_iter += 1
-+
-+			if epoch % config.save_check_points == 0:
-+				save_checkpoint(
-+					checkpoint_name, train_iter, model, model_opt, loss=outputs.loss
-+				)
-+
-+		dd.io.save(fold_dir + "/results_dict_train.h5", train_reports)
-+		dd.io.save(fold_dir + "/results_dict.h5", report_all)
-+		dd.io.save(fold_dir + "/results_dict_val.h5", report_all_val)
-+
-+	# always save final model
-+	save_checkpoint(checkpoint_name, train_iter, model, model_opt, loss=outputs.loss)
-+
-+	
-+	if config.save_test_predictions:
-+		pass
-+		# print("Starting to make model predictions on test sets for *final model*.")
-+		# for chunk_len in [5, 100]:
-+		#     start_t_preds = time.time()
-+		#     data_config = SimpleNamespace(
-+		#         **{
-+		#             **config.__dict__["__flags"],
-+		#             **{"chunk_len": chunk_len, "batch_size": 500},
-+		#         }
-+		#     )
-+		#     dataloaders, data_name = fet.load(config.data_config, config=data_config)
-+		#     test_loader_preds = dataloaders["test"]
-+
-+		#     torch.cuda.empty_cache()
-+		#     with torch.no_grad():
-+		#         preds = []
-+		#         true = []
-+		#         num_datapoints = 0
-+		#         for idx, d in enumerate(test_loader_preds):
-+		#             true.append(d[-1])
-+		#             d = nested_to(d, device, torch.float32)
-+		#             outputs = model(d)
-+
-+		#             pred_zs = outputs.prediction
-+		#             preds.append(pred_zs)
-+
-+		#             num_datapoints += len(pred_zs)
-+
-+		#             if num_datapoints >= 2000:
-+		#                 break
- 
--config = forge.config()
-+		#         preds = torch.cat(preds, dim=0).cpu()
-+		#         true = torch.cat(true, dim=0).cpu()
- 
--# Prepare environment
--logdir = osp.join(config.results_dir, config.run_name)
--logdir, resume_checkpoint = fet.init_checkpoint(
--    logdir, config.data_config, config.model_config, config.resume)
--checkpoint_name = osp.join(logdir, 'model.ckpt')
-+		#         save_dir = osp.join(logdir, f"traj_preds_{chunk_len}_steps_2k_test.pt")
-+		#         torch.save(preds, save_dir)
- 
-+		#         save_dir = osp.join(logdir, f"traj_true_{chunk_len}_steps_2k_test.pt")
-+		#         torch.save(true, save_dir)
- 
--print(logdir)
-+		#         print(
-+		#             f"Completed making test predictions for chunk_len = {chunk_len} in {time.time() - start_t_preds:.2f} seconds."
-+		#         )	
-+		
- 
-+if __name__ == "__main__":
-+	main()
- 
diff --git a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_/2/penn_dataset.py b/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_/2/penn_dataset.py
deleted file mode 100644
index 7f5a4fc..0000000
--- a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_/2/penn_dataset.py
+++ /dev/null
@@ -1,137 +0,0 @@
-import os
-import torch
-import pandas as pd
-import numpy as np
-
-from torchvision import datasets, transforms
-from torch.utils.data import Dataset, DataLoader
-from sklearn.model_selection import RepeatedKFold
-
-from os import path as osp
-import forge
-from forge import flags
-
-
-# aspects of data managmement
-flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
-flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-flags.DEFINE_boolean("cross_validate",False,"Do K-fold cross-validation")
-
-# Job management
-# flags.DEFINE_integer("batch size",5,"training batch size")
-flags.DEFINE_float("train_split",0.8,'Fraction of data to use for training.')
-flags.DEFINE_integer("n_repeats",1,"Times to repeat K-fold cross-validation")
-flags.DEFINE_integer("split_seed",1,"Seed for KFold split (integer for reproducibility")
-
-# "wavelengths between 0.05 and 1 mm in 0.025 mm increments."
-LSPACE = np.arange(0.05,1.05,0.025) # corresponds to 39 non-coord columns of data
-L_INDS = None
-
-DATAFOLDER = './penn_data'
-
-HEADINGS = np.array(['aaa0043','aaa0044','aaa0060','aaa0061','aaa0063','aaa0064','aaa0066','aaa0069','aaa0086','aaa0087','aaa_0051','aaa_0053','aaa_0054','aaa_0059','aaa_0071','aaa_0072'])
-
-
-class PennData(Dataset):
-
-    def __init__(self,path_to_data,headings,k_inds = None,include_coords = True,rescale = True,spectra_prefix = "kvals_fuse_rotate_",label_prefix = 'labels_fuse_rotate_'):
-        
-        self.data_dir = path_to_data
-        self.headings = headings
-
-        df_list = []
-        label_list = []
-        for heading in self.headings: # for each datafile heading,
-            data_name = osp.join(self.data_dir,spectra_prefix + heading+'.csv') # read kvals
-            df_temp = pd.read_csv(data_name,header=None)
-            df_list.append(df_temp)
-
-            label_name = osp.join(self.data_dir,label_prefix + heading + '.csv') # read labels
-            label_temp = pd.read_csv(label_name,header=None, names=['label'])
-            label_list.append(label_temp)
-
-        df = pd.concat(df_list, ignore_index=True)
-
-        labels = pd.concat(label_list, ignore_index=True)
-        df = pd.concat([labels, df], axis="columns") # Append labels to data
-
-        all_labels = df['label'].to_numpy()
-        all_data = df.iloc[:,1:].to_numpy()
-
-        if rescale: # rescale (normalize) wavelength intensity data
-            lambdas = all_data[:,2:] # wavelengths
-            lam_std = np.std(lambdas, axis=0)  # Calculate standard deviation along columns
-            lam_mean = np.mean(lambdas, axis=0)  # Calculate mean along columns
-            lambdas_rescaled = (lambdas - lam_mean) / lam_std 
-            all_data[:,2:] = lambdas_rescaled
-
-        if not include_coords: # removes x,y coordinates from data
-            all_data = all_data[:,2:]
-        
-        if k_inds != None: # in this case, only use subset of wavelengths
-            all_data = all_data[:,np.array(k_inds)]
-
-        self.all_data = all_data
-        self.all_labels = all_labels
-
-    def __len__(self):
-        return len(self.all_data)
-
-    def __getitem__(self,i):
-        state = {'label':self.all_labels[i],'data':self.all_data[i]}
-        return state
-
-    def __getstate__(self):
-        state = {
-            'data': self.all_data,
-            'label': self.all_labels,
-                }
-        return state
-
-    def __setstate__(self, state):
-        # Set the object's state from the provided dictionary
-        self.all_data = state['data']
-        self.all_labels = state['label']
-        
-
-
-def load(config):
-
-    n_splits = int(len(HEADINGS)/((1-config.train_split)*len(HEADINGS)))
-
-    kf = RepeatedKFold(n_splits = n_splits, n_repeats = config.n_repeats, random_state = config.split_seed) # K-fold cross validation
-
-    kf_dataloaders = []
-
-    for i, (train_ind, test_ind) in enumerate(kf.split(HEADINGS)): # for each K-fold split, 
-        n_val = len(test_ind)//2
-        n_test = len(test_ind)-n_val   
-        n_train = len(train_ind)
-        
-        # set up training DataLoader
-        train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
-
-        # set up test DataLoader
-        test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
-
-        # set up val DataLoader
-        val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-        
-
-        dataloaders = {'train':train_loader, 
-                       'test':test_loader,
-                       'val':val_loader,
-                       'train_inds':train_ind,
-                       'test_inds':test_ind,
-                       'n_val':n_val,
-                       'test_headings':list(HEADINGS[test_ind])
-                      }
-        kf_dataloaders.append(dataloaders)
-
-        if not config.cross_validate:
-        	break
-
-    return kf_dataloaders
diff --git a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/__pycache__/basic_feedforward.cpython-39.pyc b/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/__pycache__/basic_feedforward.cpython-39.pyc
deleted file mode 100644
index 9a548a8..0000000
Binary files a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/__pycache__/basic_feedforward.cpython-39.pyc and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/__pycache__/penn_dataset.cpython-39.pyc b/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/__pycache__/penn_dataset.cpython-39.pyc
deleted file mode 100644
index ba1f80e..0000000
Binary files a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/__pycache__/penn_dataset.cpython-39.pyc and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/basic_feedforward.py b/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/basic_feedforward.py
deleted file mode 100644
index b8c3962..0000000
--- a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/basic_feedforward.py
+++ /dev/null
@@ -1,42 +0,0 @@
-import torch
-import torch.nn as nn
-import torch.nn.functional as F
-import numpy as np
-
-from forge import flags
-
-# flags.DEFINE_boolean(
-#     "model_with_dict",
-#     True,
-#     "Makes model output predictions in dictionary instead of directly."
-# )
-
-class PerceptronNN(nn.Module):
-    def __init__(self, input_size, num_labels):
-        super(PerceptronNN, self).__init__()
-        # Define the layers
-        self.fc1 = nn.Linear(input_size, 128)  # First dense layer
-        self.fc2 = nn.Linear(128, 64)         # Second dense layer
-        self.fc23 = nn.Linear(64,64)
-        self.fc3 = nn.Linear(64, 64)          # Third dense layer
-        self.fc4 = nn.Linear(64, num_labels)  # Output layer
-        # self.softmax = nn.Softmax(dim=1)
-
-    def forward(self, x):
-        # Forward pass through the network
-        x = F.relu(self.fc1(x))  # Activation function between layers
-        x = F.relu(self.fc2(x))
-        x = F.relu(self.fc23(x))
-        x = F.relu(self.fc3(x))
-        x = self.fc4(x)  # No activation, this will be included in the loss function
-        # x = self.softmax(x)
-        return x
-
-def load(config):
-
-    # n_channels = 1
-    n_features = config.input_size
-    
-    mlp = PerceptronNN(n_features,2)
-    
-    return mlp, "feedforward"
\ No newline at end of file
diff --git a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/data_fold1/model_fold1.ckpt-0 b/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/data_fold1/model_fold1.ckpt-0
deleted file mode 100644
index 24b3d19..0000000
Binary files a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/data_fold1/model_fold1.ckpt-0 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/data_fold1/model_fold1.ckpt-115101 b/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/data_fold1/model_fold1.ckpt-115101
deleted file mode 100644
index 8d093d7..0000000
Binary files a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/data_fold1/model_fold1.ckpt-115101 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/data_fold1/model_fold1.ckpt-57551 b/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/data_fold1/model_fold1.ckpt-57551
deleted file mode 100644
index 00876b2..0000000
Binary files a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/data_fold1/model_fold1.ckpt-57551 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/data_fold1/model_fold1.ckpt-early_stop b/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/data_fold1/model_fold1.ckpt-early_stop
deleted file mode 100644
index c6f01aa..0000000
Binary files a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/data_fold1/model_fold1.ckpt-early_stop and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/data_fold1/results_dict.h5 b/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/data_fold1/results_dict.h5
deleted file mode 100644
index 523055f..0000000
Binary files a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/data_fold1/results_dict.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/data_fold1/results_dict_train.h5 b/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/data_fold1/results_dict_train.h5
deleted file mode 100644
index 3e162c6..0000000
Binary files a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/data_fold1/results_dict_train.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/data_fold1/results_dict_val.h5 b/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/data_fold1/results_dict_val.h5
deleted file mode 100644
index 3ad7dec..0000000
Binary files a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/data_fold1/results_dict_val.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/data_fold1/test_headings.txt b/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/data_fold1/test_headings.txt
deleted file mode 100644
index 05c4825..0000000
--- a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/data_fold1/test_headings.txt
+++ /dev/null
@@ -1,4 +0,0 @@
-aaa0060
-aaa0061
-aaa0069
-aaa_0059
diff --git a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/events.out.tfevents.1709674431.MacBook-Pro-4.local.7916.0 b/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/events.out.tfevents.1709674431.MacBook-Pro-4.local.7916.0
deleted file mode 100644
index 2e9f9a9..0000000
Binary files a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/events.out.tfevents.1709674431.MacBook-Pro-4.local.7916.0 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/flags.json b/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/flags.json
deleted file mode 100644
index 3680210..0000000
--- a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/flags.json
+++ /dev/null
@@ -1,26 +0,0 @@
-{
-    "batch_size": 100,
-    "beta1": 0.9,
-    "beta2": 0.999,
-    "cross_validate": false,
-    "data_config": "penn_dataset.py",
-    "git_commit": "7416bf730b356aabfe0df644240e40948a8196bb",
-    "include_coords": false,
-    "input_size": 39,
-    "learning_rate": 0.0001,
-    "log_train_values": true,
-    "log_val_test": true,
-    "model_config": "basic_feedforward.py",
-    "n_repeats": 1,
-    "report_loss_every": 50,
-    "rescale": true,
-    "results_dir": "checkpoints",
-    "resume": false,
-    "run_name": "testing",
-    "save_check_points": 50,
-    "save_test_predictions": false,
-    "split_seed": 1,
-    "total_evaluations": 100,
-    "train_epochs": 100,
-    "train_split": 0.8
-}
\ No newline at end of file
diff --git a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/git_diff.txt b/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/git_diff.txt
deleted file mode 100644
index 2b6c67b..0000000
--- a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/git_diff.txt
+++ /dev/null
@@ -1,1768 +0,0 @@
-Tue Mar 5 13:33:51 PST 2024
-diff --git a/.DS_Store b/.DS_Store
-index e2836a8..c46cff7 100644
-Binary files a/.DS_Store and b/.DS_Store differ
-diff --git a/.ipynb_checkpoints/basic_feedforward-checkpoint.py b/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-index 688c282..0c4bcd1 100644
---- a/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-+++ b/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-@@ -5,6 +5,12 @@ import numpy as np
- 
- from forge import flags
- 
-+flags.DEFINE_boolean(
-+    "model_with_dict",
-+    True,
-+    "Makes model output predictions in dictionary instead of directly."
-+)
-+
- class PerceptronNN(nn.Module):
-     def __init__(self, input_size, num_labels):
-         super(PerceptronNN, self).__init__()
-@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-+        self.softmax = nn.Softmax(dim=1)
- 
-     def forward(self, x):
-         # Forward pass through the network
-@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-         x = F.relu(self.fc2(x))
-         x = F.relu(self.fc3(x))
-         x = self.fc4(x)  # No activation, this will be included in the loss function
-+        x = self.softmax(x)
-         return x
- 
- def load(config):
-@@ -29,4 +37,4 @@ def load(config):
-     
-     mlp = PerceptronNN(n_features,2)
-     
--    return mlp
-\ No newline at end of file
-+    return mlp, "feedforward"
-\ No newline at end of file
-diff --git a/__pycache__/basic_feedforward.cpython-39.pyc b/__pycache__/basic_feedforward.cpython-39.pyc
-index f541140..0e2c7e5 100644
-Binary files a/__pycache__/basic_feedforward.cpython-39.pyc and b/__pycache__/basic_feedforward.cpython-39.pyc differ
-diff --git a/__pycache__/penn_dataset.cpython-39.pyc b/__pycache__/penn_dataset.cpython-39.pyc
-index 0d7a4de..19121eb 100644
-Binary files a/__pycache__/penn_dataset.cpython-39.pyc and b/__pycache__/penn_dataset.cpython-39.pyc differ
-diff --git a/basic_feedforward.py b/basic_feedforward.py
-index 688c282..b8c3962 100644
---- a/basic_feedforward.py
-+++ b/basic_feedforward.py
-@@ -5,21 +5,31 @@ import numpy as np
- 
- from forge import flags
- 
-+# flags.DEFINE_boolean(
-+#     "model_with_dict",
-+#     True,
-+#     "Makes model output predictions in dictionary instead of directly."
-+# )
-+
- class PerceptronNN(nn.Module):
-     def __init__(self, input_size, num_labels):
-         super(PerceptronNN, self).__init__()
-         # Define the layers
-         self.fc1 = nn.Linear(input_size, 128)  # First dense layer
-         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-+        self.fc23 = nn.Linear(64,64)
-         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-+        # self.softmax = nn.Softmax(dim=1)
- 
-     def forward(self, x):
-         # Forward pass through the network
-         x = F.relu(self.fc1(x))  # Activation function between layers
-         x = F.relu(self.fc2(x))
-+        x = F.relu(self.fc23(x))
-         x = F.relu(self.fc3(x))
-         x = self.fc4(x)  # No activation, this will be included in the loss function
-+        # x = self.softmax(x)
-         return x
- 
- def load(config):
-@@ -29,4 +39,4 @@ def load(config):
-     
-     mlp = PerceptronNN(n_features,2)
-     
--    return mlp
-\ No newline at end of file
-+    return mlp, "feedforward"
-\ No newline at end of file
-diff --git a/checkpoints/feedforward/1/basic_feedforward.py b/checkpoints/feedforward/1/basic_feedforward.py
-index 688c282..3a65525 100644
---- a/checkpoints/feedforward/1/basic_feedforward.py
-+++ b/checkpoints/feedforward/1/basic_feedforward.py
-@@ -5,6 +5,12 @@ import numpy as np
- 
- from forge import flags
- 
-+# flags.DEFINE_boolean(
-+#     "model_with_dict",
-+#     True,
-+#     "Makes model output predictions in dictionary instead of directly."
-+# )
-+
- class PerceptronNN(nn.Module):
-     def __init__(self, input_size, num_labels):
-         super(PerceptronNN, self).__init__()
-@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-+        self.softmax = nn.Softmax(dim=1)
- 
-     def forward(self, x):
-         # Forward pass through the network
-@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-         x = F.relu(self.fc2(x))
-         x = F.relu(self.fc3(x))
-         x = self.fc4(x)  # No activation, this will be included in the loss function
-+        x = self.softmax(x)
-         return x
- 
- def load(config):
-@@ -29,4 +37,4 @@ def load(config):
-     
-     mlp = PerceptronNN(n_features,2)
-     
--    return mlp
-\ No newline at end of file
-+    return mlp, "feedforward"
-\ No newline at end of file
-diff --git a/checkpoints/feedforward/1/flags.json b/checkpoints/feedforward/1/flags.json
-index 1d000c3..889a6ea 100644
---- a/checkpoints/feedforward/1/flags.json
-+++ b/checkpoints/feedforward/1/flags.json
-@@ -1,9 +1,15 @@
- {
-     "batch_size": 100,
-+    "beta1": 0.9,
-+    "beta2": 0.999,
-+    "cross_validate": false,
-     "data_config": "penn_dataset.py",
-+    "git_commit": "7416bf730b356aabfe0df644240e40948a8196bb",
-     "include_coords": false,
-     "input_size": 39,
--    "learning_rate": 1e-05,
-+    "learning_rate": 0.0001,
-+    "log_train_values": true,
-+    "log_val_test": true,
-     "model_config": "basic_feedforward.py",
-     "n_repeats": 1,
-     "report_loss_every": 50,
-@@ -11,7 +17,10 @@
-     "results_dir": "checkpoints",
-     "resume": false,
-     "run_name": "feedforward",
-+    "save_check_points": 50,
-+    "save_test_predictions": false,
-     "split_seed": 1,
--    "train_epochs": 20,
-+    "total_evaluations": 100,
-+    "train_epochs": 100,
-     "train_split": 0.8
- }
-\ No newline at end of file
-diff --git a/checkpoints/feedforward/1/git_diff.txt b/checkpoints/feedforward/1/git_diff.txt
-index 7b37e6f..ec23707 100644
---- a/checkpoints/feedforward/1/git_diff.txt
-+++ b/checkpoints/feedforward/1/git_diff.txt
-@@ -1 +1,873 @@
--Mon Mar 4 11:45:48 PST 2024
-+Mon Mar 4 16:34:02 PST 2024
-+diff --git a/.DS_Store b/.DS_Store
-+index e2836a8..7e3fa32 100644
-+Binary files a/.DS_Store and b/.DS_Store differ
-+diff --git a/.ipynb_checkpoints/basic_feedforward-checkpoint.py b/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-+index 688c282..0c4bcd1 100644
-+--- a/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-++++ b/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-+@@ -5,6 +5,12 @@ import numpy as np
-+ 
-+ from forge import flags
-+ 
-++flags.DEFINE_boolean(
-++    "model_with_dict",
-++    True,
-++    "Makes model output predictions in dictionary instead of directly."
-++)
-++
-+ class PerceptronNN(nn.Module):
-+     def __init__(self, input_size, num_labels):
-+         super(PerceptronNN, self).__init__()
-+@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-+         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-+         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-+         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-++        self.softmax = nn.Softmax(dim=1)
-+ 
-+     def forward(self, x):
-+         # Forward pass through the network
-+@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-+         x = F.relu(self.fc2(x))
-+         x = F.relu(self.fc3(x))
-+         x = self.fc4(x)  # No activation, this will be included in the loss function
-++        x = self.softmax(x)
-+         return x
-+ 
-+ def load(config):
-+@@ -29,4 +37,4 @@ def load(config):
-+     
-+     mlp = PerceptronNN(n_features,2)
-+     
-+-    return mlp
-+\ No newline at end of file
-++    return mlp, "feedforward"
-+\ No newline at end of file
-+diff --git a/__pycache__/basic_feedforward.cpython-39.pyc b/__pycache__/basic_feedforward.cpython-39.pyc
-+index f541140..5ad96de 100644
-+Binary files a/__pycache__/basic_feedforward.cpython-39.pyc and b/__pycache__/basic_feedforward.cpython-39.pyc differ
-+diff --git a/__pycache__/penn_dataset.cpython-39.pyc b/__pycache__/penn_dataset.cpython-39.pyc
-+index 0d7a4de..19121eb 100644
-+Binary files a/__pycache__/penn_dataset.cpython-39.pyc and b/__pycache__/penn_dataset.cpython-39.pyc differ
-+diff --git a/basic_feedforward.py b/basic_feedforward.py
-+index 688c282..3a65525 100644
-+--- a/basic_feedforward.py
-++++ b/basic_feedforward.py
-+@@ -5,6 +5,12 @@ import numpy as np
-+ 
-+ from forge import flags
-+ 
-++# flags.DEFINE_boolean(
-++#     "model_with_dict",
-++#     True,
-++#     "Makes model output predictions in dictionary instead of directly."
-++# )
-++
-+ class PerceptronNN(nn.Module):
-+     def __init__(self, input_size, num_labels):
-+         super(PerceptronNN, self).__init__()
-+@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-+         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-+         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-+         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-++        self.softmax = nn.Softmax(dim=1)
-+ 
-+     def forward(self, x):
-+         # Forward pass through the network
-+@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-+         x = F.relu(self.fc2(x))
-+         x = F.relu(self.fc3(x))
-+         x = self.fc4(x)  # No activation, this will be included in the loss function
-++        x = self.softmax(x)
-+         return x
-+ 
-+ def load(config):
-+@@ -29,4 +37,4 @@ def load(config):
-+     
-+     mlp = PerceptronNN(n_features,2)
-+     
-+-    return mlp
-+\ No newline at end of file
-++    return mlp, "feedforward"
-+\ No newline at end of file
-+diff --git a/checkpoints/feedforward/1/basic_feedforward.py b/checkpoints/feedforward/1/basic_feedforward.py
-+index 688c282..3a65525 100644
-+--- a/checkpoints/feedforward/1/basic_feedforward.py
-++++ b/checkpoints/feedforward/1/basic_feedforward.py
-+@@ -5,6 +5,12 @@ import numpy as np
-+ 
-+ from forge import flags
-+ 
-++# flags.DEFINE_boolean(
-++#     "model_with_dict",
-++#     True,
-++#     "Makes model output predictions in dictionary instead of directly."
-++# )
-++
-+ class PerceptronNN(nn.Module):
-+     def __init__(self, input_size, num_labels):
-+         super(PerceptronNN, self).__init__()
-+@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-+         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-+         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-+         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-++        self.softmax = nn.Softmax(dim=1)
-+ 
-+     def forward(self, x):
-+         # Forward pass through the network
-+@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-+         x = F.relu(self.fc2(x))
-+         x = F.relu(self.fc3(x))
-+         x = self.fc4(x)  # No activation, this will be included in the loss function
-++        x = self.softmax(x)
-+         return x
-+ 
-+ def load(config):
-+@@ -29,4 +37,4 @@ def load(config):
-+     
-+     mlp = PerceptronNN(n_features,2)
-+     
-+-    return mlp
-+\ No newline at end of file
-++    return mlp, "feedforward"
-+\ No newline at end of file
-+diff --git a/checkpoints/feedforward/1/flags.json b/checkpoints/feedforward/1/flags.json
-+index 1d000c3..889a6ea 100644
-+--- a/checkpoints/feedforward/1/flags.json
-++++ b/checkpoints/feedforward/1/flags.json
-+@@ -1,9 +1,15 @@
-+ {
-+     "batch_size": 100,
-++    "beta1": 0.9,
-++    "beta2": 0.999,
-++    "cross_validate": false,
-+     "data_config": "penn_dataset.py",
-++    "git_commit": "7416bf730b356aabfe0df644240e40948a8196bb",
-+     "include_coords": false,
-+     "input_size": 39,
-+-    "learning_rate": 1e-05,
-++    "learning_rate": 0.0001,
-++    "log_train_values": true,
-++    "log_val_test": true,
-+     "model_config": "basic_feedforward.py",
-+     "n_repeats": 1,
-+     "report_loss_every": 50,
-+@@ -11,7 +17,10 @@
-+     "results_dir": "checkpoints",
-+     "resume": false,
-+     "run_name": "feedforward",
-++    "save_check_points": 50,
-++    "save_test_predictions": false,
-+     "split_seed": 1,
-+-    "train_epochs": 20,
-++    "total_evaluations": 100,
-++    "train_epochs": 100,
-+     "train_split": 0.8
-+ }
-+\ No newline at end of file
-+diff --git a/checkpoints/feedforward/1/git_diff.txt b/checkpoints/feedforward/1/git_diff.txt
-+index 7b37e6f..5c561db 100644
-+--- a/checkpoints/feedforward/1/git_diff.txt
-++++ b/checkpoints/feedforward/1/git_diff.txt
-+@@ -1 +1 @@
-+-Mon Mar 4 11:45:48 PST 2024
-++Mon Mar 4 16:34:02 PST 2024
-+diff --git a/checkpoints/feedforward/1/penn_dataset.py b/checkpoints/feedforward/1/penn_dataset.py
-+index aa2f5a0..7f5a4fc 100644
-+--- a/checkpoints/feedforward/1/penn_dataset.py
-++++ b/checkpoints/feedforward/1/penn_dataset.py
-+@@ -15,6 +15,7 @@ from forge import flags
-+ # aspects of data managmement
-+ flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
-+ flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-++flags.DEFINE_boolean("cross_validate",False,"Do K-fold cross-validation")
-+ 
-+ # Job management
-+ # flags.DEFINE_integer("batch size",5,"training batch size")
-+@@ -109,15 +110,15 @@ def load(config):
-+         
-+         # set up training DataLoader
-+         train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, n_train),num_workers=0,shuffle = True)
-++        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
-+ 
-+         # set up test DataLoader
-+         test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, n_test),num_workers=0,shuffle = True)
-++        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
-+ 
-+         # set up val DataLoader
-+         val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, n_val),num_workers=0,shuffle = True)
-++        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-+         
-+ 
-+         dataloaders = {'train':train_loader, 
-+@@ -125,8 +126,12 @@ def load(config):
-+                        'val':val_loader,
-+                        'train_inds':train_ind,
-+                        'test_inds':test_ind,
-+-                       'n_val':n_val
-++                       'n_val':n_val,
-++                       'test_headings':list(HEADINGS[test_ind])
-+                       }
-+         kf_dataloaders.append(dataloaders)
-+ 
-++        if not config.cross_validate:
-++        	break
-++
-+     return kf_dataloaders
-+diff --git a/penn_dataset.py b/penn_dataset.py
-+index aa2f5a0..7f5a4fc 100644
-+--- a/penn_dataset.py
-++++ b/penn_dataset.py
-+@@ -15,6 +15,7 @@ from forge import flags
-+ # aspects of data managmement
-+ flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
-+ flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-++flags.DEFINE_boolean("cross_validate",False,"Do K-fold cross-validation")
-+ 
-+ # Job management
-+ # flags.DEFINE_integer("batch size",5,"training batch size")
-+@@ -109,15 +110,15 @@ def load(config):
-+         
-+         # set up training DataLoader
-+         train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, n_train),num_workers=0,shuffle = True)
-++        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
-+ 
-+         # set up test DataLoader
-+         test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, n_test),num_workers=0,shuffle = True)
-++        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
-+ 
-+         # set up val DataLoader
-+         val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, n_val),num_workers=0,shuffle = True)
-++        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-+         
-+ 
-+         dataloaders = {'train':train_loader, 
-+@@ -125,8 +126,12 @@ def load(config):
-+                        'val':val_loader,
-+                        'train_inds':train_ind,
-+                        'test_inds':test_ind,
-+-                       'n_val':n_val
-++                       'n_val':n_val,
-++                       'test_headings':list(HEADINGS[test_ind])
-+                       }
-+         kf_dataloaders.append(dataloaders)
-+ 
-++        if not config.cross_validate:
-++        	break
-++
-+     return kf_dataloaders
-+diff --git a/testing.ipynb b/testing.ipynb
-+index e5a167b..a928d8d 100644
-+--- a/testing.ipynb
-++++ b/testing.ipynb
-+@@ -2,7 +2,7 @@
-+  "cells": [
-+   {
-+    "cell_type": "code",
-+-   "execution_count": 1,
-++   "execution_count": 2,
-+    "id": "4dee7ff1-01a4-4038-b493-9729ff3693f7",
-+    "metadata": {},
-+    "outputs": [],
-+@@ -23,19 +23,19 @@
-+   },
-+   {
-+    "cell_type": "code",
-+-   "execution_count": 2,
-++   "execution_count": 3,
-+    "id": "cad0fdc8-5c35-4610-bba3-b71e60dc1b98",
-+    "metadata": {},
-+    "outputs": [],
-+    "source": [
-+-    "flags.DEFINE_integer(\"batch_size\", 100, \"Mini-batch size.\")\n",
-++    "flags.DEFINE_integer(\"batch_size\", 10, \"Mini-batch size.\")\n",
-+     "\n",
-+     "flags.DEFINE_integer(\"input_size\",39,\"Input shape to model\")"
-+    ]
-+   },
-+   {
-+    "cell_type": "code",
-+-   "execution_count": 3,
-++   "execution_count": 4,
-+    "id": "ce1b936b-8a7c-426e-a3aa-3c1c38f645de",
-+    "metadata": {},
-+    "outputs": [
-+@@ -54,8 +54,8 @@
-+   },
-+   {
-+    "cell_type": "code",
-+-   "execution_count": 9,
-+-   "id": "e862b7e2-57f5-44bf-bcf1-a91160ba66cc",
-++   "execution_count": 5,
-++   "id": "4469cddf-4dac-4468-be88-241d440401c3",
-+    "metadata": {},
-+    "outputs": [
-+     {
-+@@ -67,35 +67,89 @@
-+     }
-+    ],
-+    "source": [
-+-    "model = fet.load(\"basic_feedforward.py\",config)"
-++    "model,modelname = fet.load(\"basic_feedforward.py\",config)"
-+    ]
-+   },
-+   {
-+    "cell_type": "code",
-+-   "execution_count": 10,
-+-   "id": "07e0b160-d5d1-4e54-b4a7-ccaf2224598a",
-++   "execution_count": 17,
-++   "id": "7c9a9fe9-f5e8-456a-b964-4be13027725b",
-+    "metadata": {},
-+    "outputs": [
-+     {
-+      "data": {
-+       "text/plain": [
-+-       "PerceptronNN(\n",
-+-       "  (fc1): Linear(in_features=39, out_features=128, bias=True)\n",
-+-       "  (fc2): Linear(in_features=128, out_features=64, bias=True)\n",
-+-       "  (fc3): Linear(in_features=64, out_features=64, bias=True)\n",
-+-       "  (fc4): Linear(in_features=64, out_features=2, bias=True)\n",
-+-       ")"
-++       "['aaa0060', 'aaa0061', 'aaa0069', 'aaa_0059']"
-+       ]
-+      },
-+-     "execution_count": 10,
-++     "execution_count": 17,
-+      "metadata": {},
-+      "output_type": "execute_result"
-+     }
-+    ],
-+    "source": [
-+-    "model"
-++    "loaddat[0]['test_headings']"
-++   ]
-++  },
-++  {
-++   "cell_type": "code",
-++   "execution_count": 19,
-++   "id": "e862b7e2-57f5-44bf-bcf1-a91160ba66cc",
-++   "metadata": {},
-++   "outputs": [
-++    {
-++     "name": "stdout",
-++     "output_type": "stream",
-++     "text": [
-++      "Keys: ['cross_entropy', 'time']\n"
-++     ]
-++    }
-++   ],
-++   "source": [
-++    "import h5py\n",
-++    "\n",
-++    "file_path = \"./checkpoints/feedforward/2/data_fold1/results_dict.h5\"\n",
-++    "# Replace 'your_file.h5' with the actual path to your file\n",
-++    "f =  h5py.File(file_path, 'r') \n",
-++    "\n",
-++    "    # Get information about the data stored in the file\n",
-++    "print(\"Keys:\", list(f.keys()))  # List the top-level datasets and groups\n",
-++    "\n",
-++    "    # # Access a dataset by its name\n",
-++    "    # dataset_name = \"your_dataset_name\"\n",
-++    "    # if dataset_name in f:\n",
-++    "    #     dataset = f[dataset_name]\n",
-++    "    #     print(\"Dataset shape:\", dataset.shape)\n",
-++    "    #     print(\"Dataset dtype:\", dataset.dtype)\n",
-++    "\n",
-++    "    #     # Access the data as a NumPy array\n",
-++    "    #     data = dataset[:]  # Read the entire dataset\n",
-++    "\n",
-++    "    #     # You can now work with the data as needed, for example:\n",
-++    "    #     # Perform calculations, visualizations, etc.\n",
-++    "    # else:\n",
-++    "    #     print(f\"Dataset '{dataset_name}' not found in the file.\")"
-+    ]
-+   },
-++  {
-++   "cell_type": "code",
-++   "execution_count": 13,
-++   "id": "07e0b160-d5d1-4e54-b4a7-ccaf2224598a",
-++   "metadata": {},
-++   "outputs": [
-++    {
-++     "data": {
-++      "text/plain": [
-++       "<generator object Module.parameters at 0x3007207b0>"
-++      ]
-++     },
-++     "execution_count": 13,
-++     "metadata": {},
-++     "output_type": "execute_result"
-++    }
-++   ],
-++   "source": []
-++  },
-+   {
-+    "cell_type": "code",
-+    "execution_count": null,
-+diff --git a/train.py b/train.py
-+index c266102..516bfa9 100644
-+--- a/train.py
-++++ b/train.py
-+@@ -1,49 +1,440 @@
-+ from os import path as osp
-++import os
-++import numpy as np
-++import time
-+ 
-+ import torch
-++import torch.nn as nn
-+ import torch.nn.functional as F
-+ import torch.optim as optim
-+-
-+-import numpy as np
-++from torch.utils.tensorboard import SummaryWriter
-+ 
-+ import forge
-+ from forge import flags
-+ import forge.experiment_tools as fet
-+ 
-++from train_tools import (
-++	log_tensorboard,
-++	parse_reports,
-++	parse_reports_cpu,
-++	print_reports,
-++	load_checkpoint,
-++	save_checkpoint,
-++	nested_to,
-++	param_count,
-++)
-++
-++from copy import deepcopy
-++from attrdict import AttrDict
-++import deepdish as dd
-++from tqdm import tqdm
-++
-++# For reproducibility while researching, but might affect speed!
-++torch.backends.cudnn.deterministic = True
-++torch.backends.cudnn.benchmark = False
-++torch.manual_seed(0)
-++
-+ 
-+ # Job config
-+ flags.DEFINE_string('data_config', 'penn_dataset.py',
-+-                    'Path to a data config file.')
-++					'Path to a data config file.')
-+ flags.DEFINE_string('model_config', 'basic_feedforward.py',
-+-                    'Path to a model config file.')
-++					'Path to a model config file.')
-+ flags.DEFINE_string('results_dir', 'checkpoints',
-+-                    'Top directory for all experimental results.')
-++					'Top directory for all experimental results.')
-+ flags.DEFINE_string('run_name', 'feedforward',
-+-                    'Name of this job and name of results folder.')
-++					'Name of this job and name of results folder.')
-+ flags.DEFINE_boolean('resume', False, 'Tries to resume a job if True.')
-+ 
-+ # Logging config
-+ flags.DEFINE_integer('report_loss_every', 50,
-+-                     'Number of iterations between reporting minibatch loss.')
-+-flags.DEFINE_integer('train_epochs', 20, 'Maximum number of training epochs.')
-++					 'Number of iterations between reporting minibatch loss.')
-++flags.DEFINE_integer('train_epochs', 100, 'Maximum number of training epochs.')
-++flags.DEFINE_integer(
-++	"save_check_points",
-++	50,
-++	"frequency with which to save checkpoints, in number of epoches.",
-++)
-++flags.DEFINE_boolean("log_train_values", True, "Logs train values if True.")
-++flags.DEFINE_integer(
-++	"total_evaluations",
-++	100,
-++	"Maximum number of evaluations on test and validation data during training.",
-++)
-++flags.DEFINE_boolean(
-++	"save_test_predictions",
-++	False,
-++	"Makes and saves test predictions on one or more test sets (e.g. 5-step and 100-step predictions) at the end of training.",
-++)
-++flags.DEFINE_boolean(
-++    "log_val_test", True, "Turns off computation of validation and test errors."
-++)
-+ 
-+ # Experiment config
-+ flags.DEFINE_integer('batch_size', 100, 'Mini-batch size.')
-+-flags.DEFINE_float('learning_rate', 1e-5, 'SGD learning rate.')
-++flags.DEFINE_float("learning_rate", 1e-4, "Adam learning rate.")
-++flags.DEFINE_float("beta1", 0.9, "Adam Beta 1 parameter")
-++flags.DEFINE_float("beta2", 0.999, "Adam Beta 2 parameter")
-+ 
-+ # Specific config options
-+ flags.DEFINE_integer("input_size",39,"Input shape to model")
-+ 
-++#########################################################################################
-++
-++def evaluate(model, loader, device,fold = 0,headings = [],loss_func = nn.CrossEntropyLoss()):
-++	reports = None
-++	for data in loader:
-++		labels = data['label']
-++		inputs = nested_to(data['data'],device,torch.float32)
-++		
-++		labels_tensor = torch.zeros((len(labels), 2))
-++		for i, label in enumerate(labels):
-++			labels_tensor[i, label] = 1
-++
-++		model_output = model(inputs) # evaluate model
-++
-++		loss = loss_func(model_output, labels_tensor) # compute loss
-++		outputs = AttrDict({"loss": loss, "prediction": model_output,'data_fold':fold})
-++		outputs.reports = AttrDict({"cross_entropy": loss})
-++
-++		if reports is None:
-++			reports = {k: v.detach().clone().cpu() for k, v in outputs.reports.items()}
-++		else:
-++			for k, v in outputs.reports.items():
-++				reports[k] += v.detach().clone().cpu()
-++
-++	for k, v in reports.items():
-++		reports[k] = v / len(
-++			loader
-++		)  # SZ: note this can be slightly incorrect if mini-batch sizes vary (if batch_size doesn't divide train_size), but approximately correct.
-++
-++	# reports['test_headings'] = np.array(headings)
-++
-++	return reports
-++
-++def main():
-++
-++	config = forge.config()
-++
-++	# Set device
-++	if torch.cuda.is_available():
-++		device = f"cuda:{config.device}"
-++		torch.cuda.set_device(device)
-++	else:
-++		device = "cpu" # can change this to MPS on M1 Macs
-++
-++	# Load data
-++	data_name = "penn_data"
-++	kfold_loaders = fet.load(config.data_config, config)
-++
-++	# Load model
-++	model,model_name = fet.load(config.model_config, config)
-++	model = model.to(device)
-++
-++	loss_func = nn.CrossEntropyLoss()
-++
-++	# Prepare environment
-++	params_in_run_name = [
-++		("batch_size", "bs"),
-++		("learning_rate", "lr"),
-++		("n_train", "ntrain")
-++	]
-++
-++	run_name = ""  # config.run_name
-++	for config_param in params_in_run_name:
-++		attr = config_param[0]
-++		abbrev = config_param[1]
-++
-++		if hasattr(config, attr):
-++			run_name += abbrev
-++			run_name += str(getattr(config, attr))
-++			run_name += "_"
-++
-++	results_folder_name = osp.join(
-++		data_name,
-++		model_name,
-++		config.run_name,
-++		run_name,
-++	)
-++
-++	# Prepare environment
-++	logdir = osp.join(config.results_dir, config.run_name)
-++	logdir, resume_checkpoint = fet.init_checkpoint(
-++		logdir, config.data_config, config.model_config, config.resume)
-++
-++	print("Checkpoint directory:",logdir)
-++
-++	# Print flags
-++	fet.print_flags()
-++	# Print model info
-++	print(model)
-++
-++	# Setup optimizer
-++	model_params = model.parameters()
-++	opt_learning_rate = config.learning_rate
-++	model_opt = torch.optim.Adam(
-++		model_params, lr=opt_learning_rate, betas=(config.beta1, config.beta2)
-++	)
-++	print("Model Optimizer:")
-++	print(model_opt)
-++
-++	# Try to restore model and optimizer from checkpoint
-++	if resume_checkpoint is not None:
-++		start_epoch = load_checkpoint(resume_checkpoint, model, model_opt)
-++	else:
-++		start_epoch = 1
-++
-++	n_folds = len(kfold_loaders)
-++	print("Doing {}-fold cross-validation.".format(n_folds))
-++
-++	# KFOLD TRAINING LOOP
-++	for k,loader_k in enumerate(kfold_loaders): # loop over data splits
-++
-++		print("Training fold {}...".format(k+1))
-++
-++		# load the training data
-++		train_loader = loader_k["train"]
-++		n_train = len(train_loader.dataset)
-++		train_batch_size = train_loader.batch_size
-++
-++		# load testing, validation
-++		test_loader = loader_k["test"]
-++		n_test = len(test_loader.dataset)
-++		val_loader = loader_k["val"]
-++		n_val = len(val_loader.dataset)
-++		
-++		# create folder for this data split
-++		fold_dir = osp.join(logdir,"data_fold{}".format(k+1))
-++		fold_dir_exists = osp.exists(fold_dir)
-++		if not fold_dir_exists:
-++			if config.resume:
-++				raise ValueError("Can't resume when the checkpoint/fold dir '{}' doesn't exist.".format(fold_dir))
-++			else:
-++				os.makedirs(fold_dir)
-++		checkpoint_name = osp.join(fold_dir, 'model_fold{}.ckpt'.format(k+1))
-++
-++		# keep track of which data is test data for a given Kfold data split
-++		test_headings = loader_k['test_headings']
-++		headingsFile = osp.join(fold_dir,"test_headings.txt")
-++		with open(headingsFile,'w') as headfile:
-++			for heading in test_headings:
-++				headfile.write(heading+'\n')
-++
-++		# print(checkpoint_name)
-++
-++		train_iter = (start_epoch - 1) * (
-++		len(train_loader.dataset) // train_batch_size
-++		) + 1
-++
-++		print("Starting training at epoch = {}, iter = {}".format(start_epoch, train_iter))
-++
-++		# Setup tensorboard writing
-++		summary_writer = SummaryWriter(logdir)
-++
-++		train_reports = []
-++		report_all = {}
-++		report_all_val = {}
-++
-++		# Saving model at epoch 0 before training
-++		print("saving model at epoch 0 before training ... ")
-++		save_checkpoint(checkpoint_name, 0, model, model_opt, loss=0.0)
-++		print("finished saving model at epoch 0 before training")
-++
-++		num_params = param_count(model)
-++		print(f"Number of model parameters: {num_params}")
-++
-++		# Training
-++		start_t = time.time()
-++
-++		total_train_iters = len(train_loader) * config.train_epochs
-++		iters_per_eval = max(1, int(total_train_iters / config.total_evaluations))
-++		# print('batch',train_batch_size)
-++		# print('ntrain',n_train)
-++		# assert (
-++		# 	n_train % min(train_batch_size, n_train) == 0
-++		# ), "Batch size doesn't divide dataset size. Can be inaccurate for loss computation (see below)."
-++
-++		training_failed = False
-++		best_val_loss_so_far = 1e7
-++
-++		for epoch in tqdm(range(start_epoch, config.train_epochs + 1)):
-++			model.train()
-++
-++			for batch_idx, data_dict in enumerate(train_loader): # Loop over batched data
-++
-++				labels = data_dict['label']
-++				data = data_dict['data']
-++
-++				# send data to device
-++				data = nested_to(data,device,torch.float32)
-++				# One-hot encode the data labels
-++				labels_tensor = torch.zeros((len(labels), 2))
-++				for i, label in enumerate(labels):
-++					labels_tensor[i, label] = 1
-++
-++				model_output = model(data) # evaluate model
-++
-++				loss = loss_func(model_output, labels_tensor) # compute loss
-++				outputs = AttrDict({"loss": loss, "prediction": model_output})
-++				outputs.reports = AttrDict({"cross_entropy": loss})
-++
-++				if torch.isnan(outputs.loss): # check for failure in training
-++					if not training_failed:
-++						epoch_of_nan = epoch
-++					if (epoch > epoch_of_nan + 1) and training_failed:
-++						raise ValueError("Loss Nan-ed.")
-++					training_failed = True
-++
-++				model_opt.zero_grad()
-++				outputs.loss.backward(retain_graph=False)
-++
-++				model_opt.step() # move optimizer forward
-++
-++				train_reports.append(parse_reports_cpu(outputs.reports))
-++
-++				if config.log_train_values:
-++					reports = parse_reports(outputs.reports)
-++					if batch_idx % config.report_loss_every == 0:
-++						log_tensorboard(summary_writer, train_iter, reports, "train/")
-++						print_reports(
-++							reports,
-++							start_t,
-++							epoch,
-++							batch_idx,
-++							len(train_loader.dataset) // train_batch_size,
-++							prefix="train",
-++						)
-++						log_tensorboard(
-++							summary_writer,
-++							train_iter,
-++							{"lr": model_opt.param_groups[0]["lr"]},
-++							"hyperparams/",
-++						)
-++				# Logging and evaluation
-++				if (
-++					train_iter % iters_per_eval == 0 or (train_iter == total_train_iters)
-++				) and config.log_val_test:  # batch_idx % config.evaluate_every == 0:
-++					model.eval()
-++					with torch.no_grad():
-++						reports = evaluate(model, test_loader, device,fold = k,headings = loader_k['test_headings'])
-++						# print("REPORTS",reports)
-++						reports = parse_reports(reports)
-++						reports["time"] = time.time() - start_t
-++						if report_all == {}:
-++							report_all = deepcopy(reports)
-++
-++							for d in reports.keys():
-++								report_all[d] = [report_all[d]]
-++						else:
-++							for d in reports.keys():
-++								report_all[d].append(reports[d])
-++
-++						log_tensorboard(summary_writer, train_iter, reports, "test/")
-++						print_reports(
-++							reports,
-++							start_t,
-++							epoch,
-++							batch_idx,
-++							len(train_loader.dataset) // config.batch_size,
-++							prefix="test",
-++						)
-++
-++						# repeat for validation data
-++						reports = evaluate(model, val_loader, device,fold = k,headings = loader_k['test_headings'])
-++						reports = parse_reports(reports)
-++						reports["time"] = time.time() - start_t
-++						if report_all_val == {}:
-++							report_all_val = deepcopy(reports)
-++
-++							for d in reports.keys():
-++								report_all_val[d] = [report_all_val[d]]
-++						else:
-++							for d in reports.keys():
-++								report_all_val[d].append(reports[d])
-++
-++						log_tensorboard(summary_writer, train_iter, reports, "val/")
-++						print_reports(
-++							reports,
-++							start_t,
-++							epoch,
-++							batch_idx,
-++							len(train_loader.dataset) // config.batch_size,
-++							prefix="val",
-++						)
-++
-++						if report_all_val["cross_entropy"][-1] < best_val_loss_so_far:
-++							save_checkpoint(
-++								checkpoint_name,
-++								f"early_stop",
-++								model,
-++								model_opt,
-++								loss=outputs.loss,
-++							)
-++							best_val_loss_so_far = report_all_val["cross_entropy"][-1]
-++
-++					model.train()
-++
-++				train_iter += 1
-++
-++			if epoch % config.save_check_points == 0:
-++				save_checkpoint(
-++					checkpoint_name, train_iter, model, model_opt, loss=outputs.loss
-++				)
-++
-++		dd.io.save(fold_dir + "/results_dict_train.h5", train_reports)
-++		dd.io.save(fold_dir + "/results_dict.h5", report_all)
-++		dd.io.save(fold_dir + "/results_dict_val.h5", report_all_val)
-++
-++	# always save final model
-++	save_checkpoint(checkpoint_name, train_iter, model, model_opt, loss=outputs.loss)
-++
-++	
-++	if config.save_test_predictions:
-++		pass
-++		# print("Starting to make model predictions on test sets for *final model*.")
-++		# for chunk_len in [5, 100]:
-++		#     start_t_preds = time.time()
-++		#     data_config = SimpleNamespace(
-++		#         **{
-++		#             **config.__dict__["__flags"],
-++		#             **{"chunk_len": chunk_len, "batch_size": 500},
-++		#         }
-++		#     )
-++		#     dataloaders, data_name = fet.load(config.data_config, config=data_config)
-++		#     test_loader_preds = dataloaders["test"]
-++
-++		#     torch.cuda.empty_cache()
-++		#     with torch.no_grad():
-++		#         preds = []
-++		#         true = []
-++		#         num_datapoints = 0
-++		#         for idx, d in enumerate(test_loader_preds):
-++		#             true.append(d[-1])
-++		#             d = nested_to(d, device, torch.float32)
-++		#             outputs = model(d)
-++
-++		#             pred_zs = outputs.prediction
-++		#             preds.append(pred_zs)
-++
-++		#             num_datapoints += len(pred_zs)
-++
-++		#             if num_datapoints >= 2000:
-++		#                 break
-+ 
-+-config = forge.config()
-++		#         preds = torch.cat(preds, dim=0).cpu()
-++		#         true = torch.cat(true, dim=0).cpu()
-+ 
-+-# Prepare environment
-+-logdir = osp.join(config.results_dir, config.run_name)
-+-logdir, resume_checkpoint = fet.init_checkpoint(
-+-    logdir, config.data_config, config.model_config, config.resume)
-+-checkpoint_name = osp.join(logdir, 'model.ckpt')
-++		#         save_dir = osp.join(logdir, f"traj_preds_{chunk_len}_steps_2k_test.pt")
-++		#         torch.save(preds, save_dir)
-+ 
-++		#         save_dir = osp.join(logdir, f"traj_true_{chunk_len}_steps_2k_test.pt")
-++		#         torch.save(true, save_dir)
-+ 
-+-print(logdir)
-++		#         print(
-++		#             f"Completed making test predictions for chunk_len = {chunk_len} in {time.time() - start_t_preds:.2f} seconds."
-++		#         )	
-++		
-+ 
-++if __name__ == "__main__":
-++	main()
-+ 
-diff --git a/checkpoints/feedforward/1/penn_dataset.py b/checkpoints/feedforward/1/penn_dataset.py
-index aa2f5a0..7f5a4fc 100644
---- a/checkpoints/feedforward/1/penn_dataset.py
-+++ b/checkpoints/feedforward/1/penn_dataset.py
-@@ -15,6 +15,7 @@ from forge import flags
- # aspects of data managmement
- flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
- flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-+flags.DEFINE_boolean("cross_validate",False,"Do K-fold cross-validation")
- 
- # Job management
- # flags.DEFINE_integer("batch size",5,"training batch size")
-@@ -109,15 +110,15 @@ def load(config):
-         
-         # set up training DataLoader
-         train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, n_train),num_workers=0,shuffle = True)
-+        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
- 
-         # set up test DataLoader
-         test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, n_test),num_workers=0,shuffle = True)
-+        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
- 
-         # set up val DataLoader
-         val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, n_val),num_workers=0,shuffle = True)
-+        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-         
- 
-         dataloaders = {'train':train_loader, 
-@@ -125,8 +126,12 @@ def load(config):
-                        'val':val_loader,
-                        'train_inds':train_ind,
-                        'test_inds':test_ind,
--                       'n_val':n_val
-+                       'n_val':n_val,
-+                       'test_headings':list(HEADINGS[test_ind])
-                       }
-         kf_dataloaders.append(dataloaders)
- 
-+        if not config.cross_validate:
-+        	break
-+
-     return kf_dataloaders
-diff --git a/georgehulsey_2024.pdf b/georgehulsey_2024.pdf
-deleted file mode 100644
-index 1ab17f6..0000000
-Binary files a/georgehulsey_2024.pdf and /dev/null differ
-diff --git a/penn_dataset.py b/penn_dataset.py
-index aa2f5a0..7f5a4fc 100644
---- a/penn_dataset.py
-+++ b/penn_dataset.py
-@@ -15,6 +15,7 @@ from forge import flags
- # aspects of data managmement
- flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
- flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-+flags.DEFINE_boolean("cross_validate",False,"Do K-fold cross-validation")
- 
- # Job management
- # flags.DEFINE_integer("batch size",5,"training batch size")
-@@ -109,15 +110,15 @@ def load(config):
-         
-         # set up training DataLoader
-         train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, n_train),num_workers=0,shuffle = True)
-+        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
- 
-         # set up test DataLoader
-         test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, n_test),num_workers=0,shuffle = True)
-+        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
- 
-         # set up val DataLoader
-         val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, n_val),num_workers=0,shuffle = True)
-+        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-         
- 
-         dataloaders = {'train':train_loader, 
-@@ -125,8 +126,12 @@ def load(config):
-                        'val':val_loader,
-                        'train_inds':train_ind,
-                        'test_inds':test_ind,
--                       'n_val':n_val
-+                       'n_val':n_val,
-+                       'test_headings':list(HEADINGS[test_ind])
-                       }
-         kf_dataloaders.append(dataloaders)
- 
-+        if not config.cross_validate:
-+        	break
-+
-     return kf_dataloaders
-diff --git a/testing.ipynb b/testing.ipynb
-index e5a167b..0110538 100644
---- a/testing.ipynb
-+++ b/testing.ipynb
-@@ -2,7 +2,7 @@
-  "cells": [
-   {
-    "cell_type": "code",
--   "execution_count": 1,
-+   "execution_count": 4,
-    "id": "4dee7ff1-01a4-4038-b493-9729ff3693f7",
-    "metadata": {},
-    "outputs": [],
-@@ -23,7 +23,7 @@
-   },
-   {
-    "cell_type": "code",
--   "execution_count": 2,
-+   "execution_count": 6,
-    "id": "cad0fdc8-5c35-4610-bba3-b71e60dc1b98",
-    "metadata": {},
-    "outputs": [],
-@@ -35,7 +35,7 @@
-   },
-   {
-    "cell_type": "code",
--   "execution_count": 3,
-+   "execution_count": 7,
-    "id": "ce1b936b-8a7c-426e-a3aa-3c1c38f645de",
-    "metadata": {},
-    "outputs": [
-@@ -54,8 +54,8 @@
-   },
-   {
-    "cell_type": "code",
--   "execution_count": 9,
--   "id": "e862b7e2-57f5-44bf-bcf1-a91160ba66cc",
-+   "execution_count": 5,
-+   "id": "4469cddf-4dac-4468-be88-241d440401c3",
-    "metadata": {},
-    "outputs": [
-     {
-@@ -67,35 +67,98 @@
-     }
-    ],
-    "source": [
--    "model = fet.load(\"basic_feedforward.py\",config)"
-+    "model,modelname = fet.load(\"basic_feedforward.py\",config)"
-    ]
-   },
-   {
-    "cell_type": "code",
--   "execution_count": 10,
--   "id": "07e0b160-d5d1-4e54-b4a7-ccaf2224598a",
-+   "execution_count": 13,
-+   "id": "7c9a9fe9-f5e8-456a-b964-4be13027725b",
-    "metadata": {},
-    "outputs": [
-     {
-      "data": {
-       "text/plain": [
--       "PerceptronNN(\n",
--       "  (fc1): Linear(in_features=39, out_features=128, bias=True)\n",
--       "  (fc2): Linear(in_features=128, out_features=64, bias=True)\n",
--       "  (fc3): Linear(in_features=64, out_features=64, bias=True)\n",
--       "  (fc4): Linear(in_features=64, out_features=2, bias=True)\n",
--       ")"
-+       "array([114170,    904])"
-       ]
-      },
--     "execution_count": 10,
-+     "execution_count": 13,
-      "metadata": {},
-      "output_type": "execute_result"
-     }
-    ],
-    "source": [
--    "model"
-+    "np.bincount(loaddat[0]['train'].dataset.all_labels)"
-    ]
-   },
-+  {
-+   "cell_type": "code",
-+   "execution_count": 1,
-+   "id": "e862b7e2-57f5-44bf-bcf1-a91160ba66cc",
-+   "metadata": {},
-+   "outputs": [
-+    {
-+     "ename": "FileNotFoundError",
-+     "evalue": "[Errno 2] Unable to open file (unable to open file: name = './checkpoints/feedforward/2/data_fold1/results_dict.h5', errno = 2, error message = 'No such file or directory', flags = 0, o_flags = 0)",
-+     "output_type": "error",
-+     "traceback": [
-+      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
-+      "\u001b[0;31mFileNotFoundError\u001b[0m                         Traceback (most recent call last)",
-+      "Cell \u001b[0;32mIn[1], line 5\u001b[0m\n\u001b[1;32m      3\u001b[0m file_path \u001b[38;5;241m=\u001b[39m \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124m./checkpoints/feedforward/2/data_fold1/results_dict.h5\u001b[39m\u001b[38;5;124m\"\u001b[39m\n\u001b[1;32m      4\u001b[0m \u001b[38;5;66;03m# Replace 'your_file.h5' with the actual path to your file\u001b[39;00m\n\u001b[0;32m----> 5\u001b[0m f \u001b[38;5;241m=\u001b[39m  \u001b[43mh5py\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mFile\u001b[49m\u001b[43m(\u001b[49m\u001b[43mfile_path\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[38;5;124;43mr\u001b[39;49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[43m)\u001b[49m \n\u001b[1;32m      7\u001b[0m     \u001b[38;5;66;03m# Get information about the data stored in the file\u001b[39;00m\n\u001b[1;32m      8\u001b[0m \u001b[38;5;28mprint\u001b[39m(\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mKeys:\u001b[39m\u001b[38;5;124m\"\u001b[39m, \u001b[38;5;28mlist\u001b[39m(f\u001b[38;5;241m.\u001b[39mkeys()))\n",
-+      "File \u001b[0;32m/Applications/miniconda3/envs/lietransformer/lib/python3.9/site-packages/h5py/_hl/files.py:562\u001b[0m, in \u001b[0;36mFile.__init__\u001b[0;34m(self, name, mode, driver, libver, userblock_size, swmr, rdcc_nslots, rdcc_nbytes, rdcc_w0, track_order, fs_strategy, fs_persist, fs_threshold, fs_page_size, page_buf_size, min_meta_keep, min_raw_keep, locking, alignment_threshold, alignment_interval, meta_block_size, **kwds)\u001b[0m\n\u001b[1;32m    553\u001b[0m     fapl \u001b[38;5;241m=\u001b[39m make_fapl(driver, libver, rdcc_nslots, rdcc_nbytes, rdcc_w0,\n\u001b[1;32m    554\u001b[0m                      locking, page_buf_size, min_meta_keep, min_raw_keep,\n\u001b[1;32m    555\u001b[0m                      alignment_threshold\u001b[38;5;241m=\u001b[39malignment_threshold,\n\u001b[1;32m    556\u001b[0m                      alignment_interval\u001b[38;5;241m=\u001b[39malignment_interval,\n\u001b[1;32m    557\u001b[0m                      meta_block_size\u001b[38;5;241m=\u001b[39mmeta_block_size,\n\u001b[1;32m    558\u001b[0m                      \u001b[38;5;241m*\u001b[39m\u001b[38;5;241m*\u001b[39mkwds)\n\u001b[1;32m    559\u001b[0m     fcpl \u001b[38;5;241m=\u001b[39m make_fcpl(track_order\u001b[38;5;241m=\u001b[39mtrack_order, fs_strategy\u001b[38;5;241m=\u001b[39mfs_strategy,\n\u001b[1;32m    560\u001b[0m                      fs_persist\u001b[38;5;241m=\u001b[39mfs_persist, fs_threshold\u001b[38;5;241m=\u001b[39mfs_threshold,\n\u001b[1;32m    561\u001b[0m                      fs_page_size\u001b[38;5;241m=\u001b[39mfs_page_size)\n\u001b[0;32m--> 562\u001b[0m     fid \u001b[38;5;241m=\u001b[39m \u001b[43mmake_fid\u001b[49m\u001b[43m(\u001b[49m\u001b[43mname\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mmode\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43muserblock_size\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mfapl\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mfcpl\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mswmr\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43mswmr\u001b[49m\u001b[43m)\u001b[49m\n\u001b[1;32m    564\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;28misinstance\u001b[39m(libver, \u001b[38;5;28mtuple\u001b[39m):\n\u001b[1;32m    565\u001b[0m     \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_libver \u001b[38;5;241m=\u001b[39m libver\n",
-+      "File \u001b[0;32m/Applications/miniconda3/envs/lietransformer/lib/python3.9/site-packages/h5py/_hl/files.py:235\u001b[0m, in \u001b[0;36mmake_fid\u001b[0;34m(name, mode, userblock_size, fapl, fcpl, swmr)\u001b[0m\n\u001b[1;32m    233\u001b[0m     \u001b[38;5;28;01mif\u001b[39;00m swmr \u001b[38;5;129;01mand\u001b[39;00m swmr_support:\n\u001b[1;32m    234\u001b[0m         flags \u001b[38;5;241m|\u001b[39m\u001b[38;5;241m=\u001b[39m h5f\u001b[38;5;241m.\u001b[39mACC_SWMR_READ\n\u001b[0;32m--> 235\u001b[0m     fid \u001b[38;5;241m=\u001b[39m \u001b[43mh5f\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mopen\u001b[49m\u001b[43m(\u001b[49m\u001b[43mname\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mflags\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mfapl\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43mfapl\u001b[49m\u001b[43m)\u001b[49m\n\u001b[1;32m    236\u001b[0m \u001b[38;5;28;01melif\u001b[39;00m mode \u001b[38;5;241m==\u001b[39m \u001b[38;5;124m'\u001b[39m\u001b[38;5;124mr+\u001b[39m\u001b[38;5;124m'\u001b[39m:\n\u001b[1;32m    237\u001b[0m     fid \u001b[38;5;241m=\u001b[39m h5f\u001b[38;5;241m.\u001b[39mopen(name, h5f\u001b[38;5;241m.\u001b[39mACC_RDWR, fapl\u001b[38;5;241m=\u001b[39mfapl)\n",
-+      "File \u001b[0;32mh5py/_objects.pyx:54\u001b[0m, in \u001b[0;36mh5py._objects.with_phil.wrapper\u001b[0;34m()\u001b[0m\n",
-+      "File \u001b[0;32mh5py/_objects.pyx:55\u001b[0m, in \u001b[0;36mh5py._objects.with_phil.wrapper\u001b[0;34m()\u001b[0m\n",
-+      "File \u001b[0;32mh5py/h5f.pyx:102\u001b[0m, in \u001b[0;36mh5py.h5f.open\u001b[0;34m()\u001b[0m\n",
-+      "\u001b[0;31mFileNotFoundError\u001b[0m: [Errno 2] Unable to open file (unable to open file: name = './checkpoints/feedforward/2/data_fold1/results_dict.h5', errno = 2, error message = 'No such file or directory', flags = 0, o_flags = 0)"
-+     ]
-+    }
-+   ],
-+   "source": [
-+    "import h5py\n",
-+    "\n",
-+    "file_path = \"./checkpoints/feedforward/2/data_fold1/results_dict.h5\"\n",
-+    "# Replace 'your_file.h5' with the actual path to your file\n",
-+    "f =  h5py.File(file_path, 'r') \n",
-+    "\n",
-+    "    # Get information about the data stored in the file\n",
-+    "print(\"Keys:\", list(f.keys()))  # List the top-level datasets and groups\n",
-+    "\n",
-+    "    # # Access a dataset by its name\n",
-+    "    # dataset_name = \"your_dataset_name\"\n",
-+    "    # if dataset_name in f:\n",
-+    "    #     dataset = f[dataset_name]\n",
-+    "    #     print(\"Dataset shape:\", dataset.shape)\n",
-+    "    #     print(\"Dataset dtype:\", dataset.dtype)\n",
-+    "\n",
-+    "    #     # Access the data as a NumPy array\n",
-+    "    #     data = dataset[:]  # Read the entire dataset\n",
-+    "\n",
-+    "    #     # You can now work with the data as needed, for example:\n",
-+    "    #     # Perform calculations, visualizations, etc.\n",
-+    "    # else:\n",
-+    "    #     print(f\"Dataset '{dataset_name}' not found in the file.\")"
-+   ]
-+  },
-+  {
-+   "cell_type": "code",
-+   "execution_count": 13,
-+   "id": "07e0b160-d5d1-4e54-b4a7-ccaf2224598a",
-+   "metadata": {},
-+   "outputs": [
-+    {
-+     "data": {
-+      "text/plain": [
-+       "<generator object Module.parameters at 0x3007207b0>"
-+      ]
-+     },
-+     "execution_count": 13,
-+     "metadata": {},
-+     "output_type": "execute_result"
-+    }
-+   ],
-+   "source": []
-+  },
-   {
-    "cell_type": "code",
-    "execution_count": null,
-diff --git a/train.py b/train.py
-index c266102..def250b 100644
---- a/train.py
-+++ b/train.py
-@@ -1,49 +1,451 @@
- from os import path as osp
-+import os
-+import numpy as np
-+import time
- 
- import torch
-+import torch.nn as nn
- import torch.nn.functional as F
- import torch.optim as optim
--
--import numpy as np
-+from torch.utils.tensorboard import SummaryWriter
- 
- import forge
- from forge import flags
- import forge.experiment_tools as fet
- 
-+from train_tools import (
-+	log_tensorboard,
-+	parse_reports,
-+	parse_reports_cpu,
-+	print_reports,
-+	load_checkpoint,
-+	save_checkpoint,
-+	nested_to,
-+	param_count,
-+)
-+
-+from copy import deepcopy
-+from attrdict import AttrDict
-+import deepdish as dd
-+from tqdm import tqdm
-+
-+# For reproducibility while researching, but might affect speed!
-+torch.backends.cudnn.deterministic = True
-+torch.backends.cudnn.benchmark = False
-+torch.manual_seed(0)
-+
- 
- # Job config
- flags.DEFINE_string('data_config', 'penn_dataset.py',
--                    'Path to a data config file.')
-+					'Path to a data config file.')
- flags.DEFINE_string('model_config', 'basic_feedforward.py',
--                    'Path to a model config file.')
-+					'Path to a model config file.')
- flags.DEFINE_string('results_dir', 'checkpoints',
--                    'Top directory for all experimental results.')
--flags.DEFINE_string('run_name', 'feedforward',
--                    'Name of this job and name of results folder.')
-+					'Top directory for all experimental results.')
-+flags.DEFINE_string('run_name', 'testing',
-+					'Name of this job and name of results folder.')
- flags.DEFINE_boolean('resume', False, 'Tries to resume a job if True.')
- 
- # Logging config
- flags.DEFINE_integer('report_loss_every', 50,
--                     'Number of iterations between reporting minibatch loss.')
--flags.DEFINE_integer('train_epochs', 20, 'Maximum number of training epochs.')
-+					 'Number of iterations between reporting minibatch loss.')
-+flags.DEFINE_integer('train_epochs', 10, 'Maximum number of training epochs.')
-+flags.DEFINE_integer(
-+	"save_check_points",
-+	50,
-+	"frequency with which to save checkpoints, in number of epoches.",
-+)
-+flags.DEFINE_boolean("log_train_values", True, "Logs train values if True.")
-+flags.DEFINE_integer(
-+	"total_evaluations",
-+	100,
-+	"Maximum number of evaluations on test and validation data during training.",
-+)
-+flags.DEFINE_boolean(
-+	"save_test_predictions",
-+	False,
-+	"Makes and saves test predictions on one or more test sets (e.g. 5-step and 100-step predictions) at the end of training.",
-+)
-+flags.DEFINE_boolean(
-+    "log_val_test", True, "Turns off computation of validation and test errors."
-+)
- 
- # Experiment config
- flags.DEFINE_integer('batch_size', 100, 'Mini-batch size.')
--flags.DEFINE_float('learning_rate', 1e-5, 'SGD learning rate.')
-+flags.DEFINE_float("learning_rate", 1e-4, "Adam learning rate.")
-+flags.DEFINE_float("beta1", 0.9, "Adam Beta 1 parameter")
-+flags.DEFINE_float("beta2", 0.999, "Adam Beta 2 parameter")
- 
- # Specific config options
- flags.DEFINE_integer("input_size",39,"Input shape to model")
- 
-+#########################################################################################
-+
-+def evaluate(model, loader, device,fold = 0,headings = [],loss_func = nn.CrossEntropyLoss()):
-+	# this function does not account for class weights when evaluating cross-entropy loss.
-+	# however, they are accounted for when evaluating training loss
-+	reports = None
-+	for data in loader:
-+		labels = data['label']
-+		inputs = nested_to(data['data'],device,torch.float32)
-+		
-+		labels_tensor = torch.zeros((len(labels), 2))
-+		for i, label in enumerate(labels):
-+			labels_tensor[i, label] = 1
-+
-+		model_output = model(inputs) # evaluate model
-+
-+		loss = loss_func(model_output, labels_tensor) # compute loss
-+		outputs = AttrDict({"loss": loss, "prediction": model_output,'data_fold':fold})
-+		outputs.reports = AttrDict({"cross_entropy": loss})
-+
-+		if reports is None:
-+			reports = {k: v.detach().clone().cpu() for k, v in outputs.reports.items()}
-+		else:
-+			for k, v in outputs.reports.items():
-+				reports[k] += v.detach().clone().cpu()
-+
-+	for k, v in reports.items():
-+		reports[k] = v / len(
-+			loader
-+		)  # SZ: note this can be slightly incorrect if mini-batch sizes vary (if batch_size doesn't divide train_size), but approximately correct.
-+
-+	# reports['test_headings'] = np.array(headings)
-+
-+	return reports
-+
-+def main():
-+
-+	config = forge.config()
-+
-+	# Set device
-+	if torch.cuda.is_available():
-+		device = f"cuda:{config.device}"
-+		torch.cuda.set_device(device)
-+	else:
-+		device = "cpu" # can change this to MPS on M1 Macs
-+
-+	# Load data
-+	data_name = "penn_data"
-+	kfold_loaders = fet.load(config.data_config, config)
-+
-+	# Load model
-+	model,model_name = fet.load(config.model_config, config)
-+	model = model.to(device)
-+
-+	# Prepare environment
-+	params_in_run_name = [
-+		("batch_size", "bs"),
-+		("learning_rate", "lr"),
-+		("n_train", "ntrain"),
-+		("include_coords",'inclx'),
-+		("input_size",'inpsize'),
-+		("cross_validate",'crval'),
-+		("train_epochs",'n_epochs'),
-+	]
-+
-+	run_name = ""  # config.run_name
-+	for config_param in params_in_run_name:
-+		attr = config_param[0]
-+		abbrev = config_param[1]
-+
-+		if hasattr(config, attr):
-+			run_name += abbrev
-+			run_name += str(getattr(config, attr))
-+			run_name += "_"
-+
-+	results_folder_name = osp.join(
-+		data_name,
-+		model_name,
-+		config.run_name,
-+		run_name,
-+	)
-+
-+	# Prepare environment
-+	logdir = osp.join(config.results_dir, results_folder_name.replace(".", "_"))
-+	logdir, resume_checkpoint = fet.init_checkpoint(
-+		logdir, config.data_config, config.model_config, config.resume)
-+
-+	print("Checkpoint directory:",logdir)
-+
-+	# Print flags
-+	fet.print_flags()
-+	# Print model info
-+	print(model)
-+
-+	# Setup optimizer
-+	model_params = model.parameters()
-+	opt_learning_rate = config.learning_rate
-+	model_opt = torch.optim.Adam(
-+		model_params, lr=opt_learning_rate, betas=(config.beta1, config.beta2)
-+	)
-+	print("Model Optimizer:")
-+	print(model_opt)
-+
-+	# Try to restore model and optimizer from checkpoint
-+	if resume_checkpoint is not None:
-+		start_epoch = load_checkpoint(resume_checkpoint, model, model_opt)
-+	else:
-+		start_epoch = 1
-+
-+	n_folds = len(kfold_loaders)
-+	print("Doing {}-fold cross-validation.".format(n_folds))
-+
-+	# KFOLD TRAINING LOOP
-+	for k,loader_k in enumerate(kfold_loaders): # loop over data splits
-+
-+		print("Training fold {}...".format(k+1))
-+
-+		# load the training data
-+		train_loader = loader_k["train"]
-+		n_train = len(train_loader.dataset)
-+		train_batch_size = train_loader.batch_size
-+
-+		# load testing, validation
-+		test_loader = loader_k["test"]
-+		n_test = len(test_loader.dataset)
-+		val_loader = loader_k["val"]
-+		n_val = len(val_loader.dataset)
-+
-+		train_class_counts = np.bincount(train_loader.dataset.all_labels)
-+		train_total_counts = sum(train_class_counts)
-+		class_weight = torch.tensor(1.0 / train_class_counts) * train_total_counts / 2.0
-+
-+		loss_func = nn.CrossEntropyLoss(weight = class_weight) # define reweighted loss function
-+				
-+		# create folder for this data split
-+		fold_dir = osp.join(logdir,"data_fold{}".format(k+1))
-+		fold_dir_exists = osp.exists(fold_dir)
-+		if not fold_dir_exists:
-+			if config.resume:
-+				raise ValueError("Can't resume when the checkpoint/fold dir '{}' doesn't exist.".format(fold_dir))
-+			else:
-+				os.makedirs(fold_dir)
-+		checkpoint_name = osp.join(fold_dir, 'model_fold{}.ckpt'.format(k+1))
-+
-+		# keep track of which data is test data for a given Kfold data split
-+		test_headings = loader_k['test_headings']
-+		headingsFile = osp.join(fold_dir,"test_headings.txt")
-+		with open(headingsFile,'w') as headfile:
-+			for heading in test_headings:
-+				headfile.write(heading+'\n')
-+
-+		# print(checkpoint_name)
-+
-+		train_iter = (start_epoch - 1) * (
-+		len(train_loader.dataset) // train_batch_size
-+		) + 1
-+
-+		print("Starting training at epoch = {}, iter = {}".format(start_epoch, train_iter))
-+
-+		# Setup tensorboard writing
-+		summary_writer = SummaryWriter(logdir)
-+
-+		train_reports = []
-+		report_all = {}
-+		report_all_val = {}
-+
-+		# Saving model at epoch 0 before training
-+		print("saving model at epoch 0 before training ... ")
-+		save_checkpoint(checkpoint_name, 0, model, model_opt, loss=0.0)
-+		print("finished saving model at epoch 0 before training")
-+
-+		num_params = param_count(model)
-+		print(f"Number of model parameters: {num_params}")
-+
-+		# Training
-+		start_t = time.time()
-+
-+		total_train_iters = len(train_loader) * config.train_epochs
-+		iters_per_eval = max(1, int(total_train_iters / config.total_evaluations))
-+		# print('batch',train_batch_size)
-+		# print('ntrain',n_train)
-+		# assert (
-+		# 	n_train % min(train_batch_size, n_train) == 0
-+		# ), "Batch size doesn't divide dataset size. Can be inaccurate for loss computation (see below)."
-+
-+		training_failed = False
-+		best_val_loss_so_far = 1e7
-+
-+		for epoch in tqdm(range(start_epoch, config.train_epochs + 1)):
-+			model.train()
-+
-+			for batch_idx, data_dict in enumerate(train_loader): # Loop over batched data
-+
-+				labels = data_dict['label']
-+				data = data_dict['data']
-+
-+				# send data to device
-+				data = nested_to(data,device,torch.float32)
-+				# One-hot encode the data labels
-+				labels_tensor = torch.zeros((len(labels), 2))
-+				for i, label in enumerate(labels):
-+					labels_tensor[i, label] = 1
-+
-+				model_output = model(data) # evaluate model
-+
-+				loss = loss_func(model_output, labels_tensor) # compute loss
-+				outputs = AttrDict({"loss": loss, "prediction": model_output})
-+				outputs.reports = AttrDict({"cross_entropy": loss})
-+
-+				if torch.isnan(outputs.loss): # check for failure in training
-+					if not training_failed:
-+						epoch_of_nan = epoch
-+					if (epoch > epoch_of_nan + 1) and training_failed:
-+						raise ValueError("Loss Nan-ed.")
-+					training_failed = True
-+
-+				model_opt.zero_grad()
-+				outputs.loss.backward(retain_graph=False)
-+
-+				model_opt.step() # move optimizer forward
-+
-+				train_reports.append(parse_reports_cpu(outputs.reports))
-+
-+				if config.log_train_values:
-+					reports = parse_reports(outputs.reports)
-+					if batch_idx % config.report_loss_every == 0:
-+						log_tensorboard(summary_writer, train_iter, reports, "train/")
-+						print_reports(
-+							reports,
-+							start_t,
-+							epoch,
-+							batch_idx,
-+							len(train_loader.dataset) // train_batch_size,
-+							prefix="train",
-+						)
-+						log_tensorboard(
-+							summary_writer,
-+							train_iter,
-+							{"lr": model_opt.param_groups[0]["lr"]},
-+							"hyperparams/",
-+						)
-+				# Logging and evaluation
-+				if (
-+					train_iter % iters_per_eval == 0 or (train_iter == total_train_iters)
-+				) and config.log_val_test:  # batch_idx % config.evaluate_every == 0:
-+					model.eval()
-+					with torch.no_grad():
-+						reports = evaluate(model, test_loader, device,fold = k,headings = loader_k['test_headings'])
-+						# print("REPORTS",reports)
-+						reports = parse_reports(reports)
-+						reports["time"] = time.time() - start_t
-+						if report_all == {}:
-+							report_all = deepcopy(reports)
-+
-+							for d in reports.keys():
-+								report_all[d] = [report_all[d]]
-+						else:
-+							for d in reports.keys():
-+								report_all[d].append(reports[d])
-+
-+						log_tensorboard(summary_writer, train_iter, reports, "test/")
-+						print_reports(
-+							reports,
-+							start_t,
-+							epoch,
-+							batch_idx,
-+							len(train_loader.dataset) // config.batch_size,
-+							prefix="test",
-+						)
-+
-+						# repeat for validation data
-+						reports = evaluate(model, val_loader, device,fold = k,headings = loader_k['test_headings'])
-+						reports = parse_reports(reports)
-+						reports["time"] = time.time() - start_t
-+						if report_all_val == {}:
-+							report_all_val = deepcopy(reports)
-+
-+							for d in reports.keys():
-+								report_all_val[d] = [report_all_val[d]]
-+						else:
-+							for d in reports.keys():
-+								report_all_val[d].append(reports[d])
-+
-+						log_tensorboard(summary_writer, train_iter, reports, "val/")
-+						print_reports(
-+							reports,
-+							start_t,
-+							epoch,
-+							batch_idx,
-+							len(train_loader.dataset) // config.batch_size,
-+							prefix="val",
-+						)
-+
-+						if report_all_val["cross_entropy"][-1] < best_val_loss_so_far:
-+							save_checkpoint(
-+								checkpoint_name,
-+								f"early_stop",
-+								model,
-+								model_opt,
-+								loss=outputs.loss,
-+							)
-+							best_val_loss_so_far = report_all_val["cross_entropy"][-1]
-+
-+					model.train()
-+
-+				train_iter += 1
-+
-+			if epoch % config.save_check_points == 0:
-+				save_checkpoint(
-+					checkpoint_name, train_iter, model, model_opt, loss=outputs.loss
-+				)
-+		print('train_reports',train_reports)
-+		print("report_all",report_all)
-+		dd.io.save(fold_dir + "/results_dict_train.h5", train_reports)
-+		dd.io.save(fold_dir + "/results_dict.h5", report_all)
-+		dd.io.save(fold_dir + "/results_dict_val.h5", report_all_val)
-+
-+	# always save final model
-+	save_checkpoint(checkpoint_name, train_iter, model, model_opt, loss=outputs.loss)
-+
-+	
-+	if config.save_test_predictions:
-+		pass
-+		# print("Starting to make model predictions on test sets for *final model*.")
-+		# for chunk_len in [5, 100]:
-+		#     start_t_preds = time.time()
-+		#     data_config = SimpleNamespace(
-+		#         **{
-+		#             **config.__dict__["__flags"],
-+		#             **{"chunk_len": chunk_len, "batch_size": 500},
-+		#         }
-+		#     )
-+		#     dataloaders, data_name = fet.load(config.data_config, config=data_config)
-+		#     test_loader_preds = dataloaders["test"]
-+
-+		#     torch.cuda.empty_cache()
-+		#     with torch.no_grad():
-+		#         preds = []
-+		#         true = []
-+		#         num_datapoints = 0
-+		#         for idx, d in enumerate(test_loader_preds):
-+		#             true.append(d[-1])
-+		#             d = nested_to(d, device, torch.float32)
-+		#             outputs = model(d)
-+
-+		#             pred_zs = outputs.prediction
-+		#             preds.append(pred_zs)
-+
-+		#             num_datapoints += len(pred_zs)
-+
-+		#             if num_datapoints >= 2000:
-+		#                 break
- 
--config = forge.config()
-+		#         preds = torch.cat(preds, dim=0).cpu()
-+		#         true = torch.cat(true, dim=0).cpu()
- 
--# Prepare environment
--logdir = osp.join(config.results_dir, config.run_name)
--logdir, resume_checkpoint = fet.init_checkpoint(
--    logdir, config.data_config, config.model_config, config.resume)
--checkpoint_name = osp.join(logdir, 'model.ckpt')
-+		#         save_dir = osp.join(logdir, f"traj_preds_{chunk_len}_steps_2k_test.pt")
-+		#         torch.save(preds, save_dir)
- 
-+		#         save_dir = osp.join(logdir, f"traj_true_{chunk_len}_steps_2k_test.pt")
-+		#         torch.save(true, save_dir)
- 
--print(logdir)
-+		#         print(
-+		#             f"Completed making test predictions for chunk_len = {chunk_len} in {time.time() - start_t_preds:.2f} seconds."
-+		#         )	
-+		
- 
-+if __name__ == "__main__":
-+	main()
- 
diff --git a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/penn_dataset.py b/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/penn_dataset.py
deleted file mode 100644
index 7f5a4fc..0000000
--- a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs100_/1/penn_dataset.py
+++ /dev/null
@@ -1,137 +0,0 @@
-import os
-import torch
-import pandas as pd
-import numpy as np
-
-from torchvision import datasets, transforms
-from torch.utils.data import Dataset, DataLoader
-from sklearn.model_selection import RepeatedKFold
-
-from os import path as osp
-import forge
-from forge import flags
-
-
-# aspects of data managmement
-flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
-flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-flags.DEFINE_boolean("cross_validate",False,"Do K-fold cross-validation")
-
-# Job management
-# flags.DEFINE_integer("batch size",5,"training batch size")
-flags.DEFINE_float("train_split",0.8,'Fraction of data to use for training.')
-flags.DEFINE_integer("n_repeats",1,"Times to repeat K-fold cross-validation")
-flags.DEFINE_integer("split_seed",1,"Seed for KFold split (integer for reproducibility")
-
-# "wavelengths between 0.05 and 1 mm in 0.025 mm increments."
-LSPACE = np.arange(0.05,1.05,0.025) # corresponds to 39 non-coord columns of data
-L_INDS = None
-
-DATAFOLDER = './penn_data'
-
-HEADINGS = np.array(['aaa0043','aaa0044','aaa0060','aaa0061','aaa0063','aaa0064','aaa0066','aaa0069','aaa0086','aaa0087','aaa_0051','aaa_0053','aaa_0054','aaa_0059','aaa_0071','aaa_0072'])
-
-
-class PennData(Dataset):
-
-    def __init__(self,path_to_data,headings,k_inds = None,include_coords = True,rescale = True,spectra_prefix = "kvals_fuse_rotate_",label_prefix = 'labels_fuse_rotate_'):
-        
-        self.data_dir = path_to_data
-        self.headings = headings
-
-        df_list = []
-        label_list = []
-        for heading in self.headings: # for each datafile heading,
-            data_name = osp.join(self.data_dir,spectra_prefix + heading+'.csv') # read kvals
-            df_temp = pd.read_csv(data_name,header=None)
-            df_list.append(df_temp)
-
-            label_name = osp.join(self.data_dir,label_prefix + heading + '.csv') # read labels
-            label_temp = pd.read_csv(label_name,header=None, names=['label'])
-            label_list.append(label_temp)
-
-        df = pd.concat(df_list, ignore_index=True)
-
-        labels = pd.concat(label_list, ignore_index=True)
-        df = pd.concat([labels, df], axis="columns") # Append labels to data
-
-        all_labels = df['label'].to_numpy()
-        all_data = df.iloc[:,1:].to_numpy()
-
-        if rescale: # rescale (normalize) wavelength intensity data
-            lambdas = all_data[:,2:] # wavelengths
-            lam_std = np.std(lambdas, axis=0)  # Calculate standard deviation along columns
-            lam_mean = np.mean(lambdas, axis=0)  # Calculate mean along columns
-            lambdas_rescaled = (lambdas - lam_mean) / lam_std 
-            all_data[:,2:] = lambdas_rescaled
-
-        if not include_coords: # removes x,y coordinates from data
-            all_data = all_data[:,2:]
-        
-        if k_inds != None: # in this case, only use subset of wavelengths
-            all_data = all_data[:,np.array(k_inds)]
-
-        self.all_data = all_data
-        self.all_labels = all_labels
-
-    def __len__(self):
-        return len(self.all_data)
-
-    def __getitem__(self,i):
-        state = {'label':self.all_labels[i],'data':self.all_data[i]}
-        return state
-
-    def __getstate__(self):
-        state = {
-            'data': self.all_data,
-            'label': self.all_labels,
-                }
-        return state
-
-    def __setstate__(self, state):
-        # Set the object's state from the provided dictionary
-        self.all_data = state['data']
-        self.all_labels = state['label']
-        
-
-
-def load(config):
-
-    n_splits = int(len(HEADINGS)/((1-config.train_split)*len(HEADINGS)))
-
-    kf = RepeatedKFold(n_splits = n_splits, n_repeats = config.n_repeats, random_state = config.split_seed) # K-fold cross validation
-
-    kf_dataloaders = []
-
-    for i, (train_ind, test_ind) in enumerate(kf.split(HEADINGS)): # for each K-fold split, 
-        n_val = len(test_ind)//2
-        n_test = len(test_ind)-n_val   
-        n_train = len(train_ind)
-        
-        # set up training DataLoader
-        train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
-
-        # set up test DataLoader
-        test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
-
-        # set up val DataLoader
-        val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-        
-
-        dataloaders = {'train':train_loader, 
-                       'test':test_loader,
-                       'val':val_loader,
-                       'train_inds':train_ind,
-                       'test_inds':test_ind,
-                       'n_val':n_val,
-                       'test_headings':list(HEADINGS[test_ind])
-                      }
-        kf_dataloaders.append(dataloaders)
-
-        if not config.cross_validate:
-        	break
-
-    return kf_dataloaders
diff --git a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs10_/.DS_Store b/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs10_/.DS_Store
deleted file mode 100644
index 9c7a74d..0000000
Binary files a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs10_/.DS_Store and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs10_/1/basic_feedforward.py b/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs10_/1/basic_feedforward.py
deleted file mode 100644
index b8c3962..0000000
--- a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs10_/1/basic_feedforward.py
+++ /dev/null
@@ -1,42 +0,0 @@
-import torch
-import torch.nn as nn
-import torch.nn.functional as F
-import numpy as np
-
-from forge import flags
-
-# flags.DEFINE_boolean(
-#     "model_with_dict",
-#     True,
-#     "Makes model output predictions in dictionary instead of directly."
-# )
-
-class PerceptronNN(nn.Module):
-    def __init__(self, input_size, num_labels):
-        super(PerceptronNN, self).__init__()
-        # Define the layers
-        self.fc1 = nn.Linear(input_size, 128)  # First dense layer
-        self.fc2 = nn.Linear(128, 64)         # Second dense layer
-        self.fc23 = nn.Linear(64,64)
-        self.fc3 = nn.Linear(64, 64)          # Third dense layer
-        self.fc4 = nn.Linear(64, num_labels)  # Output layer
-        # self.softmax = nn.Softmax(dim=1)
-
-    def forward(self, x):
-        # Forward pass through the network
-        x = F.relu(self.fc1(x))  # Activation function between layers
-        x = F.relu(self.fc2(x))
-        x = F.relu(self.fc23(x))
-        x = F.relu(self.fc3(x))
-        x = self.fc4(x)  # No activation, this will be included in the loss function
-        # x = self.softmax(x)
-        return x
-
-def load(config):
-
-    # n_channels = 1
-    n_features = config.input_size
-    
-    mlp = PerceptronNN(n_features,2)
-    
-    return mlp, "feedforward"
\ No newline at end of file
diff --git a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs10_/1/data_fold1/model_fold1.ckpt-0 b/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs10_/1/data_fold1/model_fold1.ckpt-0
deleted file mode 100644
index 24b3d19..0000000
Binary files a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs10_/1/data_fold1/model_fold1.ckpt-0 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs10_/1/data_fold1/model_fold1.ckpt-11511 b/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs10_/1/data_fold1/model_fold1.ckpt-11511
deleted file mode 100644
index 4982cfb..0000000
Binary files a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs10_/1/data_fold1/model_fold1.ckpt-11511 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs10_/1/data_fold1/model_fold1.ckpt-early_stop b/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs10_/1/data_fold1/model_fold1.ckpt-early_stop
deleted file mode 100644
index 6fd2104..0000000
Binary files a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs10_/1/data_fold1/model_fold1.ckpt-early_stop and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs10_/1/data_fold1/results_dict.h5 b/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs10_/1/data_fold1/results_dict.h5
deleted file mode 100644
index c7e5da6..0000000
Binary files a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs10_/1/data_fold1/results_dict.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs10_/1/data_fold1/results_dict_train.h5 b/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs10_/1/data_fold1/results_dict_train.h5
deleted file mode 100644
index 96d7363..0000000
Binary files a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs10_/1/data_fold1/results_dict_train.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs10_/1/data_fold1/results_dict_val.h5 b/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs10_/1/data_fold1/results_dict_val.h5
deleted file mode 100644
index 1bc99fd..0000000
Binary files a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs10_/1/data_fold1/results_dict_val.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs10_/1/data_fold1/test_headings.txt b/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs10_/1/data_fold1/test_headings.txt
deleted file mode 100644
index 05c4825..0000000
--- a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs10_/1/data_fold1/test_headings.txt
+++ /dev/null
@@ -1,4 +0,0 @@
-aaa0060
-aaa0061
-aaa0069
-aaa_0059
diff --git a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs10_/1/events.out.tfevents.1709672112.MacBook-Pro-4.local.7461.0 b/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs10_/1/events.out.tfevents.1709672112.MacBook-Pro-4.local.7461.0
deleted file mode 100644
index bd35954..0000000
Binary files a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs10_/1/events.out.tfevents.1709672112.MacBook-Pro-4.local.7461.0 and /dev/null differ
diff --git a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs10_/1/flags.json b/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs10_/1/flags.json
deleted file mode 100644
index 3152d07..0000000
--- a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs10_/1/flags.json
+++ /dev/null
@@ -1,26 +0,0 @@
-{
-    "batch_size": 100,
-    "beta1": 0.9,
-    "beta2": 0.999,
-    "cross_validate": false,
-    "data_config": "penn_dataset.py",
-    "git_commit": "7416bf730b356aabfe0df644240e40948a8196bb",
-    "include_coords": false,
-    "input_size": 39,
-    "learning_rate": 0.0001,
-    "log_train_values": true,
-    "log_val_test": true,
-    "model_config": "basic_feedforward.py",
-    "n_repeats": 1,
-    "report_loss_every": 50,
-    "rescale": true,
-    "results_dir": "checkpoints",
-    "resume": false,
-    "run_name": "testing",
-    "save_check_points": 50,
-    "save_test_predictions": false,
-    "split_seed": 1,
-    "total_evaluations": 100,
-    "train_epochs": 10,
-    "train_split": 0.8
-}
\ No newline at end of file
diff --git a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs10_/1/git_diff.txt b/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs10_/1/git_diff.txt
deleted file mode 100644
index d70a1bb..0000000
--- a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs10_/1/git_diff.txt
+++ /dev/null
@@ -1,1768 +0,0 @@
-Tue Mar 5 12:55:12 PST 2024
-diff --git a/.DS_Store b/.DS_Store
-index e2836a8..c46cff7 100644
-Binary files a/.DS_Store and b/.DS_Store differ
-diff --git a/.ipynb_checkpoints/basic_feedforward-checkpoint.py b/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-index 688c282..0c4bcd1 100644
---- a/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-+++ b/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-@@ -5,6 +5,12 @@ import numpy as np
- 
- from forge import flags
- 
-+flags.DEFINE_boolean(
-+    "model_with_dict",
-+    True,
-+    "Makes model output predictions in dictionary instead of directly."
-+)
-+
- class PerceptronNN(nn.Module):
-     def __init__(self, input_size, num_labels):
-         super(PerceptronNN, self).__init__()
-@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-+        self.softmax = nn.Softmax(dim=1)
- 
-     def forward(self, x):
-         # Forward pass through the network
-@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-         x = F.relu(self.fc2(x))
-         x = F.relu(self.fc3(x))
-         x = self.fc4(x)  # No activation, this will be included in the loss function
-+        x = self.softmax(x)
-         return x
- 
- def load(config):
-@@ -29,4 +37,4 @@ def load(config):
-     
-     mlp = PerceptronNN(n_features,2)
-     
--    return mlp
-\ No newline at end of file
-+    return mlp, "feedforward"
-\ No newline at end of file
-diff --git a/__pycache__/basic_feedforward.cpython-39.pyc b/__pycache__/basic_feedforward.cpython-39.pyc
-index f541140..0e2c7e5 100644
-Binary files a/__pycache__/basic_feedforward.cpython-39.pyc and b/__pycache__/basic_feedforward.cpython-39.pyc differ
-diff --git a/__pycache__/penn_dataset.cpython-39.pyc b/__pycache__/penn_dataset.cpython-39.pyc
-index 0d7a4de..19121eb 100644
-Binary files a/__pycache__/penn_dataset.cpython-39.pyc and b/__pycache__/penn_dataset.cpython-39.pyc differ
-diff --git a/basic_feedforward.py b/basic_feedforward.py
-index 688c282..b8c3962 100644
---- a/basic_feedforward.py
-+++ b/basic_feedforward.py
-@@ -5,21 +5,31 @@ import numpy as np
- 
- from forge import flags
- 
-+# flags.DEFINE_boolean(
-+#     "model_with_dict",
-+#     True,
-+#     "Makes model output predictions in dictionary instead of directly."
-+# )
-+
- class PerceptronNN(nn.Module):
-     def __init__(self, input_size, num_labels):
-         super(PerceptronNN, self).__init__()
-         # Define the layers
-         self.fc1 = nn.Linear(input_size, 128)  # First dense layer
-         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-+        self.fc23 = nn.Linear(64,64)
-         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-+        # self.softmax = nn.Softmax(dim=1)
- 
-     def forward(self, x):
-         # Forward pass through the network
-         x = F.relu(self.fc1(x))  # Activation function between layers
-         x = F.relu(self.fc2(x))
-+        x = F.relu(self.fc23(x))
-         x = F.relu(self.fc3(x))
-         x = self.fc4(x)  # No activation, this will be included in the loss function
-+        # x = self.softmax(x)
-         return x
- 
- def load(config):
-@@ -29,4 +39,4 @@ def load(config):
-     
-     mlp = PerceptronNN(n_features,2)
-     
--    return mlp
-\ No newline at end of file
-+    return mlp, "feedforward"
-\ No newline at end of file
-diff --git a/checkpoints/feedforward/1/basic_feedforward.py b/checkpoints/feedforward/1/basic_feedforward.py
-index 688c282..3a65525 100644
---- a/checkpoints/feedforward/1/basic_feedforward.py
-+++ b/checkpoints/feedforward/1/basic_feedforward.py
-@@ -5,6 +5,12 @@ import numpy as np
- 
- from forge import flags
- 
-+# flags.DEFINE_boolean(
-+#     "model_with_dict",
-+#     True,
-+#     "Makes model output predictions in dictionary instead of directly."
-+# )
-+
- class PerceptronNN(nn.Module):
-     def __init__(self, input_size, num_labels):
-         super(PerceptronNN, self).__init__()
-@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-+        self.softmax = nn.Softmax(dim=1)
- 
-     def forward(self, x):
-         # Forward pass through the network
-@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-         x = F.relu(self.fc2(x))
-         x = F.relu(self.fc3(x))
-         x = self.fc4(x)  # No activation, this will be included in the loss function
-+        x = self.softmax(x)
-         return x
- 
- def load(config):
-@@ -29,4 +37,4 @@ def load(config):
-     
-     mlp = PerceptronNN(n_features,2)
-     
--    return mlp
-\ No newline at end of file
-+    return mlp, "feedforward"
-\ No newline at end of file
-diff --git a/checkpoints/feedforward/1/flags.json b/checkpoints/feedforward/1/flags.json
-index 1d000c3..889a6ea 100644
---- a/checkpoints/feedforward/1/flags.json
-+++ b/checkpoints/feedforward/1/flags.json
-@@ -1,9 +1,15 @@
- {
-     "batch_size": 100,
-+    "beta1": 0.9,
-+    "beta2": 0.999,
-+    "cross_validate": false,
-     "data_config": "penn_dataset.py",
-+    "git_commit": "7416bf730b356aabfe0df644240e40948a8196bb",
-     "include_coords": false,
-     "input_size": 39,
--    "learning_rate": 1e-05,
-+    "learning_rate": 0.0001,
-+    "log_train_values": true,
-+    "log_val_test": true,
-     "model_config": "basic_feedforward.py",
-     "n_repeats": 1,
-     "report_loss_every": 50,
-@@ -11,7 +17,10 @@
-     "results_dir": "checkpoints",
-     "resume": false,
-     "run_name": "feedforward",
-+    "save_check_points": 50,
-+    "save_test_predictions": false,
-     "split_seed": 1,
--    "train_epochs": 20,
-+    "total_evaluations": 100,
-+    "train_epochs": 100,
-     "train_split": 0.8
- }
-\ No newline at end of file
-diff --git a/checkpoints/feedforward/1/git_diff.txt b/checkpoints/feedforward/1/git_diff.txt
-index 7b37e6f..ec23707 100644
---- a/checkpoints/feedforward/1/git_diff.txt
-+++ b/checkpoints/feedforward/1/git_diff.txt
-@@ -1 +1,873 @@
--Mon Mar 4 11:45:48 PST 2024
-+Mon Mar 4 16:34:02 PST 2024
-+diff --git a/.DS_Store b/.DS_Store
-+index e2836a8..7e3fa32 100644
-+Binary files a/.DS_Store and b/.DS_Store differ
-+diff --git a/.ipynb_checkpoints/basic_feedforward-checkpoint.py b/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-+index 688c282..0c4bcd1 100644
-+--- a/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-++++ b/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-+@@ -5,6 +5,12 @@ import numpy as np
-+ 
-+ from forge import flags
-+ 
-++flags.DEFINE_boolean(
-++    "model_with_dict",
-++    True,
-++    "Makes model output predictions in dictionary instead of directly."
-++)
-++
-+ class PerceptronNN(nn.Module):
-+     def __init__(self, input_size, num_labels):
-+         super(PerceptronNN, self).__init__()
-+@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-+         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-+         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-+         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-++        self.softmax = nn.Softmax(dim=1)
-+ 
-+     def forward(self, x):
-+         # Forward pass through the network
-+@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-+         x = F.relu(self.fc2(x))
-+         x = F.relu(self.fc3(x))
-+         x = self.fc4(x)  # No activation, this will be included in the loss function
-++        x = self.softmax(x)
-+         return x
-+ 
-+ def load(config):
-+@@ -29,4 +37,4 @@ def load(config):
-+     
-+     mlp = PerceptronNN(n_features,2)
-+     
-+-    return mlp
-+\ No newline at end of file
-++    return mlp, "feedforward"
-+\ No newline at end of file
-+diff --git a/__pycache__/basic_feedforward.cpython-39.pyc b/__pycache__/basic_feedforward.cpython-39.pyc
-+index f541140..5ad96de 100644
-+Binary files a/__pycache__/basic_feedforward.cpython-39.pyc and b/__pycache__/basic_feedforward.cpython-39.pyc differ
-+diff --git a/__pycache__/penn_dataset.cpython-39.pyc b/__pycache__/penn_dataset.cpython-39.pyc
-+index 0d7a4de..19121eb 100644
-+Binary files a/__pycache__/penn_dataset.cpython-39.pyc and b/__pycache__/penn_dataset.cpython-39.pyc differ
-+diff --git a/basic_feedforward.py b/basic_feedforward.py
-+index 688c282..3a65525 100644
-+--- a/basic_feedforward.py
-++++ b/basic_feedforward.py
-+@@ -5,6 +5,12 @@ import numpy as np
-+ 
-+ from forge import flags
-+ 
-++# flags.DEFINE_boolean(
-++#     "model_with_dict",
-++#     True,
-++#     "Makes model output predictions in dictionary instead of directly."
-++# )
-++
-+ class PerceptronNN(nn.Module):
-+     def __init__(self, input_size, num_labels):
-+         super(PerceptronNN, self).__init__()
-+@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-+         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-+         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-+         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-++        self.softmax = nn.Softmax(dim=1)
-+ 
-+     def forward(self, x):
-+         # Forward pass through the network
-+@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-+         x = F.relu(self.fc2(x))
-+         x = F.relu(self.fc3(x))
-+         x = self.fc4(x)  # No activation, this will be included in the loss function
-++        x = self.softmax(x)
-+         return x
-+ 
-+ def load(config):
-+@@ -29,4 +37,4 @@ def load(config):
-+     
-+     mlp = PerceptronNN(n_features,2)
-+     
-+-    return mlp
-+\ No newline at end of file
-++    return mlp, "feedforward"
-+\ No newline at end of file
-+diff --git a/checkpoints/feedforward/1/basic_feedforward.py b/checkpoints/feedforward/1/basic_feedforward.py
-+index 688c282..3a65525 100644
-+--- a/checkpoints/feedforward/1/basic_feedforward.py
-++++ b/checkpoints/feedforward/1/basic_feedforward.py
-+@@ -5,6 +5,12 @@ import numpy as np
-+ 
-+ from forge import flags
-+ 
-++# flags.DEFINE_boolean(
-++#     "model_with_dict",
-++#     True,
-++#     "Makes model output predictions in dictionary instead of directly."
-++# )
-++
-+ class PerceptronNN(nn.Module):
-+     def __init__(self, input_size, num_labels):
-+         super(PerceptronNN, self).__init__()
-+@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-+         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-+         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-+         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-++        self.softmax = nn.Softmax(dim=1)
-+ 
-+     def forward(self, x):
-+         # Forward pass through the network
-+@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-+         x = F.relu(self.fc2(x))
-+         x = F.relu(self.fc3(x))
-+         x = self.fc4(x)  # No activation, this will be included in the loss function
-++        x = self.softmax(x)
-+         return x
-+ 
-+ def load(config):
-+@@ -29,4 +37,4 @@ def load(config):
-+     
-+     mlp = PerceptronNN(n_features,2)
-+     
-+-    return mlp
-+\ No newline at end of file
-++    return mlp, "feedforward"
-+\ No newline at end of file
-+diff --git a/checkpoints/feedforward/1/flags.json b/checkpoints/feedforward/1/flags.json
-+index 1d000c3..889a6ea 100644
-+--- a/checkpoints/feedforward/1/flags.json
-++++ b/checkpoints/feedforward/1/flags.json
-+@@ -1,9 +1,15 @@
-+ {
-+     "batch_size": 100,
-++    "beta1": 0.9,
-++    "beta2": 0.999,
-++    "cross_validate": false,
-+     "data_config": "penn_dataset.py",
-++    "git_commit": "7416bf730b356aabfe0df644240e40948a8196bb",
-+     "include_coords": false,
-+     "input_size": 39,
-+-    "learning_rate": 1e-05,
-++    "learning_rate": 0.0001,
-++    "log_train_values": true,
-++    "log_val_test": true,
-+     "model_config": "basic_feedforward.py",
-+     "n_repeats": 1,
-+     "report_loss_every": 50,
-+@@ -11,7 +17,10 @@
-+     "results_dir": "checkpoints",
-+     "resume": false,
-+     "run_name": "feedforward",
-++    "save_check_points": 50,
-++    "save_test_predictions": false,
-+     "split_seed": 1,
-+-    "train_epochs": 20,
-++    "total_evaluations": 100,
-++    "train_epochs": 100,
-+     "train_split": 0.8
-+ }
-+\ No newline at end of file
-+diff --git a/checkpoints/feedforward/1/git_diff.txt b/checkpoints/feedforward/1/git_diff.txt
-+index 7b37e6f..5c561db 100644
-+--- a/checkpoints/feedforward/1/git_diff.txt
-++++ b/checkpoints/feedforward/1/git_diff.txt
-+@@ -1 +1 @@
-+-Mon Mar 4 11:45:48 PST 2024
-++Mon Mar 4 16:34:02 PST 2024
-+diff --git a/checkpoints/feedforward/1/penn_dataset.py b/checkpoints/feedforward/1/penn_dataset.py
-+index aa2f5a0..7f5a4fc 100644
-+--- a/checkpoints/feedforward/1/penn_dataset.py
-++++ b/checkpoints/feedforward/1/penn_dataset.py
-+@@ -15,6 +15,7 @@ from forge import flags
-+ # aspects of data managmement
-+ flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
-+ flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-++flags.DEFINE_boolean("cross_validate",False,"Do K-fold cross-validation")
-+ 
-+ # Job management
-+ # flags.DEFINE_integer("batch size",5,"training batch size")
-+@@ -109,15 +110,15 @@ def load(config):
-+         
-+         # set up training DataLoader
-+         train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, n_train),num_workers=0,shuffle = True)
-++        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
-+ 
-+         # set up test DataLoader
-+         test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, n_test),num_workers=0,shuffle = True)
-++        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
-+ 
-+         # set up val DataLoader
-+         val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, n_val),num_workers=0,shuffle = True)
-++        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-+         
-+ 
-+         dataloaders = {'train':train_loader, 
-+@@ -125,8 +126,12 @@ def load(config):
-+                        'val':val_loader,
-+                        'train_inds':train_ind,
-+                        'test_inds':test_ind,
-+-                       'n_val':n_val
-++                       'n_val':n_val,
-++                       'test_headings':list(HEADINGS[test_ind])
-+                       }
-+         kf_dataloaders.append(dataloaders)
-+ 
-++        if not config.cross_validate:
-++        	break
-++
-+     return kf_dataloaders
-+diff --git a/penn_dataset.py b/penn_dataset.py
-+index aa2f5a0..7f5a4fc 100644
-+--- a/penn_dataset.py
-++++ b/penn_dataset.py
-+@@ -15,6 +15,7 @@ from forge import flags
-+ # aspects of data managmement
-+ flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
-+ flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-++flags.DEFINE_boolean("cross_validate",False,"Do K-fold cross-validation")
-+ 
-+ # Job management
-+ # flags.DEFINE_integer("batch size",5,"training batch size")
-+@@ -109,15 +110,15 @@ def load(config):
-+         
-+         # set up training DataLoader
-+         train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, n_train),num_workers=0,shuffle = True)
-++        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
-+ 
-+         # set up test DataLoader
-+         test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, n_test),num_workers=0,shuffle = True)
-++        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
-+ 
-+         # set up val DataLoader
-+         val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, n_val),num_workers=0,shuffle = True)
-++        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-+         
-+ 
-+         dataloaders = {'train':train_loader, 
-+@@ -125,8 +126,12 @@ def load(config):
-+                        'val':val_loader,
-+                        'train_inds':train_ind,
-+                        'test_inds':test_ind,
-+-                       'n_val':n_val
-++                       'n_val':n_val,
-++                       'test_headings':list(HEADINGS[test_ind])
-+                       }
-+         kf_dataloaders.append(dataloaders)
-+ 
-++        if not config.cross_validate:
-++        	break
-++
-+     return kf_dataloaders
-+diff --git a/testing.ipynb b/testing.ipynb
-+index e5a167b..a928d8d 100644
-+--- a/testing.ipynb
-++++ b/testing.ipynb
-+@@ -2,7 +2,7 @@
-+  "cells": [
-+   {
-+    "cell_type": "code",
-+-   "execution_count": 1,
-++   "execution_count": 2,
-+    "id": "4dee7ff1-01a4-4038-b493-9729ff3693f7",
-+    "metadata": {},
-+    "outputs": [],
-+@@ -23,19 +23,19 @@
-+   },
-+   {
-+    "cell_type": "code",
-+-   "execution_count": 2,
-++   "execution_count": 3,
-+    "id": "cad0fdc8-5c35-4610-bba3-b71e60dc1b98",
-+    "metadata": {},
-+    "outputs": [],
-+    "source": [
-+-    "flags.DEFINE_integer(\"batch_size\", 100, \"Mini-batch size.\")\n",
-++    "flags.DEFINE_integer(\"batch_size\", 10, \"Mini-batch size.\")\n",
-+     "\n",
-+     "flags.DEFINE_integer(\"input_size\",39,\"Input shape to model\")"
-+    ]
-+   },
-+   {
-+    "cell_type": "code",
-+-   "execution_count": 3,
-++   "execution_count": 4,
-+    "id": "ce1b936b-8a7c-426e-a3aa-3c1c38f645de",
-+    "metadata": {},
-+    "outputs": [
-+@@ -54,8 +54,8 @@
-+   },
-+   {
-+    "cell_type": "code",
-+-   "execution_count": 9,
-+-   "id": "e862b7e2-57f5-44bf-bcf1-a91160ba66cc",
-++   "execution_count": 5,
-++   "id": "4469cddf-4dac-4468-be88-241d440401c3",
-+    "metadata": {},
-+    "outputs": [
-+     {
-+@@ -67,35 +67,89 @@
-+     }
-+    ],
-+    "source": [
-+-    "model = fet.load(\"basic_feedforward.py\",config)"
-++    "model,modelname = fet.load(\"basic_feedforward.py\",config)"
-+    ]
-+   },
-+   {
-+    "cell_type": "code",
-+-   "execution_count": 10,
-+-   "id": "07e0b160-d5d1-4e54-b4a7-ccaf2224598a",
-++   "execution_count": 17,
-++   "id": "7c9a9fe9-f5e8-456a-b964-4be13027725b",
-+    "metadata": {},
-+    "outputs": [
-+     {
-+      "data": {
-+       "text/plain": [
-+-       "PerceptronNN(\n",
-+-       "  (fc1): Linear(in_features=39, out_features=128, bias=True)\n",
-+-       "  (fc2): Linear(in_features=128, out_features=64, bias=True)\n",
-+-       "  (fc3): Linear(in_features=64, out_features=64, bias=True)\n",
-+-       "  (fc4): Linear(in_features=64, out_features=2, bias=True)\n",
-+-       ")"
-++       "['aaa0060', 'aaa0061', 'aaa0069', 'aaa_0059']"
-+       ]
-+      },
-+-     "execution_count": 10,
-++     "execution_count": 17,
-+      "metadata": {},
-+      "output_type": "execute_result"
-+     }
-+    ],
-+    "source": [
-+-    "model"
-++    "loaddat[0]['test_headings']"
-++   ]
-++  },
-++  {
-++   "cell_type": "code",
-++   "execution_count": 19,
-++   "id": "e862b7e2-57f5-44bf-bcf1-a91160ba66cc",
-++   "metadata": {},
-++   "outputs": [
-++    {
-++     "name": "stdout",
-++     "output_type": "stream",
-++     "text": [
-++      "Keys: ['cross_entropy', 'time']\n"
-++     ]
-++    }
-++   ],
-++   "source": [
-++    "import h5py\n",
-++    "\n",
-++    "file_path = \"./checkpoints/feedforward/2/data_fold1/results_dict.h5\"\n",
-++    "# Replace 'your_file.h5' with the actual path to your file\n",
-++    "f =  h5py.File(file_path, 'r') \n",
-++    "\n",
-++    "    # Get information about the data stored in the file\n",
-++    "print(\"Keys:\", list(f.keys()))  # List the top-level datasets and groups\n",
-++    "\n",
-++    "    # # Access a dataset by its name\n",
-++    "    # dataset_name = \"your_dataset_name\"\n",
-++    "    # if dataset_name in f:\n",
-++    "    #     dataset = f[dataset_name]\n",
-++    "    #     print(\"Dataset shape:\", dataset.shape)\n",
-++    "    #     print(\"Dataset dtype:\", dataset.dtype)\n",
-++    "\n",
-++    "    #     # Access the data as a NumPy array\n",
-++    "    #     data = dataset[:]  # Read the entire dataset\n",
-++    "\n",
-++    "    #     # You can now work with the data as needed, for example:\n",
-++    "    #     # Perform calculations, visualizations, etc.\n",
-++    "    # else:\n",
-++    "    #     print(f\"Dataset '{dataset_name}' not found in the file.\")"
-+    ]
-+   },
-++  {
-++   "cell_type": "code",
-++   "execution_count": 13,
-++   "id": "07e0b160-d5d1-4e54-b4a7-ccaf2224598a",
-++   "metadata": {},
-++   "outputs": [
-++    {
-++     "data": {
-++      "text/plain": [
-++       "<generator object Module.parameters at 0x3007207b0>"
-++      ]
-++     },
-++     "execution_count": 13,
-++     "metadata": {},
-++     "output_type": "execute_result"
-++    }
-++   ],
-++   "source": []
-++  },
-+   {
-+    "cell_type": "code",
-+    "execution_count": null,
-+diff --git a/train.py b/train.py
-+index c266102..516bfa9 100644
-+--- a/train.py
-++++ b/train.py
-+@@ -1,49 +1,440 @@
-+ from os import path as osp
-++import os
-++import numpy as np
-++import time
-+ 
-+ import torch
-++import torch.nn as nn
-+ import torch.nn.functional as F
-+ import torch.optim as optim
-+-
-+-import numpy as np
-++from torch.utils.tensorboard import SummaryWriter
-+ 
-+ import forge
-+ from forge import flags
-+ import forge.experiment_tools as fet
-+ 
-++from train_tools import (
-++	log_tensorboard,
-++	parse_reports,
-++	parse_reports_cpu,
-++	print_reports,
-++	load_checkpoint,
-++	save_checkpoint,
-++	nested_to,
-++	param_count,
-++)
-++
-++from copy import deepcopy
-++from attrdict import AttrDict
-++import deepdish as dd
-++from tqdm import tqdm
-++
-++# For reproducibility while researching, but might affect speed!
-++torch.backends.cudnn.deterministic = True
-++torch.backends.cudnn.benchmark = False
-++torch.manual_seed(0)
-++
-+ 
-+ # Job config
-+ flags.DEFINE_string('data_config', 'penn_dataset.py',
-+-                    'Path to a data config file.')
-++					'Path to a data config file.')
-+ flags.DEFINE_string('model_config', 'basic_feedforward.py',
-+-                    'Path to a model config file.')
-++					'Path to a model config file.')
-+ flags.DEFINE_string('results_dir', 'checkpoints',
-+-                    'Top directory for all experimental results.')
-++					'Top directory for all experimental results.')
-+ flags.DEFINE_string('run_name', 'feedforward',
-+-                    'Name of this job and name of results folder.')
-++					'Name of this job and name of results folder.')
-+ flags.DEFINE_boolean('resume', False, 'Tries to resume a job if True.')
-+ 
-+ # Logging config
-+ flags.DEFINE_integer('report_loss_every', 50,
-+-                     'Number of iterations between reporting minibatch loss.')
-+-flags.DEFINE_integer('train_epochs', 20, 'Maximum number of training epochs.')
-++					 'Number of iterations between reporting minibatch loss.')
-++flags.DEFINE_integer('train_epochs', 100, 'Maximum number of training epochs.')
-++flags.DEFINE_integer(
-++	"save_check_points",
-++	50,
-++	"frequency with which to save checkpoints, in number of epoches.",
-++)
-++flags.DEFINE_boolean("log_train_values", True, "Logs train values if True.")
-++flags.DEFINE_integer(
-++	"total_evaluations",
-++	100,
-++	"Maximum number of evaluations on test and validation data during training.",
-++)
-++flags.DEFINE_boolean(
-++	"save_test_predictions",
-++	False,
-++	"Makes and saves test predictions on one or more test sets (e.g. 5-step and 100-step predictions) at the end of training.",
-++)
-++flags.DEFINE_boolean(
-++    "log_val_test", True, "Turns off computation of validation and test errors."
-++)
-+ 
-+ # Experiment config
-+ flags.DEFINE_integer('batch_size', 100, 'Mini-batch size.')
-+-flags.DEFINE_float('learning_rate', 1e-5, 'SGD learning rate.')
-++flags.DEFINE_float("learning_rate", 1e-4, "Adam learning rate.")
-++flags.DEFINE_float("beta1", 0.9, "Adam Beta 1 parameter")
-++flags.DEFINE_float("beta2", 0.999, "Adam Beta 2 parameter")
-+ 
-+ # Specific config options
-+ flags.DEFINE_integer("input_size",39,"Input shape to model")
-+ 
-++#########################################################################################
-++
-++def evaluate(model, loader, device,fold = 0,headings = [],loss_func = nn.CrossEntropyLoss()):
-++	reports = None
-++	for data in loader:
-++		labels = data['label']
-++		inputs = nested_to(data['data'],device,torch.float32)
-++		
-++		labels_tensor = torch.zeros((len(labels), 2))
-++		for i, label in enumerate(labels):
-++			labels_tensor[i, label] = 1
-++
-++		model_output = model(inputs) # evaluate model
-++
-++		loss = loss_func(model_output, labels_tensor) # compute loss
-++		outputs = AttrDict({"loss": loss, "prediction": model_output,'data_fold':fold})
-++		outputs.reports = AttrDict({"cross_entropy": loss})
-++
-++		if reports is None:
-++			reports = {k: v.detach().clone().cpu() for k, v in outputs.reports.items()}
-++		else:
-++			for k, v in outputs.reports.items():
-++				reports[k] += v.detach().clone().cpu()
-++
-++	for k, v in reports.items():
-++		reports[k] = v / len(
-++			loader
-++		)  # SZ: note this can be slightly incorrect if mini-batch sizes vary (if batch_size doesn't divide train_size), but approximately correct.
-++
-++	# reports['test_headings'] = np.array(headings)
-++
-++	return reports
-++
-++def main():
-++
-++	config = forge.config()
-++
-++	# Set device
-++	if torch.cuda.is_available():
-++		device = f"cuda:{config.device}"
-++		torch.cuda.set_device(device)
-++	else:
-++		device = "cpu" # can change this to MPS on M1 Macs
-++
-++	# Load data
-++	data_name = "penn_data"
-++	kfold_loaders = fet.load(config.data_config, config)
-++
-++	# Load model
-++	model,model_name = fet.load(config.model_config, config)
-++	model = model.to(device)
-++
-++	loss_func = nn.CrossEntropyLoss()
-++
-++	# Prepare environment
-++	params_in_run_name = [
-++		("batch_size", "bs"),
-++		("learning_rate", "lr"),
-++		("n_train", "ntrain")
-++	]
-++
-++	run_name = ""  # config.run_name
-++	for config_param in params_in_run_name:
-++		attr = config_param[0]
-++		abbrev = config_param[1]
-++
-++		if hasattr(config, attr):
-++			run_name += abbrev
-++			run_name += str(getattr(config, attr))
-++			run_name += "_"
-++
-++	results_folder_name = osp.join(
-++		data_name,
-++		model_name,
-++		config.run_name,
-++		run_name,
-++	)
-++
-++	# Prepare environment
-++	logdir = osp.join(config.results_dir, config.run_name)
-++	logdir, resume_checkpoint = fet.init_checkpoint(
-++		logdir, config.data_config, config.model_config, config.resume)
-++
-++	print("Checkpoint directory:",logdir)
-++
-++	# Print flags
-++	fet.print_flags()
-++	# Print model info
-++	print(model)
-++
-++	# Setup optimizer
-++	model_params = model.parameters()
-++	opt_learning_rate = config.learning_rate
-++	model_opt = torch.optim.Adam(
-++		model_params, lr=opt_learning_rate, betas=(config.beta1, config.beta2)
-++	)
-++	print("Model Optimizer:")
-++	print(model_opt)
-++
-++	# Try to restore model and optimizer from checkpoint
-++	if resume_checkpoint is not None:
-++		start_epoch = load_checkpoint(resume_checkpoint, model, model_opt)
-++	else:
-++		start_epoch = 1
-++
-++	n_folds = len(kfold_loaders)
-++	print("Doing {}-fold cross-validation.".format(n_folds))
-++
-++	# KFOLD TRAINING LOOP
-++	for k,loader_k in enumerate(kfold_loaders): # loop over data splits
-++
-++		print("Training fold {}...".format(k+1))
-++
-++		# load the training data
-++		train_loader = loader_k["train"]
-++		n_train = len(train_loader.dataset)
-++		train_batch_size = train_loader.batch_size
-++
-++		# load testing, validation
-++		test_loader = loader_k["test"]
-++		n_test = len(test_loader.dataset)
-++		val_loader = loader_k["val"]
-++		n_val = len(val_loader.dataset)
-++		
-++		# create folder for this data split
-++		fold_dir = osp.join(logdir,"data_fold{}".format(k+1))
-++		fold_dir_exists = osp.exists(fold_dir)
-++		if not fold_dir_exists:
-++			if config.resume:
-++				raise ValueError("Can't resume when the checkpoint/fold dir '{}' doesn't exist.".format(fold_dir))
-++			else:
-++				os.makedirs(fold_dir)
-++		checkpoint_name = osp.join(fold_dir, 'model_fold{}.ckpt'.format(k+1))
-++
-++		# keep track of which data is test data for a given Kfold data split
-++		test_headings = loader_k['test_headings']
-++		headingsFile = osp.join(fold_dir,"test_headings.txt")
-++		with open(headingsFile,'w') as headfile:
-++			for heading in test_headings:
-++				headfile.write(heading+'\n')
-++
-++		# print(checkpoint_name)
-++
-++		train_iter = (start_epoch - 1) * (
-++		len(train_loader.dataset) // train_batch_size
-++		) + 1
-++
-++		print("Starting training at epoch = {}, iter = {}".format(start_epoch, train_iter))
-++
-++		# Setup tensorboard writing
-++		summary_writer = SummaryWriter(logdir)
-++
-++		train_reports = []
-++		report_all = {}
-++		report_all_val = {}
-++
-++		# Saving model at epoch 0 before training
-++		print("saving model at epoch 0 before training ... ")
-++		save_checkpoint(checkpoint_name, 0, model, model_opt, loss=0.0)
-++		print("finished saving model at epoch 0 before training")
-++
-++		num_params = param_count(model)
-++		print(f"Number of model parameters: {num_params}")
-++
-++		# Training
-++		start_t = time.time()
-++
-++		total_train_iters = len(train_loader) * config.train_epochs
-++		iters_per_eval = max(1, int(total_train_iters / config.total_evaluations))
-++		# print('batch',train_batch_size)
-++		# print('ntrain',n_train)
-++		# assert (
-++		# 	n_train % min(train_batch_size, n_train) == 0
-++		# ), "Batch size doesn't divide dataset size. Can be inaccurate for loss computation (see below)."
-++
-++		training_failed = False
-++		best_val_loss_so_far = 1e7
-++
-++		for epoch in tqdm(range(start_epoch, config.train_epochs + 1)):
-++			model.train()
-++
-++			for batch_idx, data_dict in enumerate(train_loader): # Loop over batched data
-++
-++				labels = data_dict['label']
-++				data = data_dict['data']
-++
-++				# send data to device
-++				data = nested_to(data,device,torch.float32)
-++				# One-hot encode the data labels
-++				labels_tensor = torch.zeros((len(labels), 2))
-++				for i, label in enumerate(labels):
-++					labels_tensor[i, label] = 1
-++
-++				model_output = model(data) # evaluate model
-++
-++				loss = loss_func(model_output, labels_tensor) # compute loss
-++				outputs = AttrDict({"loss": loss, "prediction": model_output})
-++				outputs.reports = AttrDict({"cross_entropy": loss})
-++
-++				if torch.isnan(outputs.loss): # check for failure in training
-++					if not training_failed:
-++						epoch_of_nan = epoch
-++					if (epoch > epoch_of_nan + 1) and training_failed:
-++						raise ValueError("Loss Nan-ed.")
-++					training_failed = True
-++
-++				model_opt.zero_grad()
-++				outputs.loss.backward(retain_graph=False)
-++
-++				model_opt.step() # move optimizer forward
-++
-++				train_reports.append(parse_reports_cpu(outputs.reports))
-++
-++				if config.log_train_values:
-++					reports = parse_reports(outputs.reports)
-++					if batch_idx % config.report_loss_every == 0:
-++						log_tensorboard(summary_writer, train_iter, reports, "train/")
-++						print_reports(
-++							reports,
-++							start_t,
-++							epoch,
-++							batch_idx,
-++							len(train_loader.dataset) // train_batch_size,
-++							prefix="train",
-++						)
-++						log_tensorboard(
-++							summary_writer,
-++							train_iter,
-++							{"lr": model_opt.param_groups[0]["lr"]},
-++							"hyperparams/",
-++						)
-++				# Logging and evaluation
-++				if (
-++					train_iter % iters_per_eval == 0 or (train_iter == total_train_iters)
-++				) and config.log_val_test:  # batch_idx % config.evaluate_every == 0:
-++					model.eval()
-++					with torch.no_grad():
-++						reports = evaluate(model, test_loader, device,fold = k,headings = loader_k['test_headings'])
-++						# print("REPORTS",reports)
-++						reports = parse_reports(reports)
-++						reports["time"] = time.time() - start_t
-++						if report_all == {}:
-++							report_all = deepcopy(reports)
-++
-++							for d in reports.keys():
-++								report_all[d] = [report_all[d]]
-++						else:
-++							for d in reports.keys():
-++								report_all[d].append(reports[d])
-++
-++						log_tensorboard(summary_writer, train_iter, reports, "test/")
-++						print_reports(
-++							reports,
-++							start_t,
-++							epoch,
-++							batch_idx,
-++							len(train_loader.dataset) // config.batch_size,
-++							prefix="test",
-++						)
-++
-++						# repeat for validation data
-++						reports = evaluate(model, val_loader, device,fold = k,headings = loader_k['test_headings'])
-++						reports = parse_reports(reports)
-++						reports["time"] = time.time() - start_t
-++						if report_all_val == {}:
-++							report_all_val = deepcopy(reports)
-++
-++							for d in reports.keys():
-++								report_all_val[d] = [report_all_val[d]]
-++						else:
-++							for d in reports.keys():
-++								report_all_val[d].append(reports[d])
-++
-++						log_tensorboard(summary_writer, train_iter, reports, "val/")
-++						print_reports(
-++							reports,
-++							start_t,
-++							epoch,
-++							batch_idx,
-++							len(train_loader.dataset) // config.batch_size,
-++							prefix="val",
-++						)
-++
-++						if report_all_val["cross_entropy"][-1] < best_val_loss_so_far:
-++							save_checkpoint(
-++								checkpoint_name,
-++								f"early_stop",
-++								model,
-++								model_opt,
-++								loss=outputs.loss,
-++							)
-++							best_val_loss_so_far = report_all_val["cross_entropy"][-1]
-++
-++					model.train()
-++
-++				train_iter += 1
-++
-++			if epoch % config.save_check_points == 0:
-++				save_checkpoint(
-++					checkpoint_name, train_iter, model, model_opt, loss=outputs.loss
-++				)
-++
-++		dd.io.save(fold_dir + "/results_dict_train.h5", train_reports)
-++		dd.io.save(fold_dir + "/results_dict.h5", report_all)
-++		dd.io.save(fold_dir + "/results_dict_val.h5", report_all_val)
-++
-++	# always save final model
-++	save_checkpoint(checkpoint_name, train_iter, model, model_opt, loss=outputs.loss)
-++
-++	
-++	if config.save_test_predictions:
-++		pass
-++		# print("Starting to make model predictions on test sets for *final model*.")
-++		# for chunk_len in [5, 100]:
-++		#     start_t_preds = time.time()
-++		#     data_config = SimpleNamespace(
-++		#         **{
-++		#             **config.__dict__["__flags"],
-++		#             **{"chunk_len": chunk_len, "batch_size": 500},
-++		#         }
-++		#     )
-++		#     dataloaders, data_name = fet.load(config.data_config, config=data_config)
-++		#     test_loader_preds = dataloaders["test"]
-++
-++		#     torch.cuda.empty_cache()
-++		#     with torch.no_grad():
-++		#         preds = []
-++		#         true = []
-++		#         num_datapoints = 0
-++		#         for idx, d in enumerate(test_loader_preds):
-++		#             true.append(d[-1])
-++		#             d = nested_to(d, device, torch.float32)
-++		#             outputs = model(d)
-++
-++		#             pred_zs = outputs.prediction
-++		#             preds.append(pred_zs)
-++
-++		#             num_datapoints += len(pred_zs)
-++
-++		#             if num_datapoints >= 2000:
-++		#                 break
-+ 
-+-config = forge.config()
-++		#         preds = torch.cat(preds, dim=0).cpu()
-++		#         true = torch.cat(true, dim=0).cpu()
-+ 
-+-# Prepare environment
-+-logdir = osp.join(config.results_dir, config.run_name)
-+-logdir, resume_checkpoint = fet.init_checkpoint(
-+-    logdir, config.data_config, config.model_config, config.resume)
-+-checkpoint_name = osp.join(logdir, 'model.ckpt')
-++		#         save_dir = osp.join(logdir, f"traj_preds_{chunk_len}_steps_2k_test.pt")
-++		#         torch.save(preds, save_dir)
-+ 
-++		#         save_dir = osp.join(logdir, f"traj_true_{chunk_len}_steps_2k_test.pt")
-++		#         torch.save(true, save_dir)
-+ 
-+-print(logdir)
-++		#         print(
-++		#             f"Completed making test predictions for chunk_len = {chunk_len} in {time.time() - start_t_preds:.2f} seconds."
-++		#         )	
-++		
-+ 
-++if __name__ == "__main__":
-++	main()
-+ 
-diff --git a/checkpoints/feedforward/1/penn_dataset.py b/checkpoints/feedforward/1/penn_dataset.py
-index aa2f5a0..7f5a4fc 100644
---- a/checkpoints/feedforward/1/penn_dataset.py
-+++ b/checkpoints/feedforward/1/penn_dataset.py
-@@ -15,6 +15,7 @@ from forge import flags
- # aspects of data managmement
- flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
- flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-+flags.DEFINE_boolean("cross_validate",False,"Do K-fold cross-validation")
- 
- # Job management
- # flags.DEFINE_integer("batch size",5,"training batch size")
-@@ -109,15 +110,15 @@ def load(config):
-         
-         # set up training DataLoader
-         train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, n_train),num_workers=0,shuffle = True)
-+        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
- 
-         # set up test DataLoader
-         test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, n_test),num_workers=0,shuffle = True)
-+        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
- 
-         # set up val DataLoader
-         val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, n_val),num_workers=0,shuffle = True)
-+        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-         
- 
-         dataloaders = {'train':train_loader, 
-@@ -125,8 +126,12 @@ def load(config):
-                        'val':val_loader,
-                        'train_inds':train_ind,
-                        'test_inds':test_ind,
--                       'n_val':n_val
-+                       'n_val':n_val,
-+                       'test_headings':list(HEADINGS[test_ind])
-                       }
-         kf_dataloaders.append(dataloaders)
- 
-+        if not config.cross_validate:
-+        	break
-+
-     return kf_dataloaders
-diff --git a/georgehulsey_2024.pdf b/georgehulsey_2024.pdf
-deleted file mode 100644
-index 1ab17f6..0000000
-Binary files a/georgehulsey_2024.pdf and /dev/null differ
-diff --git a/penn_dataset.py b/penn_dataset.py
-index aa2f5a0..7f5a4fc 100644
---- a/penn_dataset.py
-+++ b/penn_dataset.py
-@@ -15,6 +15,7 @@ from forge import flags
- # aspects of data managmement
- flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
- flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-+flags.DEFINE_boolean("cross_validate",False,"Do K-fold cross-validation")
- 
- # Job management
- # flags.DEFINE_integer("batch size",5,"training batch size")
-@@ -109,15 +110,15 @@ def load(config):
-         
-         # set up training DataLoader
-         train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, n_train),num_workers=0,shuffle = True)
-+        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
- 
-         # set up test DataLoader
-         test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, n_test),num_workers=0,shuffle = True)
-+        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
- 
-         # set up val DataLoader
-         val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, n_val),num_workers=0,shuffle = True)
-+        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-         
- 
-         dataloaders = {'train':train_loader, 
-@@ -125,8 +126,12 @@ def load(config):
-                        'val':val_loader,
-                        'train_inds':train_ind,
-                        'test_inds':test_ind,
--                       'n_val':n_val
-+                       'n_val':n_val,
-+                       'test_headings':list(HEADINGS[test_ind])
-                       }
-         kf_dataloaders.append(dataloaders)
- 
-+        if not config.cross_validate:
-+        	break
-+
-     return kf_dataloaders
-diff --git a/testing.ipynb b/testing.ipynb
-index e5a167b..0110538 100644
---- a/testing.ipynb
-+++ b/testing.ipynb
-@@ -2,7 +2,7 @@
-  "cells": [
-   {
-    "cell_type": "code",
--   "execution_count": 1,
-+   "execution_count": 4,
-    "id": "4dee7ff1-01a4-4038-b493-9729ff3693f7",
-    "metadata": {},
-    "outputs": [],
-@@ -23,7 +23,7 @@
-   },
-   {
-    "cell_type": "code",
--   "execution_count": 2,
-+   "execution_count": 6,
-    "id": "cad0fdc8-5c35-4610-bba3-b71e60dc1b98",
-    "metadata": {},
-    "outputs": [],
-@@ -35,7 +35,7 @@
-   },
-   {
-    "cell_type": "code",
--   "execution_count": 3,
-+   "execution_count": 7,
-    "id": "ce1b936b-8a7c-426e-a3aa-3c1c38f645de",
-    "metadata": {},
-    "outputs": [
-@@ -54,8 +54,8 @@
-   },
-   {
-    "cell_type": "code",
--   "execution_count": 9,
--   "id": "e862b7e2-57f5-44bf-bcf1-a91160ba66cc",
-+   "execution_count": 5,
-+   "id": "4469cddf-4dac-4468-be88-241d440401c3",
-    "metadata": {},
-    "outputs": [
-     {
-@@ -67,35 +67,98 @@
-     }
-    ],
-    "source": [
--    "model = fet.load(\"basic_feedforward.py\",config)"
-+    "model,modelname = fet.load(\"basic_feedforward.py\",config)"
-    ]
-   },
-   {
-    "cell_type": "code",
--   "execution_count": 10,
--   "id": "07e0b160-d5d1-4e54-b4a7-ccaf2224598a",
-+   "execution_count": 13,
-+   "id": "7c9a9fe9-f5e8-456a-b964-4be13027725b",
-    "metadata": {},
-    "outputs": [
-     {
-      "data": {
-       "text/plain": [
--       "PerceptronNN(\n",
--       "  (fc1): Linear(in_features=39, out_features=128, bias=True)\n",
--       "  (fc2): Linear(in_features=128, out_features=64, bias=True)\n",
--       "  (fc3): Linear(in_features=64, out_features=64, bias=True)\n",
--       "  (fc4): Linear(in_features=64, out_features=2, bias=True)\n",
--       ")"
-+       "array([114170,    904])"
-       ]
-      },
--     "execution_count": 10,
-+     "execution_count": 13,
-      "metadata": {},
-      "output_type": "execute_result"
-     }
-    ],
-    "source": [
--    "model"
-+    "np.bincount(loaddat[0]['train'].dataset.all_labels)"
-    ]
-   },
-+  {
-+   "cell_type": "code",
-+   "execution_count": 1,
-+   "id": "e862b7e2-57f5-44bf-bcf1-a91160ba66cc",
-+   "metadata": {},
-+   "outputs": [
-+    {
-+     "ename": "FileNotFoundError",
-+     "evalue": "[Errno 2] Unable to open file (unable to open file: name = './checkpoints/feedforward/2/data_fold1/results_dict.h5', errno = 2, error message = 'No such file or directory', flags = 0, o_flags = 0)",
-+     "output_type": "error",
-+     "traceback": [
-+      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
-+      "\u001b[0;31mFileNotFoundError\u001b[0m                         Traceback (most recent call last)",
-+      "Cell \u001b[0;32mIn[1], line 5\u001b[0m\n\u001b[1;32m      3\u001b[0m file_path \u001b[38;5;241m=\u001b[39m \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124m./checkpoints/feedforward/2/data_fold1/results_dict.h5\u001b[39m\u001b[38;5;124m\"\u001b[39m\n\u001b[1;32m      4\u001b[0m \u001b[38;5;66;03m# Replace 'your_file.h5' with the actual path to your file\u001b[39;00m\n\u001b[0;32m----> 5\u001b[0m f \u001b[38;5;241m=\u001b[39m  \u001b[43mh5py\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mFile\u001b[49m\u001b[43m(\u001b[49m\u001b[43mfile_path\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[38;5;124;43mr\u001b[39;49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[43m)\u001b[49m \n\u001b[1;32m      7\u001b[0m     \u001b[38;5;66;03m# Get information about the data stored in the file\u001b[39;00m\n\u001b[1;32m      8\u001b[0m \u001b[38;5;28mprint\u001b[39m(\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mKeys:\u001b[39m\u001b[38;5;124m\"\u001b[39m, \u001b[38;5;28mlist\u001b[39m(f\u001b[38;5;241m.\u001b[39mkeys()))\n",
-+      "File \u001b[0;32m/Applications/miniconda3/envs/lietransformer/lib/python3.9/site-packages/h5py/_hl/files.py:562\u001b[0m, in \u001b[0;36mFile.__init__\u001b[0;34m(self, name, mode, driver, libver, userblock_size, swmr, rdcc_nslots, rdcc_nbytes, rdcc_w0, track_order, fs_strategy, fs_persist, fs_threshold, fs_page_size, page_buf_size, min_meta_keep, min_raw_keep, locking, alignment_threshold, alignment_interval, meta_block_size, **kwds)\u001b[0m\n\u001b[1;32m    553\u001b[0m     fapl \u001b[38;5;241m=\u001b[39m make_fapl(driver, libver, rdcc_nslots, rdcc_nbytes, rdcc_w0,\n\u001b[1;32m    554\u001b[0m                      locking, page_buf_size, min_meta_keep, min_raw_keep,\n\u001b[1;32m    555\u001b[0m                      alignment_threshold\u001b[38;5;241m=\u001b[39malignment_threshold,\n\u001b[1;32m    556\u001b[0m                      alignment_interval\u001b[38;5;241m=\u001b[39malignment_interval,\n\u001b[1;32m    557\u001b[0m                      meta_block_size\u001b[38;5;241m=\u001b[39mmeta_block_size,\n\u001b[1;32m    558\u001b[0m                      \u001b[38;5;241m*\u001b[39m\u001b[38;5;241m*\u001b[39mkwds)\n\u001b[1;32m    559\u001b[0m     fcpl \u001b[38;5;241m=\u001b[39m make_fcpl(track_order\u001b[38;5;241m=\u001b[39mtrack_order, fs_strategy\u001b[38;5;241m=\u001b[39mfs_strategy,\n\u001b[1;32m    560\u001b[0m                      fs_persist\u001b[38;5;241m=\u001b[39mfs_persist, fs_threshold\u001b[38;5;241m=\u001b[39mfs_threshold,\n\u001b[1;32m    561\u001b[0m                      fs_page_size\u001b[38;5;241m=\u001b[39mfs_page_size)\n\u001b[0;32m--> 562\u001b[0m     fid \u001b[38;5;241m=\u001b[39m \u001b[43mmake_fid\u001b[49m\u001b[43m(\u001b[49m\u001b[43mname\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mmode\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43muserblock_size\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mfapl\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mfcpl\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mswmr\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43mswmr\u001b[49m\u001b[43m)\u001b[49m\n\u001b[1;32m    564\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;28misinstance\u001b[39m(libver, \u001b[38;5;28mtuple\u001b[39m):\n\u001b[1;32m    565\u001b[0m     \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_libver \u001b[38;5;241m=\u001b[39m libver\n",
-+      "File \u001b[0;32m/Applications/miniconda3/envs/lietransformer/lib/python3.9/site-packages/h5py/_hl/files.py:235\u001b[0m, in \u001b[0;36mmake_fid\u001b[0;34m(name, mode, userblock_size, fapl, fcpl, swmr)\u001b[0m\n\u001b[1;32m    233\u001b[0m     \u001b[38;5;28;01mif\u001b[39;00m swmr \u001b[38;5;129;01mand\u001b[39;00m swmr_support:\n\u001b[1;32m    234\u001b[0m         flags \u001b[38;5;241m|\u001b[39m\u001b[38;5;241m=\u001b[39m h5f\u001b[38;5;241m.\u001b[39mACC_SWMR_READ\n\u001b[0;32m--> 235\u001b[0m     fid \u001b[38;5;241m=\u001b[39m \u001b[43mh5f\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mopen\u001b[49m\u001b[43m(\u001b[49m\u001b[43mname\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mflags\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mfapl\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43mfapl\u001b[49m\u001b[43m)\u001b[49m\n\u001b[1;32m    236\u001b[0m \u001b[38;5;28;01melif\u001b[39;00m mode \u001b[38;5;241m==\u001b[39m \u001b[38;5;124m'\u001b[39m\u001b[38;5;124mr+\u001b[39m\u001b[38;5;124m'\u001b[39m:\n\u001b[1;32m    237\u001b[0m     fid \u001b[38;5;241m=\u001b[39m h5f\u001b[38;5;241m.\u001b[39mopen(name, h5f\u001b[38;5;241m.\u001b[39mACC_RDWR, fapl\u001b[38;5;241m=\u001b[39mfapl)\n",
-+      "File \u001b[0;32mh5py/_objects.pyx:54\u001b[0m, in \u001b[0;36mh5py._objects.with_phil.wrapper\u001b[0;34m()\u001b[0m\n",
-+      "File \u001b[0;32mh5py/_objects.pyx:55\u001b[0m, in \u001b[0;36mh5py._objects.with_phil.wrapper\u001b[0;34m()\u001b[0m\n",
-+      "File \u001b[0;32mh5py/h5f.pyx:102\u001b[0m, in \u001b[0;36mh5py.h5f.open\u001b[0;34m()\u001b[0m\n",
-+      "\u001b[0;31mFileNotFoundError\u001b[0m: [Errno 2] Unable to open file (unable to open file: name = './checkpoints/feedforward/2/data_fold1/results_dict.h5', errno = 2, error message = 'No such file or directory', flags = 0, o_flags = 0)"
-+     ]
-+    }
-+   ],
-+   "source": [
-+    "import h5py\n",
-+    "\n",
-+    "file_path = \"./checkpoints/feedforward/2/data_fold1/results_dict.h5\"\n",
-+    "# Replace 'your_file.h5' with the actual path to your file\n",
-+    "f =  h5py.File(file_path, 'r') \n",
-+    "\n",
-+    "    # Get information about the data stored in the file\n",
-+    "print(\"Keys:\", list(f.keys()))  # List the top-level datasets and groups\n",
-+    "\n",
-+    "    # # Access a dataset by its name\n",
-+    "    # dataset_name = \"your_dataset_name\"\n",
-+    "    # if dataset_name in f:\n",
-+    "    #     dataset = f[dataset_name]\n",
-+    "    #     print(\"Dataset shape:\", dataset.shape)\n",
-+    "    #     print(\"Dataset dtype:\", dataset.dtype)\n",
-+    "\n",
-+    "    #     # Access the data as a NumPy array\n",
-+    "    #     data = dataset[:]  # Read the entire dataset\n",
-+    "\n",
-+    "    #     # You can now work with the data as needed, for example:\n",
-+    "    #     # Perform calculations, visualizations, etc.\n",
-+    "    # else:\n",
-+    "    #     print(f\"Dataset '{dataset_name}' not found in the file.\")"
-+   ]
-+  },
-+  {
-+   "cell_type": "code",
-+   "execution_count": 13,
-+   "id": "07e0b160-d5d1-4e54-b4a7-ccaf2224598a",
-+   "metadata": {},
-+   "outputs": [
-+    {
-+     "data": {
-+      "text/plain": [
-+       "<generator object Module.parameters at 0x3007207b0>"
-+      ]
-+     },
-+     "execution_count": 13,
-+     "metadata": {},
-+     "output_type": "execute_result"
-+    }
-+   ],
-+   "source": []
-+  },
-   {
-    "cell_type": "code",
-    "execution_count": null,
-diff --git a/train.py b/train.py
-index c266102..def250b 100644
---- a/train.py
-+++ b/train.py
-@@ -1,49 +1,451 @@
- from os import path as osp
-+import os
-+import numpy as np
-+import time
- 
- import torch
-+import torch.nn as nn
- import torch.nn.functional as F
- import torch.optim as optim
--
--import numpy as np
-+from torch.utils.tensorboard import SummaryWriter
- 
- import forge
- from forge import flags
- import forge.experiment_tools as fet
- 
-+from train_tools import (
-+	log_tensorboard,
-+	parse_reports,
-+	parse_reports_cpu,
-+	print_reports,
-+	load_checkpoint,
-+	save_checkpoint,
-+	nested_to,
-+	param_count,
-+)
-+
-+from copy import deepcopy
-+from attrdict import AttrDict
-+import deepdish as dd
-+from tqdm import tqdm
-+
-+# For reproducibility while researching, but might affect speed!
-+torch.backends.cudnn.deterministic = True
-+torch.backends.cudnn.benchmark = False
-+torch.manual_seed(0)
-+
- 
- # Job config
- flags.DEFINE_string('data_config', 'penn_dataset.py',
--                    'Path to a data config file.')
-+					'Path to a data config file.')
- flags.DEFINE_string('model_config', 'basic_feedforward.py',
--                    'Path to a model config file.')
-+					'Path to a model config file.')
- flags.DEFINE_string('results_dir', 'checkpoints',
--                    'Top directory for all experimental results.')
--flags.DEFINE_string('run_name', 'feedforward',
--                    'Name of this job and name of results folder.')
-+					'Top directory for all experimental results.')
-+flags.DEFINE_string('run_name', 'testing',
-+					'Name of this job and name of results folder.')
- flags.DEFINE_boolean('resume', False, 'Tries to resume a job if True.')
- 
- # Logging config
- flags.DEFINE_integer('report_loss_every', 50,
--                     'Number of iterations between reporting minibatch loss.')
--flags.DEFINE_integer('train_epochs', 20, 'Maximum number of training epochs.')
-+					 'Number of iterations between reporting minibatch loss.')
-+flags.DEFINE_integer('train_epochs', 10, 'Maximum number of training epochs.')
-+flags.DEFINE_integer(
-+	"save_check_points",
-+	50,
-+	"frequency with which to save checkpoints, in number of epoches.",
-+)
-+flags.DEFINE_boolean("log_train_values", True, "Logs train values if True.")
-+flags.DEFINE_integer(
-+	"total_evaluations",
-+	100,
-+	"Maximum number of evaluations on test and validation data during training.",
-+)
-+flags.DEFINE_boolean(
-+	"save_test_predictions",
-+	False,
-+	"Makes and saves test predictions on one or more test sets (e.g. 5-step and 100-step predictions) at the end of training.",
-+)
-+flags.DEFINE_boolean(
-+    "log_val_test", True, "Turns off computation of validation and test errors."
-+)
- 
- # Experiment config
- flags.DEFINE_integer('batch_size', 100, 'Mini-batch size.')
--flags.DEFINE_float('learning_rate', 1e-5, 'SGD learning rate.')
-+flags.DEFINE_float("learning_rate", 1e-4, "Adam learning rate.")
-+flags.DEFINE_float("beta1", 0.9, "Adam Beta 1 parameter")
-+flags.DEFINE_float("beta2", 0.999, "Adam Beta 2 parameter")
- 
- # Specific config options
- flags.DEFINE_integer("input_size",39,"Input shape to model")
- 
-+#########################################################################################
-+
-+def evaluate(model, loader, device,fold = 0,headings = [],loss_func = nn.CrossEntropyLoss()):
-+	# this function does not account for class weights when evaluating cross-entropy loss.
-+	# however, they are accounted for when evaluating training loss
-+	reports = None
-+	for data in loader:
-+		labels = data['label']
-+		inputs = nested_to(data['data'],device,torch.float32)
-+		
-+		labels_tensor = torch.zeros((len(labels), 2))
-+		for i, label in enumerate(labels):
-+			labels_tensor[i, label] = 1
-+
-+		model_output = model(inputs) # evaluate model
-+
-+		loss = loss_func(model_output, labels_tensor) # compute loss
-+		outputs = AttrDict({"loss": loss, "prediction": model_output,'data_fold':fold})
-+		outputs.reports = AttrDict({"cross_entropy": loss})
-+
-+		if reports is None:
-+			reports = {k: v.detach().clone().cpu() for k, v in outputs.reports.items()}
-+		else:
-+			for k, v in outputs.reports.items():
-+				reports[k] += v.detach().clone().cpu()
-+
-+	for k, v in reports.items():
-+		reports[k] = v / len(
-+			loader
-+		)  # SZ: note this can be slightly incorrect if mini-batch sizes vary (if batch_size doesn't divide train_size), but approximately correct.
-+
-+	# reports['test_headings'] = np.array(headings)
-+
-+	return reports
-+
-+def main():
-+
-+	config = forge.config()
-+
-+	# Set device
-+	if torch.cuda.is_available():
-+		device = f"cuda:{config.device}"
-+		torch.cuda.set_device(device)
-+	else:
-+		device = "cpu" # can change this to MPS on M1 Macs
-+
-+	# Load data
-+	data_name = "penn_data"
-+	kfold_loaders = fet.load(config.data_config, config)
-+
-+	# Load model
-+	model,model_name = fet.load(config.model_config, config)
-+	model = model.to(device)
-+
-+	# Prepare environment
-+	params_in_run_name = [
-+		("batch_size", "bs"),
-+		("learning_rate", "lr"),
-+		("n_train", "ntrain"),
-+		("include_coords",'inclx'),
-+		("input_size",'inpsize'),
-+		("cross_validate",'crval'),
-+		("train_epochs",'n_epochs'),
-+	]
-+
-+	run_name = ""  # config.run_name
-+	for config_param in params_in_run_name:
-+		attr = config_param[0]
-+		abbrev = config_param[1]
-+
-+		if hasattr(config, attr):
-+			run_name += abbrev
-+			run_name += str(getattr(config, attr))
-+			run_name += "_"
-+
-+	results_folder_name = osp.join(
-+		data_name,
-+		model_name,
-+		config.run_name,
-+		run_name,
-+	)
-+
-+	# Prepare environment
-+	logdir = osp.join(config.results_dir, results_folder_name.replace(".", "_"))
-+	logdir, resume_checkpoint = fet.init_checkpoint(
-+		logdir, config.data_config, config.model_config, config.resume)
-+
-+	print("Checkpoint directory:",logdir)
-+
-+	# Print flags
-+	fet.print_flags()
-+	# Print model info
-+	print(model)
-+
-+	# Setup optimizer
-+	model_params = model.parameters()
-+	opt_learning_rate = config.learning_rate
-+	model_opt = torch.optim.Adam(
-+		model_params, lr=opt_learning_rate, betas=(config.beta1, config.beta2)
-+	)
-+	print("Model Optimizer:")
-+	print(model_opt)
-+
-+	# Try to restore model and optimizer from checkpoint
-+	if resume_checkpoint is not None:
-+		start_epoch = load_checkpoint(resume_checkpoint, model, model_opt)
-+	else:
-+		start_epoch = 1
-+
-+	n_folds = len(kfold_loaders)
-+	print("Doing {}-fold cross-validation.".format(n_folds))
-+
-+	# KFOLD TRAINING LOOP
-+	for k,loader_k in enumerate(kfold_loaders): # loop over data splits
-+
-+		print("Training fold {}...".format(k+1))
-+
-+		# load the training data
-+		train_loader = loader_k["train"]
-+		n_train = len(train_loader.dataset)
-+		train_batch_size = train_loader.batch_size
-+
-+		# load testing, validation
-+		test_loader = loader_k["test"]
-+		n_test = len(test_loader.dataset)
-+		val_loader = loader_k["val"]
-+		n_val = len(val_loader.dataset)
-+
-+		train_class_counts = np.bincount(train_loader.dataset.all_labels)
-+		train_total_counts = sum(train_class_counts)
-+		class_weight = torch.tensor(1.0 / train_class_counts) * train_total_counts / 2.0
-+
-+		loss_func = nn.CrossEntropyLoss(weight = class_weight) # define reweighted loss function
-+				
-+		# create folder for this data split
-+		fold_dir = osp.join(logdir,"data_fold{}".format(k+1))
-+		fold_dir_exists = osp.exists(fold_dir)
-+		if not fold_dir_exists:
-+			if config.resume:
-+				raise ValueError("Can't resume when the checkpoint/fold dir '{}' doesn't exist.".format(fold_dir))
-+			else:
-+				os.makedirs(fold_dir)
-+		checkpoint_name = osp.join(fold_dir, 'model_fold{}.ckpt'.format(k+1))
-+
-+		# keep track of which data is test data for a given Kfold data split
-+		test_headings = loader_k['test_headings']
-+		headingsFile = osp.join(fold_dir,"test_headings.txt")
-+		with open(headingsFile,'w') as headfile:
-+			for heading in test_headings:
-+				headfile.write(heading+'\n')
-+
-+		# print(checkpoint_name)
-+
-+		train_iter = (start_epoch - 1) * (
-+		len(train_loader.dataset) // train_batch_size
-+		) + 1
-+
-+		print("Starting training at epoch = {}, iter = {}".format(start_epoch, train_iter))
-+
-+		# Setup tensorboard writing
-+		summary_writer = SummaryWriter(logdir)
-+
-+		train_reports = []
-+		report_all = {}
-+		report_all_val = {}
-+
-+		# Saving model at epoch 0 before training
-+		print("saving model at epoch 0 before training ... ")
-+		save_checkpoint(checkpoint_name, 0, model, model_opt, loss=0.0)
-+		print("finished saving model at epoch 0 before training")
-+
-+		num_params = param_count(model)
-+		print(f"Number of model parameters: {num_params}")
-+
-+		# Training
-+		start_t = time.time()
-+
-+		total_train_iters = len(train_loader) * config.train_epochs
-+		iters_per_eval = max(1, int(total_train_iters / config.total_evaluations))
-+		# print('batch',train_batch_size)
-+		# print('ntrain',n_train)
-+		# assert (
-+		# 	n_train % min(train_batch_size, n_train) == 0
-+		# ), "Batch size doesn't divide dataset size. Can be inaccurate for loss computation (see below)."
-+
-+		training_failed = False
-+		best_val_loss_so_far = 1e7
-+
-+		for epoch in tqdm(range(start_epoch, config.train_epochs + 1)):
-+			model.train()
-+
-+			for batch_idx, data_dict in enumerate(train_loader): # Loop over batched data
-+
-+				labels = data_dict['label']
-+				data = data_dict['data']
-+
-+				# send data to device
-+				data = nested_to(data,device,torch.float32)
-+				# One-hot encode the data labels
-+				labels_tensor = torch.zeros((len(labels), 2))
-+				for i, label in enumerate(labels):
-+					labels_tensor[i, label] = 1
-+
-+				model_output = model(data) # evaluate model
-+
-+				loss = loss_func(model_output, labels_tensor) # compute loss
-+				outputs = AttrDict({"loss": loss, "prediction": model_output})
-+				outputs.reports = AttrDict({"cross_entropy": loss})
-+
-+				if torch.isnan(outputs.loss): # check for failure in training
-+					if not training_failed:
-+						epoch_of_nan = epoch
-+					if (epoch > epoch_of_nan + 1) and training_failed:
-+						raise ValueError("Loss Nan-ed.")
-+					training_failed = True
-+
-+				model_opt.zero_grad()
-+				outputs.loss.backward(retain_graph=False)
-+
-+				model_opt.step() # move optimizer forward
-+
-+				train_reports.append(parse_reports_cpu(outputs.reports))
-+
-+				if config.log_train_values:
-+					reports = parse_reports(outputs.reports)
-+					if batch_idx % config.report_loss_every == 0:
-+						log_tensorboard(summary_writer, train_iter, reports, "train/")
-+						print_reports(
-+							reports,
-+							start_t,
-+							epoch,
-+							batch_idx,
-+							len(train_loader.dataset) // train_batch_size,
-+							prefix="train",
-+						)
-+						log_tensorboard(
-+							summary_writer,
-+							train_iter,
-+							{"lr": model_opt.param_groups[0]["lr"]},
-+							"hyperparams/",
-+						)
-+				# Logging and evaluation
-+				if (
-+					train_iter % iters_per_eval == 0 or (train_iter == total_train_iters)
-+				) and config.log_val_test:  # batch_idx % config.evaluate_every == 0:
-+					model.eval()
-+					with torch.no_grad():
-+						reports = evaluate(model, test_loader, device,fold = k,headings = loader_k['test_headings'])
-+						# print("REPORTS",reports)
-+						reports = parse_reports(reports)
-+						reports["time"] = time.time() - start_t
-+						if report_all == {}:
-+							report_all = deepcopy(reports)
-+
-+							for d in reports.keys():
-+								report_all[d] = [report_all[d]]
-+						else:
-+							for d in reports.keys():
-+								report_all[d].append(reports[d])
-+
-+						log_tensorboard(summary_writer, train_iter, reports, "test/")
-+						print_reports(
-+							reports,
-+							start_t,
-+							epoch,
-+							batch_idx,
-+							len(train_loader.dataset) // config.batch_size,
-+							prefix="test",
-+						)
-+
-+						# repeat for validation data
-+						reports = evaluate(model, val_loader, device,fold = k,headings = loader_k['test_headings'])
-+						reports = parse_reports(reports)
-+						reports["time"] = time.time() - start_t
-+						if report_all_val == {}:
-+							report_all_val = deepcopy(reports)
-+
-+							for d in reports.keys():
-+								report_all_val[d] = [report_all_val[d]]
-+						else:
-+							for d in reports.keys():
-+								report_all_val[d].append(reports[d])
-+
-+						log_tensorboard(summary_writer, train_iter, reports, "val/")
-+						print_reports(
-+							reports,
-+							start_t,
-+							epoch,
-+							batch_idx,
-+							len(train_loader.dataset) // config.batch_size,
-+							prefix="val",
-+						)
-+
-+						if report_all_val["cross_entropy"][-1] < best_val_loss_so_far:
-+							save_checkpoint(
-+								checkpoint_name,
-+								f"early_stop",
-+								model,
-+								model_opt,
-+								loss=outputs.loss,
-+							)
-+							best_val_loss_so_far = report_all_val["cross_entropy"][-1]
-+
-+					model.train()
-+
-+				train_iter += 1
-+
-+			if epoch % config.save_check_points == 0:
-+				save_checkpoint(
-+					checkpoint_name, train_iter, model, model_opt, loss=outputs.loss
-+				)
-+		print('train_reports',train_reports)
-+		print("report_all",report_all)
-+		dd.io.save(fold_dir + "/results_dict_train.h5", train_reports)
-+		dd.io.save(fold_dir + "/results_dict.h5", report_all)
-+		dd.io.save(fold_dir + "/results_dict_val.h5", report_all_val)
-+
-+	# always save final model
-+	save_checkpoint(checkpoint_name, train_iter, model, model_opt, loss=outputs.loss)
-+
-+	
-+	if config.save_test_predictions:
-+		pass
-+		# print("Starting to make model predictions on test sets for *final model*.")
-+		# for chunk_len in [5, 100]:
-+		#     start_t_preds = time.time()
-+		#     data_config = SimpleNamespace(
-+		#         **{
-+		#             **config.__dict__["__flags"],
-+		#             **{"chunk_len": chunk_len, "batch_size": 500},
-+		#         }
-+		#     )
-+		#     dataloaders, data_name = fet.load(config.data_config, config=data_config)
-+		#     test_loader_preds = dataloaders["test"]
-+
-+		#     torch.cuda.empty_cache()
-+		#     with torch.no_grad():
-+		#         preds = []
-+		#         true = []
-+		#         num_datapoints = 0
-+		#         for idx, d in enumerate(test_loader_preds):
-+		#             true.append(d[-1])
-+		#             d = nested_to(d, device, torch.float32)
-+		#             outputs = model(d)
-+
-+		#             pred_zs = outputs.prediction
-+		#             preds.append(pred_zs)
-+
-+		#             num_datapoints += len(pred_zs)
-+
-+		#             if num_datapoints >= 2000:
-+		#                 break
- 
--config = forge.config()
-+		#         preds = torch.cat(preds, dim=0).cpu()
-+		#         true = torch.cat(true, dim=0).cpu()
- 
--# Prepare environment
--logdir = osp.join(config.results_dir, config.run_name)
--logdir, resume_checkpoint = fet.init_checkpoint(
--    logdir, config.data_config, config.model_config, config.resume)
--checkpoint_name = osp.join(logdir, 'model.ckpt')
-+		#         save_dir = osp.join(logdir, f"traj_preds_{chunk_len}_steps_2k_test.pt")
-+		#         torch.save(preds, save_dir)
- 
-+		#         save_dir = osp.join(logdir, f"traj_true_{chunk_len}_steps_2k_test.pt")
-+		#         torch.save(true, save_dir)
- 
--print(logdir)
-+		#         print(
-+		#             f"Completed making test predictions for chunk_len = {chunk_len} in {time.time() - start_t_preds:.2f} seconds."
-+		#         )	
-+		
- 
-+if __name__ == "__main__":
-+	main()
- 
diff --git a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs10_/1/penn_dataset.py b/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs10_/1/penn_dataset.py
deleted file mode 100644
index 7f5a4fc..0000000
--- a/checkpoints/penn_data/feedforward/testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalFalse_n_epochs10_/1/penn_dataset.py
+++ /dev/null
@@ -1,137 +0,0 @@
-import os
-import torch
-import pandas as pd
-import numpy as np
-
-from torchvision import datasets, transforms
-from torch.utils.data import Dataset, DataLoader
-from sklearn.model_selection import RepeatedKFold
-
-from os import path as osp
-import forge
-from forge import flags
-
-
-# aspects of data managmement
-flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
-flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-flags.DEFINE_boolean("cross_validate",False,"Do K-fold cross-validation")
-
-# Job management
-# flags.DEFINE_integer("batch size",5,"training batch size")
-flags.DEFINE_float("train_split",0.8,'Fraction of data to use for training.')
-flags.DEFINE_integer("n_repeats",1,"Times to repeat K-fold cross-validation")
-flags.DEFINE_integer("split_seed",1,"Seed for KFold split (integer for reproducibility")
-
-# "wavelengths between 0.05 and 1 mm in 0.025 mm increments."
-LSPACE = np.arange(0.05,1.05,0.025) # corresponds to 39 non-coord columns of data
-L_INDS = None
-
-DATAFOLDER = './penn_data'
-
-HEADINGS = np.array(['aaa0043','aaa0044','aaa0060','aaa0061','aaa0063','aaa0064','aaa0066','aaa0069','aaa0086','aaa0087','aaa_0051','aaa_0053','aaa_0054','aaa_0059','aaa_0071','aaa_0072'])
-
-
-class PennData(Dataset):
-
-    def __init__(self,path_to_data,headings,k_inds = None,include_coords = True,rescale = True,spectra_prefix = "kvals_fuse_rotate_",label_prefix = 'labels_fuse_rotate_'):
-        
-        self.data_dir = path_to_data
-        self.headings = headings
-
-        df_list = []
-        label_list = []
-        for heading in self.headings: # for each datafile heading,
-            data_name = osp.join(self.data_dir,spectra_prefix + heading+'.csv') # read kvals
-            df_temp = pd.read_csv(data_name,header=None)
-            df_list.append(df_temp)
-
-            label_name = osp.join(self.data_dir,label_prefix + heading + '.csv') # read labels
-            label_temp = pd.read_csv(label_name,header=None, names=['label'])
-            label_list.append(label_temp)
-
-        df = pd.concat(df_list, ignore_index=True)
-
-        labels = pd.concat(label_list, ignore_index=True)
-        df = pd.concat([labels, df], axis="columns") # Append labels to data
-
-        all_labels = df['label'].to_numpy()
-        all_data = df.iloc[:,1:].to_numpy()
-
-        if rescale: # rescale (normalize) wavelength intensity data
-            lambdas = all_data[:,2:] # wavelengths
-            lam_std = np.std(lambdas, axis=0)  # Calculate standard deviation along columns
-            lam_mean = np.mean(lambdas, axis=0)  # Calculate mean along columns
-            lambdas_rescaled = (lambdas - lam_mean) / lam_std 
-            all_data[:,2:] = lambdas_rescaled
-
-        if not include_coords: # removes x,y coordinates from data
-            all_data = all_data[:,2:]
-        
-        if k_inds != None: # in this case, only use subset of wavelengths
-            all_data = all_data[:,np.array(k_inds)]
-
-        self.all_data = all_data
-        self.all_labels = all_labels
-
-    def __len__(self):
-        return len(self.all_data)
-
-    def __getitem__(self,i):
-        state = {'label':self.all_labels[i],'data':self.all_data[i]}
-        return state
-
-    def __getstate__(self):
-        state = {
-            'data': self.all_data,
-            'label': self.all_labels,
-                }
-        return state
-
-    def __setstate__(self, state):
-        # Set the object's state from the provided dictionary
-        self.all_data = state['data']
-        self.all_labels = state['label']
-        
-
-
-def load(config):
-
-    n_splits = int(len(HEADINGS)/((1-config.train_split)*len(HEADINGS)))
-
-    kf = RepeatedKFold(n_splits = n_splits, n_repeats = config.n_repeats, random_state = config.split_seed) # K-fold cross validation
-
-    kf_dataloaders = []
-
-    for i, (train_ind, test_ind) in enumerate(kf.split(HEADINGS)): # for each K-fold split, 
-        n_val = len(test_ind)//2
-        n_test = len(test_ind)-n_val   
-        n_train = len(train_ind)
-        
-        # set up training DataLoader
-        train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
-
-        # set up test DataLoader
-        test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
-
-        # set up val DataLoader
-        val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-        
-
-        dataloaders = {'train':train_loader, 
-                       'test':test_loader,
-                       'val':val_loader,
-                       'train_inds':train_ind,
-                       'test_inds':test_ind,
-                       'n_val':n_val,
-                       'test_headings':list(HEADINGS[test_ind])
-                      }
-        kf_dataloaders.append(dataloaders)
-
-        if not config.cross_validate:
-        	break
-
-    return kf_dataloaders
diff --git a/checkpoints/penn_data/gpt-FCNN/.DS_Store b/checkpoints/penn_data/gpt-FCNN/.DS_Store
deleted file mode 100644
index 2175e14..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/.DS_Store and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/.DS_Store b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/.DS_Store
deleted file mode 100644
index 724b935..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/.DS_Store and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/.DS_Store b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/.DS_Store
deleted file mode 100644
index 2dda38a..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/.DS_Store and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/1/basic_feedforward.py b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/1/basic_feedforward.py
deleted file mode 100644
index 8e85f6b..0000000
--- a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/1/basic_feedforward.py
+++ /dev/null
@@ -1,73 +0,0 @@
-import torch
-import torch.nn as nn
-import torch.nn.functional as F
-import numpy as np
-
-from forge import flags
-
-# flags.DEFINE_boolean(
-#     "model_with_dict",
-#     True,
-#     "Makes model output predictions in dictionary instead of directly."
-# )
-
-class PerceptronNN(nn.Module):
-    def __init__(self, input_size, num_labels):
-        super(PerceptronNN, self).__init__()
-        # Define the layers
-        self.fc1 = nn.Linear(input_size, 128)  # First dense layer
-        self.fc2 = nn.Linear(128, 64)         # Second dense layer
-        # self.fc23 = nn.Linear(64,64)
-        self.fc3 = nn.Linear(64, 64)          # Third dense layer
-        self.fc4 = nn.Linear(64, num_labels)  # Output layer
-        # self.softmax = nn.Softmax(dim=1)
-
-    def forward(self, x):
-        # Forward pass through the network
-        x = F.relu(self.fc1(x))  # Activation function between layers
-        x = F.relu(self.fc2(x))
-        # x = F.relu(self.fc23(x))
-        x = F.relu(self.fc3(x))
-        x = self.fc4(x)  # No activation, this will be included in the loss function
-        # x = self.softmax(x)
-        return x
-
-class GPT_PNN(nn.Module):
-    def __init__(self, input_size, num_labels):
-        super(PerceptronNN, self).__init__()
-        # Define the layers
-        self.fc1 = nn.Linear(input_size, 64)  # First dense layer, reduced size
-        self.bn1 = nn.BatchNorm1d(64)  # Batch Normalization for the first layer
-        self.dropout1 = nn.Dropout(0.5)  # Dropout with 50% probability
-        
-        # Commenting out to reduce model complexity
-        # self.fc2 = nn.Linear(128, 64)  # Second dense layer
-        # self.dropout2 = nn.Dropout(0.5)  # Additional dropout layer
-        
-        # Simplified to have fewer layers and neurons
-        self.fc2 = nn.Linear(64, 32)  # Reduced size for second dense layer
-        self.bn2 = nn.BatchNorm1d(32)  # Batch Normalization for the second layer
-        self.dropout2 = nn.Dropout(0.5)  # Dropout with 50% probability
-
-        # Output layer remains the same, adjusted for reduced prior layer size
-        self.fc3 = nn.Linear(32, num_labels)  # Output layer
-
-    def forward(self, x):
-        # Forward pass through the network with activations, batch normalization, and dropout
-        x = F.relu(self.bn1(self.fc1(x)))
-        x = self.dropout1(x)
-        x = F.relu(self.bn2(self.fc2(x)))
-        x = self.dropout2(x)
-        x = self.fc3(x)  # No activation here, use sigmoid or softmax outside if needed for binary classification
-        return x
-
-def load(config):
-
-    # n_channels = 1
-    n_features = config.input_size
-    
-    # mlp = PerceptronNN(n_features,2)
-
-    mlp = GPT_PNN(n_features,2)
-    
-    return mlp, "gpt_feedforward"
\ No newline at end of file
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/1/flags.json b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/1/flags.json
deleted file mode 100644
index 8850780..0000000
--- a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/1/flags.json
+++ /dev/null
@@ -1,28 +0,0 @@
-{
-    "batch_size": 100,
-    "beta1": 0.9,
-    "beta2": 0.999,
-    "cross_validate": true,
-    "data_config": "penn_dataset.py",
-    "git_commit": "7416bf730b356aabfe0df644240e40948a8196bb",
-    "include_coords": false,
-    "input_size": 39,
-    "learning_rate": 0.0001,
-    "log_train_values": true,
-    "log_val_test": true,
-    "model_config": "basic_feedforward.py",
-    "model_name": "gpt-FCNN",
-    "n_repeats": 1,
-    "report_loss_every": 50,
-    "rescale": true,
-    "results_dir": "checkpoints",
-    "resume": false,
-    "run_name": "hyperparam_testing",
-    "save_check_points": 10,
-    "save_test_predictions": false,
-    "split_seed": 1,
-    "total_evaluations": 100,
-    "train_epochs": 50,
-    "train_split": 0.8,
-    "use_mps": false
-}
\ No newline at end of file
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/1/git_diff.txt b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/1/git_diff.txt
deleted file mode 100644
index 7f68239..0000000
--- a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/1/git_diff.txt
+++ /dev/null
@@ -1,1812 +0,0 @@
-Tue Mar 5 17:27:03 PST 2024
-diff --git a/.DS_Store b/.DS_Store
-index e2836a8..bf7630a 100644
-Binary files a/.DS_Store and b/.DS_Store differ
-diff --git a/.ipynb_checkpoints/basic_feedforward-checkpoint.py b/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-index 688c282..0c4bcd1 100644
---- a/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-+++ b/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-@@ -5,6 +5,12 @@ import numpy as np
- 
- from forge import flags
- 
-+flags.DEFINE_boolean(
-+    "model_with_dict",
-+    True,
-+    "Makes model output predictions in dictionary instead of directly."
-+)
-+
- class PerceptronNN(nn.Module):
-     def __init__(self, input_size, num_labels):
-         super(PerceptronNN, self).__init__()
-@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-+        self.softmax = nn.Softmax(dim=1)
- 
-     def forward(self, x):
-         # Forward pass through the network
-@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-         x = F.relu(self.fc2(x))
-         x = F.relu(self.fc3(x))
-         x = self.fc4(x)  # No activation, this will be included in the loss function
-+        x = self.softmax(x)
-         return x
- 
- def load(config):
-@@ -29,4 +37,4 @@ def load(config):
-     
-     mlp = PerceptronNN(n_features,2)
-     
--    return mlp
-\ No newline at end of file
-+    return mlp, "feedforward"
-\ No newline at end of file
-diff --git a/__pycache__/basic_feedforward.cpython-39.pyc b/__pycache__/basic_feedforward.cpython-39.pyc
-index f541140..5474cc4 100644
-Binary files a/__pycache__/basic_feedforward.cpython-39.pyc and b/__pycache__/basic_feedforward.cpython-39.pyc differ
-diff --git a/__pycache__/penn_dataset.cpython-39.pyc b/__pycache__/penn_dataset.cpython-39.pyc
-index 0d7a4de..ecb5bc2 100644
-Binary files a/__pycache__/penn_dataset.cpython-39.pyc and b/__pycache__/penn_dataset.cpython-39.pyc differ
-diff --git a/basic_feedforward.py b/basic_feedforward.py
-index 688c282..8e85f6b 100644
---- a/basic_feedforward.py
-+++ b/basic_feedforward.py
-@@ -5,21 +5,60 @@ import numpy as np
- 
- from forge import flags
- 
-+# flags.DEFINE_boolean(
-+#     "model_with_dict",
-+#     True,
-+#     "Makes model output predictions in dictionary instead of directly."
-+# )
-+
- class PerceptronNN(nn.Module):
-     def __init__(self, input_size, num_labels):
-         super(PerceptronNN, self).__init__()
-         # Define the layers
-         self.fc1 = nn.Linear(input_size, 128)  # First dense layer
-         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-+        # self.fc23 = nn.Linear(64,64)
-         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-+        # self.softmax = nn.Softmax(dim=1)
- 
-     def forward(self, x):
-         # Forward pass through the network
-         x = F.relu(self.fc1(x))  # Activation function between layers
-         x = F.relu(self.fc2(x))
-+        # x = F.relu(self.fc23(x))
-         x = F.relu(self.fc3(x))
-         x = self.fc4(x)  # No activation, this will be included in the loss function
-+        # x = self.softmax(x)
-+        return x
-+
-+class GPT_PNN(nn.Module):
-+    def __init__(self, input_size, num_labels):
-+        super(PerceptronNN, self).__init__()
-+        # Define the layers
-+        self.fc1 = nn.Linear(input_size, 64)  # First dense layer, reduced size
-+        self.bn1 = nn.BatchNorm1d(64)  # Batch Normalization for the first layer
-+        self.dropout1 = nn.Dropout(0.5)  # Dropout with 50% probability
-+        
-+        # Commenting out to reduce model complexity
-+        # self.fc2 = nn.Linear(128, 64)  # Second dense layer
-+        # self.dropout2 = nn.Dropout(0.5)  # Additional dropout layer
-+        
-+        # Simplified to have fewer layers and neurons
-+        self.fc2 = nn.Linear(64, 32)  # Reduced size for second dense layer
-+        self.bn2 = nn.BatchNorm1d(32)  # Batch Normalization for the second layer
-+        self.dropout2 = nn.Dropout(0.5)  # Dropout with 50% probability
-+
-+        # Output layer remains the same, adjusted for reduced prior layer size
-+        self.fc3 = nn.Linear(32, num_labels)  # Output layer
-+
-+    def forward(self, x):
-+        # Forward pass through the network with activations, batch normalization, and dropout
-+        x = F.relu(self.bn1(self.fc1(x)))
-+        x = self.dropout1(x)
-+        x = F.relu(self.bn2(self.fc2(x)))
-+        x = self.dropout2(x)
-+        x = self.fc3(x)  # No activation here, use sigmoid or softmax outside if needed for binary classification
-         return x
- 
- def load(config):
-@@ -27,6 +66,8 @@ def load(config):
-     # n_channels = 1
-     n_features = config.input_size
-     
--    mlp = PerceptronNN(n_features,2)
-+    # mlp = PerceptronNN(n_features,2)
-+
-+    mlp = GPT_PNN(n_features,2)
-     
--    return mlp
-\ No newline at end of file
-+    return mlp, "gpt_feedforward"
-\ No newline at end of file
-diff --git a/checkpoints/feedforward/1/basic_feedforward.py b/checkpoints/feedforward/1/basic_feedforward.py
-index 688c282..3a65525 100644
---- a/checkpoints/feedforward/1/basic_feedforward.py
-+++ b/checkpoints/feedforward/1/basic_feedforward.py
-@@ -5,6 +5,12 @@ import numpy as np
- 
- from forge import flags
- 
-+# flags.DEFINE_boolean(
-+#     "model_with_dict",
-+#     True,
-+#     "Makes model output predictions in dictionary instead of directly."
-+# )
-+
- class PerceptronNN(nn.Module):
-     def __init__(self, input_size, num_labels):
-         super(PerceptronNN, self).__init__()
-@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-+        self.softmax = nn.Softmax(dim=1)
- 
-     def forward(self, x):
-         # Forward pass through the network
-@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-         x = F.relu(self.fc2(x))
-         x = F.relu(self.fc3(x))
-         x = self.fc4(x)  # No activation, this will be included in the loss function
-+        x = self.softmax(x)
-         return x
- 
- def load(config):
-@@ -29,4 +37,4 @@ def load(config):
-     
-     mlp = PerceptronNN(n_features,2)
-     
--    return mlp
-\ No newline at end of file
-+    return mlp, "feedforward"
-\ No newline at end of file
-diff --git a/checkpoints/feedforward/1/flags.json b/checkpoints/feedforward/1/flags.json
-index 1d000c3..889a6ea 100644
---- a/checkpoints/feedforward/1/flags.json
-+++ b/checkpoints/feedforward/1/flags.json
-@@ -1,9 +1,15 @@
- {
-     "batch_size": 100,
-+    "beta1": 0.9,
-+    "beta2": 0.999,
-+    "cross_validate": false,
-     "data_config": "penn_dataset.py",
-+    "git_commit": "7416bf730b356aabfe0df644240e40948a8196bb",
-     "include_coords": false,
-     "input_size": 39,
--    "learning_rate": 1e-05,
-+    "learning_rate": 0.0001,
-+    "log_train_values": true,
-+    "log_val_test": true,
-     "model_config": "basic_feedforward.py",
-     "n_repeats": 1,
-     "report_loss_every": 50,
-@@ -11,7 +17,10 @@
-     "results_dir": "checkpoints",
-     "resume": false,
-     "run_name": "feedforward",
-+    "save_check_points": 50,
-+    "save_test_predictions": false,
-     "split_seed": 1,
--    "train_epochs": 20,
-+    "total_evaluations": 100,
-+    "train_epochs": 100,
-     "train_split": 0.8
- }
-\ No newline at end of file
-diff --git a/checkpoints/feedforward/1/git_diff.txt b/checkpoints/feedforward/1/git_diff.txt
-index 7b37e6f..ec23707 100644
---- a/checkpoints/feedforward/1/git_diff.txt
-+++ b/checkpoints/feedforward/1/git_diff.txt
-@@ -1 +1,873 @@
--Mon Mar 4 11:45:48 PST 2024
-+Mon Mar 4 16:34:02 PST 2024
-+diff --git a/.DS_Store b/.DS_Store
-+index e2836a8..7e3fa32 100644
-+Binary files a/.DS_Store and b/.DS_Store differ
-+diff --git a/.ipynb_checkpoints/basic_feedforward-checkpoint.py b/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-+index 688c282..0c4bcd1 100644
-+--- a/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-++++ b/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-+@@ -5,6 +5,12 @@ import numpy as np
-+ 
-+ from forge import flags
-+ 
-++flags.DEFINE_boolean(
-++    "model_with_dict",
-++    True,
-++    "Makes model output predictions in dictionary instead of directly."
-++)
-++
-+ class PerceptronNN(nn.Module):
-+     def __init__(self, input_size, num_labels):
-+         super(PerceptronNN, self).__init__()
-+@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-+         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-+         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-+         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-++        self.softmax = nn.Softmax(dim=1)
-+ 
-+     def forward(self, x):
-+         # Forward pass through the network
-+@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-+         x = F.relu(self.fc2(x))
-+         x = F.relu(self.fc3(x))
-+         x = self.fc4(x)  # No activation, this will be included in the loss function
-++        x = self.softmax(x)
-+         return x
-+ 
-+ def load(config):
-+@@ -29,4 +37,4 @@ def load(config):
-+     
-+     mlp = PerceptronNN(n_features,2)
-+     
-+-    return mlp
-+\ No newline at end of file
-++    return mlp, "feedforward"
-+\ No newline at end of file
-+diff --git a/__pycache__/basic_feedforward.cpython-39.pyc b/__pycache__/basic_feedforward.cpython-39.pyc
-+index f541140..5ad96de 100644
-+Binary files a/__pycache__/basic_feedforward.cpython-39.pyc and b/__pycache__/basic_feedforward.cpython-39.pyc differ
-+diff --git a/__pycache__/penn_dataset.cpython-39.pyc b/__pycache__/penn_dataset.cpython-39.pyc
-+index 0d7a4de..19121eb 100644
-+Binary files a/__pycache__/penn_dataset.cpython-39.pyc and b/__pycache__/penn_dataset.cpython-39.pyc differ
-+diff --git a/basic_feedforward.py b/basic_feedforward.py
-+index 688c282..3a65525 100644
-+--- a/basic_feedforward.py
-++++ b/basic_feedforward.py
-+@@ -5,6 +5,12 @@ import numpy as np
-+ 
-+ from forge import flags
-+ 
-++# flags.DEFINE_boolean(
-++#     "model_with_dict",
-++#     True,
-++#     "Makes model output predictions in dictionary instead of directly."
-++# )
-++
-+ class PerceptronNN(nn.Module):
-+     def __init__(self, input_size, num_labels):
-+         super(PerceptronNN, self).__init__()
-+@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-+         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-+         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-+         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-++        self.softmax = nn.Softmax(dim=1)
-+ 
-+     def forward(self, x):
-+         # Forward pass through the network
-+@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-+         x = F.relu(self.fc2(x))
-+         x = F.relu(self.fc3(x))
-+         x = self.fc4(x)  # No activation, this will be included in the loss function
-++        x = self.softmax(x)
-+         return x
-+ 
-+ def load(config):
-+@@ -29,4 +37,4 @@ def load(config):
-+     
-+     mlp = PerceptronNN(n_features,2)
-+     
-+-    return mlp
-+\ No newline at end of file
-++    return mlp, "feedforward"
-+\ No newline at end of file
-+diff --git a/checkpoints/feedforward/1/basic_feedforward.py b/checkpoints/feedforward/1/basic_feedforward.py
-+index 688c282..3a65525 100644
-+--- a/checkpoints/feedforward/1/basic_feedforward.py
-++++ b/checkpoints/feedforward/1/basic_feedforward.py
-+@@ -5,6 +5,12 @@ import numpy as np
-+ 
-+ from forge import flags
-+ 
-++# flags.DEFINE_boolean(
-++#     "model_with_dict",
-++#     True,
-++#     "Makes model output predictions in dictionary instead of directly."
-++# )
-++
-+ class PerceptronNN(nn.Module):
-+     def __init__(self, input_size, num_labels):
-+         super(PerceptronNN, self).__init__()
-+@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-+         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-+         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-+         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-++        self.softmax = nn.Softmax(dim=1)
-+ 
-+     def forward(self, x):
-+         # Forward pass through the network
-+@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-+         x = F.relu(self.fc2(x))
-+         x = F.relu(self.fc3(x))
-+         x = self.fc4(x)  # No activation, this will be included in the loss function
-++        x = self.softmax(x)
-+         return x
-+ 
-+ def load(config):
-+@@ -29,4 +37,4 @@ def load(config):
-+     
-+     mlp = PerceptronNN(n_features,2)
-+     
-+-    return mlp
-+\ No newline at end of file
-++    return mlp, "feedforward"
-+\ No newline at end of file
-+diff --git a/checkpoints/feedforward/1/flags.json b/checkpoints/feedforward/1/flags.json
-+index 1d000c3..889a6ea 100644
-+--- a/checkpoints/feedforward/1/flags.json
-++++ b/checkpoints/feedforward/1/flags.json
-+@@ -1,9 +1,15 @@
-+ {
-+     "batch_size": 100,
-++    "beta1": 0.9,
-++    "beta2": 0.999,
-++    "cross_validate": false,
-+     "data_config": "penn_dataset.py",
-++    "git_commit": "7416bf730b356aabfe0df644240e40948a8196bb",
-+     "include_coords": false,
-+     "input_size": 39,
-+-    "learning_rate": 1e-05,
-++    "learning_rate": 0.0001,
-++    "log_train_values": true,
-++    "log_val_test": true,
-+     "model_config": "basic_feedforward.py",
-+     "n_repeats": 1,
-+     "report_loss_every": 50,
-+@@ -11,7 +17,10 @@
-+     "results_dir": "checkpoints",
-+     "resume": false,
-+     "run_name": "feedforward",
-++    "save_check_points": 50,
-++    "save_test_predictions": false,
-+     "split_seed": 1,
-+-    "train_epochs": 20,
-++    "total_evaluations": 100,
-++    "train_epochs": 100,
-+     "train_split": 0.8
-+ }
-+\ No newline at end of file
-+diff --git a/checkpoints/feedforward/1/git_diff.txt b/checkpoints/feedforward/1/git_diff.txt
-+index 7b37e6f..5c561db 100644
-+--- a/checkpoints/feedforward/1/git_diff.txt
-++++ b/checkpoints/feedforward/1/git_diff.txt
-+@@ -1 +1 @@
-+-Mon Mar 4 11:45:48 PST 2024
-++Mon Mar 4 16:34:02 PST 2024
-+diff --git a/checkpoints/feedforward/1/penn_dataset.py b/checkpoints/feedforward/1/penn_dataset.py
-+index aa2f5a0..7f5a4fc 100644
-+--- a/checkpoints/feedforward/1/penn_dataset.py
-++++ b/checkpoints/feedforward/1/penn_dataset.py
-+@@ -15,6 +15,7 @@ from forge import flags
-+ # aspects of data managmement
-+ flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
-+ flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-++flags.DEFINE_boolean("cross_validate",False,"Do K-fold cross-validation")
-+ 
-+ # Job management
-+ # flags.DEFINE_integer("batch size",5,"training batch size")
-+@@ -109,15 +110,15 @@ def load(config):
-+         
-+         # set up training DataLoader
-+         train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, n_train),num_workers=0,shuffle = True)
-++        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
-+ 
-+         # set up test DataLoader
-+         test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, n_test),num_workers=0,shuffle = True)
-++        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
-+ 
-+         # set up val DataLoader
-+         val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, n_val),num_workers=0,shuffle = True)
-++        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-+         
-+ 
-+         dataloaders = {'train':train_loader, 
-+@@ -125,8 +126,12 @@ def load(config):
-+                        'val':val_loader,
-+                        'train_inds':train_ind,
-+                        'test_inds':test_ind,
-+-                       'n_val':n_val
-++                       'n_val':n_val,
-++                       'test_headings':list(HEADINGS[test_ind])
-+                       }
-+         kf_dataloaders.append(dataloaders)
-+ 
-++        if not config.cross_validate:
-++        	break
-++
-+     return kf_dataloaders
-+diff --git a/penn_dataset.py b/penn_dataset.py
-+index aa2f5a0..7f5a4fc 100644
-+--- a/penn_dataset.py
-++++ b/penn_dataset.py
-+@@ -15,6 +15,7 @@ from forge import flags
-+ # aspects of data managmement
-+ flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
-+ flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-++flags.DEFINE_boolean("cross_validate",False,"Do K-fold cross-validation")
-+ 
-+ # Job management
-+ # flags.DEFINE_integer("batch size",5,"training batch size")
-+@@ -109,15 +110,15 @@ def load(config):
-+         
-+         # set up training DataLoader
-+         train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, n_train),num_workers=0,shuffle = True)
-++        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
-+ 
-+         # set up test DataLoader
-+         test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, n_test),num_workers=0,shuffle = True)
-++        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
-+ 
-+         # set up val DataLoader
-+         val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, n_val),num_workers=0,shuffle = True)
-++        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-+         
-+ 
-+         dataloaders = {'train':train_loader, 
-+@@ -125,8 +126,12 @@ def load(config):
-+                        'val':val_loader,
-+                        'train_inds':train_ind,
-+                        'test_inds':test_ind,
-+-                       'n_val':n_val
-++                       'n_val':n_val,
-++                       'test_headings':list(HEADINGS[test_ind])
-+                       }
-+         kf_dataloaders.append(dataloaders)
-+ 
-++        if not config.cross_validate:
-++        	break
-++
-+     return kf_dataloaders
-+diff --git a/testing.ipynb b/testing.ipynb
-+index e5a167b..a928d8d 100644
-+--- a/testing.ipynb
-++++ b/testing.ipynb
-+@@ -2,7 +2,7 @@
-+  "cells": [
-+   {
-+    "cell_type": "code",
-+-   "execution_count": 1,
-++   "execution_count": 2,
-+    "id": "4dee7ff1-01a4-4038-b493-9729ff3693f7",
-+    "metadata": {},
-+    "outputs": [],
-+@@ -23,19 +23,19 @@
-+   },
-+   {
-+    "cell_type": "code",
-+-   "execution_count": 2,
-++   "execution_count": 3,
-+    "id": "cad0fdc8-5c35-4610-bba3-b71e60dc1b98",
-+    "metadata": {},
-+    "outputs": [],
-+    "source": [
-+-    "flags.DEFINE_integer(\"batch_size\", 100, \"Mini-batch size.\")\n",
-++    "flags.DEFINE_integer(\"batch_size\", 10, \"Mini-batch size.\")\n",
-+     "\n",
-+     "flags.DEFINE_integer(\"input_size\",39,\"Input shape to model\")"
-+    ]
-+   },
-+   {
-+    "cell_type": "code",
-+-   "execution_count": 3,
-++   "execution_count": 4,
-+    "id": "ce1b936b-8a7c-426e-a3aa-3c1c38f645de",
-+    "metadata": {},
-+    "outputs": [
-+@@ -54,8 +54,8 @@
-+   },
-+   {
-+    "cell_type": "code",
-+-   "execution_count": 9,
-+-   "id": "e862b7e2-57f5-44bf-bcf1-a91160ba66cc",
-++   "execution_count": 5,
-++   "id": "4469cddf-4dac-4468-be88-241d440401c3",
-+    "metadata": {},
-+    "outputs": [
-+     {
-+@@ -67,35 +67,89 @@
-+     }
-+    ],
-+    "source": [
-+-    "model = fet.load(\"basic_feedforward.py\",config)"
-++    "model,modelname = fet.load(\"basic_feedforward.py\",config)"
-+    ]
-+   },
-+   {
-+    "cell_type": "code",
-+-   "execution_count": 10,
-+-   "id": "07e0b160-d5d1-4e54-b4a7-ccaf2224598a",
-++   "execution_count": 17,
-++   "id": "7c9a9fe9-f5e8-456a-b964-4be13027725b",
-+    "metadata": {},
-+    "outputs": [
-+     {
-+      "data": {
-+       "text/plain": [
-+-       "PerceptronNN(\n",
-+-       "  (fc1): Linear(in_features=39, out_features=128, bias=True)\n",
-+-       "  (fc2): Linear(in_features=128, out_features=64, bias=True)\n",
-+-       "  (fc3): Linear(in_features=64, out_features=64, bias=True)\n",
-+-       "  (fc4): Linear(in_features=64, out_features=2, bias=True)\n",
-+-       ")"
-++       "['aaa0060', 'aaa0061', 'aaa0069', 'aaa_0059']"
-+       ]
-+      },
-+-     "execution_count": 10,
-++     "execution_count": 17,
-+      "metadata": {},
-+      "output_type": "execute_result"
-+     }
-+    ],
-+    "source": [
-+-    "model"
-++    "loaddat[0]['test_headings']"
-++   ]
-++  },
-++  {
-++   "cell_type": "code",
-++   "execution_count": 19,
-++   "id": "e862b7e2-57f5-44bf-bcf1-a91160ba66cc",
-++   "metadata": {},
-++   "outputs": [
-++    {
-++     "name": "stdout",
-++     "output_type": "stream",
-++     "text": [
-++      "Keys: ['cross_entropy', 'time']\n"
-++     ]
-++    }
-++   ],
-++   "source": [
-++    "import h5py\n",
-++    "\n",
-++    "file_path = \"./checkpoints/feedforward/2/data_fold1/results_dict.h5\"\n",
-++    "# Replace 'your_file.h5' with the actual path to your file\n",
-++    "f =  h5py.File(file_path, 'r') \n",
-++    "\n",
-++    "    # Get information about the data stored in the file\n",
-++    "print(\"Keys:\", list(f.keys()))  # List the top-level datasets and groups\n",
-++    "\n",
-++    "    # # Access a dataset by its name\n",
-++    "    # dataset_name = \"your_dataset_name\"\n",
-++    "    # if dataset_name in f:\n",
-++    "    #     dataset = f[dataset_name]\n",
-++    "    #     print(\"Dataset shape:\", dataset.shape)\n",
-++    "    #     print(\"Dataset dtype:\", dataset.dtype)\n",
-++    "\n",
-++    "    #     # Access the data as a NumPy array\n",
-++    "    #     data = dataset[:]  # Read the entire dataset\n",
-++    "\n",
-++    "    #     # You can now work with the data as needed, for example:\n",
-++    "    #     # Perform calculations, visualizations, etc.\n",
-++    "    # else:\n",
-++    "    #     print(f\"Dataset '{dataset_name}' not found in the file.\")"
-+    ]
-+   },
-++  {
-++   "cell_type": "code",
-++   "execution_count": 13,
-++   "id": "07e0b160-d5d1-4e54-b4a7-ccaf2224598a",
-++   "metadata": {},
-++   "outputs": [
-++    {
-++     "data": {
-++      "text/plain": [
-++       "<generator object Module.parameters at 0x3007207b0>"
-++      ]
-++     },
-++     "execution_count": 13,
-++     "metadata": {},
-++     "output_type": "execute_result"
-++    }
-++   ],
-++   "source": []
-++  },
-+   {
-+    "cell_type": "code",
-+    "execution_count": null,
-+diff --git a/train.py b/train.py
-+index c266102..516bfa9 100644
-+--- a/train.py
-++++ b/train.py
-+@@ -1,49 +1,440 @@
-+ from os import path as osp
-++import os
-++import numpy as np
-++import time
-+ 
-+ import torch
-++import torch.nn as nn
-+ import torch.nn.functional as F
-+ import torch.optim as optim
-+-
-+-import numpy as np
-++from torch.utils.tensorboard import SummaryWriter
-+ 
-+ import forge
-+ from forge import flags
-+ import forge.experiment_tools as fet
-+ 
-++from train_tools import (
-++	log_tensorboard,
-++	parse_reports,
-++	parse_reports_cpu,
-++	print_reports,
-++	load_checkpoint,
-++	save_checkpoint,
-++	nested_to,
-++	param_count,
-++)
-++
-++from copy import deepcopy
-++from attrdict import AttrDict
-++import deepdish as dd
-++from tqdm import tqdm
-++
-++# For reproducibility while researching, but might affect speed!
-++torch.backends.cudnn.deterministic = True
-++torch.backends.cudnn.benchmark = False
-++torch.manual_seed(0)
-++
-+ 
-+ # Job config
-+ flags.DEFINE_string('data_config', 'penn_dataset.py',
-+-                    'Path to a data config file.')
-++					'Path to a data config file.')
-+ flags.DEFINE_string('model_config', 'basic_feedforward.py',
-+-                    'Path to a model config file.')
-++					'Path to a model config file.')
-+ flags.DEFINE_string('results_dir', 'checkpoints',
-+-                    'Top directory for all experimental results.')
-++					'Top directory for all experimental results.')
-+ flags.DEFINE_string('run_name', 'feedforward',
-+-                    'Name of this job and name of results folder.')
-++					'Name of this job and name of results folder.')
-+ flags.DEFINE_boolean('resume', False, 'Tries to resume a job if True.')
-+ 
-+ # Logging config
-+ flags.DEFINE_integer('report_loss_every', 50,
-+-                     'Number of iterations between reporting minibatch loss.')
-+-flags.DEFINE_integer('train_epochs', 20, 'Maximum number of training epochs.')
-++					 'Number of iterations between reporting minibatch loss.')
-++flags.DEFINE_integer('train_epochs', 100, 'Maximum number of training epochs.')
-++flags.DEFINE_integer(
-++	"save_check_points",
-++	50,
-++	"frequency with which to save checkpoints, in number of epoches.",
-++)
-++flags.DEFINE_boolean("log_train_values", True, "Logs train values if True.")
-++flags.DEFINE_integer(
-++	"total_evaluations",
-++	100,
-++	"Maximum number of evaluations on test and validation data during training.",
-++)
-++flags.DEFINE_boolean(
-++	"save_test_predictions",
-++	False,
-++	"Makes and saves test predictions on one or more test sets (e.g. 5-step and 100-step predictions) at the end of training.",
-++)
-++flags.DEFINE_boolean(
-++    "log_val_test", True, "Turns off computation of validation and test errors."
-++)
-+ 
-+ # Experiment config
-+ flags.DEFINE_integer('batch_size', 100, 'Mini-batch size.')
-+-flags.DEFINE_float('learning_rate', 1e-5, 'SGD learning rate.')
-++flags.DEFINE_float("learning_rate", 1e-4, "Adam learning rate.")
-++flags.DEFINE_float("beta1", 0.9, "Adam Beta 1 parameter")
-++flags.DEFINE_float("beta2", 0.999, "Adam Beta 2 parameter")
-+ 
-+ # Specific config options
-+ flags.DEFINE_integer("input_size",39,"Input shape to model")
-+ 
-++#########################################################################################
-++
-++def evaluate(model, loader, device,fold = 0,headings = [],loss_func = nn.CrossEntropyLoss()):
-++	reports = None
-++	for data in loader:
-++		labels = data['label']
-++		inputs = nested_to(data['data'],device,torch.float32)
-++		
-++		labels_tensor = torch.zeros((len(labels), 2))
-++		for i, label in enumerate(labels):
-++			labels_tensor[i, label] = 1
-++
-++		model_output = model(inputs) # evaluate model
-++
-++		loss = loss_func(model_output, labels_tensor) # compute loss
-++		outputs = AttrDict({"loss": loss, "prediction": model_output,'data_fold':fold})
-++		outputs.reports = AttrDict({"cross_entropy": loss})
-++
-++		if reports is None:
-++			reports = {k: v.detach().clone().cpu() for k, v in outputs.reports.items()}
-++		else:
-++			for k, v in outputs.reports.items():
-++				reports[k] += v.detach().clone().cpu()
-++
-++	for k, v in reports.items():
-++		reports[k] = v / len(
-++			loader
-++		)  # SZ: note this can be slightly incorrect if mini-batch sizes vary (if batch_size doesn't divide train_size), but approximately correct.
-++
-++	# reports['test_headings'] = np.array(headings)
-++
-++	return reports
-++
-++def main():
-++
-++	config = forge.config()
-++
-++	# Set device
-++	if torch.cuda.is_available():
-++		device = f"cuda:{config.device}"
-++		torch.cuda.set_device(device)
-++	else:
-++		device = "cpu" # can change this to MPS on M1 Macs
-++
-++	# Load data
-++	data_name = "penn_data"
-++	kfold_loaders = fet.load(config.data_config, config)
-++
-++	# Load model
-++	model,model_name = fet.load(config.model_config, config)
-++	model = model.to(device)
-++
-++	loss_func = nn.CrossEntropyLoss()
-++
-++	# Prepare environment
-++	params_in_run_name = [
-++		("batch_size", "bs"),
-++		("learning_rate", "lr"),
-++		("n_train", "ntrain")
-++	]
-++
-++	run_name = ""  # config.run_name
-++	for config_param in params_in_run_name:
-++		attr = config_param[0]
-++		abbrev = config_param[1]
-++
-++		if hasattr(config, attr):
-++			run_name += abbrev
-++			run_name += str(getattr(config, attr))
-++			run_name += "_"
-++
-++	results_folder_name = osp.join(
-++		data_name,
-++		model_name,
-++		config.run_name,
-++		run_name,
-++	)
-++
-++	# Prepare environment
-++	logdir = osp.join(config.results_dir, config.run_name)
-++	logdir, resume_checkpoint = fet.init_checkpoint(
-++		logdir, config.data_config, config.model_config, config.resume)
-++
-++	print("Checkpoint directory:",logdir)
-++
-++	# Print flags
-++	fet.print_flags()
-++	# Print model info
-++	print(model)
-++
-++	# Setup optimizer
-++	model_params = model.parameters()
-++	opt_learning_rate = config.learning_rate
-++	model_opt = torch.optim.Adam(
-++		model_params, lr=opt_learning_rate, betas=(config.beta1, config.beta2)
-++	)
-++	print("Model Optimizer:")
-++	print(model_opt)
-++
-++	# Try to restore model and optimizer from checkpoint
-++	if resume_checkpoint is not None:
-++		start_epoch = load_checkpoint(resume_checkpoint, model, model_opt)
-++	else:
-++		start_epoch = 1
-++
-++	n_folds = len(kfold_loaders)
-++	print("Doing {}-fold cross-validation.".format(n_folds))
-++
-++	# KFOLD TRAINING LOOP
-++	for k,loader_k in enumerate(kfold_loaders): # loop over data splits
-++
-++		print("Training fold {}...".format(k+1))
-++
-++		# load the training data
-++		train_loader = loader_k["train"]
-++		n_train = len(train_loader.dataset)
-++		train_batch_size = train_loader.batch_size
-++
-++		# load testing, validation
-++		test_loader = loader_k["test"]
-++		n_test = len(test_loader.dataset)
-++		val_loader = loader_k["val"]
-++		n_val = len(val_loader.dataset)
-++		
-++		# create folder for this data split
-++		fold_dir = osp.join(logdir,"data_fold{}".format(k+1))
-++		fold_dir_exists = osp.exists(fold_dir)
-++		if not fold_dir_exists:
-++			if config.resume:
-++				raise ValueError("Can't resume when the checkpoint/fold dir '{}' doesn't exist.".format(fold_dir))
-++			else:
-++				os.makedirs(fold_dir)
-++		checkpoint_name = osp.join(fold_dir, 'model_fold{}.ckpt'.format(k+1))
-++
-++		# keep track of which data is test data for a given Kfold data split
-++		test_headings = loader_k['test_headings']
-++		headingsFile = osp.join(fold_dir,"test_headings.txt")
-++		with open(headingsFile,'w') as headfile:
-++			for heading in test_headings:
-++				headfile.write(heading+'\n')
-++
-++		# print(checkpoint_name)
-++
-++		train_iter = (start_epoch - 1) * (
-++		len(train_loader.dataset) // train_batch_size
-++		) + 1
-++
-++		print("Starting training at epoch = {}, iter = {}".format(start_epoch, train_iter))
-++
-++		# Setup tensorboard writing
-++		summary_writer = SummaryWriter(logdir)
-++
-++		train_reports = []
-++		report_all = {}
-++		report_all_val = {}
-++
-++		# Saving model at epoch 0 before training
-++		print("saving model at epoch 0 before training ... ")
-++		save_checkpoint(checkpoint_name, 0, model, model_opt, loss=0.0)
-++		print("finished saving model at epoch 0 before training")
-++
-++		num_params = param_count(model)
-++		print(f"Number of model parameters: {num_params}")
-++
-++		# Training
-++		start_t = time.time()
-++
-++		total_train_iters = len(train_loader) * config.train_epochs
-++		iters_per_eval = max(1, int(total_train_iters / config.total_evaluations))
-++		# print('batch',train_batch_size)
-++		# print('ntrain',n_train)
-++		# assert (
-++		# 	n_train % min(train_batch_size, n_train) == 0
-++		# ), "Batch size doesn't divide dataset size. Can be inaccurate for loss computation (see below)."
-++
-++		training_failed = False
-++		best_val_loss_so_far = 1e7
-++
-++		for epoch in tqdm(range(start_epoch, config.train_epochs + 1)):
-++			model.train()
-++
-++			for batch_idx, data_dict in enumerate(train_loader): # Loop over batched data
-++
-++				labels = data_dict['label']
-++				data = data_dict['data']
-++
-++				# send data to device
-++				data = nested_to(data,device,torch.float32)
-++				# One-hot encode the data labels
-++				labels_tensor = torch.zeros((len(labels), 2))
-++				for i, label in enumerate(labels):
-++					labels_tensor[i, label] = 1
-++
-++				model_output = model(data) # evaluate model
-++
-++				loss = loss_func(model_output, labels_tensor) # compute loss
-++				outputs = AttrDict({"loss": loss, "prediction": model_output})
-++				outputs.reports = AttrDict({"cross_entropy": loss})
-++
-++				if torch.isnan(outputs.loss): # check for failure in training
-++					if not training_failed:
-++						epoch_of_nan = epoch
-++					if (epoch > epoch_of_nan + 1) and training_failed:
-++						raise ValueError("Loss Nan-ed.")
-++					training_failed = True
-++
-++				model_opt.zero_grad()
-++				outputs.loss.backward(retain_graph=False)
-++
-++				model_opt.step() # move optimizer forward
-++
-++				train_reports.append(parse_reports_cpu(outputs.reports))
-++
-++				if config.log_train_values:
-++					reports = parse_reports(outputs.reports)
-++					if batch_idx % config.report_loss_every == 0:
-++						log_tensorboard(summary_writer, train_iter, reports, "train/")
-++						print_reports(
-++							reports,
-++							start_t,
-++							epoch,
-++							batch_idx,
-++							len(train_loader.dataset) // train_batch_size,
-++							prefix="train",
-++						)
-++						log_tensorboard(
-++							summary_writer,
-++							train_iter,
-++							{"lr": model_opt.param_groups[0]["lr"]},
-++							"hyperparams/",
-++						)
-++				# Logging and evaluation
-++				if (
-++					train_iter % iters_per_eval == 0 or (train_iter == total_train_iters)
-++				) and config.log_val_test:  # batch_idx % config.evaluate_every == 0:
-++					model.eval()
-++					with torch.no_grad():
-++						reports = evaluate(model, test_loader, device,fold = k,headings = loader_k['test_headings'])
-++						# print("REPORTS",reports)
-++						reports = parse_reports(reports)
-++						reports["time"] = time.time() - start_t
-++						if report_all == {}:
-++							report_all = deepcopy(reports)
-++
-++							for d in reports.keys():
-++								report_all[d] = [report_all[d]]
-++						else:
-++							for d in reports.keys():
-++								report_all[d].append(reports[d])
-++
-++						log_tensorboard(summary_writer, train_iter, reports, "test/")
-++						print_reports(
-++							reports,
-++							start_t,
-++							epoch,
-++							batch_idx,
-++							len(train_loader.dataset) // config.batch_size,
-++							prefix="test",
-++						)
-++
-++						# repeat for validation data
-++						reports = evaluate(model, val_loader, device,fold = k,headings = loader_k['test_headings'])
-++						reports = parse_reports(reports)
-++						reports["time"] = time.time() - start_t
-++						if report_all_val == {}:
-++							report_all_val = deepcopy(reports)
-++
-++							for d in reports.keys():
-++								report_all_val[d] = [report_all_val[d]]
-++						else:
-++							for d in reports.keys():
-++								report_all_val[d].append(reports[d])
-++
-++						log_tensorboard(summary_writer, train_iter, reports, "val/")
-++						print_reports(
-++							reports,
-++							start_t,
-++							epoch,
-++							batch_idx,
-++							len(train_loader.dataset) // config.batch_size,
-++							prefix="val",
-++						)
-++
-++						if report_all_val["cross_entropy"][-1] < best_val_loss_so_far:
-++							save_checkpoint(
-++								checkpoint_name,
-++								f"early_stop",
-++								model,
-++								model_opt,
-++								loss=outputs.loss,
-++							)
-++							best_val_loss_so_far = report_all_val["cross_entropy"][-1]
-++
-++					model.train()
-++
-++				train_iter += 1
-++
-++			if epoch % config.save_check_points == 0:
-++				save_checkpoint(
-++					checkpoint_name, train_iter, model, model_opt, loss=outputs.loss
-++				)
-++
-++		dd.io.save(fold_dir + "/results_dict_train.h5", train_reports)
-++		dd.io.save(fold_dir + "/results_dict.h5", report_all)
-++		dd.io.save(fold_dir + "/results_dict_val.h5", report_all_val)
-++
-++	# always save final model
-++	save_checkpoint(checkpoint_name, train_iter, model, model_opt, loss=outputs.loss)
-++
-++	
-++	if config.save_test_predictions:
-++		pass
-++		# print("Starting to make model predictions on test sets for *final model*.")
-++		# for chunk_len in [5, 100]:
-++		#     start_t_preds = time.time()
-++		#     data_config = SimpleNamespace(
-++		#         **{
-++		#             **config.__dict__["__flags"],
-++		#             **{"chunk_len": chunk_len, "batch_size": 500},
-++		#         }
-++		#     )
-++		#     dataloaders, data_name = fet.load(config.data_config, config=data_config)
-++		#     test_loader_preds = dataloaders["test"]
-++
-++		#     torch.cuda.empty_cache()
-++		#     with torch.no_grad():
-++		#         preds = []
-++		#         true = []
-++		#         num_datapoints = 0
-++		#         for idx, d in enumerate(test_loader_preds):
-++		#             true.append(d[-1])
-++		#             d = nested_to(d, device, torch.float32)
-++		#             outputs = model(d)
-++
-++		#             pred_zs = outputs.prediction
-++		#             preds.append(pred_zs)
-++
-++		#             num_datapoints += len(pred_zs)
-++
-++		#             if num_datapoints >= 2000:
-++		#                 break
-+ 
-+-config = forge.config()
-++		#         preds = torch.cat(preds, dim=0).cpu()
-++		#         true = torch.cat(true, dim=0).cpu()
-+ 
-+-# Prepare environment
-+-logdir = osp.join(config.results_dir, config.run_name)
-+-logdir, resume_checkpoint = fet.init_checkpoint(
-+-    logdir, config.data_config, config.model_config, config.resume)
-+-checkpoint_name = osp.join(logdir, 'model.ckpt')
-++		#         save_dir = osp.join(logdir, f"traj_preds_{chunk_len}_steps_2k_test.pt")
-++		#         torch.save(preds, save_dir)
-+ 
-++		#         save_dir = osp.join(logdir, f"traj_true_{chunk_len}_steps_2k_test.pt")
-++		#         torch.save(true, save_dir)
-+ 
-+-print(logdir)
-++		#         print(
-++		#             f"Completed making test predictions for chunk_len = {chunk_len} in {time.time() - start_t_preds:.2f} seconds."
-++		#         )	
-++		
-+ 
-++if __name__ == "__main__":
-++	main()
-+ 
-diff --git a/checkpoints/feedforward/1/penn_dataset.py b/checkpoints/feedforward/1/penn_dataset.py
-index aa2f5a0..7f5a4fc 100644
---- a/checkpoints/feedforward/1/penn_dataset.py
-+++ b/checkpoints/feedforward/1/penn_dataset.py
-@@ -15,6 +15,7 @@ from forge import flags
- # aspects of data managmement
- flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
- flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-+flags.DEFINE_boolean("cross_validate",False,"Do K-fold cross-validation")
- 
- # Job management
- # flags.DEFINE_integer("batch size",5,"training batch size")
-@@ -109,15 +110,15 @@ def load(config):
-         
-         # set up training DataLoader
-         train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, n_train),num_workers=0,shuffle = True)
-+        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
- 
-         # set up test DataLoader
-         test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, n_test),num_workers=0,shuffle = True)
-+        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
- 
-         # set up val DataLoader
-         val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, n_val),num_workers=0,shuffle = True)
-+        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-         
- 
-         dataloaders = {'train':train_loader, 
-@@ -125,8 +126,12 @@ def load(config):
-                        'val':val_loader,
-                        'train_inds':train_ind,
-                        'test_inds':test_ind,
--                       'n_val':n_val
-+                       'n_val':n_val,
-+                       'test_headings':list(HEADINGS[test_ind])
-                       }
-         kf_dataloaders.append(dataloaders)
- 
-+        if not config.cross_validate:
-+        	break
-+
-     return kf_dataloaders
-diff --git a/georgehulsey_2024.pdf b/georgehulsey_2024.pdf
-deleted file mode 100644
-index 1ab17f6..0000000
-Binary files a/georgehulsey_2024.pdf and /dev/null differ
-diff --git a/penn_dataset.py b/penn_dataset.py
-index aa2f5a0..46c8e52 100644
---- a/penn_dataset.py
-+++ b/penn_dataset.py
-@@ -15,6 +15,7 @@ from forge import flags
- # aspects of data managmement
- flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
- flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-+flags.DEFINE_boolean("cross_validate",True,"Do K-fold cross-validation")
- 
- # Job management
- # flags.DEFINE_integer("batch size",5,"training batch size")
-@@ -109,15 +110,15 @@ def load(config):
-         
-         # set up training DataLoader
-         train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, n_train),num_workers=0,shuffle = True)
-+        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
- 
-         # set up test DataLoader
-         test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, n_test),num_workers=0,shuffle = True)
-+        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
- 
-         # set up val DataLoader
-         val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, n_val),num_workers=0,shuffle = True)
-+        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-         
- 
-         dataloaders = {'train':train_loader, 
-@@ -125,8 +126,12 @@ def load(config):
-                        'val':val_loader,
-                        'train_inds':train_ind,
-                        'test_inds':test_ind,
--                       'n_val':n_val
-+                       'n_val':n_val,
-+                       'test_headings':list(HEADINGS[test_ind])
-                       }
-         kf_dataloaders.append(dataloaders)
- 
-+        if not config.cross_validate:
-+        	break
-+
-     return kf_dataloaders
-diff --git a/testing.ipynb b/testing.ipynb
-index e5a167b..0110538 100644
---- a/testing.ipynb
-+++ b/testing.ipynb
-@@ -2,7 +2,7 @@
-  "cells": [
-   {
-    "cell_type": "code",
--   "execution_count": 1,
-+   "execution_count": 4,
-    "id": "4dee7ff1-01a4-4038-b493-9729ff3693f7",
-    "metadata": {},
-    "outputs": [],
-@@ -23,7 +23,7 @@
-   },
-   {
-    "cell_type": "code",
--   "execution_count": 2,
-+   "execution_count": 6,
-    "id": "cad0fdc8-5c35-4610-bba3-b71e60dc1b98",
-    "metadata": {},
-    "outputs": [],
-@@ -35,7 +35,7 @@
-   },
-   {
-    "cell_type": "code",
--   "execution_count": 3,
-+   "execution_count": 7,
-    "id": "ce1b936b-8a7c-426e-a3aa-3c1c38f645de",
-    "metadata": {},
-    "outputs": [
-@@ -54,8 +54,8 @@
-   },
-   {
-    "cell_type": "code",
--   "execution_count": 9,
--   "id": "e862b7e2-57f5-44bf-bcf1-a91160ba66cc",
-+   "execution_count": 5,
-+   "id": "4469cddf-4dac-4468-be88-241d440401c3",
-    "metadata": {},
-    "outputs": [
-     {
-@@ -67,35 +67,98 @@
-     }
-    ],
-    "source": [
--    "model = fet.load(\"basic_feedforward.py\",config)"
-+    "model,modelname = fet.load(\"basic_feedforward.py\",config)"
-    ]
-   },
-   {
-    "cell_type": "code",
--   "execution_count": 10,
--   "id": "07e0b160-d5d1-4e54-b4a7-ccaf2224598a",
-+   "execution_count": 13,
-+   "id": "7c9a9fe9-f5e8-456a-b964-4be13027725b",
-    "metadata": {},
-    "outputs": [
-     {
-      "data": {
-       "text/plain": [
--       "PerceptronNN(\n",
--       "  (fc1): Linear(in_features=39, out_features=128, bias=True)\n",
--       "  (fc2): Linear(in_features=128, out_features=64, bias=True)\n",
--       "  (fc3): Linear(in_features=64, out_features=64, bias=True)\n",
--       "  (fc4): Linear(in_features=64, out_features=2, bias=True)\n",
--       ")"
-+       "array([114170,    904])"
-       ]
-      },
--     "execution_count": 10,
-+     "execution_count": 13,
-      "metadata": {},
-      "output_type": "execute_result"
-     }
-    ],
-    "source": [
--    "model"
-+    "np.bincount(loaddat[0]['train'].dataset.all_labels)"
-    ]
-   },
-+  {
-+   "cell_type": "code",
-+   "execution_count": 1,
-+   "id": "e862b7e2-57f5-44bf-bcf1-a91160ba66cc",
-+   "metadata": {},
-+   "outputs": [
-+    {
-+     "ename": "FileNotFoundError",
-+     "evalue": "[Errno 2] Unable to open file (unable to open file: name = './checkpoints/feedforward/2/data_fold1/results_dict.h5', errno = 2, error message = 'No such file or directory', flags = 0, o_flags = 0)",
-+     "output_type": "error",
-+     "traceback": [
-+      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
-+      "\u001b[0;31mFileNotFoundError\u001b[0m                         Traceback (most recent call last)",
-+      "Cell \u001b[0;32mIn[1], line 5\u001b[0m\n\u001b[1;32m      3\u001b[0m file_path \u001b[38;5;241m=\u001b[39m \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124m./checkpoints/feedforward/2/data_fold1/results_dict.h5\u001b[39m\u001b[38;5;124m\"\u001b[39m\n\u001b[1;32m      4\u001b[0m \u001b[38;5;66;03m# Replace 'your_file.h5' with the actual path to your file\u001b[39;00m\n\u001b[0;32m----> 5\u001b[0m f \u001b[38;5;241m=\u001b[39m  \u001b[43mh5py\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mFile\u001b[49m\u001b[43m(\u001b[49m\u001b[43mfile_path\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[38;5;124;43mr\u001b[39;49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[43m)\u001b[49m \n\u001b[1;32m      7\u001b[0m     \u001b[38;5;66;03m# Get information about the data stored in the file\u001b[39;00m\n\u001b[1;32m      8\u001b[0m \u001b[38;5;28mprint\u001b[39m(\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mKeys:\u001b[39m\u001b[38;5;124m\"\u001b[39m, \u001b[38;5;28mlist\u001b[39m(f\u001b[38;5;241m.\u001b[39mkeys()))\n",
-+      "File \u001b[0;32m/Applications/miniconda3/envs/lietransformer/lib/python3.9/site-packages/h5py/_hl/files.py:562\u001b[0m, in \u001b[0;36mFile.__init__\u001b[0;34m(self, name, mode, driver, libver, userblock_size, swmr, rdcc_nslots, rdcc_nbytes, rdcc_w0, track_order, fs_strategy, fs_persist, fs_threshold, fs_page_size, page_buf_size, min_meta_keep, min_raw_keep, locking, alignment_threshold, alignment_interval, meta_block_size, **kwds)\u001b[0m\n\u001b[1;32m    553\u001b[0m     fapl \u001b[38;5;241m=\u001b[39m make_fapl(driver, libver, rdcc_nslots, rdcc_nbytes, rdcc_w0,\n\u001b[1;32m    554\u001b[0m                      locking, page_buf_size, min_meta_keep, min_raw_keep,\n\u001b[1;32m    555\u001b[0m                      alignment_threshold\u001b[38;5;241m=\u001b[39malignment_threshold,\n\u001b[1;32m    556\u001b[0m                      alignment_interval\u001b[38;5;241m=\u001b[39malignment_interval,\n\u001b[1;32m    557\u001b[0m                      meta_block_size\u001b[38;5;241m=\u001b[39mmeta_block_size,\n\u001b[1;32m    558\u001b[0m                      \u001b[38;5;241m*\u001b[39m\u001b[38;5;241m*\u001b[39mkwds)\n\u001b[1;32m    559\u001b[0m     fcpl \u001b[38;5;241m=\u001b[39m make_fcpl(track_order\u001b[38;5;241m=\u001b[39mtrack_order, fs_strategy\u001b[38;5;241m=\u001b[39mfs_strategy,\n\u001b[1;32m    560\u001b[0m                      fs_persist\u001b[38;5;241m=\u001b[39mfs_persist, fs_threshold\u001b[38;5;241m=\u001b[39mfs_threshold,\n\u001b[1;32m    561\u001b[0m                      fs_page_size\u001b[38;5;241m=\u001b[39mfs_page_size)\n\u001b[0;32m--> 562\u001b[0m     fid \u001b[38;5;241m=\u001b[39m \u001b[43mmake_fid\u001b[49m\u001b[43m(\u001b[49m\u001b[43mname\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mmode\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43muserblock_size\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mfapl\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mfcpl\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mswmr\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43mswmr\u001b[49m\u001b[43m)\u001b[49m\n\u001b[1;32m    564\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;28misinstance\u001b[39m(libver, \u001b[38;5;28mtuple\u001b[39m):\n\u001b[1;32m    565\u001b[0m     \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_libver \u001b[38;5;241m=\u001b[39m libver\n",
-+      "File \u001b[0;32m/Applications/miniconda3/envs/lietransformer/lib/python3.9/site-packages/h5py/_hl/files.py:235\u001b[0m, in \u001b[0;36mmake_fid\u001b[0;34m(name, mode, userblock_size, fapl, fcpl, swmr)\u001b[0m\n\u001b[1;32m    233\u001b[0m     \u001b[38;5;28;01mif\u001b[39;00m swmr \u001b[38;5;129;01mand\u001b[39;00m swmr_support:\n\u001b[1;32m    234\u001b[0m         flags \u001b[38;5;241m|\u001b[39m\u001b[38;5;241m=\u001b[39m h5f\u001b[38;5;241m.\u001b[39mACC_SWMR_READ\n\u001b[0;32m--> 235\u001b[0m     fid \u001b[38;5;241m=\u001b[39m \u001b[43mh5f\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mopen\u001b[49m\u001b[43m(\u001b[49m\u001b[43mname\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mflags\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mfapl\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43mfapl\u001b[49m\u001b[43m)\u001b[49m\n\u001b[1;32m    236\u001b[0m \u001b[38;5;28;01melif\u001b[39;00m mode \u001b[38;5;241m==\u001b[39m \u001b[38;5;124m'\u001b[39m\u001b[38;5;124mr+\u001b[39m\u001b[38;5;124m'\u001b[39m:\n\u001b[1;32m    237\u001b[0m     fid \u001b[38;5;241m=\u001b[39m h5f\u001b[38;5;241m.\u001b[39mopen(name, h5f\u001b[38;5;241m.\u001b[39mACC_RDWR, fapl\u001b[38;5;241m=\u001b[39mfapl)\n",
-+      "File \u001b[0;32mh5py/_objects.pyx:54\u001b[0m, in \u001b[0;36mh5py._objects.with_phil.wrapper\u001b[0;34m()\u001b[0m\n",
-+      "File \u001b[0;32mh5py/_objects.pyx:55\u001b[0m, in \u001b[0;36mh5py._objects.with_phil.wrapper\u001b[0;34m()\u001b[0m\n",
-+      "File \u001b[0;32mh5py/h5f.pyx:102\u001b[0m, in \u001b[0;36mh5py.h5f.open\u001b[0;34m()\u001b[0m\n",
-+      "\u001b[0;31mFileNotFoundError\u001b[0m: [Errno 2] Unable to open file (unable to open file: name = './checkpoints/feedforward/2/data_fold1/results_dict.h5', errno = 2, error message = 'No such file or directory', flags = 0, o_flags = 0)"
-+     ]
-+    }
-+   ],
-+   "source": [
-+    "import h5py\n",
-+    "\n",
-+    "file_path = \"./checkpoints/feedforward/2/data_fold1/results_dict.h5\"\n",
-+    "# Replace 'your_file.h5' with the actual path to your file\n",
-+    "f =  h5py.File(file_path, 'r') \n",
-+    "\n",
-+    "    # Get information about the data stored in the file\n",
-+    "print(\"Keys:\", list(f.keys()))  # List the top-level datasets and groups\n",
-+    "\n",
-+    "    # # Access a dataset by its name\n",
-+    "    # dataset_name = \"your_dataset_name\"\n",
-+    "    # if dataset_name in f:\n",
-+    "    #     dataset = f[dataset_name]\n",
-+    "    #     print(\"Dataset shape:\", dataset.shape)\n",
-+    "    #     print(\"Dataset dtype:\", dataset.dtype)\n",
-+    "\n",
-+    "    #     # Access the data as a NumPy array\n",
-+    "    #     data = dataset[:]  # Read the entire dataset\n",
-+    "\n",
-+    "    #     # You can now work with the data as needed, for example:\n",
-+    "    #     # Perform calculations, visualizations, etc.\n",
-+    "    # else:\n",
-+    "    #     print(f\"Dataset '{dataset_name}' not found in the file.\")"
-+   ]
-+  },
-+  {
-+   "cell_type": "code",
-+   "execution_count": 13,
-+   "id": "07e0b160-d5d1-4e54-b4a7-ccaf2224598a",
-+   "metadata": {},
-+   "outputs": [
-+    {
-+     "data": {
-+      "text/plain": [
-+       "<generator object Module.parameters at 0x3007207b0>"
-+      ]
-+     },
-+     "execution_count": 13,
-+     "metadata": {},
-+     "output_type": "execute_result"
-+    }
-+   ],
-+   "source": []
-+  },
-   {
-    "cell_type": "code",
-    "execution_count": null,
-diff --git a/train.py b/train.py
-index c266102..55f58d9 100644
---- a/train.py
-+++ b/train.py
-@@ -1,49 +1,461 @@
- from os import path as osp
-+import os
-+import numpy as np
-+import time
- 
- import torch
-+import torch.nn as nn
- import torch.nn.functional as F
- import torch.optim as optim
--
--import numpy as np
-+from torch.utils.tensorboard import SummaryWriter
- 
- import forge
- from forge import flags
- import forge.experiment_tools as fet
- 
-+from train_tools import (
-+	log_tensorboard,
-+	parse_reports,
-+	parse_reports_cpu,
-+	print_reports,
-+	load_checkpoint,
-+	save_checkpoint,
-+	nested_to,
-+	param_count,
-+)
-+
-+from copy import deepcopy
-+from attrdict import AttrDict
-+import deepdish as dd
-+from tqdm import tqdm
-+
-+# For reproducibility while researching, but might affect speed!
-+torch.backends.cudnn.deterministic = True
-+torch.backends.cudnn.benchmark = False
-+torch.manual_seed(0)
-+
- 
- # Job config
- flags.DEFINE_string('data_config', 'penn_dataset.py',
--                    'Path to a data config file.')
-+					'Path to a data config file.')
- flags.DEFINE_string('model_config', 'basic_feedforward.py',
--                    'Path to a model config file.')
-+					'Path to a model config file.')
- flags.DEFINE_string('results_dir', 'checkpoints',
--                    'Top directory for all experimental results.')
--flags.DEFINE_string('run_name', 'feedforward',
--                    'Name of this job and name of results folder.')
-+					'Top directory for all experimental results.')
-+flags.DEFINE_string('model_name', 'gpt-FCNN',
-+					'shorthand name for model.')
-+flags.DEFINE_string('run_name', 'hyperparam_testing',
-+					'Name of this job and name of results folder.')
- flags.DEFINE_boolean('resume', False, 'Tries to resume a job if True.')
- 
- # Logging config
- flags.DEFINE_integer('report_loss_every', 50,
--                     'Number of iterations between reporting minibatch loss.')
--flags.DEFINE_integer('train_epochs', 20, 'Maximum number of training epochs.')
-+					 'Number of iterations between reporting minibatch loss.')
-+flags.DEFINE_integer('train_epochs', 50, 'Maximum number of training epochs.')
-+flags.DEFINE_integer(
-+	"save_check_points",
-+	10,
-+	"frequency with which to save checkpoints, in number of epoches.",
-+)
-+flags.DEFINE_boolean("log_train_values", True, "Logs train values if True.")
-+flags.DEFINE_integer(
-+	"total_evaluations",
-+	100,
-+	"Maximum number of evaluations on test and validation data during training.",
-+)
-+flags.DEFINE_boolean(
-+	"save_test_predictions",
-+	False,
-+	"Makes and saves test predictions on one or more test sets (e.g. 5-step and 100-step predictions) at the end of training.",
-+)
-+flags.DEFINE_boolean(
-+    "log_val_test", True, "Turns off computation of validation and test errors."
-+)
-+
-+flags.DEFINE_boolean('use_mps',False,"Use Metal Performance Shaders (M1) for training.")
- 
- # Experiment config
- flags.DEFINE_integer('batch_size', 100, 'Mini-batch size.')
--flags.DEFINE_float('learning_rate', 1e-5, 'SGD learning rate.')
-+flags.DEFINE_float("learning_rate", 1e-4, "Adam learning rate.")
-+flags.DEFINE_float("beta1", 0.9, "Adam Beta 1 parameter")
-+flags.DEFINE_float("beta2", 0.999, "Adam Beta 2 parameter")
- 
- # Specific config options
- flags.DEFINE_integer("input_size",39,"Input shape to model")
- 
-+#########################################################################################
-+
-+def evaluate(model, loader, device,fold = 0,headings = [],loss_func = nn.CrossEntropyLoss()):
-+	# this function does not account for class weights when evaluating cross-entropy loss.
-+	# however, they are accounted for when evaluating training loss
-+	reports = None
-+	for data in loader:
-+		labels = data['label']
-+		inputs = nested_to(data['data'],device,torch.float32)
-+		
-+		labels_tensor = torch.zeros((len(labels), 2))
-+		for i, label in enumerate(labels):
-+			labels_tensor[i, label] = 1
-+
-+		model_output = model(inputs) # evaluate model
-+
-+		loss = loss_func(model_output, labels_tensor) # compute loss
-+		outputs = AttrDict({"loss": loss, "prediction": model_output,'data_fold':fold})
-+		outputs.reports = AttrDict({"cross_entropy": loss})
-+
-+		if reports is None:
-+			reports = {k: v.detach().clone().cpu() for k, v in outputs.reports.items()}
-+		else:
-+			for k, v in outputs.reports.items():
-+				reports[k] += v.detach().clone().cpu()
-+
-+	for k, v in reports.items():
-+		reports[k] = v / len(
-+			loader
-+		)  # SZ: note this can be slightly incorrect if mini-batch sizes vary (if batch_size doesn't divide train_size), but approximately correct.
-+
-+	# reports['test_headings'] = np.array(headings)
-+
-+	return reports
-+
-+def main():
-+
-+	config = forge.config()
-+
-+	# Set device
-+	if torch.cuda.is_available():
-+		device = f"cuda:{config.device}"
-+		torch.cuda.set_device(device)
-+	else:
-+		device = "cpu" # can change this to MPS on M1 Macs
-+
-+	if config.use_mps:
-+		device = "mps"
-+
-+	# Load data
-+	data_name = "penn_data"
-+	kfold_loaders = fet.load(config.data_config, config)
-+
-+	# Prepare environment
-+	params_in_run_name = [
-+		("batch_size", "bs"),
-+		("learning_rate", "lr"),
-+		("n_train", "ntrain"),
-+		("include_coords",'inclx'),
-+		("input_size",'inpsize'),
-+		("cross_validate",'crval'),
-+		("train_epochs",'n_epochs'),
-+	]
-+
-+	run_name = ""  # config.run_name
-+	for config_param in params_in_run_name:
-+		attr = config_param[0]
-+		abbrev = config_param[1]
-+
-+		if hasattr(config, attr):
-+			run_name += abbrev
-+			run_name += str(getattr(config, attr))
-+			run_name += "_"
-+
-+	results_folder_name = osp.join(
-+		data_name,
-+		config.model_name,
-+		config.run_name,
-+		run_name,
-+	)
-+
-+	# Prepare environment
-+	logdir = osp.join(config.results_dir, results_folder_name.replace(".", "_"))
-+	logdir, resume_checkpoint = fet.init_checkpoint(
-+		logdir, config.data_config, config.model_config, config.resume)
-+
-+	print("Checkpoint directory:",logdir)
-+
-+	# Print flags
-+	fet.print_flags()
-+
-+	n_folds = len(kfold_loaders)
-+	print("Doing {}-fold cross-validation.".format(n_folds))
-+
-+	# KFOLD TRAINING LOOP
-+	for k,loader_k in enumerate(kfold_loaders): # loop over data splits
-+
-+		print("Training fold {}...".format(k+1))
-+
-+		# Load model
-+		model,model_name = fet.load(config.model_config, config)
-+		model = model.to(device)
-+
-+		# Print model info
-+		print(model)
-+
-+		# Setup optimizer
-+		model_params = model.parameters()
-+		opt_learning_rate = config.learning_rate
-+		model_opt = torch.optim.Adam(
-+			model_params, lr=opt_learning_rate, betas=(config.beta1, config.beta2)
-+		)
-+		scheduler = torch.optim.lr_scheduler.StepLR(model_opt, step_size=10, gamma=0.5)
-+		print("Model Optimizer:")
-+		print(model_opt)
-+
-+		# Try to restore model and optimizer from checkpoint
-+		if resume_checkpoint is not None:
-+			start_epoch = load_checkpoint(resume_checkpoint, model, model_opt)
-+		else:
-+			start_epoch = 1
-+
-+		# load the training data
-+		train_loader = loader_k["train"]
-+		n_train = len(train_loader.dataset)
-+		train_batch_size = train_loader.batch_size
-+
-+		# load testing, validation
-+		test_loader = loader_k["test"]
-+		n_test = len(test_loader.dataset)
-+		val_loader = loader_k["val"]
-+		n_val = len(val_loader.dataset)
-+
-+		train_class_counts = np.bincount(train_loader.dataset.all_labels)
-+		train_total_counts = sum(train_class_counts)
-+		class_weight = torch.tensor(1.0 / train_class_counts) * train_total_counts / 2.0
-+
-+		loss_func = nn.CrossEntropyLoss(weight = class_weight) # define reweighted loss function
-+				
-+		# create folder for this data split
-+		fold_dir = osp.join(logdir,"data_fold{}".format(k+1))
-+		fold_dir_exists = osp.exists(fold_dir)
-+		if not fold_dir_exists:
-+			if config.resume:
-+				raise ValueError("Can't resume when the checkpoint/fold dir '{}' doesn't exist.".format(fold_dir))
-+			else:
-+				os.makedirs(fold_dir)
-+		checkpoint_name = osp.join(fold_dir, 'model_fold{}.ckpt'.format(k+1))
-+
-+		# keep track of which data is test data for a given Kfold data split
-+		test_headings = loader_k['test_headings']
-+		headingsFile = osp.join(fold_dir,"test_headings.txt")
-+		with open(headingsFile,'w') as headfile:
-+			for heading in test_headings:
-+				headfile.write(heading+'\n')
-+
-+		# print(checkpoint_name)
-+
-+		train_iter = (start_epoch - 1) * (
-+		len(train_loader.dataset) // train_batch_size
-+		) + 1
-+
-+		print("Starting training at epoch = {}, iter = {}".format(start_epoch, train_iter))
-+
-+		# Setup tensorboard writing
-+		summary_writer = SummaryWriter(logdir)
-+
-+		train_reports = []
-+		report_all = {}
-+		report_all_val = {}
-+
-+		# Saving model at epoch 0 before training
-+		print("saving model at epoch 0 before training ... ")
-+		save_checkpoint(checkpoint_name, 0, model, model_opt, loss=0.0)
-+		print("finished saving model at epoch 0 before training")
-+
-+		num_params = param_count(model)
-+		print(f"Number of model parameters: {num_params}")
-+
-+		# Training
-+		start_t = time.time()
-+
-+		total_train_iters = len(train_loader) * config.train_epochs
-+		iters_per_eval = max(1, int(total_train_iters / config.total_evaluations))
-+		# print('batch',train_batch_size)
-+		# print('ntrain',n_train)
-+		# assert (
-+		# 	n_train % min(train_batch_size, n_train) == 0
-+		# ), "Batch size doesn't divide dataset size. Can be inaccurate for loss computation (see below)."
-+
-+		training_failed = False
-+		best_val_loss_so_far = 1e7
-+
-+		for epoch in tqdm(range(start_epoch, config.train_epochs + 1)):
-+			model.train()
-+
-+			for batch_idx, data_dict in enumerate(train_loader): # Loop over batched data
-+
-+				labels = data_dict['label']
-+				data = data_dict['data']
-+
-+				# send data to device
-+				data = nested_to(data,device,torch.float32)
-+				# One-hot encode the data labels
-+				labels_tensor = torch.zeros((len(labels), 2))
-+				for i, label in enumerate(labels):
-+					labels_tensor[i, label] = 1
-+
-+				model_output = model(data) # evaluate model
-+
-+				loss = loss_func(model_output, labels_tensor) # compute loss
-+				outputs = AttrDict({"loss": loss, "prediction": model_output})
-+				outputs.reports = AttrDict({"cross_entropy": loss})
-+
-+				if torch.isnan(outputs.loss): # check for failure in training
-+					if not training_failed:
-+						epoch_of_nan = epoch
-+					if (epoch > epoch_of_nan + 1) and training_failed:
-+						raise ValueError("Loss Nan-ed.")
-+					training_failed = True
-+
-+				model_opt.zero_grad()
-+				outputs.loss.backward(retain_graph=False)
-+
-+				model_opt.step() # move optimizer forward
-+
-+				train_reports.append(parse_reports_cpu(outputs.reports))
-+
-+				if config.log_train_values:
-+					reports = parse_reports(outputs.reports)
-+					if batch_idx % config.report_loss_every == 0:
-+						log_tensorboard(summary_writer, train_iter, reports, "train/")
-+						print_reports(
-+							reports,
-+							start_t,
-+							epoch,
-+							batch_idx,
-+							len(train_loader.dataset) // train_batch_size,
-+							prefix="train",
-+						)
-+						log_tensorboard(
-+							summary_writer,
-+							train_iter,
-+							{"lr": model_opt.param_groups[0]["lr"]},
-+							"hyperparams/",
-+						)
-+				# Logging and evaluation
-+				if (
-+					train_iter % iters_per_eval == 0 or (train_iter == total_train_iters)
-+				) and config.log_val_test:  # batch_idx % config.evaluate_every == 0:
-+					model.eval()
-+					with torch.no_grad():
-+						reports = evaluate(model, test_loader, device,fold = k,headings = loader_k['test_headings'])
-+						# print("REPORTS",reports)
-+						reports = parse_reports(reports)
-+						reports["time"] = time.time() - start_t
-+						if report_all == {}:
-+							report_all = deepcopy(reports)
-+
-+							for d in reports.keys():
-+								report_all[d] = [report_all[d]]
-+						else:
-+							for d in reports.keys():
-+								report_all[d].append(reports[d])
-+
-+						log_tensorboard(summary_writer, train_iter, reports, "test/")
-+						print_reports(
-+							reports,
-+							start_t,
-+							epoch,
-+							batch_idx,
-+							len(train_loader.dataset) // config.batch_size,
-+							prefix="test",
-+						)
-+
-+						# repeat for validation data
-+						reports = evaluate(model, val_loader, device,fold = k,headings = loader_k['test_headings'])
-+						reports = parse_reports(reports)
-+						reports["time"] = time.time() - start_t
-+						if report_all_val == {}:
-+							report_all_val = deepcopy(reports)
-+
-+							for d in reports.keys():
-+								report_all_val[d] = [report_all_val[d]]
-+						else:
-+							for d in reports.keys():
-+								report_all_val[d].append(reports[d])
-+
-+						log_tensorboard(summary_writer, train_iter, reports, "val/")
-+						print_reports(
-+							reports,
-+							start_t,
-+							epoch,
-+							batch_idx,
-+							len(train_loader.dataset) // config.batch_size,
-+							prefix="val",
-+						)
-+
-+						if report_all_val["cross_entropy"][-1] < best_val_loss_so_far:
-+							save_checkpoint(
-+								checkpoint_name,
-+								f"early_stop",
-+								model,
-+								model_opt,
-+								loss=outputs.loss,
-+							)
-+							best_val_loss_so_far = report_all_val["cross_entropy"][-1]
-+
-+					model.train()
-+
-+				train_iter += 1
-+
-+			scheduler.step()
-+
-+			if epoch % config.save_check_points == 0:
-+				save_checkpoint(
-+					checkpoint_name, train_iter, model, model_opt, loss=outputs.loss
-+				)
-+		
-+		dd.io.save(fold_dir + "/results_dict_train.h5", train_reports)
-+		dd.io.save(fold_dir + "/results_dict.h5", report_all)
-+		dd.io.save(fold_dir + "/results_dict_val.h5", report_all_val)
-+
-+	# always save final model
-+	save_checkpoint(checkpoint_name, train_iter, model, model_opt, loss=outputs.loss)
-+
-+	
-+	if config.save_test_predictions:
-+		pass
-+		# print("Starting to make model predictions on test sets for *final model*.")
-+		# for chunk_len in [5, 100]:
-+		#     start_t_preds = time.time()
-+		#     data_config = SimpleNamespace(
-+		#         **{
-+		#             **config.__dict__["__flags"],
-+		#             **{"chunk_len": chunk_len, "batch_size": 500},
-+		#         }
-+		#     )
-+		#     dataloaders, data_name = fet.load(config.data_config, config=data_config)
-+		#     test_loader_preds = dataloaders["test"]
-+
-+		#     torch.cuda.empty_cache()
-+		#     with torch.no_grad():
-+		#         preds = []
-+		#         true = []
-+		#         num_datapoints = 0
-+		#         for idx, d in enumerate(test_loader_preds):
-+		#             true.append(d[-1])
-+		#             d = nested_to(d, device, torch.float32)
-+		#             outputs = model(d)
-+
-+		#             pred_zs = outputs.prediction
-+		#             preds.append(pred_zs)
-+
-+		#             num_datapoints += len(pred_zs)
-+
-+		#             if num_datapoints >= 2000:
-+		#                 break
- 
--config = forge.config()
-+		#         preds = torch.cat(preds, dim=0).cpu()
-+		#         true = torch.cat(true, dim=0).cpu()
- 
--# Prepare environment
--logdir = osp.join(config.results_dir, config.run_name)
--logdir, resume_checkpoint = fet.init_checkpoint(
--    logdir, config.data_config, config.model_config, config.resume)
--checkpoint_name = osp.join(logdir, 'model.ckpt')
-+		#         save_dir = osp.join(logdir, f"traj_preds_{chunk_len}_steps_2k_test.pt")
-+		#         torch.save(preds, save_dir)
- 
-+		#         save_dir = osp.join(logdir, f"traj_true_{chunk_len}_steps_2k_test.pt")
-+		#         torch.save(true, save_dir)
- 
--print(logdir)
-+		#         print(
-+		#             f"Completed making test predictions for chunk_len = {chunk_len} in {time.time() - start_t_preds:.2f} seconds."
-+		#         )	
-+		
- 
-+if __name__ == "__main__":
-+	main()
- 
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/1/penn_dataset.py b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/1/penn_dataset.py
deleted file mode 100644
index 46c8e52..0000000
--- a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/1/penn_dataset.py
+++ /dev/null
@@ -1,137 +0,0 @@
-import os
-import torch
-import pandas as pd
-import numpy as np
-
-from torchvision import datasets, transforms
-from torch.utils.data import Dataset, DataLoader
-from sklearn.model_selection import RepeatedKFold
-
-from os import path as osp
-import forge
-from forge import flags
-
-
-# aspects of data managmement
-flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
-flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-flags.DEFINE_boolean("cross_validate",True,"Do K-fold cross-validation")
-
-# Job management
-# flags.DEFINE_integer("batch size",5,"training batch size")
-flags.DEFINE_float("train_split",0.8,'Fraction of data to use for training.')
-flags.DEFINE_integer("n_repeats",1,"Times to repeat K-fold cross-validation")
-flags.DEFINE_integer("split_seed",1,"Seed for KFold split (integer for reproducibility")
-
-# "wavelengths between 0.05 and 1 mm in 0.025 mm increments."
-LSPACE = np.arange(0.05,1.05,0.025) # corresponds to 39 non-coord columns of data
-L_INDS = None
-
-DATAFOLDER = './penn_data'
-
-HEADINGS = np.array(['aaa0043','aaa0044','aaa0060','aaa0061','aaa0063','aaa0064','aaa0066','aaa0069','aaa0086','aaa0087','aaa_0051','aaa_0053','aaa_0054','aaa_0059','aaa_0071','aaa_0072'])
-
-
-class PennData(Dataset):
-
-    def __init__(self,path_to_data,headings,k_inds = None,include_coords = True,rescale = True,spectra_prefix = "kvals_fuse_rotate_",label_prefix = 'labels_fuse_rotate_'):
-        
-        self.data_dir = path_to_data
-        self.headings = headings
-
-        df_list = []
-        label_list = []
-        for heading in self.headings: # for each datafile heading,
-            data_name = osp.join(self.data_dir,spectra_prefix + heading+'.csv') # read kvals
-            df_temp = pd.read_csv(data_name,header=None)
-            df_list.append(df_temp)
-
-            label_name = osp.join(self.data_dir,label_prefix + heading + '.csv') # read labels
-            label_temp = pd.read_csv(label_name,header=None, names=['label'])
-            label_list.append(label_temp)
-
-        df = pd.concat(df_list, ignore_index=True)
-
-        labels = pd.concat(label_list, ignore_index=True)
-        df = pd.concat([labels, df], axis="columns") # Append labels to data
-
-        all_labels = df['label'].to_numpy()
-        all_data = df.iloc[:,1:].to_numpy()
-
-        if rescale: # rescale (normalize) wavelength intensity data
-            lambdas = all_data[:,2:] # wavelengths
-            lam_std = np.std(lambdas, axis=0)  # Calculate standard deviation along columns
-            lam_mean = np.mean(lambdas, axis=0)  # Calculate mean along columns
-            lambdas_rescaled = (lambdas - lam_mean) / lam_std 
-            all_data[:,2:] = lambdas_rescaled
-
-        if not include_coords: # removes x,y coordinates from data
-            all_data = all_data[:,2:]
-        
-        if k_inds != None: # in this case, only use subset of wavelengths
-            all_data = all_data[:,np.array(k_inds)]
-
-        self.all_data = all_data
-        self.all_labels = all_labels
-
-    def __len__(self):
-        return len(self.all_data)
-
-    def __getitem__(self,i):
-        state = {'label':self.all_labels[i],'data':self.all_data[i]}
-        return state
-
-    def __getstate__(self):
-        state = {
-            'data': self.all_data,
-            'label': self.all_labels,
-                }
-        return state
-
-    def __setstate__(self, state):
-        # Set the object's state from the provided dictionary
-        self.all_data = state['data']
-        self.all_labels = state['label']
-        
-
-
-def load(config):
-
-    n_splits = int(len(HEADINGS)/((1-config.train_split)*len(HEADINGS)))
-
-    kf = RepeatedKFold(n_splits = n_splits, n_repeats = config.n_repeats, random_state = config.split_seed) # K-fold cross validation
-
-    kf_dataloaders = []
-
-    for i, (train_ind, test_ind) in enumerate(kf.split(HEADINGS)): # for each K-fold split, 
-        n_val = len(test_ind)//2
-        n_test = len(test_ind)-n_val   
-        n_train = len(train_ind)
-        
-        # set up training DataLoader
-        train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
-
-        # set up test DataLoader
-        test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
-
-        # set up val DataLoader
-        val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-        
-
-        dataloaders = {'train':train_loader, 
-                       'test':test_loader,
-                       'val':val_loader,
-                       'train_inds':train_ind,
-                       'test_inds':test_ind,
-                       'n_val':n_val,
-                       'test_headings':list(HEADINGS[test_ind])
-                      }
-        kf_dataloaders.append(dataloaders)
-
-        if not config.cross_validate:
-        	break
-
-    return kf_dataloaders
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/2/basic_feedforward.py b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/2/basic_feedforward.py
deleted file mode 100644
index 0cbf8bd..0000000
--- a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/2/basic_feedforward.py
+++ /dev/null
@@ -1,73 +0,0 @@
-import torch
-import torch.nn as nn
-import torch.nn.functional as F
-import numpy as np
-
-from forge import flags
-
-# flags.DEFINE_boolean(
-#     "model_with_dict",
-#     True,
-#     "Makes model output predictions in dictionary instead of directly."
-# )
-
-class PerceptronNN(nn.Module):
-    def __init__(self, input_size, num_labels):
-        super(PerceptronNN, self).__init__()
-        # Define the layers
-        self.fc1 = nn.Linear(input_size, 128)  # First dense layer
-        self.fc2 = nn.Linear(128, 64)         # Second dense layer
-        # self.fc23 = nn.Linear(64,64)
-        self.fc3 = nn.Linear(64, 64)          # Third dense layer
-        self.fc4 = nn.Linear(64, num_labels)  # Output layer
-        # self.softmax = nn.Softmax(dim=1)
-
-    def forward(self, x):
-        # Forward pass through the network
-        x = F.relu(self.fc1(x))  # Activation function between layers
-        x = F.relu(self.fc2(x))
-        # x = F.relu(self.fc23(x))
-        x = F.relu(self.fc3(x))
-        x = self.fc4(x)  # No activation, this will be included in the loss function
-        # x = self.softmax(x)
-        return x
-
-class GPT_PNN(nn.Module):
-    def __init__(self, input_size, num_labels):
-        super(GPT_PNN, self).__init__()
-        # Define the layers
-        self.fc1 = nn.Linear(input_size, 64)  # First dense layer, reduced size
-        self.bn1 = nn.BatchNorm1d(64)  # Batch Normalization for the first layer
-        self.dropout1 = nn.Dropout(0.5)  # Dropout with 50% probability
-        
-        # Commenting out to reduce model complexity
-        # self.fc2 = nn.Linear(128, 64)  # Second dense layer
-        # self.dropout2 = nn.Dropout(0.5)  # Additional dropout layer
-        
-        # Simplified to have fewer layers and neurons
-        self.fc2 = nn.Linear(64, 32)  # Reduced size for second dense layer
-        self.bn2 = nn.BatchNorm1d(32)  # Batch Normalization for the second layer
-        self.dropout2 = nn.Dropout(0.5)  # Dropout with 50% probability
-
-        # Output layer remains the same, adjusted for reduced prior layer size
-        self.fc3 = nn.Linear(32, num_labels)  # Output layer
-
-    def forward(self, x):
-        # Forward pass through the network with activations, batch normalization, and dropout
-        x = F.relu(self.bn1(self.fc1(x)))
-        x = self.dropout1(x)
-        x = F.relu(self.bn2(self.fc2(x)))
-        x = self.dropout2(x)
-        x = self.fc3(x)  # No activation here, use sigmoid or softmax outside if needed for binary classification
-        return x
-
-def load(config):
-
-    # n_channels = 1
-    n_features = config.input_size
-    
-    # mlp = PerceptronNN(n_features,2)
-
-    mlp = GPT_PNN(n_features,2)
-    
-    return mlp, "gpt_feedforward"
\ No newline at end of file
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/2/data_fold1/model_fold1.ckpt-0 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/2/data_fold1/model_fold1.ckpt-0
deleted file mode 100644
index ae76794..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/2/data_fold1/model_fold1.ckpt-0 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/2/data_fold1/model_fold1.ckpt-early_stop b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/2/data_fold1/model_fold1.ckpt-early_stop
deleted file mode 100644
index 50cc219..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/2/data_fold1/model_fold1.ckpt-early_stop and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/2/data_fold1/test_headings.txt b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/2/data_fold1/test_headings.txt
deleted file mode 100644
index 05c4825..0000000
--- a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/2/data_fold1/test_headings.txt
+++ /dev/null
@@ -1,4 +0,0 @@
-aaa0060
-aaa0061
-aaa0069
-aaa_0059
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/2/events.out.tfevents.1709688453.MacBook-Pro-4.local.3635.0 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/2/events.out.tfevents.1709688453.MacBook-Pro-4.local.3635.0
deleted file mode 100644
index e375a54..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/2/events.out.tfevents.1709688453.MacBook-Pro-4.local.3635.0 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/2/flags.json b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/2/flags.json
deleted file mode 100644
index 8850780..0000000
--- a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/2/flags.json
+++ /dev/null
@@ -1,28 +0,0 @@
-{
-    "batch_size": 100,
-    "beta1": 0.9,
-    "beta2": 0.999,
-    "cross_validate": true,
-    "data_config": "penn_dataset.py",
-    "git_commit": "7416bf730b356aabfe0df644240e40948a8196bb",
-    "include_coords": false,
-    "input_size": 39,
-    "learning_rate": 0.0001,
-    "log_train_values": true,
-    "log_val_test": true,
-    "model_config": "basic_feedforward.py",
-    "model_name": "gpt-FCNN",
-    "n_repeats": 1,
-    "report_loss_every": 50,
-    "rescale": true,
-    "results_dir": "checkpoints",
-    "resume": false,
-    "run_name": "hyperparam_testing",
-    "save_check_points": 10,
-    "save_test_predictions": false,
-    "split_seed": 1,
-    "total_evaluations": 100,
-    "train_epochs": 50,
-    "train_split": 0.8,
-    "use_mps": false
-}
\ No newline at end of file
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/2/git_diff.txt b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/2/git_diff.txt
deleted file mode 100644
index 244e218..0000000
--- a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/2/git_diff.txt
+++ /dev/null
@@ -1,1812 +0,0 @@
-Tue Mar 5 17:27:33 PST 2024
-diff --git a/.DS_Store b/.DS_Store
-index e2836a8..bf7630a 100644
-Binary files a/.DS_Store and b/.DS_Store differ
-diff --git a/.ipynb_checkpoints/basic_feedforward-checkpoint.py b/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-index 688c282..0c4bcd1 100644
---- a/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-+++ b/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-@@ -5,6 +5,12 @@ import numpy as np
- 
- from forge import flags
- 
-+flags.DEFINE_boolean(
-+    "model_with_dict",
-+    True,
-+    "Makes model output predictions in dictionary instead of directly."
-+)
-+
- class PerceptronNN(nn.Module):
-     def __init__(self, input_size, num_labels):
-         super(PerceptronNN, self).__init__()
-@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-+        self.softmax = nn.Softmax(dim=1)
- 
-     def forward(self, x):
-         # Forward pass through the network
-@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-         x = F.relu(self.fc2(x))
-         x = F.relu(self.fc3(x))
-         x = self.fc4(x)  # No activation, this will be included in the loss function
-+        x = self.softmax(x)
-         return x
- 
- def load(config):
-@@ -29,4 +37,4 @@ def load(config):
-     
-     mlp = PerceptronNN(n_features,2)
-     
--    return mlp
-\ No newline at end of file
-+    return mlp, "feedforward"
-\ No newline at end of file
-diff --git a/__pycache__/basic_feedforward.cpython-39.pyc b/__pycache__/basic_feedforward.cpython-39.pyc
-index f541140..66fb4f4 100644
-Binary files a/__pycache__/basic_feedforward.cpython-39.pyc and b/__pycache__/basic_feedforward.cpython-39.pyc differ
-diff --git a/__pycache__/penn_dataset.cpython-39.pyc b/__pycache__/penn_dataset.cpython-39.pyc
-index 0d7a4de..ecb5bc2 100644
-Binary files a/__pycache__/penn_dataset.cpython-39.pyc and b/__pycache__/penn_dataset.cpython-39.pyc differ
-diff --git a/basic_feedforward.py b/basic_feedforward.py
-index 688c282..0cbf8bd 100644
---- a/basic_feedforward.py
-+++ b/basic_feedforward.py
-@@ -5,21 +5,60 @@ import numpy as np
- 
- from forge import flags
- 
-+# flags.DEFINE_boolean(
-+#     "model_with_dict",
-+#     True,
-+#     "Makes model output predictions in dictionary instead of directly."
-+# )
-+
- class PerceptronNN(nn.Module):
-     def __init__(self, input_size, num_labels):
-         super(PerceptronNN, self).__init__()
-         # Define the layers
-         self.fc1 = nn.Linear(input_size, 128)  # First dense layer
-         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-+        # self.fc23 = nn.Linear(64,64)
-         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-+        # self.softmax = nn.Softmax(dim=1)
- 
-     def forward(self, x):
-         # Forward pass through the network
-         x = F.relu(self.fc1(x))  # Activation function between layers
-         x = F.relu(self.fc2(x))
-+        # x = F.relu(self.fc23(x))
-         x = F.relu(self.fc3(x))
-         x = self.fc4(x)  # No activation, this will be included in the loss function
-+        # x = self.softmax(x)
-+        return x
-+
-+class GPT_PNN(nn.Module):
-+    def __init__(self, input_size, num_labels):
-+        super(GPT_PNN, self).__init__()
-+        # Define the layers
-+        self.fc1 = nn.Linear(input_size, 64)  # First dense layer, reduced size
-+        self.bn1 = nn.BatchNorm1d(64)  # Batch Normalization for the first layer
-+        self.dropout1 = nn.Dropout(0.5)  # Dropout with 50% probability
-+        
-+        # Commenting out to reduce model complexity
-+        # self.fc2 = nn.Linear(128, 64)  # Second dense layer
-+        # self.dropout2 = nn.Dropout(0.5)  # Additional dropout layer
-+        
-+        # Simplified to have fewer layers and neurons
-+        self.fc2 = nn.Linear(64, 32)  # Reduced size for second dense layer
-+        self.bn2 = nn.BatchNorm1d(32)  # Batch Normalization for the second layer
-+        self.dropout2 = nn.Dropout(0.5)  # Dropout with 50% probability
-+
-+        # Output layer remains the same, adjusted for reduced prior layer size
-+        self.fc3 = nn.Linear(32, num_labels)  # Output layer
-+
-+    def forward(self, x):
-+        # Forward pass through the network with activations, batch normalization, and dropout
-+        x = F.relu(self.bn1(self.fc1(x)))
-+        x = self.dropout1(x)
-+        x = F.relu(self.bn2(self.fc2(x)))
-+        x = self.dropout2(x)
-+        x = self.fc3(x)  # No activation here, use sigmoid or softmax outside if needed for binary classification
-         return x
- 
- def load(config):
-@@ -27,6 +66,8 @@ def load(config):
-     # n_channels = 1
-     n_features = config.input_size
-     
--    mlp = PerceptronNN(n_features,2)
-+    # mlp = PerceptronNN(n_features,2)
-+
-+    mlp = GPT_PNN(n_features,2)
-     
--    return mlp
-\ No newline at end of file
-+    return mlp, "gpt_feedforward"
-\ No newline at end of file
-diff --git a/checkpoints/feedforward/1/basic_feedforward.py b/checkpoints/feedforward/1/basic_feedforward.py
-index 688c282..3a65525 100644
---- a/checkpoints/feedforward/1/basic_feedforward.py
-+++ b/checkpoints/feedforward/1/basic_feedforward.py
-@@ -5,6 +5,12 @@ import numpy as np
- 
- from forge import flags
- 
-+# flags.DEFINE_boolean(
-+#     "model_with_dict",
-+#     True,
-+#     "Makes model output predictions in dictionary instead of directly."
-+# )
-+
- class PerceptronNN(nn.Module):
-     def __init__(self, input_size, num_labels):
-         super(PerceptronNN, self).__init__()
-@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-+        self.softmax = nn.Softmax(dim=1)
- 
-     def forward(self, x):
-         # Forward pass through the network
-@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-         x = F.relu(self.fc2(x))
-         x = F.relu(self.fc3(x))
-         x = self.fc4(x)  # No activation, this will be included in the loss function
-+        x = self.softmax(x)
-         return x
- 
- def load(config):
-@@ -29,4 +37,4 @@ def load(config):
-     
-     mlp = PerceptronNN(n_features,2)
-     
--    return mlp
-\ No newline at end of file
-+    return mlp, "feedforward"
-\ No newline at end of file
-diff --git a/checkpoints/feedforward/1/flags.json b/checkpoints/feedforward/1/flags.json
-index 1d000c3..889a6ea 100644
---- a/checkpoints/feedforward/1/flags.json
-+++ b/checkpoints/feedforward/1/flags.json
-@@ -1,9 +1,15 @@
- {
-     "batch_size": 100,
-+    "beta1": 0.9,
-+    "beta2": 0.999,
-+    "cross_validate": false,
-     "data_config": "penn_dataset.py",
-+    "git_commit": "7416bf730b356aabfe0df644240e40948a8196bb",
-     "include_coords": false,
-     "input_size": 39,
--    "learning_rate": 1e-05,
-+    "learning_rate": 0.0001,
-+    "log_train_values": true,
-+    "log_val_test": true,
-     "model_config": "basic_feedforward.py",
-     "n_repeats": 1,
-     "report_loss_every": 50,
-@@ -11,7 +17,10 @@
-     "results_dir": "checkpoints",
-     "resume": false,
-     "run_name": "feedforward",
-+    "save_check_points": 50,
-+    "save_test_predictions": false,
-     "split_seed": 1,
--    "train_epochs": 20,
-+    "total_evaluations": 100,
-+    "train_epochs": 100,
-     "train_split": 0.8
- }
-\ No newline at end of file
-diff --git a/checkpoints/feedforward/1/git_diff.txt b/checkpoints/feedforward/1/git_diff.txt
-index 7b37e6f..ec23707 100644
---- a/checkpoints/feedforward/1/git_diff.txt
-+++ b/checkpoints/feedforward/1/git_diff.txt
-@@ -1 +1,873 @@
--Mon Mar 4 11:45:48 PST 2024
-+Mon Mar 4 16:34:02 PST 2024
-+diff --git a/.DS_Store b/.DS_Store
-+index e2836a8..7e3fa32 100644
-+Binary files a/.DS_Store and b/.DS_Store differ
-+diff --git a/.ipynb_checkpoints/basic_feedforward-checkpoint.py b/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-+index 688c282..0c4bcd1 100644
-+--- a/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-++++ b/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-+@@ -5,6 +5,12 @@ import numpy as np
-+ 
-+ from forge import flags
-+ 
-++flags.DEFINE_boolean(
-++    "model_with_dict",
-++    True,
-++    "Makes model output predictions in dictionary instead of directly."
-++)
-++
-+ class PerceptronNN(nn.Module):
-+     def __init__(self, input_size, num_labels):
-+         super(PerceptronNN, self).__init__()
-+@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-+         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-+         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-+         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-++        self.softmax = nn.Softmax(dim=1)
-+ 
-+     def forward(self, x):
-+         # Forward pass through the network
-+@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-+         x = F.relu(self.fc2(x))
-+         x = F.relu(self.fc3(x))
-+         x = self.fc4(x)  # No activation, this will be included in the loss function
-++        x = self.softmax(x)
-+         return x
-+ 
-+ def load(config):
-+@@ -29,4 +37,4 @@ def load(config):
-+     
-+     mlp = PerceptronNN(n_features,2)
-+     
-+-    return mlp
-+\ No newline at end of file
-++    return mlp, "feedforward"
-+\ No newline at end of file
-+diff --git a/__pycache__/basic_feedforward.cpython-39.pyc b/__pycache__/basic_feedforward.cpython-39.pyc
-+index f541140..5ad96de 100644
-+Binary files a/__pycache__/basic_feedforward.cpython-39.pyc and b/__pycache__/basic_feedforward.cpython-39.pyc differ
-+diff --git a/__pycache__/penn_dataset.cpython-39.pyc b/__pycache__/penn_dataset.cpython-39.pyc
-+index 0d7a4de..19121eb 100644
-+Binary files a/__pycache__/penn_dataset.cpython-39.pyc and b/__pycache__/penn_dataset.cpython-39.pyc differ
-+diff --git a/basic_feedforward.py b/basic_feedforward.py
-+index 688c282..3a65525 100644
-+--- a/basic_feedforward.py
-++++ b/basic_feedforward.py
-+@@ -5,6 +5,12 @@ import numpy as np
-+ 
-+ from forge import flags
-+ 
-++# flags.DEFINE_boolean(
-++#     "model_with_dict",
-++#     True,
-++#     "Makes model output predictions in dictionary instead of directly."
-++# )
-++
-+ class PerceptronNN(nn.Module):
-+     def __init__(self, input_size, num_labels):
-+         super(PerceptronNN, self).__init__()
-+@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-+         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-+         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-+         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-++        self.softmax = nn.Softmax(dim=1)
-+ 
-+     def forward(self, x):
-+         # Forward pass through the network
-+@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-+         x = F.relu(self.fc2(x))
-+         x = F.relu(self.fc3(x))
-+         x = self.fc4(x)  # No activation, this will be included in the loss function
-++        x = self.softmax(x)
-+         return x
-+ 
-+ def load(config):
-+@@ -29,4 +37,4 @@ def load(config):
-+     
-+     mlp = PerceptronNN(n_features,2)
-+     
-+-    return mlp
-+\ No newline at end of file
-++    return mlp, "feedforward"
-+\ No newline at end of file
-+diff --git a/checkpoints/feedforward/1/basic_feedforward.py b/checkpoints/feedforward/1/basic_feedforward.py
-+index 688c282..3a65525 100644
-+--- a/checkpoints/feedforward/1/basic_feedforward.py
-++++ b/checkpoints/feedforward/1/basic_feedforward.py
-+@@ -5,6 +5,12 @@ import numpy as np
-+ 
-+ from forge import flags
-+ 
-++# flags.DEFINE_boolean(
-++#     "model_with_dict",
-++#     True,
-++#     "Makes model output predictions in dictionary instead of directly."
-++# )
-++
-+ class PerceptronNN(nn.Module):
-+     def __init__(self, input_size, num_labels):
-+         super(PerceptronNN, self).__init__()
-+@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-+         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-+         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-+         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-++        self.softmax = nn.Softmax(dim=1)
-+ 
-+     def forward(self, x):
-+         # Forward pass through the network
-+@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-+         x = F.relu(self.fc2(x))
-+         x = F.relu(self.fc3(x))
-+         x = self.fc4(x)  # No activation, this will be included in the loss function
-++        x = self.softmax(x)
-+         return x
-+ 
-+ def load(config):
-+@@ -29,4 +37,4 @@ def load(config):
-+     
-+     mlp = PerceptronNN(n_features,2)
-+     
-+-    return mlp
-+\ No newline at end of file
-++    return mlp, "feedforward"
-+\ No newline at end of file
-+diff --git a/checkpoints/feedforward/1/flags.json b/checkpoints/feedforward/1/flags.json
-+index 1d000c3..889a6ea 100644
-+--- a/checkpoints/feedforward/1/flags.json
-++++ b/checkpoints/feedforward/1/flags.json
-+@@ -1,9 +1,15 @@
-+ {
-+     "batch_size": 100,
-++    "beta1": 0.9,
-++    "beta2": 0.999,
-++    "cross_validate": false,
-+     "data_config": "penn_dataset.py",
-++    "git_commit": "7416bf730b356aabfe0df644240e40948a8196bb",
-+     "include_coords": false,
-+     "input_size": 39,
-+-    "learning_rate": 1e-05,
-++    "learning_rate": 0.0001,
-++    "log_train_values": true,
-++    "log_val_test": true,
-+     "model_config": "basic_feedforward.py",
-+     "n_repeats": 1,
-+     "report_loss_every": 50,
-+@@ -11,7 +17,10 @@
-+     "results_dir": "checkpoints",
-+     "resume": false,
-+     "run_name": "feedforward",
-++    "save_check_points": 50,
-++    "save_test_predictions": false,
-+     "split_seed": 1,
-+-    "train_epochs": 20,
-++    "total_evaluations": 100,
-++    "train_epochs": 100,
-+     "train_split": 0.8
-+ }
-+\ No newline at end of file
-+diff --git a/checkpoints/feedforward/1/git_diff.txt b/checkpoints/feedforward/1/git_diff.txt
-+index 7b37e6f..5c561db 100644
-+--- a/checkpoints/feedforward/1/git_diff.txt
-++++ b/checkpoints/feedforward/1/git_diff.txt
-+@@ -1 +1 @@
-+-Mon Mar 4 11:45:48 PST 2024
-++Mon Mar 4 16:34:02 PST 2024
-+diff --git a/checkpoints/feedforward/1/penn_dataset.py b/checkpoints/feedforward/1/penn_dataset.py
-+index aa2f5a0..7f5a4fc 100644
-+--- a/checkpoints/feedforward/1/penn_dataset.py
-++++ b/checkpoints/feedforward/1/penn_dataset.py
-+@@ -15,6 +15,7 @@ from forge import flags
-+ # aspects of data managmement
-+ flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
-+ flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-++flags.DEFINE_boolean("cross_validate",False,"Do K-fold cross-validation")
-+ 
-+ # Job management
-+ # flags.DEFINE_integer("batch size",5,"training batch size")
-+@@ -109,15 +110,15 @@ def load(config):
-+         
-+         # set up training DataLoader
-+         train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, n_train),num_workers=0,shuffle = True)
-++        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
-+ 
-+         # set up test DataLoader
-+         test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, n_test),num_workers=0,shuffle = True)
-++        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
-+ 
-+         # set up val DataLoader
-+         val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, n_val),num_workers=0,shuffle = True)
-++        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-+         
-+ 
-+         dataloaders = {'train':train_loader, 
-+@@ -125,8 +126,12 @@ def load(config):
-+                        'val':val_loader,
-+                        'train_inds':train_ind,
-+                        'test_inds':test_ind,
-+-                       'n_val':n_val
-++                       'n_val':n_val,
-++                       'test_headings':list(HEADINGS[test_ind])
-+                       }
-+         kf_dataloaders.append(dataloaders)
-+ 
-++        if not config.cross_validate:
-++        	break
-++
-+     return kf_dataloaders
-+diff --git a/penn_dataset.py b/penn_dataset.py
-+index aa2f5a0..7f5a4fc 100644
-+--- a/penn_dataset.py
-++++ b/penn_dataset.py
-+@@ -15,6 +15,7 @@ from forge import flags
-+ # aspects of data managmement
-+ flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
-+ flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-++flags.DEFINE_boolean("cross_validate",False,"Do K-fold cross-validation")
-+ 
-+ # Job management
-+ # flags.DEFINE_integer("batch size",5,"training batch size")
-+@@ -109,15 +110,15 @@ def load(config):
-+         
-+         # set up training DataLoader
-+         train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, n_train),num_workers=0,shuffle = True)
-++        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
-+ 
-+         # set up test DataLoader
-+         test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, n_test),num_workers=0,shuffle = True)
-++        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
-+ 
-+         # set up val DataLoader
-+         val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, n_val),num_workers=0,shuffle = True)
-++        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-+         
-+ 
-+         dataloaders = {'train':train_loader, 
-+@@ -125,8 +126,12 @@ def load(config):
-+                        'val':val_loader,
-+                        'train_inds':train_ind,
-+                        'test_inds':test_ind,
-+-                       'n_val':n_val
-++                       'n_val':n_val,
-++                       'test_headings':list(HEADINGS[test_ind])
-+                       }
-+         kf_dataloaders.append(dataloaders)
-+ 
-++        if not config.cross_validate:
-++        	break
-++
-+     return kf_dataloaders
-+diff --git a/testing.ipynb b/testing.ipynb
-+index e5a167b..a928d8d 100644
-+--- a/testing.ipynb
-++++ b/testing.ipynb
-+@@ -2,7 +2,7 @@
-+  "cells": [
-+   {
-+    "cell_type": "code",
-+-   "execution_count": 1,
-++   "execution_count": 2,
-+    "id": "4dee7ff1-01a4-4038-b493-9729ff3693f7",
-+    "metadata": {},
-+    "outputs": [],
-+@@ -23,19 +23,19 @@
-+   },
-+   {
-+    "cell_type": "code",
-+-   "execution_count": 2,
-++   "execution_count": 3,
-+    "id": "cad0fdc8-5c35-4610-bba3-b71e60dc1b98",
-+    "metadata": {},
-+    "outputs": [],
-+    "source": [
-+-    "flags.DEFINE_integer(\"batch_size\", 100, \"Mini-batch size.\")\n",
-++    "flags.DEFINE_integer(\"batch_size\", 10, \"Mini-batch size.\")\n",
-+     "\n",
-+     "flags.DEFINE_integer(\"input_size\",39,\"Input shape to model\")"
-+    ]
-+   },
-+   {
-+    "cell_type": "code",
-+-   "execution_count": 3,
-++   "execution_count": 4,
-+    "id": "ce1b936b-8a7c-426e-a3aa-3c1c38f645de",
-+    "metadata": {},
-+    "outputs": [
-+@@ -54,8 +54,8 @@
-+   },
-+   {
-+    "cell_type": "code",
-+-   "execution_count": 9,
-+-   "id": "e862b7e2-57f5-44bf-bcf1-a91160ba66cc",
-++   "execution_count": 5,
-++   "id": "4469cddf-4dac-4468-be88-241d440401c3",
-+    "metadata": {},
-+    "outputs": [
-+     {
-+@@ -67,35 +67,89 @@
-+     }
-+    ],
-+    "source": [
-+-    "model = fet.load(\"basic_feedforward.py\",config)"
-++    "model,modelname = fet.load(\"basic_feedforward.py\",config)"
-+    ]
-+   },
-+   {
-+    "cell_type": "code",
-+-   "execution_count": 10,
-+-   "id": "07e0b160-d5d1-4e54-b4a7-ccaf2224598a",
-++   "execution_count": 17,
-++   "id": "7c9a9fe9-f5e8-456a-b964-4be13027725b",
-+    "metadata": {},
-+    "outputs": [
-+     {
-+      "data": {
-+       "text/plain": [
-+-       "PerceptronNN(\n",
-+-       "  (fc1): Linear(in_features=39, out_features=128, bias=True)\n",
-+-       "  (fc2): Linear(in_features=128, out_features=64, bias=True)\n",
-+-       "  (fc3): Linear(in_features=64, out_features=64, bias=True)\n",
-+-       "  (fc4): Linear(in_features=64, out_features=2, bias=True)\n",
-+-       ")"
-++       "['aaa0060', 'aaa0061', 'aaa0069', 'aaa_0059']"
-+       ]
-+      },
-+-     "execution_count": 10,
-++     "execution_count": 17,
-+      "metadata": {},
-+      "output_type": "execute_result"
-+     }
-+    ],
-+    "source": [
-+-    "model"
-++    "loaddat[0]['test_headings']"
-++   ]
-++  },
-++  {
-++   "cell_type": "code",
-++   "execution_count": 19,
-++   "id": "e862b7e2-57f5-44bf-bcf1-a91160ba66cc",
-++   "metadata": {},
-++   "outputs": [
-++    {
-++     "name": "stdout",
-++     "output_type": "stream",
-++     "text": [
-++      "Keys: ['cross_entropy', 'time']\n"
-++     ]
-++    }
-++   ],
-++   "source": [
-++    "import h5py\n",
-++    "\n",
-++    "file_path = \"./checkpoints/feedforward/2/data_fold1/results_dict.h5\"\n",
-++    "# Replace 'your_file.h5' with the actual path to your file\n",
-++    "f =  h5py.File(file_path, 'r') \n",
-++    "\n",
-++    "    # Get information about the data stored in the file\n",
-++    "print(\"Keys:\", list(f.keys()))  # List the top-level datasets and groups\n",
-++    "\n",
-++    "    # # Access a dataset by its name\n",
-++    "    # dataset_name = \"your_dataset_name\"\n",
-++    "    # if dataset_name in f:\n",
-++    "    #     dataset = f[dataset_name]\n",
-++    "    #     print(\"Dataset shape:\", dataset.shape)\n",
-++    "    #     print(\"Dataset dtype:\", dataset.dtype)\n",
-++    "\n",
-++    "    #     # Access the data as a NumPy array\n",
-++    "    #     data = dataset[:]  # Read the entire dataset\n",
-++    "\n",
-++    "    #     # You can now work with the data as needed, for example:\n",
-++    "    #     # Perform calculations, visualizations, etc.\n",
-++    "    # else:\n",
-++    "    #     print(f\"Dataset '{dataset_name}' not found in the file.\")"
-+    ]
-+   },
-++  {
-++   "cell_type": "code",
-++   "execution_count": 13,
-++   "id": "07e0b160-d5d1-4e54-b4a7-ccaf2224598a",
-++   "metadata": {},
-++   "outputs": [
-++    {
-++     "data": {
-++      "text/plain": [
-++       "<generator object Module.parameters at 0x3007207b0>"
-++      ]
-++     },
-++     "execution_count": 13,
-++     "metadata": {},
-++     "output_type": "execute_result"
-++    }
-++   ],
-++   "source": []
-++  },
-+   {
-+    "cell_type": "code",
-+    "execution_count": null,
-+diff --git a/train.py b/train.py
-+index c266102..516bfa9 100644
-+--- a/train.py
-++++ b/train.py
-+@@ -1,49 +1,440 @@
-+ from os import path as osp
-++import os
-++import numpy as np
-++import time
-+ 
-+ import torch
-++import torch.nn as nn
-+ import torch.nn.functional as F
-+ import torch.optim as optim
-+-
-+-import numpy as np
-++from torch.utils.tensorboard import SummaryWriter
-+ 
-+ import forge
-+ from forge import flags
-+ import forge.experiment_tools as fet
-+ 
-++from train_tools import (
-++	log_tensorboard,
-++	parse_reports,
-++	parse_reports_cpu,
-++	print_reports,
-++	load_checkpoint,
-++	save_checkpoint,
-++	nested_to,
-++	param_count,
-++)
-++
-++from copy import deepcopy
-++from attrdict import AttrDict
-++import deepdish as dd
-++from tqdm import tqdm
-++
-++# For reproducibility while researching, but might affect speed!
-++torch.backends.cudnn.deterministic = True
-++torch.backends.cudnn.benchmark = False
-++torch.manual_seed(0)
-++
-+ 
-+ # Job config
-+ flags.DEFINE_string('data_config', 'penn_dataset.py',
-+-                    'Path to a data config file.')
-++					'Path to a data config file.')
-+ flags.DEFINE_string('model_config', 'basic_feedforward.py',
-+-                    'Path to a model config file.')
-++					'Path to a model config file.')
-+ flags.DEFINE_string('results_dir', 'checkpoints',
-+-                    'Top directory for all experimental results.')
-++					'Top directory for all experimental results.')
-+ flags.DEFINE_string('run_name', 'feedforward',
-+-                    'Name of this job and name of results folder.')
-++					'Name of this job and name of results folder.')
-+ flags.DEFINE_boolean('resume', False, 'Tries to resume a job if True.')
-+ 
-+ # Logging config
-+ flags.DEFINE_integer('report_loss_every', 50,
-+-                     'Number of iterations between reporting minibatch loss.')
-+-flags.DEFINE_integer('train_epochs', 20, 'Maximum number of training epochs.')
-++					 'Number of iterations between reporting minibatch loss.')
-++flags.DEFINE_integer('train_epochs', 100, 'Maximum number of training epochs.')
-++flags.DEFINE_integer(
-++	"save_check_points",
-++	50,
-++	"frequency with which to save checkpoints, in number of epoches.",
-++)
-++flags.DEFINE_boolean("log_train_values", True, "Logs train values if True.")
-++flags.DEFINE_integer(
-++	"total_evaluations",
-++	100,
-++	"Maximum number of evaluations on test and validation data during training.",
-++)
-++flags.DEFINE_boolean(
-++	"save_test_predictions",
-++	False,
-++	"Makes and saves test predictions on one or more test sets (e.g. 5-step and 100-step predictions) at the end of training.",
-++)
-++flags.DEFINE_boolean(
-++    "log_val_test", True, "Turns off computation of validation and test errors."
-++)
-+ 
-+ # Experiment config
-+ flags.DEFINE_integer('batch_size', 100, 'Mini-batch size.')
-+-flags.DEFINE_float('learning_rate', 1e-5, 'SGD learning rate.')
-++flags.DEFINE_float("learning_rate", 1e-4, "Adam learning rate.")
-++flags.DEFINE_float("beta1", 0.9, "Adam Beta 1 parameter")
-++flags.DEFINE_float("beta2", 0.999, "Adam Beta 2 parameter")
-+ 
-+ # Specific config options
-+ flags.DEFINE_integer("input_size",39,"Input shape to model")
-+ 
-++#########################################################################################
-++
-++def evaluate(model, loader, device,fold = 0,headings = [],loss_func = nn.CrossEntropyLoss()):
-++	reports = None
-++	for data in loader:
-++		labels = data['label']
-++		inputs = nested_to(data['data'],device,torch.float32)
-++		
-++		labels_tensor = torch.zeros((len(labels), 2))
-++		for i, label in enumerate(labels):
-++			labels_tensor[i, label] = 1
-++
-++		model_output = model(inputs) # evaluate model
-++
-++		loss = loss_func(model_output, labels_tensor) # compute loss
-++		outputs = AttrDict({"loss": loss, "prediction": model_output,'data_fold':fold})
-++		outputs.reports = AttrDict({"cross_entropy": loss})
-++
-++		if reports is None:
-++			reports = {k: v.detach().clone().cpu() for k, v in outputs.reports.items()}
-++		else:
-++			for k, v in outputs.reports.items():
-++				reports[k] += v.detach().clone().cpu()
-++
-++	for k, v in reports.items():
-++		reports[k] = v / len(
-++			loader
-++		)  # SZ: note this can be slightly incorrect if mini-batch sizes vary (if batch_size doesn't divide train_size), but approximately correct.
-++
-++	# reports['test_headings'] = np.array(headings)
-++
-++	return reports
-++
-++def main():
-++
-++	config = forge.config()
-++
-++	# Set device
-++	if torch.cuda.is_available():
-++		device = f"cuda:{config.device}"
-++		torch.cuda.set_device(device)
-++	else:
-++		device = "cpu" # can change this to MPS on M1 Macs
-++
-++	# Load data
-++	data_name = "penn_data"
-++	kfold_loaders = fet.load(config.data_config, config)
-++
-++	# Load model
-++	model,model_name = fet.load(config.model_config, config)
-++	model = model.to(device)
-++
-++	loss_func = nn.CrossEntropyLoss()
-++
-++	# Prepare environment
-++	params_in_run_name = [
-++		("batch_size", "bs"),
-++		("learning_rate", "lr"),
-++		("n_train", "ntrain")
-++	]
-++
-++	run_name = ""  # config.run_name
-++	for config_param in params_in_run_name:
-++		attr = config_param[0]
-++		abbrev = config_param[1]
-++
-++		if hasattr(config, attr):
-++			run_name += abbrev
-++			run_name += str(getattr(config, attr))
-++			run_name += "_"
-++
-++	results_folder_name = osp.join(
-++		data_name,
-++		model_name,
-++		config.run_name,
-++		run_name,
-++	)
-++
-++	# Prepare environment
-++	logdir = osp.join(config.results_dir, config.run_name)
-++	logdir, resume_checkpoint = fet.init_checkpoint(
-++		logdir, config.data_config, config.model_config, config.resume)
-++
-++	print("Checkpoint directory:",logdir)
-++
-++	# Print flags
-++	fet.print_flags()
-++	# Print model info
-++	print(model)
-++
-++	# Setup optimizer
-++	model_params = model.parameters()
-++	opt_learning_rate = config.learning_rate
-++	model_opt = torch.optim.Adam(
-++		model_params, lr=opt_learning_rate, betas=(config.beta1, config.beta2)
-++	)
-++	print("Model Optimizer:")
-++	print(model_opt)
-++
-++	# Try to restore model and optimizer from checkpoint
-++	if resume_checkpoint is not None:
-++		start_epoch = load_checkpoint(resume_checkpoint, model, model_opt)
-++	else:
-++		start_epoch = 1
-++
-++	n_folds = len(kfold_loaders)
-++	print("Doing {}-fold cross-validation.".format(n_folds))
-++
-++	# KFOLD TRAINING LOOP
-++	for k,loader_k in enumerate(kfold_loaders): # loop over data splits
-++
-++		print("Training fold {}...".format(k+1))
-++
-++		# load the training data
-++		train_loader = loader_k["train"]
-++		n_train = len(train_loader.dataset)
-++		train_batch_size = train_loader.batch_size
-++
-++		# load testing, validation
-++		test_loader = loader_k["test"]
-++		n_test = len(test_loader.dataset)
-++		val_loader = loader_k["val"]
-++		n_val = len(val_loader.dataset)
-++		
-++		# create folder for this data split
-++		fold_dir = osp.join(logdir,"data_fold{}".format(k+1))
-++		fold_dir_exists = osp.exists(fold_dir)
-++		if not fold_dir_exists:
-++			if config.resume:
-++				raise ValueError("Can't resume when the checkpoint/fold dir '{}' doesn't exist.".format(fold_dir))
-++			else:
-++				os.makedirs(fold_dir)
-++		checkpoint_name = osp.join(fold_dir, 'model_fold{}.ckpt'.format(k+1))
-++
-++		# keep track of which data is test data for a given Kfold data split
-++		test_headings = loader_k['test_headings']
-++		headingsFile = osp.join(fold_dir,"test_headings.txt")
-++		with open(headingsFile,'w') as headfile:
-++			for heading in test_headings:
-++				headfile.write(heading+'\n')
-++
-++		# print(checkpoint_name)
-++
-++		train_iter = (start_epoch - 1) * (
-++		len(train_loader.dataset) // train_batch_size
-++		) + 1
-++
-++		print("Starting training at epoch = {}, iter = {}".format(start_epoch, train_iter))
-++
-++		# Setup tensorboard writing
-++		summary_writer = SummaryWriter(logdir)
-++
-++		train_reports = []
-++		report_all = {}
-++		report_all_val = {}
-++
-++		# Saving model at epoch 0 before training
-++		print("saving model at epoch 0 before training ... ")
-++		save_checkpoint(checkpoint_name, 0, model, model_opt, loss=0.0)
-++		print("finished saving model at epoch 0 before training")
-++
-++		num_params = param_count(model)
-++		print(f"Number of model parameters: {num_params}")
-++
-++		# Training
-++		start_t = time.time()
-++
-++		total_train_iters = len(train_loader) * config.train_epochs
-++		iters_per_eval = max(1, int(total_train_iters / config.total_evaluations))
-++		# print('batch',train_batch_size)
-++		# print('ntrain',n_train)
-++		# assert (
-++		# 	n_train % min(train_batch_size, n_train) == 0
-++		# ), "Batch size doesn't divide dataset size. Can be inaccurate for loss computation (see below)."
-++
-++		training_failed = False
-++		best_val_loss_so_far = 1e7
-++
-++		for epoch in tqdm(range(start_epoch, config.train_epochs + 1)):
-++			model.train()
-++
-++			for batch_idx, data_dict in enumerate(train_loader): # Loop over batched data
-++
-++				labels = data_dict['label']
-++				data = data_dict['data']
-++
-++				# send data to device
-++				data = nested_to(data,device,torch.float32)
-++				# One-hot encode the data labels
-++				labels_tensor = torch.zeros((len(labels), 2))
-++				for i, label in enumerate(labels):
-++					labels_tensor[i, label] = 1
-++
-++				model_output = model(data) # evaluate model
-++
-++				loss = loss_func(model_output, labels_tensor) # compute loss
-++				outputs = AttrDict({"loss": loss, "prediction": model_output})
-++				outputs.reports = AttrDict({"cross_entropy": loss})
-++
-++				if torch.isnan(outputs.loss): # check for failure in training
-++					if not training_failed:
-++						epoch_of_nan = epoch
-++					if (epoch > epoch_of_nan + 1) and training_failed:
-++						raise ValueError("Loss Nan-ed.")
-++					training_failed = True
-++
-++				model_opt.zero_grad()
-++				outputs.loss.backward(retain_graph=False)
-++
-++				model_opt.step() # move optimizer forward
-++
-++				train_reports.append(parse_reports_cpu(outputs.reports))
-++
-++				if config.log_train_values:
-++					reports = parse_reports(outputs.reports)
-++					if batch_idx % config.report_loss_every == 0:
-++						log_tensorboard(summary_writer, train_iter, reports, "train/")
-++						print_reports(
-++							reports,
-++							start_t,
-++							epoch,
-++							batch_idx,
-++							len(train_loader.dataset) // train_batch_size,
-++							prefix="train",
-++						)
-++						log_tensorboard(
-++							summary_writer,
-++							train_iter,
-++							{"lr": model_opt.param_groups[0]["lr"]},
-++							"hyperparams/",
-++						)
-++				# Logging and evaluation
-++				if (
-++					train_iter % iters_per_eval == 0 or (train_iter == total_train_iters)
-++				) and config.log_val_test:  # batch_idx % config.evaluate_every == 0:
-++					model.eval()
-++					with torch.no_grad():
-++						reports = evaluate(model, test_loader, device,fold = k,headings = loader_k['test_headings'])
-++						# print("REPORTS",reports)
-++						reports = parse_reports(reports)
-++						reports["time"] = time.time() - start_t
-++						if report_all == {}:
-++							report_all = deepcopy(reports)
-++
-++							for d in reports.keys():
-++								report_all[d] = [report_all[d]]
-++						else:
-++							for d in reports.keys():
-++								report_all[d].append(reports[d])
-++
-++						log_tensorboard(summary_writer, train_iter, reports, "test/")
-++						print_reports(
-++							reports,
-++							start_t,
-++							epoch,
-++							batch_idx,
-++							len(train_loader.dataset) // config.batch_size,
-++							prefix="test",
-++						)
-++
-++						# repeat for validation data
-++						reports = evaluate(model, val_loader, device,fold = k,headings = loader_k['test_headings'])
-++						reports = parse_reports(reports)
-++						reports["time"] = time.time() - start_t
-++						if report_all_val == {}:
-++							report_all_val = deepcopy(reports)
-++
-++							for d in reports.keys():
-++								report_all_val[d] = [report_all_val[d]]
-++						else:
-++							for d in reports.keys():
-++								report_all_val[d].append(reports[d])
-++
-++						log_tensorboard(summary_writer, train_iter, reports, "val/")
-++						print_reports(
-++							reports,
-++							start_t,
-++							epoch,
-++							batch_idx,
-++							len(train_loader.dataset) // config.batch_size,
-++							prefix="val",
-++						)
-++
-++						if report_all_val["cross_entropy"][-1] < best_val_loss_so_far:
-++							save_checkpoint(
-++								checkpoint_name,
-++								f"early_stop",
-++								model,
-++								model_opt,
-++								loss=outputs.loss,
-++							)
-++							best_val_loss_so_far = report_all_val["cross_entropy"][-1]
-++
-++					model.train()
-++
-++				train_iter += 1
-++
-++			if epoch % config.save_check_points == 0:
-++				save_checkpoint(
-++					checkpoint_name, train_iter, model, model_opt, loss=outputs.loss
-++				)
-++
-++		dd.io.save(fold_dir + "/results_dict_train.h5", train_reports)
-++		dd.io.save(fold_dir + "/results_dict.h5", report_all)
-++		dd.io.save(fold_dir + "/results_dict_val.h5", report_all_val)
-++
-++	# always save final model
-++	save_checkpoint(checkpoint_name, train_iter, model, model_opt, loss=outputs.loss)
-++
-++	
-++	if config.save_test_predictions:
-++		pass
-++		# print("Starting to make model predictions on test sets for *final model*.")
-++		# for chunk_len in [5, 100]:
-++		#     start_t_preds = time.time()
-++		#     data_config = SimpleNamespace(
-++		#         **{
-++		#             **config.__dict__["__flags"],
-++		#             **{"chunk_len": chunk_len, "batch_size": 500},
-++		#         }
-++		#     )
-++		#     dataloaders, data_name = fet.load(config.data_config, config=data_config)
-++		#     test_loader_preds = dataloaders["test"]
-++
-++		#     torch.cuda.empty_cache()
-++		#     with torch.no_grad():
-++		#         preds = []
-++		#         true = []
-++		#         num_datapoints = 0
-++		#         for idx, d in enumerate(test_loader_preds):
-++		#             true.append(d[-1])
-++		#             d = nested_to(d, device, torch.float32)
-++		#             outputs = model(d)
-++
-++		#             pred_zs = outputs.prediction
-++		#             preds.append(pred_zs)
-++
-++		#             num_datapoints += len(pred_zs)
-++
-++		#             if num_datapoints >= 2000:
-++		#                 break
-+ 
-+-config = forge.config()
-++		#         preds = torch.cat(preds, dim=0).cpu()
-++		#         true = torch.cat(true, dim=0).cpu()
-+ 
-+-# Prepare environment
-+-logdir = osp.join(config.results_dir, config.run_name)
-+-logdir, resume_checkpoint = fet.init_checkpoint(
-+-    logdir, config.data_config, config.model_config, config.resume)
-+-checkpoint_name = osp.join(logdir, 'model.ckpt')
-++		#         save_dir = osp.join(logdir, f"traj_preds_{chunk_len}_steps_2k_test.pt")
-++		#         torch.save(preds, save_dir)
-+ 
-++		#         save_dir = osp.join(logdir, f"traj_true_{chunk_len}_steps_2k_test.pt")
-++		#         torch.save(true, save_dir)
-+ 
-+-print(logdir)
-++		#         print(
-++		#             f"Completed making test predictions for chunk_len = {chunk_len} in {time.time() - start_t_preds:.2f} seconds."
-++		#         )	
-++		
-+ 
-++if __name__ == "__main__":
-++	main()
-+ 
-diff --git a/checkpoints/feedforward/1/penn_dataset.py b/checkpoints/feedforward/1/penn_dataset.py
-index aa2f5a0..7f5a4fc 100644
---- a/checkpoints/feedforward/1/penn_dataset.py
-+++ b/checkpoints/feedforward/1/penn_dataset.py
-@@ -15,6 +15,7 @@ from forge import flags
- # aspects of data managmement
- flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
- flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-+flags.DEFINE_boolean("cross_validate",False,"Do K-fold cross-validation")
- 
- # Job management
- # flags.DEFINE_integer("batch size",5,"training batch size")
-@@ -109,15 +110,15 @@ def load(config):
-         
-         # set up training DataLoader
-         train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, n_train),num_workers=0,shuffle = True)
-+        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
- 
-         # set up test DataLoader
-         test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, n_test),num_workers=0,shuffle = True)
-+        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
- 
-         # set up val DataLoader
-         val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, n_val),num_workers=0,shuffle = True)
-+        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-         
- 
-         dataloaders = {'train':train_loader, 
-@@ -125,8 +126,12 @@ def load(config):
-                        'val':val_loader,
-                        'train_inds':train_ind,
-                        'test_inds':test_ind,
--                       'n_val':n_val
-+                       'n_val':n_val,
-+                       'test_headings':list(HEADINGS[test_ind])
-                       }
-         kf_dataloaders.append(dataloaders)
- 
-+        if not config.cross_validate:
-+        	break
-+
-     return kf_dataloaders
-diff --git a/georgehulsey_2024.pdf b/georgehulsey_2024.pdf
-deleted file mode 100644
-index 1ab17f6..0000000
-Binary files a/georgehulsey_2024.pdf and /dev/null differ
-diff --git a/penn_dataset.py b/penn_dataset.py
-index aa2f5a0..46c8e52 100644
---- a/penn_dataset.py
-+++ b/penn_dataset.py
-@@ -15,6 +15,7 @@ from forge import flags
- # aspects of data managmement
- flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
- flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-+flags.DEFINE_boolean("cross_validate",True,"Do K-fold cross-validation")
- 
- # Job management
- # flags.DEFINE_integer("batch size",5,"training batch size")
-@@ -109,15 +110,15 @@ def load(config):
-         
-         # set up training DataLoader
-         train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, n_train),num_workers=0,shuffle = True)
-+        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
- 
-         # set up test DataLoader
-         test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, n_test),num_workers=0,shuffle = True)
-+        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
- 
-         # set up val DataLoader
-         val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, n_val),num_workers=0,shuffle = True)
-+        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-         
- 
-         dataloaders = {'train':train_loader, 
-@@ -125,8 +126,12 @@ def load(config):
-                        'val':val_loader,
-                        'train_inds':train_ind,
-                        'test_inds':test_ind,
--                       'n_val':n_val
-+                       'n_val':n_val,
-+                       'test_headings':list(HEADINGS[test_ind])
-                       }
-         kf_dataloaders.append(dataloaders)
- 
-+        if not config.cross_validate:
-+        	break
-+
-     return kf_dataloaders
-diff --git a/testing.ipynb b/testing.ipynb
-index e5a167b..0110538 100644
---- a/testing.ipynb
-+++ b/testing.ipynb
-@@ -2,7 +2,7 @@
-  "cells": [
-   {
-    "cell_type": "code",
--   "execution_count": 1,
-+   "execution_count": 4,
-    "id": "4dee7ff1-01a4-4038-b493-9729ff3693f7",
-    "metadata": {},
-    "outputs": [],
-@@ -23,7 +23,7 @@
-   },
-   {
-    "cell_type": "code",
--   "execution_count": 2,
-+   "execution_count": 6,
-    "id": "cad0fdc8-5c35-4610-bba3-b71e60dc1b98",
-    "metadata": {},
-    "outputs": [],
-@@ -35,7 +35,7 @@
-   },
-   {
-    "cell_type": "code",
--   "execution_count": 3,
-+   "execution_count": 7,
-    "id": "ce1b936b-8a7c-426e-a3aa-3c1c38f645de",
-    "metadata": {},
-    "outputs": [
-@@ -54,8 +54,8 @@
-   },
-   {
-    "cell_type": "code",
--   "execution_count": 9,
--   "id": "e862b7e2-57f5-44bf-bcf1-a91160ba66cc",
-+   "execution_count": 5,
-+   "id": "4469cddf-4dac-4468-be88-241d440401c3",
-    "metadata": {},
-    "outputs": [
-     {
-@@ -67,35 +67,98 @@
-     }
-    ],
-    "source": [
--    "model = fet.load(\"basic_feedforward.py\",config)"
-+    "model,modelname = fet.load(\"basic_feedforward.py\",config)"
-    ]
-   },
-   {
-    "cell_type": "code",
--   "execution_count": 10,
--   "id": "07e0b160-d5d1-4e54-b4a7-ccaf2224598a",
-+   "execution_count": 13,
-+   "id": "7c9a9fe9-f5e8-456a-b964-4be13027725b",
-    "metadata": {},
-    "outputs": [
-     {
-      "data": {
-       "text/plain": [
--       "PerceptronNN(\n",
--       "  (fc1): Linear(in_features=39, out_features=128, bias=True)\n",
--       "  (fc2): Linear(in_features=128, out_features=64, bias=True)\n",
--       "  (fc3): Linear(in_features=64, out_features=64, bias=True)\n",
--       "  (fc4): Linear(in_features=64, out_features=2, bias=True)\n",
--       ")"
-+       "array([114170,    904])"
-       ]
-      },
--     "execution_count": 10,
-+     "execution_count": 13,
-      "metadata": {},
-      "output_type": "execute_result"
-     }
-    ],
-    "source": [
--    "model"
-+    "np.bincount(loaddat[0]['train'].dataset.all_labels)"
-    ]
-   },
-+  {
-+   "cell_type": "code",
-+   "execution_count": 1,
-+   "id": "e862b7e2-57f5-44bf-bcf1-a91160ba66cc",
-+   "metadata": {},
-+   "outputs": [
-+    {
-+     "ename": "FileNotFoundError",
-+     "evalue": "[Errno 2] Unable to open file (unable to open file: name = './checkpoints/feedforward/2/data_fold1/results_dict.h5', errno = 2, error message = 'No such file or directory', flags = 0, o_flags = 0)",
-+     "output_type": "error",
-+     "traceback": [
-+      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
-+      "\u001b[0;31mFileNotFoundError\u001b[0m                         Traceback (most recent call last)",
-+      "Cell \u001b[0;32mIn[1], line 5\u001b[0m\n\u001b[1;32m      3\u001b[0m file_path \u001b[38;5;241m=\u001b[39m \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124m./checkpoints/feedforward/2/data_fold1/results_dict.h5\u001b[39m\u001b[38;5;124m\"\u001b[39m\n\u001b[1;32m      4\u001b[0m \u001b[38;5;66;03m# Replace 'your_file.h5' with the actual path to your file\u001b[39;00m\n\u001b[0;32m----> 5\u001b[0m f \u001b[38;5;241m=\u001b[39m  \u001b[43mh5py\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mFile\u001b[49m\u001b[43m(\u001b[49m\u001b[43mfile_path\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[38;5;124;43mr\u001b[39;49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[43m)\u001b[49m \n\u001b[1;32m      7\u001b[0m     \u001b[38;5;66;03m# Get information about the data stored in the file\u001b[39;00m\n\u001b[1;32m      8\u001b[0m \u001b[38;5;28mprint\u001b[39m(\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mKeys:\u001b[39m\u001b[38;5;124m\"\u001b[39m, \u001b[38;5;28mlist\u001b[39m(f\u001b[38;5;241m.\u001b[39mkeys()))\n",
-+      "File \u001b[0;32m/Applications/miniconda3/envs/lietransformer/lib/python3.9/site-packages/h5py/_hl/files.py:562\u001b[0m, in \u001b[0;36mFile.__init__\u001b[0;34m(self, name, mode, driver, libver, userblock_size, swmr, rdcc_nslots, rdcc_nbytes, rdcc_w0, track_order, fs_strategy, fs_persist, fs_threshold, fs_page_size, page_buf_size, min_meta_keep, min_raw_keep, locking, alignment_threshold, alignment_interval, meta_block_size, **kwds)\u001b[0m\n\u001b[1;32m    553\u001b[0m     fapl \u001b[38;5;241m=\u001b[39m make_fapl(driver, libver, rdcc_nslots, rdcc_nbytes, rdcc_w0,\n\u001b[1;32m    554\u001b[0m                      locking, page_buf_size, min_meta_keep, min_raw_keep,\n\u001b[1;32m    555\u001b[0m                      alignment_threshold\u001b[38;5;241m=\u001b[39malignment_threshold,\n\u001b[1;32m    556\u001b[0m                      alignment_interval\u001b[38;5;241m=\u001b[39malignment_interval,\n\u001b[1;32m    557\u001b[0m                      meta_block_size\u001b[38;5;241m=\u001b[39mmeta_block_size,\n\u001b[1;32m    558\u001b[0m                      \u001b[38;5;241m*\u001b[39m\u001b[38;5;241m*\u001b[39mkwds)\n\u001b[1;32m    559\u001b[0m     fcpl \u001b[38;5;241m=\u001b[39m make_fcpl(track_order\u001b[38;5;241m=\u001b[39mtrack_order, fs_strategy\u001b[38;5;241m=\u001b[39mfs_strategy,\n\u001b[1;32m    560\u001b[0m                      fs_persist\u001b[38;5;241m=\u001b[39mfs_persist, fs_threshold\u001b[38;5;241m=\u001b[39mfs_threshold,\n\u001b[1;32m    561\u001b[0m                      fs_page_size\u001b[38;5;241m=\u001b[39mfs_page_size)\n\u001b[0;32m--> 562\u001b[0m     fid \u001b[38;5;241m=\u001b[39m \u001b[43mmake_fid\u001b[49m\u001b[43m(\u001b[49m\u001b[43mname\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mmode\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43muserblock_size\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mfapl\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mfcpl\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mswmr\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43mswmr\u001b[49m\u001b[43m)\u001b[49m\n\u001b[1;32m    564\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;28misinstance\u001b[39m(libver, \u001b[38;5;28mtuple\u001b[39m):\n\u001b[1;32m    565\u001b[0m     \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_libver \u001b[38;5;241m=\u001b[39m libver\n",
-+      "File \u001b[0;32m/Applications/miniconda3/envs/lietransformer/lib/python3.9/site-packages/h5py/_hl/files.py:235\u001b[0m, in \u001b[0;36mmake_fid\u001b[0;34m(name, mode, userblock_size, fapl, fcpl, swmr)\u001b[0m\n\u001b[1;32m    233\u001b[0m     \u001b[38;5;28;01mif\u001b[39;00m swmr \u001b[38;5;129;01mand\u001b[39;00m swmr_support:\n\u001b[1;32m    234\u001b[0m         flags \u001b[38;5;241m|\u001b[39m\u001b[38;5;241m=\u001b[39m h5f\u001b[38;5;241m.\u001b[39mACC_SWMR_READ\n\u001b[0;32m--> 235\u001b[0m     fid \u001b[38;5;241m=\u001b[39m \u001b[43mh5f\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mopen\u001b[49m\u001b[43m(\u001b[49m\u001b[43mname\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mflags\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mfapl\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43mfapl\u001b[49m\u001b[43m)\u001b[49m\n\u001b[1;32m    236\u001b[0m \u001b[38;5;28;01melif\u001b[39;00m mode \u001b[38;5;241m==\u001b[39m \u001b[38;5;124m'\u001b[39m\u001b[38;5;124mr+\u001b[39m\u001b[38;5;124m'\u001b[39m:\n\u001b[1;32m    237\u001b[0m     fid \u001b[38;5;241m=\u001b[39m h5f\u001b[38;5;241m.\u001b[39mopen(name, h5f\u001b[38;5;241m.\u001b[39mACC_RDWR, fapl\u001b[38;5;241m=\u001b[39mfapl)\n",
-+      "File \u001b[0;32mh5py/_objects.pyx:54\u001b[0m, in \u001b[0;36mh5py._objects.with_phil.wrapper\u001b[0;34m()\u001b[0m\n",
-+      "File \u001b[0;32mh5py/_objects.pyx:55\u001b[0m, in \u001b[0;36mh5py._objects.with_phil.wrapper\u001b[0;34m()\u001b[0m\n",
-+      "File \u001b[0;32mh5py/h5f.pyx:102\u001b[0m, in \u001b[0;36mh5py.h5f.open\u001b[0;34m()\u001b[0m\n",
-+      "\u001b[0;31mFileNotFoundError\u001b[0m: [Errno 2] Unable to open file (unable to open file: name = './checkpoints/feedforward/2/data_fold1/results_dict.h5', errno = 2, error message = 'No such file or directory', flags = 0, o_flags = 0)"
-+     ]
-+    }
-+   ],
-+   "source": [
-+    "import h5py\n",
-+    "\n",
-+    "file_path = \"./checkpoints/feedforward/2/data_fold1/results_dict.h5\"\n",
-+    "# Replace 'your_file.h5' with the actual path to your file\n",
-+    "f =  h5py.File(file_path, 'r') \n",
-+    "\n",
-+    "    # Get information about the data stored in the file\n",
-+    "print(\"Keys:\", list(f.keys()))  # List the top-level datasets and groups\n",
-+    "\n",
-+    "    # # Access a dataset by its name\n",
-+    "    # dataset_name = \"your_dataset_name\"\n",
-+    "    # if dataset_name in f:\n",
-+    "    #     dataset = f[dataset_name]\n",
-+    "    #     print(\"Dataset shape:\", dataset.shape)\n",
-+    "    #     print(\"Dataset dtype:\", dataset.dtype)\n",
-+    "\n",
-+    "    #     # Access the data as a NumPy array\n",
-+    "    #     data = dataset[:]  # Read the entire dataset\n",
-+    "\n",
-+    "    #     # You can now work with the data as needed, for example:\n",
-+    "    #     # Perform calculations, visualizations, etc.\n",
-+    "    # else:\n",
-+    "    #     print(f\"Dataset '{dataset_name}' not found in the file.\")"
-+   ]
-+  },
-+  {
-+   "cell_type": "code",
-+   "execution_count": 13,
-+   "id": "07e0b160-d5d1-4e54-b4a7-ccaf2224598a",
-+   "metadata": {},
-+   "outputs": [
-+    {
-+     "data": {
-+      "text/plain": [
-+       "<generator object Module.parameters at 0x3007207b0>"
-+      ]
-+     },
-+     "execution_count": 13,
-+     "metadata": {},
-+     "output_type": "execute_result"
-+    }
-+   ],
-+   "source": []
-+  },
-   {
-    "cell_type": "code",
-    "execution_count": null,
-diff --git a/train.py b/train.py
-index c266102..55f58d9 100644
---- a/train.py
-+++ b/train.py
-@@ -1,49 +1,461 @@
- from os import path as osp
-+import os
-+import numpy as np
-+import time
- 
- import torch
-+import torch.nn as nn
- import torch.nn.functional as F
- import torch.optim as optim
--
--import numpy as np
-+from torch.utils.tensorboard import SummaryWriter
- 
- import forge
- from forge import flags
- import forge.experiment_tools as fet
- 
-+from train_tools import (
-+	log_tensorboard,
-+	parse_reports,
-+	parse_reports_cpu,
-+	print_reports,
-+	load_checkpoint,
-+	save_checkpoint,
-+	nested_to,
-+	param_count,
-+)
-+
-+from copy import deepcopy
-+from attrdict import AttrDict
-+import deepdish as dd
-+from tqdm import tqdm
-+
-+# For reproducibility while researching, but might affect speed!
-+torch.backends.cudnn.deterministic = True
-+torch.backends.cudnn.benchmark = False
-+torch.manual_seed(0)
-+
- 
- # Job config
- flags.DEFINE_string('data_config', 'penn_dataset.py',
--                    'Path to a data config file.')
-+					'Path to a data config file.')
- flags.DEFINE_string('model_config', 'basic_feedforward.py',
--                    'Path to a model config file.')
-+					'Path to a model config file.')
- flags.DEFINE_string('results_dir', 'checkpoints',
--                    'Top directory for all experimental results.')
--flags.DEFINE_string('run_name', 'feedforward',
--                    'Name of this job and name of results folder.')
-+					'Top directory for all experimental results.')
-+flags.DEFINE_string('model_name', 'gpt-FCNN',
-+					'shorthand name for model.')
-+flags.DEFINE_string('run_name', 'hyperparam_testing',
-+					'Name of this job and name of results folder.')
- flags.DEFINE_boolean('resume', False, 'Tries to resume a job if True.')
- 
- # Logging config
- flags.DEFINE_integer('report_loss_every', 50,
--                     'Number of iterations between reporting minibatch loss.')
--flags.DEFINE_integer('train_epochs', 20, 'Maximum number of training epochs.')
-+					 'Number of iterations between reporting minibatch loss.')
-+flags.DEFINE_integer('train_epochs', 50, 'Maximum number of training epochs.')
-+flags.DEFINE_integer(
-+	"save_check_points",
-+	10,
-+	"frequency with which to save checkpoints, in number of epoches.",
-+)
-+flags.DEFINE_boolean("log_train_values", True, "Logs train values if True.")
-+flags.DEFINE_integer(
-+	"total_evaluations",
-+	100,
-+	"Maximum number of evaluations on test and validation data during training.",
-+)
-+flags.DEFINE_boolean(
-+	"save_test_predictions",
-+	False,
-+	"Makes and saves test predictions on one or more test sets (e.g. 5-step and 100-step predictions) at the end of training.",
-+)
-+flags.DEFINE_boolean(
-+    "log_val_test", True, "Turns off computation of validation and test errors."
-+)
-+
-+flags.DEFINE_boolean('use_mps',False,"Use Metal Performance Shaders (M1) for training.")
- 
- # Experiment config
- flags.DEFINE_integer('batch_size', 100, 'Mini-batch size.')
--flags.DEFINE_float('learning_rate', 1e-5, 'SGD learning rate.')
-+flags.DEFINE_float("learning_rate", 1e-4, "Adam learning rate.")
-+flags.DEFINE_float("beta1", 0.9, "Adam Beta 1 parameter")
-+flags.DEFINE_float("beta2", 0.999, "Adam Beta 2 parameter")
- 
- # Specific config options
- flags.DEFINE_integer("input_size",39,"Input shape to model")
- 
-+#########################################################################################
-+
-+def evaluate(model, loader, device,fold = 0,headings = [],loss_func = nn.CrossEntropyLoss()):
-+	# this function does not account for class weights when evaluating cross-entropy loss.
-+	# however, they are accounted for when evaluating training loss
-+	reports = None
-+	for data in loader:
-+		labels = data['label']
-+		inputs = nested_to(data['data'],device,torch.float32)
-+		
-+		labels_tensor = torch.zeros((len(labels), 2))
-+		for i, label in enumerate(labels):
-+			labels_tensor[i, label] = 1
-+
-+		model_output = model(inputs) # evaluate model
-+
-+		loss = loss_func(model_output, labels_tensor) # compute loss
-+		outputs = AttrDict({"loss": loss, "prediction": model_output,'data_fold':fold})
-+		outputs.reports = AttrDict({"cross_entropy": loss})
-+
-+		if reports is None:
-+			reports = {k: v.detach().clone().cpu() for k, v in outputs.reports.items()}
-+		else:
-+			for k, v in outputs.reports.items():
-+				reports[k] += v.detach().clone().cpu()
-+
-+	for k, v in reports.items():
-+		reports[k] = v / len(
-+			loader
-+		)  # SZ: note this can be slightly incorrect if mini-batch sizes vary (if batch_size doesn't divide train_size), but approximately correct.
-+
-+	# reports['test_headings'] = np.array(headings)
-+
-+	return reports
-+
-+def main():
-+
-+	config = forge.config()
-+
-+	# Set device
-+	if torch.cuda.is_available():
-+		device = f"cuda:{config.device}"
-+		torch.cuda.set_device(device)
-+	else:
-+		device = "cpu" # can change this to MPS on M1 Macs
-+
-+	if config.use_mps:
-+		device = "mps"
-+
-+	# Load data
-+	data_name = "penn_data"
-+	kfold_loaders = fet.load(config.data_config, config)
-+
-+	# Prepare environment
-+	params_in_run_name = [
-+		("batch_size", "bs"),
-+		("learning_rate", "lr"),
-+		("n_train", "ntrain"),
-+		("include_coords",'inclx'),
-+		("input_size",'inpsize'),
-+		("cross_validate",'crval'),
-+		("train_epochs",'n_epochs'),
-+	]
-+
-+	run_name = ""  # config.run_name
-+	for config_param in params_in_run_name:
-+		attr = config_param[0]
-+		abbrev = config_param[1]
-+
-+		if hasattr(config, attr):
-+			run_name += abbrev
-+			run_name += str(getattr(config, attr))
-+			run_name += "_"
-+
-+	results_folder_name = osp.join(
-+		data_name,
-+		config.model_name,
-+		config.run_name,
-+		run_name,
-+	)
-+
-+	# Prepare environment
-+	logdir = osp.join(config.results_dir, results_folder_name.replace(".", "_"))
-+	logdir, resume_checkpoint = fet.init_checkpoint(
-+		logdir, config.data_config, config.model_config, config.resume)
-+
-+	print("Checkpoint directory:",logdir)
-+
-+	# Print flags
-+	fet.print_flags()
-+
-+	n_folds = len(kfold_loaders)
-+	print("Doing {}-fold cross-validation.".format(n_folds))
-+
-+	# KFOLD TRAINING LOOP
-+	for k,loader_k in enumerate(kfold_loaders): # loop over data splits
-+
-+		print("Training fold {}...".format(k+1))
-+
-+		# Load model
-+		model,model_name = fet.load(config.model_config, config)
-+		model = model.to(device)
-+
-+		# Print model info
-+		print(model)
-+
-+		# Setup optimizer
-+		model_params = model.parameters()
-+		opt_learning_rate = config.learning_rate
-+		model_opt = torch.optim.Adam(
-+			model_params, lr=opt_learning_rate, betas=(config.beta1, config.beta2)
-+		)
-+		scheduler = torch.optim.lr_scheduler.StepLR(model_opt, step_size=10, gamma=0.5)
-+		print("Model Optimizer:")
-+		print(model_opt)
-+
-+		# Try to restore model and optimizer from checkpoint
-+		if resume_checkpoint is not None:
-+			start_epoch = load_checkpoint(resume_checkpoint, model, model_opt)
-+		else:
-+			start_epoch = 1
-+
-+		# load the training data
-+		train_loader = loader_k["train"]
-+		n_train = len(train_loader.dataset)
-+		train_batch_size = train_loader.batch_size
-+
-+		# load testing, validation
-+		test_loader = loader_k["test"]
-+		n_test = len(test_loader.dataset)
-+		val_loader = loader_k["val"]
-+		n_val = len(val_loader.dataset)
-+
-+		train_class_counts = np.bincount(train_loader.dataset.all_labels)
-+		train_total_counts = sum(train_class_counts)
-+		class_weight = torch.tensor(1.0 / train_class_counts) * train_total_counts / 2.0
-+
-+		loss_func = nn.CrossEntropyLoss(weight = class_weight) # define reweighted loss function
-+				
-+		# create folder for this data split
-+		fold_dir = osp.join(logdir,"data_fold{}".format(k+1))
-+		fold_dir_exists = osp.exists(fold_dir)
-+		if not fold_dir_exists:
-+			if config.resume:
-+				raise ValueError("Can't resume when the checkpoint/fold dir '{}' doesn't exist.".format(fold_dir))
-+			else:
-+				os.makedirs(fold_dir)
-+		checkpoint_name = osp.join(fold_dir, 'model_fold{}.ckpt'.format(k+1))
-+
-+		# keep track of which data is test data for a given Kfold data split
-+		test_headings = loader_k['test_headings']
-+		headingsFile = osp.join(fold_dir,"test_headings.txt")
-+		with open(headingsFile,'w') as headfile:
-+			for heading in test_headings:
-+				headfile.write(heading+'\n')
-+
-+		# print(checkpoint_name)
-+
-+		train_iter = (start_epoch - 1) * (
-+		len(train_loader.dataset) // train_batch_size
-+		) + 1
-+
-+		print("Starting training at epoch = {}, iter = {}".format(start_epoch, train_iter))
-+
-+		# Setup tensorboard writing
-+		summary_writer = SummaryWriter(logdir)
-+
-+		train_reports = []
-+		report_all = {}
-+		report_all_val = {}
-+
-+		# Saving model at epoch 0 before training
-+		print("saving model at epoch 0 before training ... ")
-+		save_checkpoint(checkpoint_name, 0, model, model_opt, loss=0.0)
-+		print("finished saving model at epoch 0 before training")
-+
-+		num_params = param_count(model)
-+		print(f"Number of model parameters: {num_params}")
-+
-+		# Training
-+		start_t = time.time()
-+
-+		total_train_iters = len(train_loader) * config.train_epochs
-+		iters_per_eval = max(1, int(total_train_iters / config.total_evaluations))
-+		# print('batch',train_batch_size)
-+		# print('ntrain',n_train)
-+		# assert (
-+		# 	n_train % min(train_batch_size, n_train) == 0
-+		# ), "Batch size doesn't divide dataset size. Can be inaccurate for loss computation (see below)."
-+
-+		training_failed = False
-+		best_val_loss_so_far = 1e7
-+
-+		for epoch in tqdm(range(start_epoch, config.train_epochs + 1)):
-+			model.train()
-+
-+			for batch_idx, data_dict in enumerate(train_loader): # Loop over batched data
-+
-+				labels = data_dict['label']
-+				data = data_dict['data']
-+
-+				# send data to device
-+				data = nested_to(data,device,torch.float32)
-+				# One-hot encode the data labels
-+				labels_tensor = torch.zeros((len(labels), 2))
-+				for i, label in enumerate(labels):
-+					labels_tensor[i, label] = 1
-+
-+				model_output = model(data) # evaluate model
-+
-+				loss = loss_func(model_output, labels_tensor) # compute loss
-+				outputs = AttrDict({"loss": loss, "prediction": model_output})
-+				outputs.reports = AttrDict({"cross_entropy": loss})
-+
-+				if torch.isnan(outputs.loss): # check for failure in training
-+					if not training_failed:
-+						epoch_of_nan = epoch
-+					if (epoch > epoch_of_nan + 1) and training_failed:
-+						raise ValueError("Loss Nan-ed.")
-+					training_failed = True
-+
-+				model_opt.zero_grad()
-+				outputs.loss.backward(retain_graph=False)
-+
-+				model_opt.step() # move optimizer forward
-+
-+				train_reports.append(parse_reports_cpu(outputs.reports))
-+
-+				if config.log_train_values:
-+					reports = parse_reports(outputs.reports)
-+					if batch_idx % config.report_loss_every == 0:
-+						log_tensorboard(summary_writer, train_iter, reports, "train/")
-+						print_reports(
-+							reports,
-+							start_t,
-+							epoch,
-+							batch_idx,
-+							len(train_loader.dataset) // train_batch_size,
-+							prefix="train",
-+						)
-+						log_tensorboard(
-+							summary_writer,
-+							train_iter,
-+							{"lr": model_opt.param_groups[0]["lr"]},
-+							"hyperparams/",
-+						)
-+				# Logging and evaluation
-+				if (
-+					train_iter % iters_per_eval == 0 or (train_iter == total_train_iters)
-+				) and config.log_val_test:  # batch_idx % config.evaluate_every == 0:
-+					model.eval()
-+					with torch.no_grad():
-+						reports = evaluate(model, test_loader, device,fold = k,headings = loader_k['test_headings'])
-+						# print("REPORTS",reports)
-+						reports = parse_reports(reports)
-+						reports["time"] = time.time() - start_t
-+						if report_all == {}:
-+							report_all = deepcopy(reports)
-+
-+							for d in reports.keys():
-+								report_all[d] = [report_all[d]]
-+						else:
-+							for d in reports.keys():
-+								report_all[d].append(reports[d])
-+
-+						log_tensorboard(summary_writer, train_iter, reports, "test/")
-+						print_reports(
-+							reports,
-+							start_t,
-+							epoch,
-+							batch_idx,
-+							len(train_loader.dataset) // config.batch_size,
-+							prefix="test",
-+						)
-+
-+						# repeat for validation data
-+						reports = evaluate(model, val_loader, device,fold = k,headings = loader_k['test_headings'])
-+						reports = parse_reports(reports)
-+						reports["time"] = time.time() - start_t
-+						if report_all_val == {}:
-+							report_all_val = deepcopy(reports)
-+
-+							for d in reports.keys():
-+								report_all_val[d] = [report_all_val[d]]
-+						else:
-+							for d in reports.keys():
-+								report_all_val[d].append(reports[d])
-+
-+						log_tensorboard(summary_writer, train_iter, reports, "val/")
-+						print_reports(
-+							reports,
-+							start_t,
-+							epoch,
-+							batch_idx,
-+							len(train_loader.dataset) // config.batch_size,
-+							prefix="val",
-+						)
-+
-+						if report_all_val["cross_entropy"][-1] < best_val_loss_so_far:
-+							save_checkpoint(
-+								checkpoint_name,
-+								f"early_stop",
-+								model,
-+								model_opt,
-+								loss=outputs.loss,
-+							)
-+							best_val_loss_so_far = report_all_val["cross_entropy"][-1]
-+
-+					model.train()
-+
-+				train_iter += 1
-+
-+			scheduler.step()
-+
-+			if epoch % config.save_check_points == 0:
-+				save_checkpoint(
-+					checkpoint_name, train_iter, model, model_opt, loss=outputs.loss
-+				)
-+		
-+		dd.io.save(fold_dir + "/results_dict_train.h5", train_reports)
-+		dd.io.save(fold_dir + "/results_dict.h5", report_all)
-+		dd.io.save(fold_dir + "/results_dict_val.h5", report_all_val)
-+
-+	# always save final model
-+	save_checkpoint(checkpoint_name, train_iter, model, model_opt, loss=outputs.loss)
-+
-+	
-+	if config.save_test_predictions:
-+		pass
-+		# print("Starting to make model predictions on test sets for *final model*.")
-+		# for chunk_len in [5, 100]:
-+		#     start_t_preds = time.time()
-+		#     data_config = SimpleNamespace(
-+		#         **{
-+		#             **config.__dict__["__flags"],
-+		#             **{"chunk_len": chunk_len, "batch_size": 500},
-+		#         }
-+		#     )
-+		#     dataloaders, data_name = fet.load(config.data_config, config=data_config)
-+		#     test_loader_preds = dataloaders["test"]
-+
-+		#     torch.cuda.empty_cache()
-+		#     with torch.no_grad():
-+		#         preds = []
-+		#         true = []
-+		#         num_datapoints = 0
-+		#         for idx, d in enumerate(test_loader_preds):
-+		#             true.append(d[-1])
-+		#             d = nested_to(d, device, torch.float32)
-+		#             outputs = model(d)
-+
-+		#             pred_zs = outputs.prediction
-+		#             preds.append(pred_zs)
-+
-+		#             num_datapoints += len(pred_zs)
-+
-+		#             if num_datapoints >= 2000:
-+		#                 break
- 
--config = forge.config()
-+		#         preds = torch.cat(preds, dim=0).cpu()
-+		#         true = torch.cat(true, dim=0).cpu()
- 
--# Prepare environment
--logdir = osp.join(config.results_dir, config.run_name)
--logdir, resume_checkpoint = fet.init_checkpoint(
--    logdir, config.data_config, config.model_config, config.resume)
--checkpoint_name = osp.join(logdir, 'model.ckpt')
-+		#         save_dir = osp.join(logdir, f"traj_preds_{chunk_len}_steps_2k_test.pt")
-+		#         torch.save(preds, save_dir)
- 
-+		#         save_dir = osp.join(logdir, f"traj_true_{chunk_len}_steps_2k_test.pt")
-+		#         torch.save(true, save_dir)
- 
--print(logdir)
-+		#         print(
-+		#             f"Completed making test predictions for chunk_len = {chunk_len} in {time.time() - start_t_preds:.2f} seconds."
-+		#         )	
-+		
- 
-+if __name__ == "__main__":
-+	main()
- 
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/2/penn_dataset.py b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/2/penn_dataset.py
deleted file mode 100644
index 46c8e52..0000000
--- a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/2/penn_dataset.py
+++ /dev/null
@@ -1,137 +0,0 @@
-import os
-import torch
-import pandas as pd
-import numpy as np
-
-from torchvision import datasets, transforms
-from torch.utils.data import Dataset, DataLoader
-from sklearn.model_selection import RepeatedKFold
-
-from os import path as osp
-import forge
-from forge import flags
-
-
-# aspects of data managmement
-flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
-flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-flags.DEFINE_boolean("cross_validate",True,"Do K-fold cross-validation")
-
-# Job management
-# flags.DEFINE_integer("batch size",5,"training batch size")
-flags.DEFINE_float("train_split",0.8,'Fraction of data to use for training.')
-flags.DEFINE_integer("n_repeats",1,"Times to repeat K-fold cross-validation")
-flags.DEFINE_integer("split_seed",1,"Seed for KFold split (integer for reproducibility")
-
-# "wavelengths between 0.05 and 1 mm in 0.025 mm increments."
-LSPACE = np.arange(0.05,1.05,0.025) # corresponds to 39 non-coord columns of data
-L_INDS = None
-
-DATAFOLDER = './penn_data'
-
-HEADINGS = np.array(['aaa0043','aaa0044','aaa0060','aaa0061','aaa0063','aaa0064','aaa0066','aaa0069','aaa0086','aaa0087','aaa_0051','aaa_0053','aaa_0054','aaa_0059','aaa_0071','aaa_0072'])
-
-
-class PennData(Dataset):
-
-    def __init__(self,path_to_data,headings,k_inds = None,include_coords = True,rescale = True,spectra_prefix = "kvals_fuse_rotate_",label_prefix = 'labels_fuse_rotate_'):
-        
-        self.data_dir = path_to_data
-        self.headings = headings
-
-        df_list = []
-        label_list = []
-        for heading in self.headings: # for each datafile heading,
-            data_name = osp.join(self.data_dir,spectra_prefix + heading+'.csv') # read kvals
-            df_temp = pd.read_csv(data_name,header=None)
-            df_list.append(df_temp)
-
-            label_name = osp.join(self.data_dir,label_prefix + heading + '.csv') # read labels
-            label_temp = pd.read_csv(label_name,header=None, names=['label'])
-            label_list.append(label_temp)
-
-        df = pd.concat(df_list, ignore_index=True)
-
-        labels = pd.concat(label_list, ignore_index=True)
-        df = pd.concat([labels, df], axis="columns") # Append labels to data
-
-        all_labels = df['label'].to_numpy()
-        all_data = df.iloc[:,1:].to_numpy()
-
-        if rescale: # rescale (normalize) wavelength intensity data
-            lambdas = all_data[:,2:] # wavelengths
-            lam_std = np.std(lambdas, axis=0)  # Calculate standard deviation along columns
-            lam_mean = np.mean(lambdas, axis=0)  # Calculate mean along columns
-            lambdas_rescaled = (lambdas - lam_mean) / lam_std 
-            all_data[:,2:] = lambdas_rescaled
-
-        if not include_coords: # removes x,y coordinates from data
-            all_data = all_data[:,2:]
-        
-        if k_inds != None: # in this case, only use subset of wavelengths
-            all_data = all_data[:,np.array(k_inds)]
-
-        self.all_data = all_data
-        self.all_labels = all_labels
-
-    def __len__(self):
-        return len(self.all_data)
-
-    def __getitem__(self,i):
-        state = {'label':self.all_labels[i],'data':self.all_data[i]}
-        return state
-
-    def __getstate__(self):
-        state = {
-            'data': self.all_data,
-            'label': self.all_labels,
-                }
-        return state
-
-    def __setstate__(self, state):
-        # Set the object's state from the provided dictionary
-        self.all_data = state['data']
-        self.all_labels = state['label']
-        
-
-
-def load(config):
-
-    n_splits = int(len(HEADINGS)/((1-config.train_split)*len(HEADINGS)))
-
-    kf = RepeatedKFold(n_splits = n_splits, n_repeats = config.n_repeats, random_state = config.split_seed) # K-fold cross validation
-
-    kf_dataloaders = []
-
-    for i, (train_ind, test_ind) in enumerate(kf.split(HEADINGS)): # for each K-fold split, 
-        n_val = len(test_ind)//2
-        n_test = len(test_ind)-n_val   
-        n_train = len(train_ind)
-        
-        # set up training DataLoader
-        train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
-
-        # set up test DataLoader
-        test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
-
-        # set up val DataLoader
-        val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-        
-
-        dataloaders = {'train':train_loader, 
-                       'test':test_loader,
-                       'val':val_loader,
-                       'train_inds':train_ind,
-                       'test_inds':test_ind,
-                       'n_val':n_val,
-                       'test_headings':list(HEADINGS[test_ind])
-                      }
-        kf_dataloaders.append(dataloaders)
-
-        if not config.cross_validate:
-        	break
-
-    return kf_dataloaders
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/__pycache__/basic_feedforward.cpython-39.pyc b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/__pycache__/basic_feedforward.cpython-39.pyc
deleted file mode 100644
index a739604..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/__pycache__/basic_feedforward.cpython-39.pyc and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/__pycache__/penn_dataset.cpython-39.pyc b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/__pycache__/penn_dataset.cpython-39.pyc
deleted file mode 100644
index cff8a12..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/__pycache__/penn_dataset.cpython-39.pyc and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/basic_feedforward.py b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/basic_feedforward.py
deleted file mode 100644
index 0cbf8bd..0000000
--- a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/basic_feedforward.py
+++ /dev/null
@@ -1,73 +0,0 @@
-import torch
-import torch.nn as nn
-import torch.nn.functional as F
-import numpy as np
-
-from forge import flags
-
-# flags.DEFINE_boolean(
-#     "model_with_dict",
-#     True,
-#     "Makes model output predictions in dictionary instead of directly."
-# )
-
-class PerceptronNN(nn.Module):
-    def __init__(self, input_size, num_labels):
-        super(PerceptronNN, self).__init__()
-        # Define the layers
-        self.fc1 = nn.Linear(input_size, 128)  # First dense layer
-        self.fc2 = nn.Linear(128, 64)         # Second dense layer
-        # self.fc23 = nn.Linear(64,64)
-        self.fc3 = nn.Linear(64, 64)          # Third dense layer
-        self.fc4 = nn.Linear(64, num_labels)  # Output layer
-        # self.softmax = nn.Softmax(dim=1)
-
-    def forward(self, x):
-        # Forward pass through the network
-        x = F.relu(self.fc1(x))  # Activation function between layers
-        x = F.relu(self.fc2(x))
-        # x = F.relu(self.fc23(x))
-        x = F.relu(self.fc3(x))
-        x = self.fc4(x)  # No activation, this will be included in the loss function
-        # x = self.softmax(x)
-        return x
-
-class GPT_PNN(nn.Module):
-    def __init__(self, input_size, num_labels):
-        super(GPT_PNN, self).__init__()
-        # Define the layers
-        self.fc1 = nn.Linear(input_size, 64)  # First dense layer, reduced size
-        self.bn1 = nn.BatchNorm1d(64)  # Batch Normalization for the first layer
-        self.dropout1 = nn.Dropout(0.5)  # Dropout with 50% probability
-        
-        # Commenting out to reduce model complexity
-        # self.fc2 = nn.Linear(128, 64)  # Second dense layer
-        # self.dropout2 = nn.Dropout(0.5)  # Additional dropout layer
-        
-        # Simplified to have fewer layers and neurons
-        self.fc2 = nn.Linear(64, 32)  # Reduced size for second dense layer
-        self.bn2 = nn.BatchNorm1d(32)  # Batch Normalization for the second layer
-        self.dropout2 = nn.Dropout(0.5)  # Dropout with 50% probability
-
-        # Output layer remains the same, adjusted for reduced prior layer size
-        self.fc3 = nn.Linear(32, num_labels)  # Output layer
-
-    def forward(self, x):
-        # Forward pass through the network with activations, batch normalization, and dropout
-        x = F.relu(self.bn1(self.fc1(x)))
-        x = self.dropout1(x)
-        x = F.relu(self.bn2(self.fc2(x)))
-        x = self.dropout2(x)
-        x = self.fc3(x)  # No activation here, use sigmoid or softmax outside if needed for binary classification
-        return x
-
-def load(config):
-
-    # n_channels = 1
-    n_features = config.input_size
-    
-    # mlp = PerceptronNN(n_features,2)
-
-    mlp = GPT_PNN(n_features,2)
-    
-    return mlp, "gpt_feedforward"
\ No newline at end of file
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold1/model_fold1.ckpt-0 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold1/model_fold1.ckpt-0
deleted file mode 100644
index ae76794..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold1/model_fold1.ckpt-0 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold1/model_fold1.ckpt-57551 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold1/model_fold1.ckpt-57551
deleted file mode 100644
index f8e676e..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold1/model_fold1.ckpt-57551 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold1/model_fold1.ckpt-early_stop b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold1/model_fold1.ckpt-early_stop
deleted file mode 100644
index 42508a0..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold1/model_fold1.ckpt-early_stop and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold1/results_dict.h5 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold1/results_dict.h5
deleted file mode 100644
index d037340..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold1/results_dict.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold1/results_dict_train.h5 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold1/results_dict_train.h5
deleted file mode 100644
index 6c8da46..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold1/results_dict_train.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold1/results_dict_val.h5 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold1/results_dict_val.h5
deleted file mode 100644
index 15e792f..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold1/results_dict_val.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold1/test_headings.txt b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold1/test_headings.txt
deleted file mode 100644
index 05c4825..0000000
--- a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold1/test_headings.txt
+++ /dev/null
@@ -1,4 +0,0 @@
-aaa0060
-aaa0061
-aaa0069
-aaa_0059
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold2/model_fold2.ckpt-0 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold2/model_fold2.ckpt-0
deleted file mode 100644
index 76751da..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold2/model_fold2.ckpt-0 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold2/model_fold2.ckpt-60651 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold2/model_fold2.ckpt-60651
deleted file mode 100644
index 35a1085..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold2/model_fold2.ckpt-60651 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold2/model_fold2.ckpt-early_stop b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold2/model_fold2.ckpt-early_stop
deleted file mode 100644
index 6f45ca9..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold2/model_fold2.ckpt-early_stop and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold2/results_dict.h5 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold2/results_dict.h5
deleted file mode 100644
index ac2d2f5..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold2/results_dict.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold2/results_dict_train.h5 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold2/results_dict_train.h5
deleted file mode 100644
index 6ac9ddd..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold2/results_dict_train.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold2/results_dict_val.h5 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold2/results_dict_val.h5
deleted file mode 100644
index 4260b9e..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold2/results_dict_val.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold2/test_headings.txt b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold2/test_headings.txt
deleted file mode 100644
index b87ab5e..0000000
--- a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold2/test_headings.txt
+++ /dev/null
@@ -1,3 +0,0 @@
-aaa0063
-aaa0066
-aaa_0051
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold3/model_fold3.ckpt-0 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold3/model_fold3.ckpt-0
deleted file mode 100644
index 7cfbb66..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold3/model_fold3.ckpt-0 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold3/model_fold3.ckpt-63751 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold3/model_fold3.ckpt-63751
deleted file mode 100644
index 89f8c09..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold3/model_fold3.ckpt-63751 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold3/model_fold3.ckpt-early_stop b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold3/model_fold3.ckpt-early_stop
deleted file mode 100644
index d99a3c0..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold3/model_fold3.ckpt-early_stop and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold3/results_dict.h5 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold3/results_dict.h5
deleted file mode 100644
index d06bbae..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold3/results_dict.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold3/results_dict_train.h5 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold3/results_dict_train.h5
deleted file mode 100644
index 6ca5aca..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold3/results_dict_train.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold3/results_dict_val.h5 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold3/results_dict_val.h5
deleted file mode 100644
index bd0e6d2..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold3/results_dict_val.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold3/test_headings.txt b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold3/test_headings.txt
deleted file mode 100644
index 8417193..0000000
--- a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold3/test_headings.txt
+++ /dev/null
@@ -1,3 +0,0 @@
-aaa0043
-aaa0044
-aaa_0071
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold4/model_fold4.ckpt-0 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold4/model_fold4.ckpt-0
deleted file mode 100644
index 53e2d53..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold4/model_fold4.ckpt-0 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold4/model_fold4.ckpt-63601 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold4/model_fold4.ckpt-63601
deleted file mode 100644
index 8645643..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold4/model_fold4.ckpt-63601 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold4/model_fold4.ckpt-early_stop b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold4/model_fold4.ckpt-early_stop
deleted file mode 100644
index 339e6eb..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold4/model_fold4.ckpt-early_stop and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold4/results_dict.h5 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold4/results_dict.h5
deleted file mode 100644
index 683ffe4..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold4/results_dict.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold4/results_dict_train.h5 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold4/results_dict_train.h5
deleted file mode 100644
index 17da4b8..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold4/results_dict_train.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold4/results_dict_val.h5 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold4/results_dict_val.h5
deleted file mode 100644
index 222c0c9..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold4/results_dict_val.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold4/test_headings.txt b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold4/test_headings.txt
deleted file mode 100644
index ad5063c..0000000
--- a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold4/test_headings.txt
+++ /dev/null
@@ -1,3 +0,0 @@
-aaa0086
-aaa0087
-aaa_0072
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold5/model_fold5.ckpt-0 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold5/model_fold5.ckpt-0
deleted file mode 100644
index a5eac18..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold5/model_fold5.ckpt-0 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold5/model_fold5.ckpt-61201 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold5/model_fold5.ckpt-61201
deleted file mode 100644
index 35b450e..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold5/model_fold5.ckpt-61201 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold5/model_fold5.ckpt-early_stop b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold5/model_fold5.ckpt-early_stop
deleted file mode 100644
index 12aab23..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold5/model_fold5.ckpt-early_stop and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold5/results_dict.h5 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold5/results_dict.h5
deleted file mode 100644
index 0cf1759..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold5/results_dict.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold5/results_dict_train.h5 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold5/results_dict_train.h5
deleted file mode 100644
index 96ad1a8..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold5/results_dict_train.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold5/results_dict_val.h5 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold5/results_dict_val.h5
deleted file mode 100644
index c7c745a..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold5/results_dict_val.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold5/test_headings.txt b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold5/test_headings.txt
deleted file mode 100644
index a4e6319..0000000
--- a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/data_fold5/test_headings.txt
+++ /dev/null
@@ -1,3 +0,0 @@
-aaa0064
-aaa_0053
-aaa_0054
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/events.out.tfevents.1709688478.MacBook-Pro-4.local.3657.0 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/events.out.tfevents.1709688478.MacBook-Pro-4.local.3657.0
deleted file mode 100644
index e543f98..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/events.out.tfevents.1709688478.MacBook-Pro-4.local.3657.0 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/events.out.tfevents.1709688612.MacBook-Pro-4.local.3657.1 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/events.out.tfevents.1709688612.MacBook-Pro-4.local.3657.1
deleted file mode 100644
index 7d5e36a..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/events.out.tfevents.1709688612.MacBook-Pro-4.local.3657.1 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/events.out.tfevents.1709688746.MacBook-Pro-4.local.3657.2 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/events.out.tfevents.1709688746.MacBook-Pro-4.local.3657.2
deleted file mode 100644
index 6017972..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/events.out.tfevents.1709688746.MacBook-Pro-4.local.3657.2 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/events.out.tfevents.1709689208.MacBook-Pro-4.local.3657.3 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/events.out.tfevents.1709689208.MacBook-Pro-4.local.3657.3
deleted file mode 100644
index 8bee476..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/events.out.tfevents.1709689208.MacBook-Pro-4.local.3657.3 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/events.out.tfevents.1709689359.MacBook-Pro-4.local.3657.4 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/events.out.tfevents.1709689359.MacBook-Pro-4.local.3657.4
deleted file mode 100644
index 4590a78..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/events.out.tfevents.1709689359.MacBook-Pro-4.local.3657.4 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/flags.json b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/flags.json
deleted file mode 100644
index 0e7ba1c..0000000
--- a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/flags.json
+++ /dev/null
@@ -1,28 +0,0 @@
-{
-    "batch_size": 100,
-    "beta1": 0.9,
-    "beta2": 0.999,
-    "cross_validate": true,
-    "data_config": "penn_dataset.py",
-    "git_commit": "7416bf730b356aabfe0df644240e40948a8196bb",
-    "include_coords": false,
-    "input_size": 39,
-    "learning_rate": 0.0001,
-    "log_train_values": true,
-    "log_val_test": true,
-    "model_config": "basic_feedforward.py",
-    "model_name": "gpt-FCNN",
-    "n_repeats": 1,
-    "report_loss_every": 50,
-    "rescale": true,
-    "results_dir": "checkpoints",
-    "resume": false,
-    "run_name": "hyperparam_testing",
-    "save_check_points": 50,
-    "save_test_predictions": false,
-    "split_seed": 1,
-    "total_evaluations": 100,
-    "train_epochs": 50,
-    "train_split": 0.8,
-    "use_mps": false
-}
\ No newline at end of file
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/git_diff.txt b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/git_diff.txt
deleted file mode 100644
index 209d7e0..0000000
--- a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/git_diff.txt
+++ /dev/null
@@ -1,1812 +0,0 @@
-Tue Mar 5 17:27:58 PST 2024
-diff --git a/.DS_Store b/.DS_Store
-index e2836a8..bf7630a 100644
-Binary files a/.DS_Store and b/.DS_Store differ
-diff --git a/.ipynb_checkpoints/basic_feedforward-checkpoint.py b/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-index 688c282..0c4bcd1 100644
---- a/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-+++ b/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-@@ -5,6 +5,12 @@ import numpy as np
- 
- from forge import flags
- 
-+flags.DEFINE_boolean(
-+    "model_with_dict",
-+    True,
-+    "Makes model output predictions in dictionary instead of directly."
-+)
-+
- class PerceptronNN(nn.Module):
-     def __init__(self, input_size, num_labels):
-         super(PerceptronNN, self).__init__()
-@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-+        self.softmax = nn.Softmax(dim=1)
- 
-     def forward(self, x):
-         # Forward pass through the network
-@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-         x = F.relu(self.fc2(x))
-         x = F.relu(self.fc3(x))
-         x = self.fc4(x)  # No activation, this will be included in the loss function
-+        x = self.softmax(x)
-         return x
- 
- def load(config):
-@@ -29,4 +37,4 @@ def load(config):
-     
-     mlp = PerceptronNN(n_features,2)
-     
--    return mlp
-\ No newline at end of file
-+    return mlp, "feedforward"
-\ No newline at end of file
-diff --git a/__pycache__/basic_feedforward.cpython-39.pyc b/__pycache__/basic_feedforward.cpython-39.pyc
-index f541140..66fb4f4 100644
-Binary files a/__pycache__/basic_feedforward.cpython-39.pyc and b/__pycache__/basic_feedforward.cpython-39.pyc differ
-diff --git a/__pycache__/penn_dataset.cpython-39.pyc b/__pycache__/penn_dataset.cpython-39.pyc
-index 0d7a4de..ecb5bc2 100644
-Binary files a/__pycache__/penn_dataset.cpython-39.pyc and b/__pycache__/penn_dataset.cpython-39.pyc differ
-diff --git a/basic_feedforward.py b/basic_feedforward.py
-index 688c282..0cbf8bd 100644
---- a/basic_feedforward.py
-+++ b/basic_feedforward.py
-@@ -5,21 +5,60 @@ import numpy as np
- 
- from forge import flags
- 
-+# flags.DEFINE_boolean(
-+#     "model_with_dict",
-+#     True,
-+#     "Makes model output predictions in dictionary instead of directly."
-+# )
-+
- class PerceptronNN(nn.Module):
-     def __init__(self, input_size, num_labels):
-         super(PerceptronNN, self).__init__()
-         # Define the layers
-         self.fc1 = nn.Linear(input_size, 128)  # First dense layer
-         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-+        # self.fc23 = nn.Linear(64,64)
-         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-+        # self.softmax = nn.Softmax(dim=1)
- 
-     def forward(self, x):
-         # Forward pass through the network
-         x = F.relu(self.fc1(x))  # Activation function between layers
-         x = F.relu(self.fc2(x))
-+        # x = F.relu(self.fc23(x))
-         x = F.relu(self.fc3(x))
-         x = self.fc4(x)  # No activation, this will be included in the loss function
-+        # x = self.softmax(x)
-+        return x
-+
-+class GPT_PNN(nn.Module):
-+    def __init__(self, input_size, num_labels):
-+        super(GPT_PNN, self).__init__()
-+        # Define the layers
-+        self.fc1 = nn.Linear(input_size, 64)  # First dense layer, reduced size
-+        self.bn1 = nn.BatchNorm1d(64)  # Batch Normalization for the first layer
-+        self.dropout1 = nn.Dropout(0.5)  # Dropout with 50% probability
-+        
-+        # Commenting out to reduce model complexity
-+        # self.fc2 = nn.Linear(128, 64)  # Second dense layer
-+        # self.dropout2 = nn.Dropout(0.5)  # Additional dropout layer
-+        
-+        # Simplified to have fewer layers and neurons
-+        self.fc2 = nn.Linear(64, 32)  # Reduced size for second dense layer
-+        self.bn2 = nn.BatchNorm1d(32)  # Batch Normalization for the second layer
-+        self.dropout2 = nn.Dropout(0.5)  # Dropout with 50% probability
-+
-+        # Output layer remains the same, adjusted for reduced prior layer size
-+        self.fc3 = nn.Linear(32, num_labels)  # Output layer
-+
-+    def forward(self, x):
-+        # Forward pass through the network with activations, batch normalization, and dropout
-+        x = F.relu(self.bn1(self.fc1(x)))
-+        x = self.dropout1(x)
-+        x = F.relu(self.bn2(self.fc2(x)))
-+        x = self.dropout2(x)
-+        x = self.fc3(x)  # No activation here, use sigmoid or softmax outside if needed for binary classification
-         return x
- 
- def load(config):
-@@ -27,6 +66,8 @@ def load(config):
-     # n_channels = 1
-     n_features = config.input_size
-     
--    mlp = PerceptronNN(n_features,2)
-+    # mlp = PerceptronNN(n_features,2)
-+
-+    mlp = GPT_PNN(n_features,2)
-     
--    return mlp
-\ No newline at end of file
-+    return mlp, "gpt_feedforward"
-\ No newline at end of file
-diff --git a/checkpoints/feedforward/1/basic_feedforward.py b/checkpoints/feedforward/1/basic_feedforward.py
-index 688c282..3a65525 100644
---- a/checkpoints/feedforward/1/basic_feedforward.py
-+++ b/checkpoints/feedforward/1/basic_feedforward.py
-@@ -5,6 +5,12 @@ import numpy as np
- 
- from forge import flags
- 
-+# flags.DEFINE_boolean(
-+#     "model_with_dict",
-+#     True,
-+#     "Makes model output predictions in dictionary instead of directly."
-+# )
-+
- class PerceptronNN(nn.Module):
-     def __init__(self, input_size, num_labels):
-         super(PerceptronNN, self).__init__()
-@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-+        self.softmax = nn.Softmax(dim=1)
- 
-     def forward(self, x):
-         # Forward pass through the network
-@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-         x = F.relu(self.fc2(x))
-         x = F.relu(self.fc3(x))
-         x = self.fc4(x)  # No activation, this will be included in the loss function
-+        x = self.softmax(x)
-         return x
- 
- def load(config):
-@@ -29,4 +37,4 @@ def load(config):
-     
-     mlp = PerceptronNN(n_features,2)
-     
--    return mlp
-\ No newline at end of file
-+    return mlp, "feedforward"
-\ No newline at end of file
-diff --git a/checkpoints/feedforward/1/flags.json b/checkpoints/feedforward/1/flags.json
-index 1d000c3..889a6ea 100644
---- a/checkpoints/feedforward/1/flags.json
-+++ b/checkpoints/feedforward/1/flags.json
-@@ -1,9 +1,15 @@
- {
-     "batch_size": 100,
-+    "beta1": 0.9,
-+    "beta2": 0.999,
-+    "cross_validate": false,
-     "data_config": "penn_dataset.py",
-+    "git_commit": "7416bf730b356aabfe0df644240e40948a8196bb",
-     "include_coords": false,
-     "input_size": 39,
--    "learning_rate": 1e-05,
-+    "learning_rate": 0.0001,
-+    "log_train_values": true,
-+    "log_val_test": true,
-     "model_config": "basic_feedforward.py",
-     "n_repeats": 1,
-     "report_loss_every": 50,
-@@ -11,7 +17,10 @@
-     "results_dir": "checkpoints",
-     "resume": false,
-     "run_name": "feedforward",
-+    "save_check_points": 50,
-+    "save_test_predictions": false,
-     "split_seed": 1,
--    "train_epochs": 20,
-+    "total_evaluations": 100,
-+    "train_epochs": 100,
-     "train_split": 0.8
- }
-\ No newline at end of file
-diff --git a/checkpoints/feedforward/1/git_diff.txt b/checkpoints/feedforward/1/git_diff.txt
-index 7b37e6f..ec23707 100644
---- a/checkpoints/feedforward/1/git_diff.txt
-+++ b/checkpoints/feedforward/1/git_diff.txt
-@@ -1 +1,873 @@
--Mon Mar 4 11:45:48 PST 2024
-+Mon Mar 4 16:34:02 PST 2024
-+diff --git a/.DS_Store b/.DS_Store
-+index e2836a8..7e3fa32 100644
-+Binary files a/.DS_Store and b/.DS_Store differ
-+diff --git a/.ipynb_checkpoints/basic_feedforward-checkpoint.py b/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-+index 688c282..0c4bcd1 100644
-+--- a/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-++++ b/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-+@@ -5,6 +5,12 @@ import numpy as np
-+ 
-+ from forge import flags
-+ 
-++flags.DEFINE_boolean(
-++    "model_with_dict",
-++    True,
-++    "Makes model output predictions in dictionary instead of directly."
-++)
-++
-+ class PerceptronNN(nn.Module):
-+     def __init__(self, input_size, num_labels):
-+         super(PerceptronNN, self).__init__()
-+@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-+         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-+         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-+         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-++        self.softmax = nn.Softmax(dim=1)
-+ 
-+     def forward(self, x):
-+         # Forward pass through the network
-+@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-+         x = F.relu(self.fc2(x))
-+         x = F.relu(self.fc3(x))
-+         x = self.fc4(x)  # No activation, this will be included in the loss function
-++        x = self.softmax(x)
-+         return x
-+ 
-+ def load(config):
-+@@ -29,4 +37,4 @@ def load(config):
-+     
-+     mlp = PerceptronNN(n_features,2)
-+     
-+-    return mlp
-+\ No newline at end of file
-++    return mlp, "feedforward"
-+\ No newline at end of file
-+diff --git a/__pycache__/basic_feedforward.cpython-39.pyc b/__pycache__/basic_feedforward.cpython-39.pyc
-+index f541140..5ad96de 100644
-+Binary files a/__pycache__/basic_feedforward.cpython-39.pyc and b/__pycache__/basic_feedforward.cpython-39.pyc differ
-+diff --git a/__pycache__/penn_dataset.cpython-39.pyc b/__pycache__/penn_dataset.cpython-39.pyc
-+index 0d7a4de..19121eb 100644
-+Binary files a/__pycache__/penn_dataset.cpython-39.pyc and b/__pycache__/penn_dataset.cpython-39.pyc differ
-+diff --git a/basic_feedforward.py b/basic_feedforward.py
-+index 688c282..3a65525 100644
-+--- a/basic_feedforward.py
-++++ b/basic_feedforward.py
-+@@ -5,6 +5,12 @@ import numpy as np
-+ 
-+ from forge import flags
-+ 
-++# flags.DEFINE_boolean(
-++#     "model_with_dict",
-++#     True,
-++#     "Makes model output predictions in dictionary instead of directly."
-++# )
-++
-+ class PerceptronNN(nn.Module):
-+     def __init__(self, input_size, num_labels):
-+         super(PerceptronNN, self).__init__()
-+@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-+         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-+         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-+         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-++        self.softmax = nn.Softmax(dim=1)
-+ 
-+     def forward(self, x):
-+         # Forward pass through the network
-+@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-+         x = F.relu(self.fc2(x))
-+         x = F.relu(self.fc3(x))
-+         x = self.fc4(x)  # No activation, this will be included in the loss function
-++        x = self.softmax(x)
-+         return x
-+ 
-+ def load(config):
-+@@ -29,4 +37,4 @@ def load(config):
-+     
-+     mlp = PerceptronNN(n_features,2)
-+     
-+-    return mlp
-+\ No newline at end of file
-++    return mlp, "feedforward"
-+\ No newline at end of file
-+diff --git a/checkpoints/feedforward/1/basic_feedforward.py b/checkpoints/feedforward/1/basic_feedforward.py
-+index 688c282..3a65525 100644
-+--- a/checkpoints/feedforward/1/basic_feedforward.py
-++++ b/checkpoints/feedforward/1/basic_feedforward.py
-+@@ -5,6 +5,12 @@ import numpy as np
-+ 
-+ from forge import flags
-+ 
-++# flags.DEFINE_boolean(
-++#     "model_with_dict",
-++#     True,
-++#     "Makes model output predictions in dictionary instead of directly."
-++# )
-++
-+ class PerceptronNN(nn.Module):
-+     def __init__(self, input_size, num_labels):
-+         super(PerceptronNN, self).__init__()
-+@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-+         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-+         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-+         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-++        self.softmax = nn.Softmax(dim=1)
-+ 
-+     def forward(self, x):
-+         # Forward pass through the network
-+@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-+         x = F.relu(self.fc2(x))
-+         x = F.relu(self.fc3(x))
-+         x = self.fc4(x)  # No activation, this will be included in the loss function
-++        x = self.softmax(x)
-+         return x
-+ 
-+ def load(config):
-+@@ -29,4 +37,4 @@ def load(config):
-+     
-+     mlp = PerceptronNN(n_features,2)
-+     
-+-    return mlp
-+\ No newline at end of file
-++    return mlp, "feedforward"
-+\ No newline at end of file
-+diff --git a/checkpoints/feedforward/1/flags.json b/checkpoints/feedforward/1/flags.json
-+index 1d000c3..889a6ea 100644
-+--- a/checkpoints/feedforward/1/flags.json
-++++ b/checkpoints/feedforward/1/flags.json
-+@@ -1,9 +1,15 @@
-+ {
-+     "batch_size": 100,
-++    "beta1": 0.9,
-++    "beta2": 0.999,
-++    "cross_validate": false,
-+     "data_config": "penn_dataset.py",
-++    "git_commit": "7416bf730b356aabfe0df644240e40948a8196bb",
-+     "include_coords": false,
-+     "input_size": 39,
-+-    "learning_rate": 1e-05,
-++    "learning_rate": 0.0001,
-++    "log_train_values": true,
-++    "log_val_test": true,
-+     "model_config": "basic_feedforward.py",
-+     "n_repeats": 1,
-+     "report_loss_every": 50,
-+@@ -11,7 +17,10 @@
-+     "results_dir": "checkpoints",
-+     "resume": false,
-+     "run_name": "feedforward",
-++    "save_check_points": 50,
-++    "save_test_predictions": false,
-+     "split_seed": 1,
-+-    "train_epochs": 20,
-++    "total_evaluations": 100,
-++    "train_epochs": 100,
-+     "train_split": 0.8
-+ }
-+\ No newline at end of file
-+diff --git a/checkpoints/feedforward/1/git_diff.txt b/checkpoints/feedforward/1/git_diff.txt
-+index 7b37e6f..5c561db 100644
-+--- a/checkpoints/feedforward/1/git_diff.txt
-++++ b/checkpoints/feedforward/1/git_diff.txt
-+@@ -1 +1 @@
-+-Mon Mar 4 11:45:48 PST 2024
-++Mon Mar 4 16:34:02 PST 2024
-+diff --git a/checkpoints/feedforward/1/penn_dataset.py b/checkpoints/feedforward/1/penn_dataset.py
-+index aa2f5a0..7f5a4fc 100644
-+--- a/checkpoints/feedforward/1/penn_dataset.py
-++++ b/checkpoints/feedforward/1/penn_dataset.py
-+@@ -15,6 +15,7 @@ from forge import flags
-+ # aspects of data managmement
-+ flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
-+ flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-++flags.DEFINE_boolean("cross_validate",False,"Do K-fold cross-validation")
-+ 
-+ # Job management
-+ # flags.DEFINE_integer("batch size",5,"training batch size")
-+@@ -109,15 +110,15 @@ def load(config):
-+         
-+         # set up training DataLoader
-+         train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, n_train),num_workers=0,shuffle = True)
-++        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
-+ 
-+         # set up test DataLoader
-+         test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, n_test),num_workers=0,shuffle = True)
-++        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
-+ 
-+         # set up val DataLoader
-+         val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, n_val),num_workers=0,shuffle = True)
-++        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-+         
-+ 
-+         dataloaders = {'train':train_loader, 
-+@@ -125,8 +126,12 @@ def load(config):
-+                        'val':val_loader,
-+                        'train_inds':train_ind,
-+                        'test_inds':test_ind,
-+-                       'n_val':n_val
-++                       'n_val':n_val,
-++                       'test_headings':list(HEADINGS[test_ind])
-+                       }
-+         kf_dataloaders.append(dataloaders)
-+ 
-++        if not config.cross_validate:
-++        	break
-++
-+     return kf_dataloaders
-+diff --git a/penn_dataset.py b/penn_dataset.py
-+index aa2f5a0..7f5a4fc 100644
-+--- a/penn_dataset.py
-++++ b/penn_dataset.py
-+@@ -15,6 +15,7 @@ from forge import flags
-+ # aspects of data managmement
-+ flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
-+ flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-++flags.DEFINE_boolean("cross_validate",False,"Do K-fold cross-validation")
-+ 
-+ # Job management
-+ # flags.DEFINE_integer("batch size",5,"training batch size")
-+@@ -109,15 +110,15 @@ def load(config):
-+         
-+         # set up training DataLoader
-+         train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, n_train),num_workers=0,shuffle = True)
-++        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
-+ 
-+         # set up test DataLoader
-+         test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, n_test),num_workers=0,shuffle = True)
-++        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
-+ 
-+         # set up val DataLoader
-+         val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, n_val),num_workers=0,shuffle = True)
-++        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-+         
-+ 
-+         dataloaders = {'train':train_loader, 
-+@@ -125,8 +126,12 @@ def load(config):
-+                        'val':val_loader,
-+                        'train_inds':train_ind,
-+                        'test_inds':test_ind,
-+-                       'n_val':n_val
-++                       'n_val':n_val,
-++                       'test_headings':list(HEADINGS[test_ind])
-+                       }
-+         kf_dataloaders.append(dataloaders)
-+ 
-++        if not config.cross_validate:
-++        	break
-++
-+     return kf_dataloaders
-+diff --git a/testing.ipynb b/testing.ipynb
-+index e5a167b..a928d8d 100644
-+--- a/testing.ipynb
-++++ b/testing.ipynb
-+@@ -2,7 +2,7 @@
-+  "cells": [
-+   {
-+    "cell_type": "code",
-+-   "execution_count": 1,
-++   "execution_count": 2,
-+    "id": "4dee7ff1-01a4-4038-b493-9729ff3693f7",
-+    "metadata": {},
-+    "outputs": [],
-+@@ -23,19 +23,19 @@
-+   },
-+   {
-+    "cell_type": "code",
-+-   "execution_count": 2,
-++   "execution_count": 3,
-+    "id": "cad0fdc8-5c35-4610-bba3-b71e60dc1b98",
-+    "metadata": {},
-+    "outputs": [],
-+    "source": [
-+-    "flags.DEFINE_integer(\"batch_size\", 100, \"Mini-batch size.\")\n",
-++    "flags.DEFINE_integer(\"batch_size\", 10, \"Mini-batch size.\")\n",
-+     "\n",
-+     "flags.DEFINE_integer(\"input_size\",39,\"Input shape to model\")"
-+    ]
-+   },
-+   {
-+    "cell_type": "code",
-+-   "execution_count": 3,
-++   "execution_count": 4,
-+    "id": "ce1b936b-8a7c-426e-a3aa-3c1c38f645de",
-+    "metadata": {},
-+    "outputs": [
-+@@ -54,8 +54,8 @@
-+   },
-+   {
-+    "cell_type": "code",
-+-   "execution_count": 9,
-+-   "id": "e862b7e2-57f5-44bf-bcf1-a91160ba66cc",
-++   "execution_count": 5,
-++   "id": "4469cddf-4dac-4468-be88-241d440401c3",
-+    "metadata": {},
-+    "outputs": [
-+     {
-+@@ -67,35 +67,89 @@
-+     }
-+    ],
-+    "source": [
-+-    "model = fet.load(\"basic_feedforward.py\",config)"
-++    "model,modelname = fet.load(\"basic_feedforward.py\",config)"
-+    ]
-+   },
-+   {
-+    "cell_type": "code",
-+-   "execution_count": 10,
-+-   "id": "07e0b160-d5d1-4e54-b4a7-ccaf2224598a",
-++   "execution_count": 17,
-++   "id": "7c9a9fe9-f5e8-456a-b964-4be13027725b",
-+    "metadata": {},
-+    "outputs": [
-+     {
-+      "data": {
-+       "text/plain": [
-+-       "PerceptronNN(\n",
-+-       "  (fc1): Linear(in_features=39, out_features=128, bias=True)\n",
-+-       "  (fc2): Linear(in_features=128, out_features=64, bias=True)\n",
-+-       "  (fc3): Linear(in_features=64, out_features=64, bias=True)\n",
-+-       "  (fc4): Linear(in_features=64, out_features=2, bias=True)\n",
-+-       ")"
-++       "['aaa0060', 'aaa0061', 'aaa0069', 'aaa_0059']"
-+       ]
-+      },
-+-     "execution_count": 10,
-++     "execution_count": 17,
-+      "metadata": {},
-+      "output_type": "execute_result"
-+     }
-+    ],
-+    "source": [
-+-    "model"
-++    "loaddat[0]['test_headings']"
-++   ]
-++  },
-++  {
-++   "cell_type": "code",
-++   "execution_count": 19,
-++   "id": "e862b7e2-57f5-44bf-bcf1-a91160ba66cc",
-++   "metadata": {},
-++   "outputs": [
-++    {
-++     "name": "stdout",
-++     "output_type": "stream",
-++     "text": [
-++      "Keys: ['cross_entropy', 'time']\n"
-++     ]
-++    }
-++   ],
-++   "source": [
-++    "import h5py\n",
-++    "\n",
-++    "file_path = \"./checkpoints/feedforward/2/data_fold1/results_dict.h5\"\n",
-++    "# Replace 'your_file.h5' with the actual path to your file\n",
-++    "f =  h5py.File(file_path, 'r') \n",
-++    "\n",
-++    "    # Get information about the data stored in the file\n",
-++    "print(\"Keys:\", list(f.keys()))  # List the top-level datasets and groups\n",
-++    "\n",
-++    "    # # Access a dataset by its name\n",
-++    "    # dataset_name = \"your_dataset_name\"\n",
-++    "    # if dataset_name in f:\n",
-++    "    #     dataset = f[dataset_name]\n",
-++    "    #     print(\"Dataset shape:\", dataset.shape)\n",
-++    "    #     print(\"Dataset dtype:\", dataset.dtype)\n",
-++    "\n",
-++    "    #     # Access the data as a NumPy array\n",
-++    "    #     data = dataset[:]  # Read the entire dataset\n",
-++    "\n",
-++    "    #     # You can now work with the data as needed, for example:\n",
-++    "    #     # Perform calculations, visualizations, etc.\n",
-++    "    # else:\n",
-++    "    #     print(f\"Dataset '{dataset_name}' not found in the file.\")"
-+    ]
-+   },
-++  {
-++   "cell_type": "code",
-++   "execution_count": 13,
-++   "id": "07e0b160-d5d1-4e54-b4a7-ccaf2224598a",
-++   "metadata": {},
-++   "outputs": [
-++    {
-++     "data": {
-++      "text/plain": [
-++       "<generator object Module.parameters at 0x3007207b0>"
-++      ]
-++     },
-++     "execution_count": 13,
-++     "metadata": {},
-++     "output_type": "execute_result"
-++    }
-++   ],
-++   "source": []
-++  },
-+   {
-+    "cell_type": "code",
-+    "execution_count": null,
-+diff --git a/train.py b/train.py
-+index c266102..516bfa9 100644
-+--- a/train.py
-++++ b/train.py
-+@@ -1,49 +1,440 @@
-+ from os import path as osp
-++import os
-++import numpy as np
-++import time
-+ 
-+ import torch
-++import torch.nn as nn
-+ import torch.nn.functional as F
-+ import torch.optim as optim
-+-
-+-import numpy as np
-++from torch.utils.tensorboard import SummaryWriter
-+ 
-+ import forge
-+ from forge import flags
-+ import forge.experiment_tools as fet
-+ 
-++from train_tools import (
-++	log_tensorboard,
-++	parse_reports,
-++	parse_reports_cpu,
-++	print_reports,
-++	load_checkpoint,
-++	save_checkpoint,
-++	nested_to,
-++	param_count,
-++)
-++
-++from copy import deepcopy
-++from attrdict import AttrDict
-++import deepdish as dd
-++from tqdm import tqdm
-++
-++# For reproducibility while researching, but might affect speed!
-++torch.backends.cudnn.deterministic = True
-++torch.backends.cudnn.benchmark = False
-++torch.manual_seed(0)
-++
-+ 
-+ # Job config
-+ flags.DEFINE_string('data_config', 'penn_dataset.py',
-+-                    'Path to a data config file.')
-++					'Path to a data config file.')
-+ flags.DEFINE_string('model_config', 'basic_feedforward.py',
-+-                    'Path to a model config file.')
-++					'Path to a model config file.')
-+ flags.DEFINE_string('results_dir', 'checkpoints',
-+-                    'Top directory for all experimental results.')
-++					'Top directory for all experimental results.')
-+ flags.DEFINE_string('run_name', 'feedforward',
-+-                    'Name of this job and name of results folder.')
-++					'Name of this job and name of results folder.')
-+ flags.DEFINE_boolean('resume', False, 'Tries to resume a job if True.')
-+ 
-+ # Logging config
-+ flags.DEFINE_integer('report_loss_every', 50,
-+-                     'Number of iterations between reporting minibatch loss.')
-+-flags.DEFINE_integer('train_epochs', 20, 'Maximum number of training epochs.')
-++					 'Number of iterations between reporting minibatch loss.')
-++flags.DEFINE_integer('train_epochs', 100, 'Maximum number of training epochs.')
-++flags.DEFINE_integer(
-++	"save_check_points",
-++	50,
-++	"frequency with which to save checkpoints, in number of epoches.",
-++)
-++flags.DEFINE_boolean("log_train_values", True, "Logs train values if True.")
-++flags.DEFINE_integer(
-++	"total_evaluations",
-++	100,
-++	"Maximum number of evaluations on test and validation data during training.",
-++)
-++flags.DEFINE_boolean(
-++	"save_test_predictions",
-++	False,
-++	"Makes and saves test predictions on one or more test sets (e.g. 5-step and 100-step predictions) at the end of training.",
-++)
-++flags.DEFINE_boolean(
-++    "log_val_test", True, "Turns off computation of validation and test errors."
-++)
-+ 
-+ # Experiment config
-+ flags.DEFINE_integer('batch_size', 100, 'Mini-batch size.')
-+-flags.DEFINE_float('learning_rate', 1e-5, 'SGD learning rate.')
-++flags.DEFINE_float("learning_rate", 1e-4, "Adam learning rate.")
-++flags.DEFINE_float("beta1", 0.9, "Adam Beta 1 parameter")
-++flags.DEFINE_float("beta2", 0.999, "Adam Beta 2 parameter")
-+ 
-+ # Specific config options
-+ flags.DEFINE_integer("input_size",39,"Input shape to model")
-+ 
-++#########################################################################################
-++
-++def evaluate(model, loader, device,fold = 0,headings = [],loss_func = nn.CrossEntropyLoss()):
-++	reports = None
-++	for data in loader:
-++		labels = data['label']
-++		inputs = nested_to(data['data'],device,torch.float32)
-++		
-++		labels_tensor = torch.zeros((len(labels), 2))
-++		for i, label in enumerate(labels):
-++			labels_tensor[i, label] = 1
-++
-++		model_output = model(inputs) # evaluate model
-++
-++		loss = loss_func(model_output, labels_tensor) # compute loss
-++		outputs = AttrDict({"loss": loss, "prediction": model_output,'data_fold':fold})
-++		outputs.reports = AttrDict({"cross_entropy": loss})
-++
-++		if reports is None:
-++			reports = {k: v.detach().clone().cpu() for k, v in outputs.reports.items()}
-++		else:
-++			for k, v in outputs.reports.items():
-++				reports[k] += v.detach().clone().cpu()
-++
-++	for k, v in reports.items():
-++		reports[k] = v / len(
-++			loader
-++		)  # SZ: note this can be slightly incorrect if mini-batch sizes vary (if batch_size doesn't divide train_size), but approximately correct.
-++
-++	# reports['test_headings'] = np.array(headings)
-++
-++	return reports
-++
-++def main():
-++
-++	config = forge.config()
-++
-++	# Set device
-++	if torch.cuda.is_available():
-++		device = f"cuda:{config.device}"
-++		torch.cuda.set_device(device)
-++	else:
-++		device = "cpu" # can change this to MPS on M1 Macs
-++
-++	# Load data
-++	data_name = "penn_data"
-++	kfold_loaders = fet.load(config.data_config, config)
-++
-++	# Load model
-++	model,model_name = fet.load(config.model_config, config)
-++	model = model.to(device)
-++
-++	loss_func = nn.CrossEntropyLoss()
-++
-++	# Prepare environment
-++	params_in_run_name = [
-++		("batch_size", "bs"),
-++		("learning_rate", "lr"),
-++		("n_train", "ntrain")
-++	]
-++
-++	run_name = ""  # config.run_name
-++	for config_param in params_in_run_name:
-++		attr = config_param[0]
-++		abbrev = config_param[1]
-++
-++		if hasattr(config, attr):
-++			run_name += abbrev
-++			run_name += str(getattr(config, attr))
-++			run_name += "_"
-++
-++	results_folder_name = osp.join(
-++		data_name,
-++		model_name,
-++		config.run_name,
-++		run_name,
-++	)
-++
-++	# Prepare environment
-++	logdir = osp.join(config.results_dir, config.run_name)
-++	logdir, resume_checkpoint = fet.init_checkpoint(
-++		logdir, config.data_config, config.model_config, config.resume)
-++
-++	print("Checkpoint directory:",logdir)
-++
-++	# Print flags
-++	fet.print_flags()
-++	# Print model info
-++	print(model)
-++
-++	# Setup optimizer
-++	model_params = model.parameters()
-++	opt_learning_rate = config.learning_rate
-++	model_opt = torch.optim.Adam(
-++		model_params, lr=opt_learning_rate, betas=(config.beta1, config.beta2)
-++	)
-++	print("Model Optimizer:")
-++	print(model_opt)
-++
-++	# Try to restore model and optimizer from checkpoint
-++	if resume_checkpoint is not None:
-++		start_epoch = load_checkpoint(resume_checkpoint, model, model_opt)
-++	else:
-++		start_epoch = 1
-++
-++	n_folds = len(kfold_loaders)
-++	print("Doing {}-fold cross-validation.".format(n_folds))
-++
-++	# KFOLD TRAINING LOOP
-++	for k,loader_k in enumerate(kfold_loaders): # loop over data splits
-++
-++		print("Training fold {}...".format(k+1))
-++
-++		# load the training data
-++		train_loader = loader_k["train"]
-++		n_train = len(train_loader.dataset)
-++		train_batch_size = train_loader.batch_size
-++
-++		# load testing, validation
-++		test_loader = loader_k["test"]
-++		n_test = len(test_loader.dataset)
-++		val_loader = loader_k["val"]
-++		n_val = len(val_loader.dataset)
-++		
-++		# create folder for this data split
-++		fold_dir = osp.join(logdir,"data_fold{}".format(k+1))
-++		fold_dir_exists = osp.exists(fold_dir)
-++		if not fold_dir_exists:
-++			if config.resume:
-++				raise ValueError("Can't resume when the checkpoint/fold dir '{}' doesn't exist.".format(fold_dir))
-++			else:
-++				os.makedirs(fold_dir)
-++		checkpoint_name = osp.join(fold_dir, 'model_fold{}.ckpt'.format(k+1))
-++
-++		# keep track of which data is test data for a given Kfold data split
-++		test_headings = loader_k['test_headings']
-++		headingsFile = osp.join(fold_dir,"test_headings.txt")
-++		with open(headingsFile,'w') as headfile:
-++			for heading in test_headings:
-++				headfile.write(heading+'\n')
-++
-++		# print(checkpoint_name)
-++
-++		train_iter = (start_epoch - 1) * (
-++		len(train_loader.dataset) // train_batch_size
-++		) + 1
-++
-++		print("Starting training at epoch = {}, iter = {}".format(start_epoch, train_iter))
-++
-++		# Setup tensorboard writing
-++		summary_writer = SummaryWriter(logdir)
-++
-++		train_reports = []
-++		report_all = {}
-++		report_all_val = {}
-++
-++		# Saving model at epoch 0 before training
-++		print("saving model at epoch 0 before training ... ")
-++		save_checkpoint(checkpoint_name, 0, model, model_opt, loss=0.0)
-++		print("finished saving model at epoch 0 before training")
-++
-++		num_params = param_count(model)
-++		print(f"Number of model parameters: {num_params}")
-++
-++		# Training
-++		start_t = time.time()
-++
-++		total_train_iters = len(train_loader) * config.train_epochs
-++		iters_per_eval = max(1, int(total_train_iters / config.total_evaluations))
-++		# print('batch',train_batch_size)
-++		# print('ntrain',n_train)
-++		# assert (
-++		# 	n_train % min(train_batch_size, n_train) == 0
-++		# ), "Batch size doesn't divide dataset size. Can be inaccurate for loss computation (see below)."
-++
-++		training_failed = False
-++		best_val_loss_so_far = 1e7
-++
-++		for epoch in tqdm(range(start_epoch, config.train_epochs + 1)):
-++			model.train()
-++
-++			for batch_idx, data_dict in enumerate(train_loader): # Loop over batched data
-++
-++				labels = data_dict['label']
-++				data = data_dict['data']
-++
-++				# send data to device
-++				data = nested_to(data,device,torch.float32)
-++				# One-hot encode the data labels
-++				labels_tensor = torch.zeros((len(labels), 2))
-++				for i, label in enumerate(labels):
-++					labels_tensor[i, label] = 1
-++
-++				model_output = model(data) # evaluate model
-++
-++				loss = loss_func(model_output, labels_tensor) # compute loss
-++				outputs = AttrDict({"loss": loss, "prediction": model_output})
-++				outputs.reports = AttrDict({"cross_entropy": loss})
-++
-++				if torch.isnan(outputs.loss): # check for failure in training
-++					if not training_failed:
-++						epoch_of_nan = epoch
-++					if (epoch > epoch_of_nan + 1) and training_failed:
-++						raise ValueError("Loss Nan-ed.")
-++					training_failed = True
-++
-++				model_opt.zero_grad()
-++				outputs.loss.backward(retain_graph=False)
-++
-++				model_opt.step() # move optimizer forward
-++
-++				train_reports.append(parse_reports_cpu(outputs.reports))
-++
-++				if config.log_train_values:
-++					reports = parse_reports(outputs.reports)
-++					if batch_idx % config.report_loss_every == 0:
-++						log_tensorboard(summary_writer, train_iter, reports, "train/")
-++						print_reports(
-++							reports,
-++							start_t,
-++							epoch,
-++							batch_idx,
-++							len(train_loader.dataset) // train_batch_size,
-++							prefix="train",
-++						)
-++						log_tensorboard(
-++							summary_writer,
-++							train_iter,
-++							{"lr": model_opt.param_groups[0]["lr"]},
-++							"hyperparams/",
-++						)
-++				# Logging and evaluation
-++				if (
-++					train_iter % iters_per_eval == 0 or (train_iter == total_train_iters)
-++				) and config.log_val_test:  # batch_idx % config.evaluate_every == 0:
-++					model.eval()
-++					with torch.no_grad():
-++						reports = evaluate(model, test_loader, device,fold = k,headings = loader_k['test_headings'])
-++						# print("REPORTS",reports)
-++						reports = parse_reports(reports)
-++						reports["time"] = time.time() - start_t
-++						if report_all == {}:
-++							report_all = deepcopy(reports)
-++
-++							for d in reports.keys():
-++								report_all[d] = [report_all[d]]
-++						else:
-++							for d in reports.keys():
-++								report_all[d].append(reports[d])
-++
-++						log_tensorboard(summary_writer, train_iter, reports, "test/")
-++						print_reports(
-++							reports,
-++							start_t,
-++							epoch,
-++							batch_idx,
-++							len(train_loader.dataset) // config.batch_size,
-++							prefix="test",
-++						)
-++
-++						# repeat for validation data
-++						reports = evaluate(model, val_loader, device,fold = k,headings = loader_k['test_headings'])
-++						reports = parse_reports(reports)
-++						reports["time"] = time.time() - start_t
-++						if report_all_val == {}:
-++							report_all_val = deepcopy(reports)
-++
-++							for d in reports.keys():
-++								report_all_val[d] = [report_all_val[d]]
-++						else:
-++							for d in reports.keys():
-++								report_all_val[d].append(reports[d])
-++
-++						log_tensorboard(summary_writer, train_iter, reports, "val/")
-++						print_reports(
-++							reports,
-++							start_t,
-++							epoch,
-++							batch_idx,
-++							len(train_loader.dataset) // config.batch_size,
-++							prefix="val",
-++						)
-++
-++						if report_all_val["cross_entropy"][-1] < best_val_loss_so_far:
-++							save_checkpoint(
-++								checkpoint_name,
-++								f"early_stop",
-++								model,
-++								model_opt,
-++								loss=outputs.loss,
-++							)
-++							best_val_loss_so_far = report_all_val["cross_entropy"][-1]
-++
-++					model.train()
-++
-++				train_iter += 1
-++
-++			if epoch % config.save_check_points == 0:
-++				save_checkpoint(
-++					checkpoint_name, train_iter, model, model_opt, loss=outputs.loss
-++				)
-++
-++		dd.io.save(fold_dir + "/results_dict_train.h5", train_reports)
-++		dd.io.save(fold_dir + "/results_dict.h5", report_all)
-++		dd.io.save(fold_dir + "/results_dict_val.h5", report_all_val)
-++
-++	# always save final model
-++	save_checkpoint(checkpoint_name, train_iter, model, model_opt, loss=outputs.loss)
-++
-++	
-++	if config.save_test_predictions:
-++		pass
-++		# print("Starting to make model predictions on test sets for *final model*.")
-++		# for chunk_len in [5, 100]:
-++		#     start_t_preds = time.time()
-++		#     data_config = SimpleNamespace(
-++		#         **{
-++		#             **config.__dict__["__flags"],
-++		#             **{"chunk_len": chunk_len, "batch_size": 500},
-++		#         }
-++		#     )
-++		#     dataloaders, data_name = fet.load(config.data_config, config=data_config)
-++		#     test_loader_preds = dataloaders["test"]
-++
-++		#     torch.cuda.empty_cache()
-++		#     with torch.no_grad():
-++		#         preds = []
-++		#         true = []
-++		#         num_datapoints = 0
-++		#         for idx, d in enumerate(test_loader_preds):
-++		#             true.append(d[-1])
-++		#             d = nested_to(d, device, torch.float32)
-++		#             outputs = model(d)
-++
-++		#             pred_zs = outputs.prediction
-++		#             preds.append(pred_zs)
-++
-++		#             num_datapoints += len(pred_zs)
-++
-++		#             if num_datapoints >= 2000:
-++		#                 break
-+ 
-+-config = forge.config()
-++		#         preds = torch.cat(preds, dim=0).cpu()
-++		#         true = torch.cat(true, dim=0).cpu()
-+ 
-+-# Prepare environment
-+-logdir = osp.join(config.results_dir, config.run_name)
-+-logdir, resume_checkpoint = fet.init_checkpoint(
-+-    logdir, config.data_config, config.model_config, config.resume)
-+-checkpoint_name = osp.join(logdir, 'model.ckpt')
-++		#         save_dir = osp.join(logdir, f"traj_preds_{chunk_len}_steps_2k_test.pt")
-++		#         torch.save(preds, save_dir)
-+ 
-++		#         save_dir = osp.join(logdir, f"traj_true_{chunk_len}_steps_2k_test.pt")
-++		#         torch.save(true, save_dir)
-+ 
-+-print(logdir)
-++		#         print(
-++		#             f"Completed making test predictions for chunk_len = {chunk_len} in {time.time() - start_t_preds:.2f} seconds."
-++		#         )	
-++		
-+ 
-++if __name__ == "__main__":
-++	main()
-+ 
-diff --git a/checkpoints/feedforward/1/penn_dataset.py b/checkpoints/feedforward/1/penn_dataset.py
-index aa2f5a0..7f5a4fc 100644
---- a/checkpoints/feedforward/1/penn_dataset.py
-+++ b/checkpoints/feedforward/1/penn_dataset.py
-@@ -15,6 +15,7 @@ from forge import flags
- # aspects of data managmement
- flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
- flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-+flags.DEFINE_boolean("cross_validate",False,"Do K-fold cross-validation")
- 
- # Job management
- # flags.DEFINE_integer("batch size",5,"training batch size")
-@@ -109,15 +110,15 @@ def load(config):
-         
-         # set up training DataLoader
-         train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, n_train),num_workers=0,shuffle = True)
-+        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
- 
-         # set up test DataLoader
-         test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, n_test),num_workers=0,shuffle = True)
-+        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
- 
-         # set up val DataLoader
-         val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, n_val),num_workers=0,shuffle = True)
-+        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-         
- 
-         dataloaders = {'train':train_loader, 
-@@ -125,8 +126,12 @@ def load(config):
-                        'val':val_loader,
-                        'train_inds':train_ind,
-                        'test_inds':test_ind,
--                       'n_val':n_val
-+                       'n_val':n_val,
-+                       'test_headings':list(HEADINGS[test_ind])
-                       }
-         kf_dataloaders.append(dataloaders)
- 
-+        if not config.cross_validate:
-+        	break
-+
-     return kf_dataloaders
-diff --git a/georgehulsey_2024.pdf b/georgehulsey_2024.pdf
-deleted file mode 100644
-index 1ab17f6..0000000
-Binary files a/georgehulsey_2024.pdf and /dev/null differ
-diff --git a/penn_dataset.py b/penn_dataset.py
-index aa2f5a0..46c8e52 100644
---- a/penn_dataset.py
-+++ b/penn_dataset.py
-@@ -15,6 +15,7 @@ from forge import flags
- # aspects of data managmement
- flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
- flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-+flags.DEFINE_boolean("cross_validate",True,"Do K-fold cross-validation")
- 
- # Job management
- # flags.DEFINE_integer("batch size",5,"training batch size")
-@@ -109,15 +110,15 @@ def load(config):
-         
-         # set up training DataLoader
-         train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, n_train),num_workers=0,shuffle = True)
-+        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
- 
-         # set up test DataLoader
-         test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, n_test),num_workers=0,shuffle = True)
-+        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
- 
-         # set up val DataLoader
-         val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, n_val),num_workers=0,shuffle = True)
-+        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-         
- 
-         dataloaders = {'train':train_loader, 
-@@ -125,8 +126,12 @@ def load(config):
-                        'val':val_loader,
-                        'train_inds':train_ind,
-                        'test_inds':test_ind,
--                       'n_val':n_val
-+                       'n_val':n_val,
-+                       'test_headings':list(HEADINGS[test_ind])
-                       }
-         kf_dataloaders.append(dataloaders)
- 
-+        if not config.cross_validate:
-+        	break
-+
-     return kf_dataloaders
-diff --git a/testing.ipynb b/testing.ipynb
-index e5a167b..0110538 100644
---- a/testing.ipynb
-+++ b/testing.ipynb
-@@ -2,7 +2,7 @@
-  "cells": [
-   {
-    "cell_type": "code",
--   "execution_count": 1,
-+   "execution_count": 4,
-    "id": "4dee7ff1-01a4-4038-b493-9729ff3693f7",
-    "metadata": {},
-    "outputs": [],
-@@ -23,7 +23,7 @@
-   },
-   {
-    "cell_type": "code",
--   "execution_count": 2,
-+   "execution_count": 6,
-    "id": "cad0fdc8-5c35-4610-bba3-b71e60dc1b98",
-    "metadata": {},
-    "outputs": [],
-@@ -35,7 +35,7 @@
-   },
-   {
-    "cell_type": "code",
--   "execution_count": 3,
-+   "execution_count": 7,
-    "id": "ce1b936b-8a7c-426e-a3aa-3c1c38f645de",
-    "metadata": {},
-    "outputs": [
-@@ -54,8 +54,8 @@
-   },
-   {
-    "cell_type": "code",
--   "execution_count": 9,
--   "id": "e862b7e2-57f5-44bf-bcf1-a91160ba66cc",
-+   "execution_count": 5,
-+   "id": "4469cddf-4dac-4468-be88-241d440401c3",
-    "metadata": {},
-    "outputs": [
-     {
-@@ -67,35 +67,98 @@
-     }
-    ],
-    "source": [
--    "model = fet.load(\"basic_feedforward.py\",config)"
-+    "model,modelname = fet.load(\"basic_feedforward.py\",config)"
-    ]
-   },
-   {
-    "cell_type": "code",
--   "execution_count": 10,
--   "id": "07e0b160-d5d1-4e54-b4a7-ccaf2224598a",
-+   "execution_count": 13,
-+   "id": "7c9a9fe9-f5e8-456a-b964-4be13027725b",
-    "metadata": {},
-    "outputs": [
-     {
-      "data": {
-       "text/plain": [
--       "PerceptronNN(\n",
--       "  (fc1): Linear(in_features=39, out_features=128, bias=True)\n",
--       "  (fc2): Linear(in_features=128, out_features=64, bias=True)\n",
--       "  (fc3): Linear(in_features=64, out_features=64, bias=True)\n",
--       "  (fc4): Linear(in_features=64, out_features=2, bias=True)\n",
--       ")"
-+       "array([114170,    904])"
-       ]
-      },
--     "execution_count": 10,
-+     "execution_count": 13,
-      "metadata": {},
-      "output_type": "execute_result"
-     }
-    ],
-    "source": [
--    "model"
-+    "np.bincount(loaddat[0]['train'].dataset.all_labels)"
-    ]
-   },
-+  {
-+   "cell_type": "code",
-+   "execution_count": 1,
-+   "id": "e862b7e2-57f5-44bf-bcf1-a91160ba66cc",
-+   "metadata": {},
-+   "outputs": [
-+    {
-+     "ename": "FileNotFoundError",
-+     "evalue": "[Errno 2] Unable to open file (unable to open file: name = './checkpoints/feedforward/2/data_fold1/results_dict.h5', errno = 2, error message = 'No such file or directory', flags = 0, o_flags = 0)",
-+     "output_type": "error",
-+     "traceback": [
-+      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
-+      "\u001b[0;31mFileNotFoundError\u001b[0m                         Traceback (most recent call last)",
-+      "Cell \u001b[0;32mIn[1], line 5\u001b[0m\n\u001b[1;32m      3\u001b[0m file_path \u001b[38;5;241m=\u001b[39m \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124m./checkpoints/feedforward/2/data_fold1/results_dict.h5\u001b[39m\u001b[38;5;124m\"\u001b[39m\n\u001b[1;32m      4\u001b[0m \u001b[38;5;66;03m# Replace 'your_file.h5' with the actual path to your file\u001b[39;00m\n\u001b[0;32m----> 5\u001b[0m f \u001b[38;5;241m=\u001b[39m  \u001b[43mh5py\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mFile\u001b[49m\u001b[43m(\u001b[49m\u001b[43mfile_path\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[38;5;124;43mr\u001b[39;49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[43m)\u001b[49m \n\u001b[1;32m      7\u001b[0m     \u001b[38;5;66;03m# Get information about the data stored in the file\u001b[39;00m\n\u001b[1;32m      8\u001b[0m \u001b[38;5;28mprint\u001b[39m(\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mKeys:\u001b[39m\u001b[38;5;124m\"\u001b[39m, \u001b[38;5;28mlist\u001b[39m(f\u001b[38;5;241m.\u001b[39mkeys()))\n",
-+      "File \u001b[0;32m/Applications/miniconda3/envs/lietransformer/lib/python3.9/site-packages/h5py/_hl/files.py:562\u001b[0m, in \u001b[0;36mFile.__init__\u001b[0;34m(self, name, mode, driver, libver, userblock_size, swmr, rdcc_nslots, rdcc_nbytes, rdcc_w0, track_order, fs_strategy, fs_persist, fs_threshold, fs_page_size, page_buf_size, min_meta_keep, min_raw_keep, locking, alignment_threshold, alignment_interval, meta_block_size, **kwds)\u001b[0m\n\u001b[1;32m    553\u001b[0m     fapl \u001b[38;5;241m=\u001b[39m make_fapl(driver, libver, rdcc_nslots, rdcc_nbytes, rdcc_w0,\n\u001b[1;32m    554\u001b[0m                      locking, page_buf_size, min_meta_keep, min_raw_keep,\n\u001b[1;32m    555\u001b[0m                      alignment_threshold\u001b[38;5;241m=\u001b[39malignment_threshold,\n\u001b[1;32m    556\u001b[0m                      alignment_interval\u001b[38;5;241m=\u001b[39malignment_interval,\n\u001b[1;32m    557\u001b[0m                      meta_block_size\u001b[38;5;241m=\u001b[39mmeta_block_size,\n\u001b[1;32m    558\u001b[0m                      \u001b[38;5;241m*\u001b[39m\u001b[38;5;241m*\u001b[39mkwds)\n\u001b[1;32m    559\u001b[0m     fcpl \u001b[38;5;241m=\u001b[39m make_fcpl(track_order\u001b[38;5;241m=\u001b[39mtrack_order, fs_strategy\u001b[38;5;241m=\u001b[39mfs_strategy,\n\u001b[1;32m    560\u001b[0m                      fs_persist\u001b[38;5;241m=\u001b[39mfs_persist, fs_threshold\u001b[38;5;241m=\u001b[39mfs_threshold,\n\u001b[1;32m    561\u001b[0m                      fs_page_size\u001b[38;5;241m=\u001b[39mfs_page_size)\n\u001b[0;32m--> 562\u001b[0m     fid \u001b[38;5;241m=\u001b[39m \u001b[43mmake_fid\u001b[49m\u001b[43m(\u001b[49m\u001b[43mname\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mmode\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43muserblock_size\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mfapl\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mfcpl\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mswmr\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43mswmr\u001b[49m\u001b[43m)\u001b[49m\n\u001b[1;32m    564\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;28misinstance\u001b[39m(libver, \u001b[38;5;28mtuple\u001b[39m):\n\u001b[1;32m    565\u001b[0m     \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_libver \u001b[38;5;241m=\u001b[39m libver\n",
-+      "File \u001b[0;32m/Applications/miniconda3/envs/lietransformer/lib/python3.9/site-packages/h5py/_hl/files.py:235\u001b[0m, in \u001b[0;36mmake_fid\u001b[0;34m(name, mode, userblock_size, fapl, fcpl, swmr)\u001b[0m\n\u001b[1;32m    233\u001b[0m     \u001b[38;5;28;01mif\u001b[39;00m swmr \u001b[38;5;129;01mand\u001b[39;00m swmr_support:\n\u001b[1;32m    234\u001b[0m         flags \u001b[38;5;241m|\u001b[39m\u001b[38;5;241m=\u001b[39m h5f\u001b[38;5;241m.\u001b[39mACC_SWMR_READ\n\u001b[0;32m--> 235\u001b[0m     fid \u001b[38;5;241m=\u001b[39m \u001b[43mh5f\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mopen\u001b[49m\u001b[43m(\u001b[49m\u001b[43mname\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mflags\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mfapl\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43mfapl\u001b[49m\u001b[43m)\u001b[49m\n\u001b[1;32m    236\u001b[0m \u001b[38;5;28;01melif\u001b[39;00m mode \u001b[38;5;241m==\u001b[39m \u001b[38;5;124m'\u001b[39m\u001b[38;5;124mr+\u001b[39m\u001b[38;5;124m'\u001b[39m:\n\u001b[1;32m    237\u001b[0m     fid \u001b[38;5;241m=\u001b[39m h5f\u001b[38;5;241m.\u001b[39mopen(name, h5f\u001b[38;5;241m.\u001b[39mACC_RDWR, fapl\u001b[38;5;241m=\u001b[39mfapl)\n",
-+      "File \u001b[0;32mh5py/_objects.pyx:54\u001b[0m, in \u001b[0;36mh5py._objects.with_phil.wrapper\u001b[0;34m()\u001b[0m\n",
-+      "File \u001b[0;32mh5py/_objects.pyx:55\u001b[0m, in \u001b[0;36mh5py._objects.with_phil.wrapper\u001b[0;34m()\u001b[0m\n",
-+      "File \u001b[0;32mh5py/h5f.pyx:102\u001b[0m, in \u001b[0;36mh5py.h5f.open\u001b[0;34m()\u001b[0m\n",
-+      "\u001b[0;31mFileNotFoundError\u001b[0m: [Errno 2] Unable to open file (unable to open file: name = './checkpoints/feedforward/2/data_fold1/results_dict.h5', errno = 2, error message = 'No such file or directory', flags = 0, o_flags = 0)"
-+     ]
-+    }
-+   ],
-+   "source": [
-+    "import h5py\n",
-+    "\n",
-+    "file_path = \"./checkpoints/feedforward/2/data_fold1/results_dict.h5\"\n",
-+    "# Replace 'your_file.h5' with the actual path to your file\n",
-+    "f =  h5py.File(file_path, 'r') \n",
-+    "\n",
-+    "    # Get information about the data stored in the file\n",
-+    "print(\"Keys:\", list(f.keys()))  # List the top-level datasets and groups\n",
-+    "\n",
-+    "    # # Access a dataset by its name\n",
-+    "    # dataset_name = \"your_dataset_name\"\n",
-+    "    # if dataset_name in f:\n",
-+    "    #     dataset = f[dataset_name]\n",
-+    "    #     print(\"Dataset shape:\", dataset.shape)\n",
-+    "    #     print(\"Dataset dtype:\", dataset.dtype)\n",
-+    "\n",
-+    "    #     # Access the data as a NumPy array\n",
-+    "    #     data = dataset[:]  # Read the entire dataset\n",
-+    "\n",
-+    "    #     # You can now work with the data as needed, for example:\n",
-+    "    #     # Perform calculations, visualizations, etc.\n",
-+    "    # else:\n",
-+    "    #     print(f\"Dataset '{dataset_name}' not found in the file.\")"
-+   ]
-+  },
-+  {
-+   "cell_type": "code",
-+   "execution_count": 13,
-+   "id": "07e0b160-d5d1-4e54-b4a7-ccaf2224598a",
-+   "metadata": {},
-+   "outputs": [
-+    {
-+     "data": {
-+      "text/plain": [
-+       "<generator object Module.parameters at 0x3007207b0>"
-+      ]
-+     },
-+     "execution_count": 13,
-+     "metadata": {},
-+     "output_type": "execute_result"
-+    }
-+   ],
-+   "source": []
-+  },
-   {
-    "cell_type": "code",
-    "execution_count": null,
-diff --git a/train.py b/train.py
-index c266102..9c27c90 100644
---- a/train.py
-+++ b/train.py
-@@ -1,49 +1,461 @@
- from os import path as osp
-+import os
-+import numpy as np
-+import time
- 
- import torch
-+import torch.nn as nn
- import torch.nn.functional as F
- import torch.optim as optim
--
--import numpy as np
-+from torch.utils.tensorboard import SummaryWriter
- 
- import forge
- from forge import flags
- import forge.experiment_tools as fet
- 
-+from train_tools import (
-+	log_tensorboard,
-+	parse_reports,
-+	parse_reports_cpu,
-+	print_reports,
-+	load_checkpoint,
-+	save_checkpoint,
-+	nested_to,
-+	param_count,
-+)
-+
-+from copy import deepcopy
-+from attrdict import AttrDict
-+import deepdish as dd
-+from tqdm import tqdm
-+
-+# For reproducibility while researching, but might affect speed!
-+torch.backends.cudnn.deterministic = True
-+torch.backends.cudnn.benchmark = False
-+torch.manual_seed(0)
-+
- 
- # Job config
- flags.DEFINE_string('data_config', 'penn_dataset.py',
--                    'Path to a data config file.')
-+					'Path to a data config file.')
- flags.DEFINE_string('model_config', 'basic_feedforward.py',
--                    'Path to a model config file.')
-+					'Path to a model config file.')
- flags.DEFINE_string('results_dir', 'checkpoints',
--                    'Top directory for all experimental results.')
--flags.DEFINE_string('run_name', 'feedforward',
--                    'Name of this job and name of results folder.')
-+					'Top directory for all experimental results.')
-+flags.DEFINE_string('model_name', 'gpt-FCNN',
-+					'shorthand name for model.')
-+flags.DEFINE_string('run_name', 'hyperparam_testing',
-+					'Name of this job and name of results folder.')
- flags.DEFINE_boolean('resume', False, 'Tries to resume a job if True.')
- 
- # Logging config
- flags.DEFINE_integer('report_loss_every', 50,
--                     'Number of iterations between reporting minibatch loss.')
--flags.DEFINE_integer('train_epochs', 20, 'Maximum number of training epochs.')
-+					 'Number of iterations between reporting minibatch loss.')
-+flags.DEFINE_integer('train_epochs', 50, 'Maximum number of training epochs.')
-+flags.DEFINE_integer(
-+	"save_check_points",
-+	50,
-+	"frequency with which to save checkpoints, in number of epoches.",
-+)
-+flags.DEFINE_boolean("log_train_values", True, "Logs train values if True.")
-+flags.DEFINE_integer(
-+	"total_evaluations",
-+	100,
-+	"Maximum number of evaluations on test and validation data during training.",
-+)
-+flags.DEFINE_boolean(
-+	"save_test_predictions",
-+	False,
-+	"Makes and saves test predictions on one or more test sets (e.g. 5-step and 100-step predictions) at the end of training.",
-+)
-+flags.DEFINE_boolean(
-+    "log_val_test", True, "Turns off computation of validation and test errors."
-+)
-+
-+flags.DEFINE_boolean('use_mps',False,"Use Metal Performance Shaders (M1) for training.")
- 
- # Experiment config
- flags.DEFINE_integer('batch_size', 100, 'Mini-batch size.')
--flags.DEFINE_float('learning_rate', 1e-5, 'SGD learning rate.')
-+flags.DEFINE_float("learning_rate", 1e-4, "Adam learning rate.")
-+flags.DEFINE_float("beta1", 0.9, "Adam Beta 1 parameter")
-+flags.DEFINE_float("beta2", 0.999, "Adam Beta 2 parameter")
- 
- # Specific config options
- flags.DEFINE_integer("input_size",39,"Input shape to model")
- 
-+#########################################################################################
-+
-+def evaluate(model, loader, device,fold = 0,headings = [],loss_func = nn.CrossEntropyLoss()):
-+	# this function does not account for class weights when evaluating cross-entropy loss.
-+	# however, they are accounted for when evaluating training loss
-+	reports = None
-+	for data in loader:
-+		labels = data['label']
-+		inputs = nested_to(data['data'],device,torch.float32)
-+		
-+		labels_tensor = torch.zeros((len(labels), 2))
-+		for i, label in enumerate(labels):
-+			labels_tensor[i, label] = 1
-+
-+		model_output = model(inputs) # evaluate model
-+
-+		loss = loss_func(model_output, labels_tensor) # compute loss
-+		outputs = AttrDict({"loss": loss, "prediction": model_output,'data_fold':fold})
-+		outputs.reports = AttrDict({"cross_entropy": loss})
-+
-+		if reports is None:
-+			reports = {k: v.detach().clone().cpu() for k, v in outputs.reports.items()}
-+		else:
-+			for k, v in outputs.reports.items():
-+				reports[k] += v.detach().clone().cpu()
-+
-+	for k, v in reports.items():
-+		reports[k] = v / len(
-+			loader
-+		)  # SZ: note this can be slightly incorrect if mini-batch sizes vary (if batch_size doesn't divide train_size), but approximately correct.
-+
-+	# reports['test_headings'] = np.array(headings)
-+
-+	return reports
-+
-+def main():
-+
-+	config = forge.config()
-+
-+	# Set device
-+	if torch.cuda.is_available():
-+		device = f"cuda:{config.device}"
-+		torch.cuda.set_device(device)
-+	else:
-+		device = "cpu" # can change this to MPS on M1 Macs
-+
-+	if config.use_mps:
-+		device = "mps"
-+
-+	# Load data
-+	data_name = "penn_data"
-+	kfold_loaders = fet.load(config.data_config, config)
-+
-+	# Prepare environment
-+	params_in_run_name = [
-+		("batch_size", "bs"),
-+		("learning_rate", "lr"),
-+		("n_train", "ntrain"),
-+		("include_coords",'inclx'),
-+		("input_size",'inpsize'),
-+		("cross_validate",'crval'),
-+		("train_epochs",'n_epochs'),
-+	]
-+
-+	run_name = ""  # config.run_name
-+	for config_param in params_in_run_name:
-+		attr = config_param[0]
-+		abbrev = config_param[1]
-+
-+		if hasattr(config, attr):
-+			run_name += abbrev
-+			run_name += str(getattr(config, attr))
-+			run_name += "_"
-+
-+	results_folder_name = osp.join(
-+		data_name,
-+		config.model_name,
-+		config.run_name,
-+		run_name,
-+	)
-+
-+	# Prepare environment
-+	logdir = osp.join(config.results_dir, results_folder_name.replace(".", "_"))
-+	logdir, resume_checkpoint = fet.init_checkpoint(
-+		logdir, config.data_config, config.model_config, config.resume)
-+
-+	print("Checkpoint directory:",logdir)
-+
-+	# Print flags
-+	fet.print_flags()
-+
-+	n_folds = len(kfold_loaders)
-+	print("Doing {}-fold cross-validation.".format(n_folds))
-+
-+	# KFOLD TRAINING LOOP
-+	for k,loader_k in enumerate(kfold_loaders): # loop over data splits
-+
-+		print("Training fold {}...".format(k+1))
-+
-+		# Load model
-+		model,model_name = fet.load(config.model_config, config)
-+		model = model.to(device)
-+
-+		# Print model info
-+		print(model)
-+
-+		# Setup optimizer
-+		model_params = model.parameters()
-+		opt_learning_rate = config.learning_rate
-+		model_opt = torch.optim.Adam(
-+			model_params, lr=opt_learning_rate, betas=(config.beta1, config.beta2)
-+		)
-+		scheduler = torch.optim.lr_scheduler.StepLR(model_opt, step_size=10, gamma=0.5)
-+		print("Model Optimizer:")
-+		print(model_opt)
-+
-+		# Try to restore model and optimizer from checkpoint
-+		if resume_checkpoint is not None:
-+			start_epoch = load_checkpoint(resume_checkpoint, model, model_opt)
-+		else:
-+			start_epoch = 1
-+
-+		# load the training data
-+		train_loader = loader_k["train"]
-+		n_train = len(train_loader.dataset)
-+		train_batch_size = train_loader.batch_size
-+
-+		# load testing, validation
-+		test_loader = loader_k["test"]
-+		n_test = len(test_loader.dataset)
-+		val_loader = loader_k["val"]
-+		n_val = len(val_loader.dataset)
-+
-+		train_class_counts = np.bincount(train_loader.dataset.all_labels)
-+		train_total_counts = sum(train_class_counts)
-+		class_weight = torch.tensor(1.0 / train_class_counts) * train_total_counts / 2.0
-+
-+		loss_func = nn.CrossEntropyLoss(weight = class_weight) # define reweighted loss function
-+				
-+		# create folder for this data split
-+		fold_dir = osp.join(logdir,"data_fold{}".format(k+1))
-+		fold_dir_exists = osp.exists(fold_dir)
-+		if not fold_dir_exists:
-+			if config.resume:
-+				raise ValueError("Can't resume when the checkpoint/fold dir '{}' doesn't exist.".format(fold_dir))
-+			else:
-+				os.makedirs(fold_dir)
-+		checkpoint_name = osp.join(fold_dir, 'model_fold{}.ckpt'.format(k+1))
-+
-+		# keep track of which data is test data for a given Kfold data split
-+		test_headings = loader_k['test_headings']
-+		headingsFile = osp.join(fold_dir,"test_headings.txt")
-+		with open(headingsFile,'w') as headfile:
-+			for heading in test_headings:
-+				headfile.write(heading+'\n')
-+
-+		# print(checkpoint_name)
-+
-+		train_iter = (start_epoch - 1) * (
-+		len(train_loader.dataset) // train_batch_size
-+		) + 1
-+
-+		print("Starting training at epoch = {}, iter = {}".format(start_epoch, train_iter))
-+
-+		# Setup tensorboard writing
-+		summary_writer = SummaryWriter(logdir)
-+
-+		train_reports = []
-+		report_all = {}
-+		report_all_val = {}
-+
-+		# Saving model at epoch 0 before training
-+		print("saving model at epoch 0 before training ... ")
-+		save_checkpoint(checkpoint_name, 0, model, model_opt, loss=0.0)
-+		print("finished saving model at epoch 0 before training")
-+
-+		num_params = param_count(model)
-+		print(f"Number of model parameters: {num_params}")
-+
-+		# Training
-+		start_t = time.time()
-+
-+		total_train_iters = len(train_loader) * config.train_epochs
-+		iters_per_eval = max(1, int(total_train_iters / config.total_evaluations))
-+		# print('batch',train_batch_size)
-+		# print('ntrain',n_train)
-+		# assert (
-+		# 	n_train % min(train_batch_size, n_train) == 0
-+		# ), "Batch size doesn't divide dataset size. Can be inaccurate for loss computation (see below)."
-+
-+		training_failed = False
-+		best_val_loss_so_far = 1e7
-+
-+		for epoch in tqdm(range(start_epoch, config.train_epochs + 1)):
-+			model.train()
-+
-+			for batch_idx, data_dict in enumerate(train_loader): # Loop over batched data
-+
-+				labels = data_dict['label']
-+				data = data_dict['data']
-+
-+				# send data to device
-+				data = nested_to(data,device,torch.float32)
-+				# One-hot encode the data labels
-+				labels_tensor = torch.zeros((len(labels), 2))
-+				for i, label in enumerate(labels):
-+					labels_tensor[i, label] = 1
-+
-+				model_output = model(data) # evaluate model
-+
-+				loss = loss_func(model_output, labels_tensor) # compute loss
-+				outputs = AttrDict({"loss": loss, "prediction": model_output})
-+				outputs.reports = AttrDict({"cross_entropy": loss})
-+
-+				if torch.isnan(outputs.loss): # check for failure in training
-+					if not training_failed:
-+						epoch_of_nan = epoch
-+					if (epoch > epoch_of_nan + 1) and training_failed:
-+						raise ValueError("Loss Nan-ed.")
-+					training_failed = True
-+
-+				model_opt.zero_grad()
-+				outputs.loss.backward(retain_graph=False)
-+
-+				model_opt.step() # move optimizer forward
-+
-+				train_reports.append(parse_reports_cpu(outputs.reports))
-+
-+				if config.log_train_values:
-+					reports = parse_reports(outputs.reports)
-+					if batch_idx % config.report_loss_every == 0:
-+						log_tensorboard(summary_writer, train_iter, reports, "train/")
-+						print_reports(
-+							reports,
-+							start_t,
-+							epoch,
-+							batch_idx,
-+							len(train_loader.dataset) // train_batch_size,
-+							prefix="train",
-+						)
-+						log_tensorboard(
-+							summary_writer,
-+							train_iter,
-+							{"lr": model_opt.param_groups[0]["lr"]},
-+							"hyperparams/",
-+						)
-+				# Logging and evaluation
-+				if (
-+					train_iter % iters_per_eval == 0 or (train_iter == total_train_iters)
-+				) and config.log_val_test:  # batch_idx % config.evaluate_every == 0:
-+					model.eval()
-+					with torch.no_grad():
-+						reports = evaluate(model, test_loader, device,fold = k,headings = loader_k['test_headings'])
-+						# print("REPORTS",reports)
-+						reports = parse_reports(reports)
-+						reports["time"] = time.time() - start_t
-+						if report_all == {}:
-+							report_all = deepcopy(reports)
-+
-+							for d in reports.keys():
-+								report_all[d] = [report_all[d]]
-+						else:
-+							for d in reports.keys():
-+								report_all[d].append(reports[d])
-+
-+						log_tensorboard(summary_writer, train_iter, reports, "test/")
-+						print_reports(
-+							reports,
-+							start_t,
-+							epoch,
-+							batch_idx,
-+							len(train_loader.dataset) // config.batch_size,
-+							prefix="test",
-+						)
-+
-+						# repeat for validation data
-+						reports = evaluate(model, val_loader, device,fold = k,headings = loader_k['test_headings'])
-+						reports = parse_reports(reports)
-+						reports["time"] = time.time() - start_t
-+						if report_all_val == {}:
-+							report_all_val = deepcopy(reports)
-+
-+							for d in reports.keys():
-+								report_all_val[d] = [report_all_val[d]]
-+						else:
-+							for d in reports.keys():
-+								report_all_val[d].append(reports[d])
-+
-+						log_tensorboard(summary_writer, train_iter, reports, "val/")
-+						print_reports(
-+							reports,
-+							start_t,
-+							epoch,
-+							batch_idx,
-+							len(train_loader.dataset) // config.batch_size,
-+							prefix="val",
-+						)
-+
-+						if report_all_val["cross_entropy"][-1] < best_val_loss_so_far:
-+							save_checkpoint(
-+								checkpoint_name,
-+								f"early_stop",
-+								model,
-+								model_opt,
-+								loss=outputs.loss,
-+							)
-+							best_val_loss_so_far = report_all_val["cross_entropy"][-1]
-+
-+					model.train()
-+
-+				train_iter += 1
-+
-+			scheduler.step()
-+
-+			if epoch % config.save_check_points == 0:
-+				save_checkpoint(
-+					checkpoint_name, train_iter, model, model_opt, loss=outputs.loss
-+				)
-+		
-+		dd.io.save(fold_dir + "/results_dict_train.h5", train_reports)
-+		dd.io.save(fold_dir + "/results_dict.h5", report_all)
-+		dd.io.save(fold_dir + "/results_dict_val.h5", report_all_val)
-+
-+	# always save final model
-+	save_checkpoint(checkpoint_name, train_iter, model, model_opt, loss=outputs.loss)
-+
-+	
-+	if config.save_test_predictions:
-+		pass
-+		# print("Starting to make model predictions on test sets for *final model*.")
-+		# for chunk_len in [5, 100]:
-+		#     start_t_preds = time.time()
-+		#     data_config = SimpleNamespace(
-+		#         **{
-+		#             **config.__dict__["__flags"],
-+		#             **{"chunk_len": chunk_len, "batch_size": 500},
-+		#         }
-+		#     )
-+		#     dataloaders, data_name = fet.load(config.data_config, config=data_config)
-+		#     test_loader_preds = dataloaders["test"]
-+
-+		#     torch.cuda.empty_cache()
-+		#     with torch.no_grad():
-+		#         preds = []
-+		#         true = []
-+		#         num_datapoints = 0
-+		#         for idx, d in enumerate(test_loader_preds):
-+		#             true.append(d[-1])
-+		#             d = nested_to(d, device, torch.float32)
-+		#             outputs = model(d)
-+
-+		#             pred_zs = outputs.prediction
-+		#             preds.append(pred_zs)
-+
-+		#             num_datapoints += len(pred_zs)
-+
-+		#             if num_datapoints >= 2000:
-+		#                 break
- 
--config = forge.config()
-+		#         preds = torch.cat(preds, dim=0).cpu()
-+		#         true = torch.cat(true, dim=0).cpu()
- 
--# Prepare environment
--logdir = osp.join(config.results_dir, config.run_name)
--logdir, resume_checkpoint = fet.init_checkpoint(
--    logdir, config.data_config, config.model_config, config.resume)
--checkpoint_name = osp.join(logdir, 'model.ckpt')
-+		#         save_dir = osp.join(logdir, f"traj_preds_{chunk_len}_steps_2k_test.pt")
-+		#         torch.save(preds, save_dir)
- 
-+		#         save_dir = osp.join(logdir, f"traj_true_{chunk_len}_steps_2k_test.pt")
-+		#         torch.save(true, save_dir)
- 
--print(logdir)
-+		#         print(
-+		#             f"Completed making test predictions for chunk_len = {chunk_len} in {time.time() - start_t_preds:.2f} seconds."
-+		#         )	
-+		
- 
-+if __name__ == "__main__":
-+	main()
- 
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/penn_dataset.py b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/penn_dataset.py
deleted file mode 100644
index 46c8e52..0000000
--- a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_0001_inclxFalse_inpsize39_crvalTrue_n_epochs50_/3/penn_dataset.py
+++ /dev/null
@@ -1,137 +0,0 @@
-import os
-import torch
-import pandas as pd
-import numpy as np
-
-from torchvision import datasets, transforms
-from torch.utils.data import Dataset, DataLoader
-from sklearn.model_selection import RepeatedKFold
-
-from os import path as osp
-import forge
-from forge import flags
-
-
-# aspects of data managmement
-flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
-flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-flags.DEFINE_boolean("cross_validate",True,"Do K-fold cross-validation")
-
-# Job management
-# flags.DEFINE_integer("batch size",5,"training batch size")
-flags.DEFINE_float("train_split",0.8,'Fraction of data to use for training.')
-flags.DEFINE_integer("n_repeats",1,"Times to repeat K-fold cross-validation")
-flags.DEFINE_integer("split_seed",1,"Seed for KFold split (integer for reproducibility")
-
-# "wavelengths between 0.05 and 1 mm in 0.025 mm increments."
-LSPACE = np.arange(0.05,1.05,0.025) # corresponds to 39 non-coord columns of data
-L_INDS = None
-
-DATAFOLDER = './penn_data'
-
-HEADINGS = np.array(['aaa0043','aaa0044','aaa0060','aaa0061','aaa0063','aaa0064','aaa0066','aaa0069','aaa0086','aaa0087','aaa_0051','aaa_0053','aaa_0054','aaa_0059','aaa_0071','aaa_0072'])
-
-
-class PennData(Dataset):
-
-    def __init__(self,path_to_data,headings,k_inds = None,include_coords = True,rescale = True,spectra_prefix = "kvals_fuse_rotate_",label_prefix = 'labels_fuse_rotate_'):
-        
-        self.data_dir = path_to_data
-        self.headings = headings
-
-        df_list = []
-        label_list = []
-        for heading in self.headings: # for each datafile heading,
-            data_name = osp.join(self.data_dir,spectra_prefix + heading+'.csv') # read kvals
-            df_temp = pd.read_csv(data_name,header=None)
-            df_list.append(df_temp)
-
-            label_name = osp.join(self.data_dir,label_prefix + heading + '.csv') # read labels
-            label_temp = pd.read_csv(label_name,header=None, names=['label'])
-            label_list.append(label_temp)
-
-        df = pd.concat(df_list, ignore_index=True)
-
-        labels = pd.concat(label_list, ignore_index=True)
-        df = pd.concat([labels, df], axis="columns") # Append labels to data
-
-        all_labels = df['label'].to_numpy()
-        all_data = df.iloc[:,1:].to_numpy()
-
-        if rescale: # rescale (normalize) wavelength intensity data
-            lambdas = all_data[:,2:] # wavelengths
-            lam_std = np.std(lambdas, axis=0)  # Calculate standard deviation along columns
-            lam_mean = np.mean(lambdas, axis=0)  # Calculate mean along columns
-            lambdas_rescaled = (lambdas - lam_mean) / lam_std 
-            all_data[:,2:] = lambdas_rescaled
-
-        if not include_coords: # removes x,y coordinates from data
-            all_data = all_data[:,2:]
-        
-        if k_inds != None: # in this case, only use subset of wavelengths
-            all_data = all_data[:,np.array(k_inds)]
-
-        self.all_data = all_data
-        self.all_labels = all_labels
-
-    def __len__(self):
-        return len(self.all_data)
-
-    def __getitem__(self,i):
-        state = {'label':self.all_labels[i],'data':self.all_data[i]}
-        return state
-
-    def __getstate__(self):
-        state = {
-            'data': self.all_data,
-            'label': self.all_labels,
-                }
-        return state
-
-    def __setstate__(self, state):
-        # Set the object's state from the provided dictionary
-        self.all_data = state['data']
-        self.all_labels = state['label']
-        
-
-
-def load(config):
-
-    n_splits = int(len(HEADINGS)/((1-config.train_split)*len(HEADINGS)))
-
-    kf = RepeatedKFold(n_splits = n_splits, n_repeats = config.n_repeats, random_state = config.split_seed) # K-fold cross validation
-
-    kf_dataloaders = []
-
-    for i, (train_ind, test_ind) in enumerate(kf.split(HEADINGS)): # for each K-fold split, 
-        n_val = len(test_ind)//2
-        n_test = len(test_ind)-n_val   
-        n_train = len(train_ind)
-        
-        # set up training DataLoader
-        train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
-
-        # set up test DataLoader
-        test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
-
-        # set up val DataLoader
-        val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-        
-
-        dataloaders = {'train':train_loader, 
-                       'test':test_loader,
-                       'val':val_loader,
-                       'train_inds':train_ind,
-                       'test_inds':test_ind,
-                       'n_val':n_val,
-                       'test_headings':list(HEADINGS[test_ind])
-                      }
-        kf_dataloaders.append(dataloaders)
-
-        if not config.cross_validate:
-        	break
-
-    return kf_dataloaders
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/.DS_Store b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/.DS_Store
deleted file mode 100644
index 835f63a..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/.DS_Store and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/basic_feedforward.py b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/basic_feedforward.py
deleted file mode 100644
index c36011b..0000000
--- a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/basic_feedforward.py
+++ /dev/null
@@ -1,74 +0,0 @@
-import torch
-import torch.nn as nn
-import torch.nn.functional as F
-import numpy as np
-
-from forge import flags
-
-# flags.DEFINE_boolean(
-#     "model_with_dict",
-#     True,
-#     "Makes model output predictions in dictionary instead of directly."
-# )
-
-class PerceptronNN(nn.Module):
-    def __init__(self, input_size, num_labels):
-        super(PerceptronNN, self).__init__()
-        # Define the layers
-        self.fc1 = nn.Linear(input_size, 128)  # First dense layer
-        self.fc2 = nn.Linear(128, 64)         # Second dense layer
-        # self.fc23 = nn.Linear(64,64)
-        self.fc3 = nn.Linear(64, 64)          # Third dense layer
-        self.fc4 = nn.Linear(64, num_labels)  # Output layer
-        # self.softmax = nn.Softmax(dim=1)
-
-    def forward(self, x):
-        # Forward pass through the network
-        x = F.relu(self.fc1(x))  # Activation function between layers
-        x = F.relu(self.fc2(x))
-        # x = F.relu(self.fc23(x))
-        x = F.relu(self.fc3(x))
-        x = self.fc4(x)  # No activation, this will be included in the loss function
-        # x = self.softmax(x)
-        return x
-
-class GPT_PNN(nn.Module):
-    def __init__(self, input_size, num_labels):
-        super(GPT_PNN, self).__init__()
-        # Define the layers
-        self.fc1 = nn.Linear(input_size, 64)  # First dense layer, reduced size
-        self.bn1 = nn.BatchNorm1d(64)  # Batch Normalization for the first layer
-        self.dropout1 = nn.Dropout(0.5)  # Dropout with 50% probability
-        
-        # Commenting out to reduce model complexity
-        # self.fc2 = nn.Linear(128, 64)  # Second dense layer
-        # self.dropout2 = nn.Dropout(0.5)  # Additional dropout layer
-        
-        # Simplified to have fewer layers and neurons
-        self.fc2 = nn.Linear(64, 32)  # Reduced size for second dense layer
-        self.bn2 = nn.BatchNorm1d(32)  # Batch Normalization for the second layer
-        self.dropout2 = nn.Dropout(0.5)  # Dropout with 50% probability
-
-        # Output layer remains the same, adjusted for reduced prior layer size
-        self.fc3 = nn.Linear(32, num_labels)  # Output layer
-
-    def forward(self, x):
-        # x = x[:,::2] # try using every other wavelength
-        # Forward pass through the network with activations, batch normalization, and dropout
-        x = F.relu(self.bn1(self.fc1(x)))
-        x = self.dropout1(x)
-        x = F.relu(self.bn2(self.fc2(x)))
-        x = self.dropout2(x)
-        x = self.fc3(x)  # No activation here, use sigmoid or softmax outside if needed for binary classification
-        return x
-
-def load(config):
-
-    # n_channels = 1
-    n_features = config.input_size
-    
-    # mlp = PerceptronNN(n_features,2)
-
-    mlp = GPT_PNN(n_features,2)
-    
-    return mlp, "gpt_feedforward_halfLs"
\ No newline at end of file
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold1/model_fold1.ckpt-0 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold1/model_fold1.ckpt-0
deleted file mode 100644
index 26d8425..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold1/model_fold1.ckpt-0 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold1/model_fold1.ckpt-early_stop b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold1/model_fold1.ckpt-early_stop
deleted file mode 100644
index 0cd460b..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold1/model_fold1.ckpt-early_stop and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold1/results_dict.h5 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold1/results_dict.h5
deleted file mode 100644
index d089940..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold1/results_dict.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold1/results_dict_train.h5 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold1/results_dict_train.h5
deleted file mode 100644
index 9a3a720..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold1/results_dict_train.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold1/results_dict_val.h5 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold1/results_dict_val.h5
deleted file mode 100644
index c36c75b..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold1/results_dict_val.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold1/test_headings.txt b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold1/test_headings.txt
deleted file mode 100644
index 05c4825..0000000
--- a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold1/test_headings.txt
+++ /dev/null
@@ -1,4 +0,0 @@
-aaa0060
-aaa0061
-aaa0069
-aaa_0059
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold2/model_fold2.ckpt-0 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold2/model_fold2.ckpt-0
deleted file mode 100644
index ee5ba66..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold2/model_fold2.ckpt-0 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold2/results_dict.h5 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold2/results_dict.h5
deleted file mode 100644
index c6a6b9e..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold2/results_dict.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold2/results_dict_train.h5 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold2/results_dict_train.h5
deleted file mode 100644
index 38249e9..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold2/results_dict_train.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold2/results_dict_val.h5 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold2/results_dict_val.h5
deleted file mode 100644
index 74d141e..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold2/results_dict_val.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold2/test_headings.txt b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold2/test_headings.txt
deleted file mode 100644
index b87ab5e..0000000
--- a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold2/test_headings.txt
+++ /dev/null
@@ -1,3 +0,0 @@
-aaa0063
-aaa0066
-aaa_0051
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold3/model_fold3.ckpt-0 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold3/model_fold3.ckpt-0
deleted file mode 100644
index 1b3855a..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold3/model_fold3.ckpt-0 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold3/results_dict.h5 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold3/results_dict.h5
deleted file mode 100644
index 0cd8c75..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold3/results_dict.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold3/results_dict_train.h5 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold3/results_dict_train.h5
deleted file mode 100644
index a79c88a..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold3/results_dict_train.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold3/results_dict_val.h5 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold3/results_dict_val.h5
deleted file mode 100644
index e5251c9..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold3/results_dict_val.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold3/test_headings.txt b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold3/test_headings.txt
deleted file mode 100644
index 8417193..0000000
--- a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold3/test_headings.txt
+++ /dev/null
@@ -1,3 +0,0 @@
-aaa0043
-aaa0044
-aaa_0071
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold4/model_fold4.ckpt-0 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold4/model_fold4.ckpt-0
deleted file mode 100644
index 016ac92..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold4/model_fold4.ckpt-0 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold4/results_dict.h5 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold4/results_dict.h5
deleted file mode 100644
index 8f00dd7..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold4/results_dict.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold4/results_dict_train.h5 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold4/results_dict_train.h5
deleted file mode 100644
index 974558f..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold4/results_dict_train.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold4/results_dict_val.h5 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold4/results_dict_val.h5
deleted file mode 100644
index e50d7f2..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold4/results_dict_val.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold4/test_headings.txt b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold4/test_headings.txt
deleted file mode 100644
index ad5063c..0000000
--- a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold4/test_headings.txt
+++ /dev/null
@@ -1,3 +0,0 @@
-aaa0086
-aaa0087
-aaa_0072
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold5/model_fold5.ckpt-0 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold5/model_fold5.ckpt-0
deleted file mode 100644
index c8c47aa..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold5/model_fold5.ckpt-0 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold5/model_fold5.ckpt-24481 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold5/model_fold5.ckpt-24481
deleted file mode 100644
index b09492f..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold5/model_fold5.ckpt-24481 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold5/results_dict.h5 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold5/results_dict.h5
deleted file mode 100644
index f5b63bc..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold5/results_dict.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold5/results_dict_train.h5 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold5/results_dict_train.h5
deleted file mode 100644
index 9d84553..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold5/results_dict_train.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold5/results_dict_val.h5 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold5/results_dict_val.h5
deleted file mode 100644
index e5a9009..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold5/results_dict_val.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold5/test_headings.txt b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold5/test_headings.txt
deleted file mode 100644
index a4e6319..0000000
--- a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/data_fold5/test_headings.txt
+++ /dev/null
@@ -1,3 +0,0 @@
-aaa0064
-aaa_0053
-aaa_0054
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/events.out.tfevents.1709708956.MacBook-Pro-4.local.7010.0 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/events.out.tfevents.1709708956.MacBook-Pro-4.local.7010.0
deleted file mode 100644
index d6d7394..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/events.out.tfevents.1709708956.MacBook-Pro-4.local.7010.0 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/events.out.tfevents.1709709038.MacBook-Pro-4.local.7010.1 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/events.out.tfevents.1709709038.MacBook-Pro-4.local.7010.1
deleted file mode 100644
index dce9ab1..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/events.out.tfevents.1709709038.MacBook-Pro-4.local.7010.1 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/events.out.tfevents.1709709123.MacBook-Pro-4.local.7010.2 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/events.out.tfevents.1709709123.MacBook-Pro-4.local.7010.2
deleted file mode 100644
index cd83d3a..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/events.out.tfevents.1709709123.MacBook-Pro-4.local.7010.2 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/events.out.tfevents.1709709206.MacBook-Pro-4.local.7010.3 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/events.out.tfevents.1709709206.MacBook-Pro-4.local.7010.3
deleted file mode 100644
index 01fd2ab..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/events.out.tfevents.1709709206.MacBook-Pro-4.local.7010.3 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/events.out.tfevents.1709709291.MacBook-Pro-4.local.7010.4 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/events.out.tfevents.1709709291.MacBook-Pro-4.local.7010.4
deleted file mode 100644
index 35fd52e..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/events.out.tfevents.1709709291.MacBook-Pro-4.local.7010.4 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/flags.json b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/flags.json
deleted file mode 100644
index 08cf9e1..0000000
--- a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/flags.json
+++ /dev/null
@@ -1,28 +0,0 @@
-{
-    "batch_size": 100,
-    "beta1": 0.9,
-    "beta2": 0.999,
-    "cross_validate": true,
-    "data_config": "penn_dataset.py",
-    "git_commit": "7416bf730b356aabfe0df644240e40948a8196bb",
-    "include_coords": false,
-    "input_size": 39,
-    "learning_rate": 0.001,
-    "log_train_values": true,
-    "log_val_test": true,
-    "model_config": "basic_feedforward.py",
-    "model_name": "gpt-FCNN",
-    "n_repeats": 1,
-    "report_loss_every": 50,
-    "rescale": true,
-    "results_dir": "checkpoints",
-    "resume": false,
-    "run_name": "hyperparam_testing",
-    "save_check_points": 50,
-    "save_test_predictions": false,
-    "split_seed": 1,
-    "total_evaluations": 100,
-    "train_epochs": 20,
-    "train_split": 0.8,
-    "use_mps": false
-}
\ No newline at end of file
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/git_diff.txt b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/git_diff.txt
deleted file mode 100644
index 5d92aa6..0000000
--- a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/git_diff.txt
+++ /dev/null
@@ -1,1180 +0,0 @@
-Tue Mar 5 23:09:16 PST 2024
-diff --git a/.DS_Store b/.DS_Store
-index e2836a8..bf7630a 100644
-Binary files a/.DS_Store and b/.DS_Store differ
-diff --git a/.ipynb_checkpoints/basic_feedforward-checkpoint.py b/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-index 688c282..0c4bcd1 100644
---- a/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-+++ b/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-@@ -5,6 +5,12 @@ import numpy as np
- 
- from forge import flags
- 
-+flags.DEFINE_boolean(
-+    "model_with_dict",
-+    True,
-+    "Makes model output predictions in dictionary instead of directly."
-+)
-+
- class PerceptronNN(nn.Module):
-     def __init__(self, input_size, num_labels):
-         super(PerceptronNN, self).__init__()
-@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-+        self.softmax = nn.Softmax(dim=1)
- 
-     def forward(self, x):
-         # Forward pass through the network
-@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-         x = F.relu(self.fc2(x))
-         x = F.relu(self.fc3(x))
-         x = self.fc4(x)  # No activation, this will be included in the loss function
-+        x = self.softmax(x)
-         return x
- 
- def load(config):
-@@ -29,4 +37,4 @@ def load(config):
-     
-     mlp = PerceptronNN(n_features,2)
-     
--    return mlp
-\ No newline at end of file
-+    return mlp, "feedforward"
-\ No newline at end of file
-diff --git a/.ipynb_checkpoints/penn_dataset-checkpoint.py b/.ipynb_checkpoints/penn_dataset-checkpoint.py
-index aa2f5a0..bd95ece 100644
---- a/.ipynb_checkpoints/penn_dataset-checkpoint.py
-+++ b/.ipynb_checkpoints/penn_dataset-checkpoint.py
-@@ -15,16 +15,17 @@ from forge import flags
- # aspects of data managmement
- flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
- flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-+flags.DEFINE_boolean("cross_validate",True,"Do K-fold cross-validation")
- 
- # Job management
- # flags.DEFINE_integer("batch size",5,"training batch size")
- flags.DEFINE_float("train_split",0.8,'Fraction of data to use for training.')
--flags.DEFINE_integer("n_repeats",1,"Times to repeat K-fold cross-validation")
-+flags.DEFINE_integer("n_repeats",2,"Times to repeat K-fold cross-validation")
- flags.DEFINE_integer("split_seed",1,"Seed for KFold split (integer for reproducibility")
- 
- # "wavelengths between 0.05 and 1 mm in 0.025 mm increments."
- LSPACE = np.arange(0.05,1.05,0.025) # corresponds to 39 non-coord columns of data
--L_INDS = None
-+L_INDS = None # specific indices of data to select
- 
- DATAFOLDER = './penn_data'
- 
-@@ -40,10 +41,12 @@ class PennData(Dataset):
- 
-         df_list = []
-         label_list = []
--        for heading in self.headings: # for each datafile heading,
-+        for idx,heading in enumerate(self.headings): # for each datafile heading,
-             data_name = osp.join(self.data_dir,spectra_prefix + heading+'.csv') # read kvals
-             df_temp = pd.read_csv(data_name,header=None)
-+            df_temp['h_idx'] = idx
-             df_list.append(df_temp)
-+            
- 
-             label_name = osp.join(self.data_dir,label_prefix + heading + '.csv') # read labels
-             label_temp = pd.read_csv(label_name,header=None, names=['label'])
-@@ -57,18 +60,23 @@ class PennData(Dataset):
-         all_labels = df['label'].to_numpy()
-         all_data = df.iloc[:,1:].to_numpy()
- 
-+        # if include_coords:
-+        #     kstart = 3
-+        # else:
-+        #     kstart = 0
-+
-         if rescale: # rescale (normalize) wavelength intensity data
--            lambdas = all_data[:,2:] # wavelengths
-+            lambdas = all_data[:,3:] # wavelengths
-             lam_std = np.std(lambdas, axis=0)  # Calculate standard deviation along columns
-             lam_mean = np.mean(lambdas, axis=0)  # Calculate mean along columns
-             lambdas_rescaled = (lambdas - lam_mean) / lam_std 
--            all_data[:,2:] = lambdas_rescaled
-+            all_data[:,3:] = lambdas_rescaled
- 
--        if not include_coords: # removes x,y coordinates from data
--            all_data = all_data[:,2:]
--        
--        if k_inds != None: # in this case, only use subset of wavelengths
--            all_data = all_data[:,np.array(k_inds)]
-+        # if k_inds != None: # THIS DOES NOT MAKE SENSE HERE
-+        #     all_data[:,3:] = all_data[:,np.array(k_inds)]
-+
-+        if not include_coords: # removes x,y coordinates (and heading index) from data
-+            all_data = all_data[:,3:]
- 
-         self.all_data = all_data
-         self.all_labels = all_labels
-@@ -109,15 +117,15 @@ def load(config):
-         
-         # set up training DataLoader
-         train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, n_train),num_workers=0,shuffle = True)
-+        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
- 
-         # set up test DataLoader
-         test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, n_test),num_workers=0,shuffle = True)
-+        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
- 
-         # set up val DataLoader
-         val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, n_val),num_workers=0,shuffle = True)
-+        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-         
- 
-         dataloaders = {'train':train_loader, 
-@@ -125,8 +133,12 @@ def load(config):
-                        'val':val_loader,
-                        'train_inds':train_ind,
-                        'test_inds':test_ind,
--                       'n_val':n_val
-+                       'n_val':n_val,
-+                       'test_headings':list(HEADINGS[test_ind])
-                       }
-         kf_dataloaders.append(dataloaders)
- 
-+        if not config.cross_validate:
-+        	break
-+
-     return kf_dataloaders
-diff --git a/__pycache__/basic_feedforward.cpython-39.pyc b/__pycache__/basic_feedforward.cpython-39.pyc
-index f541140..4a02232 100644
-Binary files a/__pycache__/basic_feedforward.cpython-39.pyc and b/__pycache__/basic_feedforward.cpython-39.pyc differ
-diff --git a/__pycache__/penn_dataset.cpython-39.pyc b/__pycache__/penn_dataset.cpython-39.pyc
-index 0d7a4de..cf395be 100644
-Binary files a/__pycache__/penn_dataset.cpython-39.pyc and b/__pycache__/penn_dataset.cpython-39.pyc differ
-diff --git a/basic_feedforward.py b/basic_feedforward.py
-index 688c282..c36011b 100644
---- a/basic_feedforward.py
-+++ b/basic_feedforward.py
-@@ -5,21 +5,61 @@ import numpy as np
- 
- from forge import flags
- 
-+# flags.DEFINE_boolean(
-+#     "model_with_dict",
-+#     True,
-+#     "Makes model output predictions in dictionary instead of directly."
-+# )
-+
- class PerceptronNN(nn.Module):
-     def __init__(self, input_size, num_labels):
-         super(PerceptronNN, self).__init__()
-         # Define the layers
-         self.fc1 = nn.Linear(input_size, 128)  # First dense layer
-         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-+        # self.fc23 = nn.Linear(64,64)
-         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-+        # self.softmax = nn.Softmax(dim=1)
- 
-     def forward(self, x):
-         # Forward pass through the network
-         x = F.relu(self.fc1(x))  # Activation function between layers
-         x = F.relu(self.fc2(x))
-+        # x = F.relu(self.fc23(x))
-         x = F.relu(self.fc3(x))
-         x = self.fc4(x)  # No activation, this will be included in the loss function
-+        # x = self.softmax(x)
-+        return x
-+
-+class GPT_PNN(nn.Module):
-+    def __init__(self, input_size, num_labels):
-+        super(GPT_PNN, self).__init__()
-+        # Define the layers
-+        self.fc1 = nn.Linear(input_size, 64)  # First dense layer, reduced size
-+        self.bn1 = nn.BatchNorm1d(64)  # Batch Normalization for the first layer
-+        self.dropout1 = nn.Dropout(0.5)  # Dropout with 50% probability
-+        
-+        # Commenting out to reduce model complexity
-+        # self.fc2 = nn.Linear(128, 64)  # Second dense layer
-+        # self.dropout2 = nn.Dropout(0.5)  # Additional dropout layer
-+        
-+        # Simplified to have fewer layers and neurons
-+        self.fc2 = nn.Linear(64, 32)  # Reduced size for second dense layer
-+        self.bn2 = nn.BatchNorm1d(32)  # Batch Normalization for the second layer
-+        self.dropout2 = nn.Dropout(0.5)  # Dropout with 50% probability
-+
-+        # Output layer remains the same, adjusted for reduced prior layer size
-+        self.fc3 = nn.Linear(32, num_labels)  # Output layer
-+
-+    def forward(self, x):
-+        # x = x[:,::2] # try using every other wavelength
-+        # Forward pass through the network with activations, batch normalization, and dropout
-+        x = F.relu(self.bn1(self.fc1(x)))
-+        x = self.dropout1(x)
-+        x = F.relu(self.bn2(self.fc2(x)))
-+        x = self.dropout2(x)
-+        x = self.fc3(x)  # No activation here, use sigmoid or softmax outside if needed for binary classification
-         return x
- 
- def load(config):
-@@ -27,6 +67,8 @@ def load(config):
-     # n_channels = 1
-     n_features = config.input_size
-     
--    mlp = PerceptronNN(n_features,2)
-+    # mlp = PerceptronNN(n_features,2)
-+
-+    mlp = GPT_PNN(n_features,2)
-     
--    return mlp
-\ No newline at end of file
-+    return mlp, "gpt_feedforward_halfLs"
-\ No newline at end of file
-diff --git a/checkpoints/feedforward/1/basic_feedforward.py b/checkpoints/feedforward/1/basic_feedforward.py
-deleted file mode 100644
-index 688c282..0000000
---- a/checkpoints/feedforward/1/basic_feedforward.py
-+++ /dev/null
-@@ -1,32 +0,0 @@
--import torch
--import torch.nn as nn
--import torch.nn.functional as F
--import numpy as np
--
--from forge import flags
--
--class PerceptronNN(nn.Module):
--    def __init__(self, input_size, num_labels):
--        super(PerceptronNN, self).__init__()
--        # Define the layers
--        self.fc1 = nn.Linear(input_size, 128)  # First dense layer
--        self.fc2 = nn.Linear(128, 64)         # Second dense layer
--        self.fc3 = nn.Linear(64, 64)          # Third dense layer
--        self.fc4 = nn.Linear(64, num_labels)  # Output layer
--
--    def forward(self, x):
--        # Forward pass through the network
--        x = F.relu(self.fc1(x))  # Activation function between layers
--        x = F.relu(self.fc2(x))
--        x = F.relu(self.fc3(x))
--        x = self.fc4(x)  # No activation, this will be included in the loss function
--        return x
--
--def load(config):
--
--    # n_channels = 1
--    n_features = config.input_size
--    
--    mlp = PerceptronNN(n_features,2)
--    
--    return mlp
-\ No newline at end of file
-diff --git a/checkpoints/feedforward/1/flags.json b/checkpoints/feedforward/1/flags.json
-deleted file mode 100644
-index 1d000c3..0000000
---- a/checkpoints/feedforward/1/flags.json
-+++ /dev/null
-@@ -1,17 +0,0 @@
--{
--    "batch_size": 100,
--    "data_config": "penn_dataset.py",
--    "include_coords": false,
--    "input_size": 39,
--    "learning_rate": 1e-05,
--    "model_config": "basic_feedforward.py",
--    "n_repeats": 1,
--    "report_loss_every": 50,
--    "rescale": true,
--    "results_dir": "checkpoints",
--    "resume": false,
--    "run_name": "feedforward",
--    "split_seed": 1,
--    "train_epochs": 20,
--    "train_split": 0.8
--}
-\ No newline at end of file
-diff --git a/checkpoints/feedforward/1/git_diff.txt b/checkpoints/feedforward/1/git_diff.txt
-deleted file mode 100644
-index 7b37e6f..0000000
---- a/checkpoints/feedforward/1/git_diff.txt
-+++ /dev/null
-@@ -1 +0,0 @@
--Mon Mar 4 11:45:48 PST 2024
-diff --git a/checkpoints/feedforward/1/penn_dataset.py b/checkpoints/feedforward/1/penn_dataset.py
-deleted file mode 100644
-index aa2f5a0..0000000
---- a/checkpoints/feedforward/1/penn_dataset.py
-+++ /dev/null
-@@ -1,132 +0,0 @@
--import os
--import torch
--import pandas as pd
--import numpy as np
--
--from torchvision import datasets, transforms
--from torch.utils.data import Dataset, DataLoader
--from sklearn.model_selection import RepeatedKFold
--
--from os import path as osp
--import forge
--from forge import flags
--
--
--# aspects of data managmement
--flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
--flags.DEFINE_boolean("rescale", True, "Rescales intensities")
--
--# Job management
--# flags.DEFINE_integer("batch size",5,"training batch size")
--flags.DEFINE_float("train_split",0.8,'Fraction of data to use for training.')
--flags.DEFINE_integer("n_repeats",1,"Times to repeat K-fold cross-validation")
--flags.DEFINE_integer("split_seed",1,"Seed for KFold split (integer for reproducibility")
--
--# "wavelengths between 0.05 and 1 mm in 0.025 mm increments."
--LSPACE = np.arange(0.05,1.05,0.025) # corresponds to 39 non-coord columns of data
--L_INDS = None
--
--DATAFOLDER = './penn_data'
--
--HEADINGS = np.array(['aaa0043','aaa0044','aaa0060','aaa0061','aaa0063','aaa0064','aaa0066','aaa0069','aaa0086','aaa0087','aaa_0051','aaa_0053','aaa_0054','aaa_0059','aaa_0071','aaa_0072'])
--
--
--class PennData(Dataset):
--
--    def __init__(self,path_to_data,headings,k_inds = None,include_coords = True,rescale = True,spectra_prefix = "kvals_fuse_rotate_",label_prefix = 'labels_fuse_rotate_'):
--        
--        self.data_dir = path_to_data
--        self.headings = headings
--
--        df_list = []
--        label_list = []
--        for heading in self.headings: # for each datafile heading,
--            data_name = osp.join(self.data_dir,spectra_prefix + heading+'.csv') # read kvals
--            df_temp = pd.read_csv(data_name,header=None)
--            df_list.append(df_temp)
--
--            label_name = osp.join(self.data_dir,label_prefix + heading + '.csv') # read labels
--            label_temp = pd.read_csv(label_name,header=None, names=['label'])
--            label_list.append(label_temp)
--
--        df = pd.concat(df_list, ignore_index=True)
--
--        labels = pd.concat(label_list, ignore_index=True)
--        df = pd.concat([labels, df], axis="columns") # Append labels to data
--
--        all_labels = df['label'].to_numpy()
--        all_data = df.iloc[:,1:].to_numpy()
--
--        if rescale: # rescale (normalize) wavelength intensity data
--            lambdas = all_data[:,2:] # wavelengths
--            lam_std = np.std(lambdas, axis=0)  # Calculate standard deviation along columns
--            lam_mean = np.mean(lambdas, axis=0)  # Calculate mean along columns
--            lambdas_rescaled = (lambdas - lam_mean) / lam_std 
--            all_data[:,2:] = lambdas_rescaled
--
--        if not include_coords: # removes x,y coordinates from data
--            all_data = all_data[:,2:]
--        
--        if k_inds != None: # in this case, only use subset of wavelengths
--            all_data = all_data[:,np.array(k_inds)]
--
--        self.all_data = all_data
--        self.all_labels = all_labels
--
--    def __len__(self):
--        return len(self.all_data)
--
--    def __getitem__(self,i):
--        state = {'label':self.all_labels[i],'data':self.all_data[i]}
--        return state
--
--    def __getstate__(self):
--        state = {
--            'data': self.all_data,
--            'label': self.all_labels,
--                }
--        return state
--
--    def __setstate__(self, state):
--        # Set the object's state from the provided dictionary
--        self.all_data = state['data']
--        self.all_labels = state['label']
--        
--
--
--def load(config):
--
--    n_splits = int(len(HEADINGS)/((1-config.train_split)*len(HEADINGS)))
--
--    kf = RepeatedKFold(n_splits = n_splits, n_repeats = config.n_repeats, random_state = config.split_seed) # K-fold cross validation
--
--    kf_dataloaders = []
--
--    for i, (train_ind, test_ind) in enumerate(kf.split(HEADINGS)): # for each K-fold split, 
--        n_val = len(test_ind)//2
--        n_test = len(test_ind)-n_val   
--        n_train = len(train_ind)
--        
--        # set up training DataLoader
--        train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, n_train),num_workers=0,shuffle = True)
--
--        # set up test DataLoader
--        test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, n_test),num_workers=0,shuffle = True)
--
--        # set up val DataLoader
--        val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, n_val),num_workers=0,shuffle = True)
--        
--
--        dataloaders = {'train':train_loader, 
--                       'test':test_loader,
--                       'val':val_loader,
--                       'train_inds':train_ind,
--                       'test_inds':test_ind,
--                       'n_val':n_val
--                      }
--        kf_dataloaders.append(dataloaders)
--
--    return kf_dataloaders
-diff --git a/georgehulsey_2024.pdf b/georgehulsey_2024.pdf
-deleted file mode 100644
-index 1ab17f6..0000000
-Binary files a/georgehulsey_2024.pdf and /dev/null differ
-diff --git a/penn_dataset.py b/penn_dataset.py
-index aa2f5a0..4f4221c 100644
---- a/penn_dataset.py
-+++ b/penn_dataset.py
-@@ -15,6 +15,7 @@ from forge import flags
- # aspects of data managmement
- flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
- flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-+flags.DEFINE_boolean("cross_validate",True,"Do K-fold cross-validation")
- 
- # Job management
- # flags.DEFINE_integer("batch size",5,"training batch size")
-@@ -24,7 +25,7 @@ flags.DEFINE_integer("split_seed",1,"Seed for KFold split (integer for reproduci
- 
- # "wavelengths between 0.05 and 1 mm in 0.025 mm increments."
- LSPACE = np.arange(0.05,1.05,0.025) # corresponds to 39 non-coord columns of data
--L_INDS = None
-+L_INDS = None # specific indices of data to select
- 
- DATAFOLDER = './penn_data'
- 
-@@ -40,10 +41,12 @@ class PennData(Dataset):
- 
-         df_list = []
-         label_list = []
--        for heading in self.headings: # for each datafile heading,
-+        for idx,heading in enumerate(self.headings): # for each datafile heading,
-             data_name = osp.join(self.data_dir,spectra_prefix + heading+'.csv') # read kvals
-             df_temp = pd.read_csv(data_name,header=None)
-+            df_temp['h_idx'] = idx
-             df_list.append(df_temp)
-+            
- 
-             label_name = osp.join(self.data_dir,label_prefix + heading + '.csv') # read labels
-             label_temp = pd.read_csv(label_name,header=None, names=['label'])
-@@ -57,18 +60,23 @@ class PennData(Dataset):
-         all_labels = df['label'].to_numpy()
-         all_data = df.iloc[:,1:].to_numpy()
- 
-+        # if include_coords:
-+        #     kstart = 3
-+        # else:
-+        #     kstart = 0
-+
-         if rescale: # rescale (normalize) wavelength intensity data
--            lambdas = all_data[:,2:] # wavelengths
-+            lambdas = all_data[:,3:] # wavelengths
-             lam_std = np.std(lambdas, axis=0)  # Calculate standard deviation along columns
-             lam_mean = np.mean(lambdas, axis=0)  # Calculate mean along columns
-             lambdas_rescaled = (lambdas - lam_mean) / lam_std 
--            all_data[:,2:] = lambdas_rescaled
-+            all_data[:,3:] = lambdas_rescaled
- 
--        if not include_coords: # removes x,y coordinates from data
--            all_data = all_data[:,2:]
--        
--        if k_inds != None: # in this case, only use subset of wavelengths
--            all_data = all_data[:,np.array(k_inds)]
-+        # if k_inds != None: # THIS DOES NOT MAKE SENSE HERE
-+        #     all_data[:,3:] = all_data[:,np.array(k_inds)]
-+
-+        if not include_coords: # removes x,y coordinates (and heading index) from data
-+            all_data = all_data[:,3:]
- 
-         self.all_data = all_data
-         self.all_labels = all_labels
-@@ -109,15 +117,15 @@ def load(config):
-         
-         # set up training DataLoader
-         train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, n_train),num_workers=0,shuffle = True)
-+        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
- 
-         # set up test DataLoader
-         test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, n_test),num_workers=0,shuffle = True)
-+        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
- 
-         # set up val DataLoader
-         val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, n_val),num_workers=0,shuffle = True)
-+        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-         
- 
-         dataloaders = {'train':train_loader, 
-@@ -125,8 +133,12 @@ def load(config):
-                        'val':val_loader,
-                        'train_inds':train_ind,
-                        'test_inds':test_ind,
--                       'n_val':n_val
-+                       'n_val':n_val,
-+                       'test_headings':list(HEADINGS[test_ind])
-                       }
-         kf_dataloaders.append(dataloaders)
- 
-+        if not config.cross_validate:
-+        	break
-+
-     return kf_dataloaders
-diff --git a/testing.ipynb b/testing.ipynb
-index e5a167b..0110538 100644
---- a/testing.ipynb
-+++ b/testing.ipynb
-@@ -2,7 +2,7 @@
-  "cells": [
-   {
-    "cell_type": "code",
--   "execution_count": 1,
-+   "execution_count": 4,
-    "id": "4dee7ff1-01a4-4038-b493-9729ff3693f7",
-    "metadata": {},
-    "outputs": [],
-@@ -23,7 +23,7 @@
-   },
-   {
-    "cell_type": "code",
--   "execution_count": 2,
-+   "execution_count": 6,
-    "id": "cad0fdc8-5c35-4610-bba3-b71e60dc1b98",
-    "metadata": {},
-    "outputs": [],
-@@ -35,7 +35,7 @@
-   },
-   {
-    "cell_type": "code",
--   "execution_count": 3,
-+   "execution_count": 7,
-    "id": "ce1b936b-8a7c-426e-a3aa-3c1c38f645de",
-    "metadata": {},
-    "outputs": [
-@@ -54,8 +54,8 @@
-   },
-   {
-    "cell_type": "code",
--   "execution_count": 9,
--   "id": "e862b7e2-57f5-44bf-bcf1-a91160ba66cc",
-+   "execution_count": 5,
-+   "id": "4469cddf-4dac-4468-be88-241d440401c3",
-    "metadata": {},
-    "outputs": [
-     {
-@@ -67,35 +67,98 @@
-     }
-    ],
-    "source": [
--    "model = fet.load(\"basic_feedforward.py\",config)"
-+    "model,modelname = fet.load(\"basic_feedforward.py\",config)"
-    ]
-   },
-   {
-    "cell_type": "code",
--   "execution_count": 10,
--   "id": "07e0b160-d5d1-4e54-b4a7-ccaf2224598a",
-+   "execution_count": 13,
-+   "id": "7c9a9fe9-f5e8-456a-b964-4be13027725b",
-    "metadata": {},
-    "outputs": [
-     {
-      "data": {
-       "text/plain": [
--       "PerceptronNN(\n",
--       "  (fc1): Linear(in_features=39, out_features=128, bias=True)\n",
--       "  (fc2): Linear(in_features=128, out_features=64, bias=True)\n",
--       "  (fc3): Linear(in_features=64, out_features=64, bias=True)\n",
--       "  (fc4): Linear(in_features=64, out_features=2, bias=True)\n",
--       ")"
-+       "array([114170,    904])"
-       ]
-      },
--     "execution_count": 10,
-+     "execution_count": 13,
-      "metadata": {},
-      "output_type": "execute_result"
-     }
-    ],
-    "source": [
--    "model"
-+    "np.bincount(loaddat[0]['train'].dataset.all_labels)"
-    ]
-   },
-+  {
-+   "cell_type": "code",
-+   "execution_count": 1,
-+   "id": "e862b7e2-57f5-44bf-bcf1-a91160ba66cc",
-+   "metadata": {},
-+   "outputs": [
-+    {
-+     "ename": "FileNotFoundError",
-+     "evalue": "[Errno 2] Unable to open file (unable to open file: name = './checkpoints/feedforward/2/data_fold1/results_dict.h5', errno = 2, error message = 'No such file or directory', flags = 0, o_flags = 0)",
-+     "output_type": "error",
-+     "traceback": [
-+      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
-+      "\u001b[0;31mFileNotFoundError\u001b[0m                         Traceback (most recent call last)",
-+      "Cell \u001b[0;32mIn[1], line 5\u001b[0m\n\u001b[1;32m      3\u001b[0m file_path \u001b[38;5;241m=\u001b[39m \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124m./checkpoints/feedforward/2/data_fold1/results_dict.h5\u001b[39m\u001b[38;5;124m\"\u001b[39m\n\u001b[1;32m      4\u001b[0m \u001b[38;5;66;03m# Replace 'your_file.h5' with the actual path to your file\u001b[39;00m\n\u001b[0;32m----> 5\u001b[0m f \u001b[38;5;241m=\u001b[39m  \u001b[43mh5py\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mFile\u001b[49m\u001b[43m(\u001b[49m\u001b[43mfile_path\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[38;5;124;43mr\u001b[39;49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[43m)\u001b[49m \n\u001b[1;32m      7\u001b[0m     \u001b[38;5;66;03m# Get information about the data stored in the file\u001b[39;00m\n\u001b[1;32m      8\u001b[0m \u001b[38;5;28mprint\u001b[39m(\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mKeys:\u001b[39m\u001b[38;5;124m\"\u001b[39m, \u001b[38;5;28mlist\u001b[39m(f\u001b[38;5;241m.\u001b[39mkeys()))\n",
-+      "File \u001b[0;32m/Applications/miniconda3/envs/lietransformer/lib/python3.9/site-packages/h5py/_hl/files.py:562\u001b[0m, in \u001b[0;36mFile.__init__\u001b[0;34m(self, name, mode, driver, libver, userblock_size, swmr, rdcc_nslots, rdcc_nbytes, rdcc_w0, track_order, fs_strategy, fs_persist, fs_threshold, fs_page_size, page_buf_size, min_meta_keep, min_raw_keep, locking, alignment_threshold, alignment_interval, meta_block_size, **kwds)\u001b[0m\n\u001b[1;32m    553\u001b[0m     fapl \u001b[38;5;241m=\u001b[39m make_fapl(driver, libver, rdcc_nslots, rdcc_nbytes, rdcc_w0,\n\u001b[1;32m    554\u001b[0m                      locking, page_buf_size, min_meta_keep, min_raw_keep,\n\u001b[1;32m    555\u001b[0m                      alignment_threshold\u001b[38;5;241m=\u001b[39malignment_threshold,\n\u001b[1;32m    556\u001b[0m                      alignment_interval\u001b[38;5;241m=\u001b[39malignment_interval,\n\u001b[1;32m    557\u001b[0m                      meta_block_size\u001b[38;5;241m=\u001b[39mmeta_block_size,\n\u001b[1;32m    558\u001b[0m                      \u001b[38;5;241m*\u001b[39m\u001b[38;5;241m*\u001b[39mkwds)\n\u001b[1;32m    559\u001b[0m     fcpl \u001b[38;5;241m=\u001b[39m make_fcpl(track_order\u001b[38;5;241m=\u001b[39mtrack_order, fs_strategy\u001b[38;5;241m=\u001b[39mfs_strategy,\n\u001b[1;32m    560\u001b[0m                      fs_persist\u001b[38;5;241m=\u001b[39mfs_persist, fs_threshold\u001b[38;5;241m=\u001b[39mfs_threshold,\n\u001b[1;32m    561\u001b[0m                      fs_page_size\u001b[38;5;241m=\u001b[39mfs_page_size)\n\u001b[0;32m--> 562\u001b[0m     fid \u001b[38;5;241m=\u001b[39m \u001b[43mmake_fid\u001b[49m\u001b[43m(\u001b[49m\u001b[43mname\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mmode\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43muserblock_size\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mfapl\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mfcpl\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mswmr\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43mswmr\u001b[49m\u001b[43m)\u001b[49m\n\u001b[1;32m    564\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;28misinstance\u001b[39m(libver, \u001b[38;5;28mtuple\u001b[39m):\n\u001b[1;32m    565\u001b[0m     \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_libver \u001b[38;5;241m=\u001b[39m libver\n",
-+      "File \u001b[0;32m/Applications/miniconda3/envs/lietransformer/lib/python3.9/site-packages/h5py/_hl/files.py:235\u001b[0m, in \u001b[0;36mmake_fid\u001b[0;34m(name, mode, userblock_size, fapl, fcpl, swmr)\u001b[0m\n\u001b[1;32m    233\u001b[0m     \u001b[38;5;28;01mif\u001b[39;00m swmr \u001b[38;5;129;01mand\u001b[39;00m swmr_support:\n\u001b[1;32m    234\u001b[0m         flags \u001b[38;5;241m|\u001b[39m\u001b[38;5;241m=\u001b[39m h5f\u001b[38;5;241m.\u001b[39mACC_SWMR_READ\n\u001b[0;32m--> 235\u001b[0m     fid \u001b[38;5;241m=\u001b[39m \u001b[43mh5f\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mopen\u001b[49m\u001b[43m(\u001b[49m\u001b[43mname\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mflags\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mfapl\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43mfapl\u001b[49m\u001b[43m)\u001b[49m\n\u001b[1;32m    236\u001b[0m \u001b[38;5;28;01melif\u001b[39;00m mode \u001b[38;5;241m==\u001b[39m \u001b[38;5;124m'\u001b[39m\u001b[38;5;124mr+\u001b[39m\u001b[38;5;124m'\u001b[39m:\n\u001b[1;32m    237\u001b[0m     fid \u001b[38;5;241m=\u001b[39m h5f\u001b[38;5;241m.\u001b[39mopen(name, h5f\u001b[38;5;241m.\u001b[39mACC_RDWR, fapl\u001b[38;5;241m=\u001b[39mfapl)\n",
-+      "File \u001b[0;32mh5py/_objects.pyx:54\u001b[0m, in \u001b[0;36mh5py._objects.with_phil.wrapper\u001b[0;34m()\u001b[0m\n",
-+      "File \u001b[0;32mh5py/_objects.pyx:55\u001b[0m, in \u001b[0;36mh5py._objects.with_phil.wrapper\u001b[0;34m()\u001b[0m\n",
-+      "File \u001b[0;32mh5py/h5f.pyx:102\u001b[0m, in \u001b[0;36mh5py.h5f.open\u001b[0;34m()\u001b[0m\n",
-+      "\u001b[0;31mFileNotFoundError\u001b[0m: [Errno 2] Unable to open file (unable to open file: name = './checkpoints/feedforward/2/data_fold1/results_dict.h5', errno = 2, error message = 'No such file or directory', flags = 0, o_flags = 0)"
-+     ]
-+    }
-+   ],
-+   "source": [
-+    "import h5py\n",
-+    "\n",
-+    "file_path = \"./checkpoints/feedforward/2/data_fold1/results_dict.h5\"\n",
-+    "# Replace 'your_file.h5' with the actual path to your file\n",
-+    "f =  h5py.File(file_path, 'r') \n",
-+    "\n",
-+    "    # Get information about the data stored in the file\n",
-+    "print(\"Keys:\", list(f.keys()))  # List the top-level datasets and groups\n",
-+    "\n",
-+    "    # # Access a dataset by its name\n",
-+    "    # dataset_name = \"your_dataset_name\"\n",
-+    "    # if dataset_name in f:\n",
-+    "    #     dataset = f[dataset_name]\n",
-+    "    #     print(\"Dataset shape:\", dataset.shape)\n",
-+    "    #     print(\"Dataset dtype:\", dataset.dtype)\n",
-+    "\n",
-+    "    #     # Access the data as a NumPy array\n",
-+    "    #     data = dataset[:]  # Read the entire dataset\n",
-+    "\n",
-+    "    #     # You can now work with the data as needed, for example:\n",
-+    "    #     # Perform calculations, visualizations, etc.\n",
-+    "    # else:\n",
-+    "    #     print(f\"Dataset '{dataset_name}' not found in the file.\")"
-+   ]
-+  },
-+  {
-+   "cell_type": "code",
-+   "execution_count": 13,
-+   "id": "07e0b160-d5d1-4e54-b4a7-ccaf2224598a",
-+   "metadata": {},
-+   "outputs": [
-+    {
-+     "data": {
-+      "text/plain": [
-+       "<generator object Module.parameters at 0x3007207b0>"
-+      ]
-+     },
-+     "execution_count": 13,
-+     "metadata": {},
-+     "output_type": "execute_result"
-+    }
-+   ],
-+   "source": []
-+  },
-   {
-    "cell_type": "code",
-    "execution_count": null,
-diff --git a/train.py b/train.py
-index c266102..0b4a6a1 100644
---- a/train.py
-+++ b/train.py
-@@ -1,49 +1,464 @@
- from os import path as osp
-+import os
-+import numpy as np
-+import time
- 
- import torch
-+import torch.nn as nn
- import torch.nn.functional as F
- import torch.optim as optim
--
--import numpy as np
-+from torch.utils.tensorboard import SummaryWriter
- 
- import forge
- from forge import flags
- import forge.experiment_tools as fet
- 
-+from train_tools import (
-+	log_tensorboard,
-+	parse_reports,
-+	parse_reports_cpu,
-+	print_reports,
-+	load_checkpoint,
-+	save_checkpoint,
-+	nested_to,
-+	param_count,
-+)
-+
-+from copy import deepcopy
-+from attrdict import AttrDict
-+import deepdish as dd
-+from tqdm import tqdm
-+
-+# For reproducibility while researching, but might affect speed!
-+torch.backends.cudnn.deterministic = False
-+torch.backends.cudnn.benchmark = False
-+torch.manual_seed(0)
-+
- 
- # Job config
- flags.DEFINE_string('data_config', 'penn_dataset.py',
--                    'Path to a data config file.')
-+					'Path to a data config file.')
- flags.DEFINE_string('model_config', 'basic_feedforward.py',
--                    'Path to a model config file.')
-+					'Path to a model config file.')
- flags.DEFINE_string('results_dir', 'checkpoints',
--                    'Top directory for all experimental results.')
--flags.DEFINE_string('run_name', 'feedforward',
--                    'Name of this job and name of results folder.')
-+					'Top directory for all experimental results.')
-+flags.DEFINE_string('model_name', 'gpt-FCNN',
-+					'shorthand name for model.')
-+flags.DEFINE_string('run_name', 'hyperparam_testing',
-+					'Name of this job and name of results folder.')
- flags.DEFINE_boolean('resume', False, 'Tries to resume a job if True.')
- 
- # Logging config
- flags.DEFINE_integer('report_loss_every', 50,
--                     'Number of iterations between reporting minibatch loss.')
-+					 'Number of iterations between reporting minibatch loss.')
- flags.DEFINE_integer('train_epochs', 20, 'Maximum number of training epochs.')
-+flags.DEFINE_integer(
-+	"save_check_points",
-+	50,
-+	"frequency with which to save checkpoints, in number of epoches.",
-+)
-+flags.DEFINE_boolean("log_train_values", True, "Logs train values if True.")
-+flags.DEFINE_integer(
-+	"total_evaluations",
-+	100,
-+	"Maximum number of evaluations on test and validation data during training.",
-+)
-+flags.DEFINE_boolean(
-+	"save_test_predictions",
-+	False,
-+	"Makes and saves test predictions on one or more test sets (e.g. 5-step and 100-step predictions) at the end of training.",
-+)
-+flags.DEFINE_boolean(
-+    "log_val_test", True, "Turns off computation of validation and test errors."
-+)
-+
-+flags.DEFINE_boolean('use_mps',False,"Use Metal Performance Shaders (M1) for training.")
- 
- # Experiment config
- flags.DEFINE_integer('batch_size', 100, 'Mini-batch size.')
--flags.DEFINE_float('learning_rate', 1e-5, 'SGD learning rate.')
-+flags.DEFINE_float("learning_rate", 1e-3, "Adam learning rate.")
-+flags.DEFINE_float("beta1", 0.9, "Adam Beta 1 parameter")
-+flags.DEFINE_float("beta2", 0.999, "Adam Beta 2 parameter")
- 
- # Specific config options
- flags.DEFINE_integer("input_size",39,"Input shape to model")
- 
-+#########################################################################################
-+
-+def evaluate(model, loader, device,fold = 0,headings = [],loss_func = nn.CrossEntropyLoss()):
-+	# this function does not account for class weights when evaluating cross-entropy loss.
-+	# however, they are accounted for when evaluating training loss
-+	reports = None
-+	for data in loader:
-+		labels = data['label']
-+		inputs = nested_to(data['data'],device,torch.float32)
-+		
-+		labels_tensor = torch.zeros((len(labels), 2))
-+		for i, label in enumerate(labels):
-+			labels_tensor[i, label] = 1
-+
-+		model_output = model(inputs) # evaluate model
-+
-+		loss = loss_func(model_output, labels_tensor) # compute loss
-+		outputs = AttrDict({"loss": loss, "prediction": model_output,'data_fold':fold})
-+		outputs.reports = AttrDict({"cross_entropy": loss})
-+
-+		if reports is None:
-+			reports = {k: v.detach().clone().cpu() for k, v in outputs.reports.items()}
-+		else:
-+			for k, v in outputs.reports.items():
-+				reports[k] += v.detach().clone().cpu()
-+
-+	for k, v in reports.items():
-+		reports[k] = v / len(
-+			loader
-+		)  # SZ: note this can be slightly incorrect if mini-batch sizes vary (if batch_size doesn't divide train_size), but approximately correct.
-+
-+	# reports['test_headings'] = np.array(headings)
-+
-+	return reports
-+
-+def main():
-+
-+	config = forge.config()
-+
-+	# Set device
-+	if torch.cuda.is_available():
-+		device = f"cuda:{config.device}"
-+		torch.cuda.set_device(device)
-+	else:
-+		device = "cpu" # can change this to MPS on M1 Macs
-+
-+	if config.use_mps:
-+		device = "mps"
-+
-+	# Load data
-+	data_name = "penn_data"
-+	kfold_loaders = fet.load(config.data_config, config)
-+
-+	# Prepare environment
-+	params_in_run_name = [
-+		("batch_size", "bs"),
-+		("learning_rate", "lr"),
-+		("n_train", "ntrain"),
-+		("include_coords",'inclx'),
-+		("input_size",'inpsize'),
-+		("cross_validate",'crval'),
-+		("train_epochs",'n_epochs'),
-+		("n_repeats",'nrep')
-+	]
-+
-+	run_name = ""  # config.run_name
-+	for config_param in params_in_run_name:
-+		attr = config_param[0]
-+		abbrev = config_param[1]
-+
-+		if hasattr(config, attr):
-+			run_name += abbrev
-+			run_name += str(getattr(config, attr))
-+			run_name += "_"
-+
-+	results_folder_name = osp.join(
-+		data_name,
-+		config.model_name,
-+		config.run_name,
-+		run_name,
-+	)
-+
-+	# Prepare environment
-+	logdir = osp.join(config.results_dir, results_folder_name.replace(".", "_"))
-+	logdir, resume_checkpoint = fet.init_checkpoint(
-+		logdir, config.data_config, config.model_config, config.resume)
-+
-+	print("Checkpoint directory:",logdir)
-+
-+	# Print flags
-+	fet.print_flags()
-+
-+	n_folds = len(kfold_loaders)
-+	print("Doing {}-fold cross-validation.".format(n_folds))
-+
-+	# KFOLD TRAINING LOOP
-+	for k,loader_k in enumerate(kfold_loaders): # loop over data splits
-+
-+		print("Training fold {}...".format(k+1))
-+
-+		# Load model
-+		model,model_name = fet.load(config.model_config, config)
-+		model = model.to(device)
-+
-+		# Print model info
-+		print(model)
-+
-+		# Setup optimizer
-+		model_params = model.parameters()
-+		opt_learning_rate = config.learning_rate
-+		model_opt = torch.optim.Adam(
-+			model_params, lr=opt_learning_rate, betas=(config.beta1, config.beta2)
-+		)
-+		scheduler = torch.optim.lr_scheduler.StepLR(model_opt, step_size=10, gamma=0.5)
-+		print("Model Optimizer:")
-+		print(model_opt)
-+
-+		# Try to restore model and optimizer from checkpoint
-+		if resume_checkpoint is not None:
-+			start_epoch = load_checkpoint(resume_checkpoint, model, model_opt)
-+		else:
-+			start_epoch = 1
-+
-+		# load the training data
-+		train_loader = loader_k["train"]
-+		n_train = len(train_loader.dataset)
-+		train_batch_size = train_loader.batch_size
-+
-+		# load testing, validation
-+		test_loader = loader_k["test"]
-+		n_test = len(test_loader.dataset)
-+		val_loader = loader_k["val"]
-+		n_val = len(val_loader.dataset)
-+
-+		train_class_counts = np.bincount(train_loader.dataset.all_labels)
-+		train_total_counts = sum(train_class_counts)
-+		class_weight = torch.tensor(1.0 / train_class_counts) * train_total_counts / 2.0
-+
-+		loss_func = nn.CrossEntropyLoss(weight = class_weight) # define reweighted loss function
-+				
-+		# create folder for this data split
-+		fold_dir = osp.join(logdir,"data_fold{}".format(k+1))
-+		fold_dir_exists = osp.exists(fold_dir)
-+		if not fold_dir_exists:
-+			if config.resume:
-+				raise ValueError("Can't resume when the checkpoint/fold dir '{}' doesn't exist.".format(fold_dir))
-+			else:
-+				os.makedirs(fold_dir)
-+		checkpoint_name = osp.join(fold_dir, 'model_fold{}.ckpt'.format(k+1))
-+
-+		# keep track of which data is test data for a given Kfold data split
-+		test_headings = loader_k['test_headings']
-+		headingsFile = osp.join(fold_dir,"test_headings.txt")
-+		with open(headingsFile,'w') as headfile:
-+			for heading in test_headings:
-+				headfile.write(heading+'\n')
-+
-+		# print(checkpoint_name)
-+
-+		train_iter = (start_epoch - 1) * (
-+		len(train_loader.dataset) // train_batch_size
-+		) + 1
-+
-+		print("Starting training at epoch = {}, iter = {}".format(start_epoch, train_iter))
-+
-+		# Setup tensorboard writing
-+		summary_writer = SummaryWriter(logdir)
-+
-+		train_reports = []
-+		report_all = {}
-+		report_all_val = {}
-+
-+		# Saving model at epoch 0 before training
-+		print("saving model at epoch 0 before training ... ")
-+		save_checkpoint(checkpoint_name, 0, model, model_opt, loss=0.0)
-+		print("finished saving model at epoch 0 before training")
-+
-+		num_params = param_count(model)
-+		print(f"Number of model parameters: {num_params}")
-+
-+		# Training
-+		start_t = time.time()
-+
-+		total_train_iters = len(train_loader) * config.train_epochs
-+		iters_per_eval = max(1, int(total_train_iters / config.total_evaluations))
-+		# print('batch',train_batch_size)
-+		# print('ntrain',n_train)
-+		# assert (
-+		# 	n_train % min(train_batch_size, n_train) == 0
-+		# ), "Batch size doesn't divide dataset size. Can be inaccurate for loss computation (see below)."
-+
-+		training_failed = False
-+		best_val_loss_so_far = 1e7
-+
-+		for epoch in tqdm(range(start_epoch, config.train_epochs + 1)):
-+			model.train()
-+
-+			for batch_idx, data_dict in enumerate(train_loader): # Loop over batched data
-+
-+				labels = data_dict['label']
-+				data = data_dict['data']
-+
-+				# send data to device
-+				data = nested_to(data,device,torch.float32)
-+				# One-hot encode the data labels
-+				labels_tensor = torch.zeros((len(labels), 2))
-+				for i, label in enumerate(labels):
-+					labels_tensor[i, label] = 1
-+
-+				model_output = model(data) # evaluate model
-+
-+				loss = loss_func(model_output, labels_tensor) # compute loss
-+				outputs = AttrDict({"loss": loss, "prediction": model_output})
-+				outputs.reports = AttrDict({"cross_entropy": loss})
-+
-+				if torch.isnan(outputs.loss): # check for failure in training
-+					if not training_failed:
-+						epoch_of_nan = epoch
-+					if (epoch > epoch_of_nan + 1) and training_failed:
-+						raise ValueError("Loss Nan-ed.")
-+					training_failed = True
-+
-+				model_opt.zero_grad()
-+				outputs.loss.backward(retain_graph=False)
-+
-+				model_opt.step() # move optimizer forward
-+
-+				
-+
-+				if config.log_train_values:
-+					reports = parse_reports(outputs.reports)
-+					if batch_idx % config.report_loss_every == 0:
-+						log_tensorboard(summary_writer, train_iter, reports, "train/")
-+						print_reports(
-+							reports,
-+							start_t,
-+							epoch,
-+							batch_idx,
-+							len(train_loader.dataset) // train_batch_size,
-+							prefix="train",
-+						)
-+						log_tensorboard(
-+							summary_writer,
-+							train_iter,
-+							{"lr": model_opt.param_groups[0]["lr"]},
-+							"hyperparams/",
-+						)
-+				# Logging and evaluation
-+				if (
-+					train_iter % iters_per_eval == 0 or (train_iter == total_train_iters)
-+				) and config.log_val_test:  # batch_idx % config.evaluate_every == 0:
-+					model.eval()
-+					with torch.no_grad():
-+						reports = evaluate(model, test_loader, device,fold = k,headings = loader_k['test_headings'])
-+						# print("REPORTS",reports)
-+						reports = parse_reports(reports)
-+						reports["time"] = time.time() - start_t
-+						if report_all == {}:
-+							report_all = deepcopy(reports)
-+
-+							for d in reports.keys():
-+								report_all[d] = [report_all[d]]
-+						else:
-+							for d in reports.keys():
-+								report_all[d].append(reports[d])
-+
-+						log_tensorboard(summary_writer, train_iter, reports, "test/")
-+						print_reports(
-+							reports,
-+							start_t,
-+							epoch,
-+							batch_idx,
-+							len(train_loader.dataset) // config.batch_size,
-+							prefix="test",
-+						)
-+
-+						# repeat for validation data
-+						reports = evaluate(model, val_loader, device,fold = k,headings = loader_k['test_headings'])
-+						reports = parse_reports(reports)
-+						reports["time"] = time.time() - start_t
-+						if report_all_val == {}:
-+							report_all_val = deepcopy(reports)
-+
-+							for d in reports.keys():
-+								report_all_val[d] = [report_all_val[d]]
-+						else:
-+							for d in reports.keys():
-+								report_all_val[d].append(reports[d])
-+
-+						log_tensorboard(summary_writer, train_iter, reports, "val/")
-+						print_reports(
-+							reports,
-+							start_t,
-+							epoch,
-+							batch_idx,
-+							len(train_loader.dataset) // config.batch_size,
-+							prefix="val",
-+						)
-+
-+						if report_all_val["cross_entropy"][-1] < best_val_loss_so_far:
-+							save_checkpoint(
-+								checkpoint_name,
-+								f"early_stop",
-+								model,
-+								model_opt,
-+								loss=outputs.loss,
-+							)
-+							best_val_loss_so_far = report_all_val["cross_entropy"][-1]
-+
-+					model.train()
-+
-+				train_iter += 1
-+
-+			scheduler.step()
-+
-+			train_reports.append([epoch,loss.item()])
-+
-+			if epoch % config.save_check_points == 0:
-+				save_checkpoint(
-+					checkpoint_name, train_iter, model, model_opt, loss=outputs.loss
-+				)
-+		
-+		dd.io.save(fold_dir + "/results_dict_train.h5", train_reports)
-+		dd.io.save(fold_dir + "/results_dict.h5", report_all)
-+		dd.io.save(fold_dir + "/results_dict_val.h5", report_all_val)
-+
-+	# always save final model
-+	save_checkpoint(checkpoint_name, train_iter, model, model_opt, loss=outputs.loss)
-+
-+	
-+	if config.save_test_predictions:
-+		pass
-+		# print("Starting to make model predictions on test sets for *final model*.")
-+		# for chunk_len in [5, 100]:
-+		#     start_t_preds = time.time()
-+		#     data_config = SimpleNamespace(
-+		#         **{
-+		#             **config.__dict__["__flags"],
-+		#             **{"chunk_len": chunk_len, "batch_size": 500},
-+		#         }
-+		#     )
-+		#     dataloaders, data_name = fet.load(config.data_config, config=data_config)
-+		#     test_loader_preds = dataloaders["test"]
-+
-+		#     torch.cuda.empty_cache()
-+		#     with torch.no_grad():
-+		#         preds = []
-+		#         true = []
-+		#         num_datapoints = 0
-+		#         for idx, d in enumerate(test_loader_preds):
-+		#             true.append(d[-1])
-+		#             d = nested_to(d, device, torch.float32)
-+		#             outputs = model(d)
-+
-+		#             pred_zs = outputs.prediction
-+		#             preds.append(pred_zs)
-+
-+		#             num_datapoints += len(pred_zs)
-+
-+		#             if num_datapoints >= 2000:
-+		#                 break
- 
--config = forge.config()
-+		#         preds = torch.cat(preds, dim=0).cpu()
-+		#         true = torch.cat(true, dim=0).cpu()
- 
--# Prepare environment
--logdir = osp.join(config.results_dir, config.run_name)
--logdir, resume_checkpoint = fet.init_checkpoint(
--    logdir, config.data_config, config.model_config, config.resume)
--checkpoint_name = osp.join(logdir, 'model.ckpt')
-+		#         save_dir = osp.join(logdir, f"traj_preds_{chunk_len}_steps_2k_test.pt")
-+		#         torch.save(preds, save_dir)
- 
-+		#         save_dir = osp.join(logdir, f"traj_true_{chunk_len}_steps_2k_test.pt")
-+		#         torch.save(true, save_dir)
- 
--print(logdir)
-+		#         print(
-+		#             f"Completed making test predictions for chunk_len = {chunk_len} in {time.time() - start_t_preds:.2f} seconds."
-+		#         )	
-+		
- 
-+if __name__ == "__main__":
-+	main()
- 
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/penn_dataset.py b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/penn_dataset.py
deleted file mode 100644
index 4f4221c..0000000
--- a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/1/penn_dataset.py
+++ /dev/null
@@ -1,144 +0,0 @@
-import os
-import torch
-import pandas as pd
-import numpy as np
-
-from torchvision import datasets, transforms
-from torch.utils.data import Dataset, DataLoader
-from sklearn.model_selection import RepeatedKFold
-
-from os import path as osp
-import forge
-from forge import flags
-
-
-# aspects of data managmement
-flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
-flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-flags.DEFINE_boolean("cross_validate",True,"Do K-fold cross-validation")
-
-# Job management
-# flags.DEFINE_integer("batch size",5,"training batch size")
-flags.DEFINE_float("train_split",0.8,'Fraction of data to use for training.')
-flags.DEFINE_integer("n_repeats",1,"Times to repeat K-fold cross-validation")
-flags.DEFINE_integer("split_seed",1,"Seed for KFold split (integer for reproducibility")
-
-# "wavelengths between 0.05 and 1 mm in 0.025 mm increments."
-LSPACE = np.arange(0.05,1.05,0.025) # corresponds to 39 non-coord columns of data
-L_INDS = None # specific indices of data to select
-
-DATAFOLDER = './penn_data'
-
-HEADINGS = np.array(['aaa0043','aaa0044','aaa0060','aaa0061','aaa0063','aaa0064','aaa0066','aaa0069','aaa0086','aaa0087','aaa_0051','aaa_0053','aaa_0054','aaa_0059','aaa_0071','aaa_0072'])
-
-
-class PennData(Dataset):
-
-    def __init__(self,path_to_data,headings,k_inds = None,include_coords = True,rescale = True,spectra_prefix = "kvals_fuse_rotate_",label_prefix = 'labels_fuse_rotate_'):
-        
-        self.data_dir = path_to_data
-        self.headings = headings
-
-        df_list = []
-        label_list = []
-        for idx,heading in enumerate(self.headings): # for each datafile heading,
-            data_name = osp.join(self.data_dir,spectra_prefix + heading+'.csv') # read kvals
-            df_temp = pd.read_csv(data_name,header=None)
-            df_temp['h_idx'] = idx
-            df_list.append(df_temp)
-            
-
-            label_name = osp.join(self.data_dir,label_prefix + heading + '.csv') # read labels
-            label_temp = pd.read_csv(label_name,header=None, names=['label'])
-            label_list.append(label_temp)
-
-        df = pd.concat(df_list, ignore_index=True)
-
-        labels = pd.concat(label_list, ignore_index=True)
-        df = pd.concat([labels, df], axis="columns") # Append labels to data
-
-        all_labels = df['label'].to_numpy()
-        all_data = df.iloc[:,1:].to_numpy()
-
-        # if include_coords:
-        #     kstart = 3
-        # else:
-        #     kstart = 0
-
-        if rescale: # rescale (normalize) wavelength intensity data
-            lambdas = all_data[:,3:] # wavelengths
-            lam_std = np.std(lambdas, axis=0)  # Calculate standard deviation along columns
-            lam_mean = np.mean(lambdas, axis=0)  # Calculate mean along columns
-            lambdas_rescaled = (lambdas - lam_mean) / lam_std 
-            all_data[:,3:] = lambdas_rescaled
-
-        # if k_inds != None: # THIS DOES NOT MAKE SENSE HERE
-        #     all_data[:,3:] = all_data[:,np.array(k_inds)]
-
-        if not include_coords: # removes x,y coordinates (and heading index) from data
-            all_data = all_data[:,3:]
-
-        self.all_data = all_data
-        self.all_labels = all_labels
-
-    def __len__(self):
-        return len(self.all_data)
-
-    def __getitem__(self,i):
-        state = {'label':self.all_labels[i],'data':self.all_data[i]}
-        return state
-
-    def __getstate__(self):
-        state = {
-            'data': self.all_data,
-            'label': self.all_labels,
-                }
-        return state
-
-    def __setstate__(self, state):
-        # Set the object's state from the provided dictionary
-        self.all_data = state['data']
-        self.all_labels = state['label']
-        
-
-
-def load(config):
-
-    n_splits = int(len(HEADINGS)/((1-config.train_split)*len(HEADINGS)))
-
-    kf = RepeatedKFold(n_splits = n_splits, n_repeats = config.n_repeats, random_state = config.split_seed) # K-fold cross validation
-
-    kf_dataloaders = []
-
-    for i, (train_ind, test_ind) in enumerate(kf.split(HEADINGS)): # for each K-fold split, 
-        n_val = len(test_ind)//2
-        n_test = len(test_ind)-n_val   
-        n_train = len(train_ind)
-        
-        # set up training DataLoader
-        train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
-
-        # set up test DataLoader
-        test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
-
-        # set up val DataLoader
-        val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-        
-
-        dataloaders = {'train':train_loader, 
-                       'test':test_loader,
-                       'val':val_loader,
-                       'train_inds':train_ind,
-                       'test_inds':test_ind,
-                       'n_val':n_val,
-                       'test_headings':list(HEADINGS[test_ind])
-                      }
-        kf_dataloaders.append(dataloaders)
-
-        if not config.cross_validate:
-        	break
-
-    return kf_dataloaders
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/__pycache__/basic_feedforward.cpython-39.pyc b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/__pycache__/basic_feedforward.cpython-39.pyc
deleted file mode 100644
index 42d2664..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/__pycache__/basic_feedforward.cpython-39.pyc and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/__pycache__/penn_dataset.cpython-39.pyc b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/__pycache__/penn_dataset.cpython-39.pyc
deleted file mode 100644
index 48aeff9..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/__pycache__/penn_dataset.cpython-39.pyc and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/basic_feedforward.py b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/basic_feedforward.py
deleted file mode 100644
index c36011b..0000000
--- a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/basic_feedforward.py
+++ /dev/null
@@ -1,74 +0,0 @@
-import torch
-import torch.nn as nn
-import torch.nn.functional as F
-import numpy as np
-
-from forge import flags
-
-# flags.DEFINE_boolean(
-#     "model_with_dict",
-#     True,
-#     "Makes model output predictions in dictionary instead of directly."
-# )
-
-class PerceptronNN(nn.Module):
-    def __init__(self, input_size, num_labels):
-        super(PerceptronNN, self).__init__()
-        # Define the layers
-        self.fc1 = nn.Linear(input_size, 128)  # First dense layer
-        self.fc2 = nn.Linear(128, 64)         # Second dense layer
-        # self.fc23 = nn.Linear(64,64)
-        self.fc3 = nn.Linear(64, 64)          # Third dense layer
-        self.fc4 = nn.Linear(64, num_labels)  # Output layer
-        # self.softmax = nn.Softmax(dim=1)
-
-    def forward(self, x):
-        # Forward pass through the network
-        x = F.relu(self.fc1(x))  # Activation function between layers
-        x = F.relu(self.fc2(x))
-        # x = F.relu(self.fc23(x))
-        x = F.relu(self.fc3(x))
-        x = self.fc4(x)  # No activation, this will be included in the loss function
-        # x = self.softmax(x)
-        return x
-
-class GPT_PNN(nn.Module):
-    def __init__(self, input_size, num_labels):
-        super(GPT_PNN, self).__init__()
-        # Define the layers
-        self.fc1 = nn.Linear(input_size, 64)  # First dense layer, reduced size
-        self.bn1 = nn.BatchNorm1d(64)  # Batch Normalization for the first layer
-        self.dropout1 = nn.Dropout(0.5)  # Dropout with 50% probability
-        
-        # Commenting out to reduce model complexity
-        # self.fc2 = nn.Linear(128, 64)  # Second dense layer
-        # self.dropout2 = nn.Dropout(0.5)  # Additional dropout layer
-        
-        # Simplified to have fewer layers and neurons
-        self.fc2 = nn.Linear(64, 32)  # Reduced size for second dense layer
-        self.bn2 = nn.BatchNorm1d(32)  # Batch Normalization for the second layer
-        self.dropout2 = nn.Dropout(0.5)  # Dropout with 50% probability
-
-        # Output layer remains the same, adjusted for reduced prior layer size
-        self.fc3 = nn.Linear(32, num_labels)  # Output layer
-
-    def forward(self, x):
-        # x = x[:,::2] # try using every other wavelength
-        # Forward pass through the network with activations, batch normalization, and dropout
-        x = F.relu(self.bn1(self.fc1(x)))
-        x = self.dropout1(x)
-        x = F.relu(self.bn2(self.fc2(x)))
-        x = self.dropout2(x)
-        x = self.fc3(x)  # No activation here, use sigmoid or softmax outside if needed for binary classification
-        return x
-
-def load(config):
-
-    # n_channels = 1
-    n_features = config.input_size
-    
-    # mlp = PerceptronNN(n_features,2)
-
-    mlp = GPT_PNN(n_features,2)
-    
-    return mlp, "gpt_feedforward_halfLs"
\ No newline at end of file
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold1/model_fold1.ckpt-0 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold1/model_fold1.ckpt-0
deleted file mode 100644
index 26d8425..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold1/model_fold1.ckpt-0 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold1/model_fold1.ckpt-early_stop b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold1/model_fold1.ckpt-early_stop
deleted file mode 100644
index b1f459e..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold1/model_fold1.ckpt-early_stop and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold1/results_dict.h5 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold1/results_dict.h5
deleted file mode 100644
index a7736c5..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold1/results_dict.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold1/results_dict_train.h5 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold1/results_dict_train.h5
deleted file mode 100644
index 24bdd9e..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold1/results_dict_train.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold1/results_dict_val.h5 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold1/results_dict_val.h5
deleted file mode 100644
index 11a17da..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold1/results_dict_val.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold1/test_headings.txt b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold1/test_headings.txt
deleted file mode 100644
index 05c4825..0000000
--- a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold1/test_headings.txt
+++ /dev/null
@@ -1,4 +0,0 @@
-aaa0060
-aaa0061
-aaa0069
-aaa_0059
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold2/model_fold2.ckpt-0 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold2/model_fold2.ckpt-0
deleted file mode 100644
index ee5ba66..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold2/model_fold2.ckpt-0 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold2/model_fold2.ckpt-early_stop b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold2/model_fold2.ckpt-early_stop
deleted file mode 100644
index 66d6289..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold2/model_fold2.ckpt-early_stop and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold2/results_dict.h5 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold2/results_dict.h5
deleted file mode 100644
index 8d03b72..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold2/results_dict.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold2/results_dict_train.h5 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold2/results_dict_train.h5
deleted file mode 100644
index 83c7da3..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold2/results_dict_train.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold2/results_dict_val.h5 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold2/results_dict_val.h5
deleted file mode 100644
index 82a5f02..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold2/results_dict_val.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold2/test_headings.txt b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold2/test_headings.txt
deleted file mode 100644
index b87ab5e..0000000
--- a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold2/test_headings.txt
+++ /dev/null
@@ -1,3 +0,0 @@
-aaa0063
-aaa0066
-aaa_0051
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold3/model_fold3.ckpt-0 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold3/model_fold3.ckpt-0
deleted file mode 100644
index 1b3855a..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold3/model_fold3.ckpt-0 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold3/model_fold3.ckpt-early_stop b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold3/model_fold3.ckpt-early_stop
deleted file mode 100644
index 7a643ed..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold3/model_fold3.ckpt-early_stop and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold3/results_dict.h5 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold3/results_dict.h5
deleted file mode 100644
index 11dae2a..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold3/results_dict.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold3/results_dict_train.h5 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold3/results_dict_train.h5
deleted file mode 100644
index 5d926d0..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold3/results_dict_train.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold3/results_dict_val.h5 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold3/results_dict_val.h5
deleted file mode 100644
index 4b2cee8..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold3/results_dict_val.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold3/test_headings.txt b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold3/test_headings.txt
deleted file mode 100644
index 8417193..0000000
--- a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold3/test_headings.txt
+++ /dev/null
@@ -1,3 +0,0 @@
-aaa0043
-aaa0044
-aaa_0071
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold4/model_fold4.ckpt-0 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold4/model_fold4.ckpt-0
deleted file mode 100644
index 016ac92..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold4/model_fold4.ckpt-0 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold4/model_fold4.ckpt-early_stop b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold4/model_fold4.ckpt-early_stop
deleted file mode 100644
index 3153c94..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold4/model_fold4.ckpt-early_stop and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold4/results_dict.h5 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold4/results_dict.h5
deleted file mode 100644
index 2c3247c..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold4/results_dict.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold4/results_dict_train.h5 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold4/results_dict_train.h5
deleted file mode 100644
index ede32bd..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold4/results_dict_train.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold4/results_dict_val.h5 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold4/results_dict_val.h5
deleted file mode 100644
index ec22062..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold4/results_dict_val.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold4/test_headings.txt b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold4/test_headings.txt
deleted file mode 100644
index ad5063c..0000000
--- a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold4/test_headings.txt
+++ /dev/null
@@ -1,3 +0,0 @@
-aaa0086
-aaa0087
-aaa_0072
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold5/model_fold5.ckpt-0 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold5/model_fold5.ckpt-0
deleted file mode 100644
index c8c47aa..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold5/model_fold5.ckpt-0 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold5/model_fold5.ckpt-24481 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold5/model_fold5.ckpt-24481
deleted file mode 100644
index 9a6c099..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold5/model_fold5.ckpt-24481 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold5/model_fold5.ckpt-early_stop b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold5/model_fold5.ckpt-early_stop
deleted file mode 100644
index cb2b070..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold5/model_fold5.ckpt-early_stop and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold5/results_dict.h5 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold5/results_dict.h5
deleted file mode 100644
index 6b47d4b..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold5/results_dict.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold5/results_dict_train.h5 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold5/results_dict_train.h5
deleted file mode 100644
index 558d939..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold5/results_dict_train.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold5/results_dict_val.h5 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold5/results_dict_val.h5
deleted file mode 100644
index a2bf9d7..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold5/results_dict_val.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold5/test_headings.txt b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold5/test_headings.txt
deleted file mode 100644
index a4e6319..0000000
--- a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/data_fold5/test_headings.txt
+++ /dev/null
@@ -1,3 +0,0 @@
-aaa0064
-aaa_0053
-aaa_0054
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/events.out.tfevents.1709711867.MacBook-Pro-4.local.7580.0 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/events.out.tfevents.1709711867.MacBook-Pro-4.local.7580.0
deleted file mode 100644
index 9673422..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/events.out.tfevents.1709711867.MacBook-Pro-4.local.7580.0 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/events.out.tfevents.1709711935.MacBook-Pro-4.local.7580.1 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/events.out.tfevents.1709711935.MacBook-Pro-4.local.7580.1
deleted file mode 100644
index f71cf82..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/events.out.tfevents.1709711935.MacBook-Pro-4.local.7580.1 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/events.out.tfevents.1709712001.MacBook-Pro-4.local.7580.2 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/events.out.tfevents.1709712001.MacBook-Pro-4.local.7580.2
deleted file mode 100644
index 1a022e8..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/events.out.tfevents.1709712001.MacBook-Pro-4.local.7580.2 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/events.out.tfevents.1709712066.MacBook-Pro-4.local.7580.3 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/events.out.tfevents.1709712066.MacBook-Pro-4.local.7580.3
deleted file mode 100644
index 1d078fa..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/events.out.tfevents.1709712066.MacBook-Pro-4.local.7580.3 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/events.out.tfevents.1709712130.MacBook-Pro-4.local.7580.4 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/events.out.tfevents.1709712130.MacBook-Pro-4.local.7580.4
deleted file mode 100644
index 93921f7..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/events.out.tfevents.1709712130.MacBook-Pro-4.local.7580.4 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/flags.json b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/flags.json
deleted file mode 100644
index 08cf9e1..0000000
--- a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/flags.json
+++ /dev/null
@@ -1,28 +0,0 @@
-{
-    "batch_size": 100,
-    "beta1": 0.9,
-    "beta2": 0.999,
-    "cross_validate": true,
-    "data_config": "penn_dataset.py",
-    "git_commit": "7416bf730b356aabfe0df644240e40948a8196bb",
-    "include_coords": false,
-    "input_size": 39,
-    "learning_rate": 0.001,
-    "log_train_values": true,
-    "log_val_test": true,
-    "model_config": "basic_feedforward.py",
-    "model_name": "gpt-FCNN",
-    "n_repeats": 1,
-    "report_loss_every": 50,
-    "rescale": true,
-    "results_dir": "checkpoints",
-    "resume": false,
-    "run_name": "hyperparam_testing",
-    "save_check_points": 50,
-    "save_test_predictions": false,
-    "split_seed": 1,
-    "total_evaluations": 100,
-    "train_epochs": 20,
-    "train_split": 0.8,
-    "use_mps": false
-}
\ No newline at end of file
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/git_diff.txt b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/git_diff.txt
deleted file mode 100644
index 62120f2..0000000
--- a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/git_diff.txt
+++ /dev/null
@@ -1,1339 +0,0 @@
-Tue Mar 5 23:57:47 PST 2024
-diff --git a/.DS_Store b/.DS_Store
-index e2836a8..bf7630a 100644
-Binary files a/.DS_Store and b/.DS_Store differ
-diff --git a/.ipynb_checkpoints/basic_feedforward-checkpoint.py b/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-index 688c282..0c4bcd1 100644
---- a/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-+++ b/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-@@ -5,6 +5,12 @@ import numpy as np
- 
- from forge import flags
- 
-+flags.DEFINE_boolean(
-+    "model_with_dict",
-+    True,
-+    "Makes model output predictions in dictionary instead of directly."
-+)
-+
- class PerceptronNN(nn.Module):
-     def __init__(self, input_size, num_labels):
-         super(PerceptronNN, self).__init__()
-@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-+        self.softmax = nn.Softmax(dim=1)
- 
-     def forward(self, x):
-         # Forward pass through the network
-@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-         x = F.relu(self.fc2(x))
-         x = F.relu(self.fc3(x))
-         x = self.fc4(x)  # No activation, this will be included in the loss function
-+        x = self.softmax(x)
-         return x
- 
- def load(config):
-@@ -29,4 +37,4 @@ def load(config):
-     
-     mlp = PerceptronNN(n_features,2)
-     
--    return mlp
-\ No newline at end of file
-+    return mlp, "feedforward"
-\ No newline at end of file
-diff --git a/.ipynb_checkpoints/penn_dataset-checkpoint.py b/.ipynb_checkpoints/penn_dataset-checkpoint.py
-index aa2f5a0..8c5b51d 100644
---- a/.ipynb_checkpoints/penn_dataset-checkpoint.py
-+++ b/.ipynb_checkpoints/penn_dataset-checkpoint.py
-@@ -15,16 +15,17 @@ from forge import flags
- # aspects of data managmement
- flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
- flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-+flags.DEFINE_boolean("cross_validate",True,"Do K-fold cross-validation")
- 
- # Job management
- # flags.DEFINE_integer("batch size",5,"training batch size")
- flags.DEFINE_float("train_split",0.8,'Fraction of data to use for training.')
--flags.DEFINE_integer("n_repeats",1,"Times to repeat K-fold cross-validation")
-+flags.DEFINE_integer("n_repeats",2,"Times to repeat K-fold cross-validation")
- flags.DEFINE_integer("split_seed",1,"Seed for KFold split (integer for reproducibility")
- 
- # "wavelengths between 0.05 and 1 mm in 0.025 mm increments."
- LSPACE = np.arange(0.05,1.05,0.025) # corresponds to 39 non-coord columns of data
--L_INDS = None
-+L_INDS = None # specific indices of data to select
- 
- DATAFOLDER = './penn_data'
- 
-@@ -40,11 +41,12 @@ class PennData(Dataset):
- 
-         df_list = []
-         label_list = []
--        for heading in self.headings: # for each datafile heading,
-+        for idx,heading in enumerate(self.headings): # for each datafile heading,
-             data_name = osp.join(self.data_dir,spectra_prefix + heading+'.csv') # read kvals
-             df_temp = pd.read_csv(data_name,header=None)
-+            df_temp.insert(0, 'h_idx', idx)
-             df_list.append(df_temp)
--
-+            
-             label_name = osp.join(self.data_dir,label_prefix + heading + '.csv') # read labels
-             label_temp = pd.read_csv(label_name,header=None, names=['label'])
-             label_list.append(label_temp)
-@@ -57,27 +59,30 @@ class PennData(Dataset):
-         all_labels = df['label'].to_numpy()
-         all_data = df.iloc[:,1:].to_numpy()
- 
-+        lambdas = all_data[:,3:]
-+
-         if rescale: # rescale (normalize) wavelength intensity data
--            lambdas = all_data[:,2:] # wavelengths
-             lam_std = np.std(lambdas, axis=0)  # Calculate standard deviation along columns
-             lam_mean = np.mean(lambdas, axis=0)  # Calculate mean along columns
-             lambdas_rescaled = (lambdas - lam_mean) / lam_std 
--            all_data[:,2:] = lambdas_rescaled
-+            lambdas = lambdas_rescaled
- 
--        if not include_coords: # removes x,y coordinates from data
--            all_data = all_data[:,2:]
--        
--        if k_inds != None: # in this case, only use subset of wavelengths
--            all_data = all_data[:,np.array(k_inds)]
-+        # if k_inds != None: # THIS DOES NOT MAKE SENSE HERE
-+        #     all_data[:,3:] = all_data[:,np.array(k_inds)]
-+        self.data = lambdas
-+        self.labels = all_labels
- 
--        self.all_data = all_data
--        self.all_labels = all_labels
-+        if include_coords: # removes x,y coordinates (and heading index) from data
-+            # all_data = all_data[:,3:]
-+            self.coords = all_data[:,:3]
-+        else:
-+            self.coords = None
- 
-     def __len__(self):
-         return len(self.all_data)
- 
-     def __getitem__(self,i):
--        state = {'label':self.all_labels[i],'data':self.all_data[i]}
-+        state = {'label':self.all_labels[i],'coords':self.coords,'data':self.all_data[i]}
-         return state
- 
-     def __getstate__(self):
-@@ -109,15 +114,15 @@ def load(config):
-         
-         # set up training DataLoader
-         train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, n_train),num_workers=0,shuffle = True)
-+        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
- 
-         # set up test DataLoader
-         test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, n_test),num_workers=0,shuffle = True)
-+        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
- 
-         # set up val DataLoader
-         val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, n_val),num_workers=0,shuffle = True)
-+        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-         
- 
-         dataloaders = {'train':train_loader, 
-@@ -125,8 +130,12 @@ def load(config):
-                        'val':val_loader,
-                        'train_inds':train_ind,
-                        'test_inds':test_ind,
--                       'n_val':n_val
-+                       'n_val':n_val,
-+                       'test_headings':list(HEADINGS[test_ind])
-                       }
-         kf_dataloaders.append(dataloaders)
- 
-+        if not config.cross_validate:
-+        	break
-+
-     return kf_dataloaders
-diff --git a/__pycache__/basic_feedforward.cpython-39.pyc b/__pycache__/basic_feedforward.cpython-39.pyc
-index f541140..4a02232 100644
-Binary files a/__pycache__/basic_feedforward.cpython-39.pyc and b/__pycache__/basic_feedforward.cpython-39.pyc differ
-diff --git a/__pycache__/penn_dataset.cpython-39.pyc b/__pycache__/penn_dataset.cpython-39.pyc
-index 0d7a4de..ea4dbe7 100644
-Binary files a/__pycache__/penn_dataset.cpython-39.pyc and b/__pycache__/penn_dataset.cpython-39.pyc differ
-diff --git a/basic_feedforward.py b/basic_feedforward.py
-index 688c282..c36011b 100644
---- a/basic_feedforward.py
-+++ b/basic_feedforward.py
-@@ -5,21 +5,61 @@ import numpy as np
- 
- from forge import flags
- 
-+# flags.DEFINE_boolean(
-+#     "model_with_dict",
-+#     True,
-+#     "Makes model output predictions in dictionary instead of directly."
-+# )
-+
- class PerceptronNN(nn.Module):
-     def __init__(self, input_size, num_labels):
-         super(PerceptronNN, self).__init__()
-         # Define the layers
-         self.fc1 = nn.Linear(input_size, 128)  # First dense layer
-         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-+        # self.fc23 = nn.Linear(64,64)
-         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-+        # self.softmax = nn.Softmax(dim=1)
- 
-     def forward(self, x):
-         # Forward pass through the network
-         x = F.relu(self.fc1(x))  # Activation function between layers
-         x = F.relu(self.fc2(x))
-+        # x = F.relu(self.fc23(x))
-         x = F.relu(self.fc3(x))
-         x = self.fc4(x)  # No activation, this will be included in the loss function
-+        # x = self.softmax(x)
-+        return x
-+
-+class GPT_PNN(nn.Module):
-+    def __init__(self, input_size, num_labels):
-+        super(GPT_PNN, self).__init__()
-+        # Define the layers
-+        self.fc1 = nn.Linear(input_size, 64)  # First dense layer, reduced size
-+        self.bn1 = nn.BatchNorm1d(64)  # Batch Normalization for the first layer
-+        self.dropout1 = nn.Dropout(0.5)  # Dropout with 50% probability
-+        
-+        # Commenting out to reduce model complexity
-+        # self.fc2 = nn.Linear(128, 64)  # Second dense layer
-+        # self.dropout2 = nn.Dropout(0.5)  # Additional dropout layer
-+        
-+        # Simplified to have fewer layers and neurons
-+        self.fc2 = nn.Linear(64, 32)  # Reduced size for second dense layer
-+        self.bn2 = nn.BatchNorm1d(32)  # Batch Normalization for the second layer
-+        self.dropout2 = nn.Dropout(0.5)  # Dropout with 50% probability
-+
-+        # Output layer remains the same, adjusted for reduced prior layer size
-+        self.fc3 = nn.Linear(32, num_labels)  # Output layer
-+
-+    def forward(self, x):
-+        # x = x[:,::2] # try using every other wavelength
-+        # Forward pass through the network with activations, batch normalization, and dropout
-+        x = F.relu(self.bn1(self.fc1(x)))
-+        x = self.dropout1(x)
-+        x = F.relu(self.bn2(self.fc2(x)))
-+        x = self.dropout2(x)
-+        x = self.fc3(x)  # No activation here, use sigmoid or softmax outside if needed for binary classification
-         return x
- 
- def load(config):
-@@ -27,6 +67,8 @@ def load(config):
-     # n_channels = 1
-     n_features = config.input_size
-     
--    mlp = PerceptronNN(n_features,2)
-+    # mlp = PerceptronNN(n_features,2)
-+
-+    mlp = GPT_PNN(n_features,2)
-     
--    return mlp
-\ No newline at end of file
-+    return mlp, "gpt_feedforward_halfLs"
-\ No newline at end of file
-diff --git a/checkpoints/feedforward/1/basic_feedforward.py b/checkpoints/feedforward/1/basic_feedforward.py
-deleted file mode 100644
-index 688c282..0000000
---- a/checkpoints/feedforward/1/basic_feedforward.py
-+++ /dev/null
-@@ -1,32 +0,0 @@
--import torch
--import torch.nn as nn
--import torch.nn.functional as F
--import numpy as np
--
--from forge import flags
--
--class PerceptronNN(nn.Module):
--    def __init__(self, input_size, num_labels):
--        super(PerceptronNN, self).__init__()
--        # Define the layers
--        self.fc1 = nn.Linear(input_size, 128)  # First dense layer
--        self.fc2 = nn.Linear(128, 64)         # Second dense layer
--        self.fc3 = nn.Linear(64, 64)          # Third dense layer
--        self.fc4 = nn.Linear(64, num_labels)  # Output layer
--
--    def forward(self, x):
--        # Forward pass through the network
--        x = F.relu(self.fc1(x))  # Activation function between layers
--        x = F.relu(self.fc2(x))
--        x = F.relu(self.fc3(x))
--        x = self.fc4(x)  # No activation, this will be included in the loss function
--        return x
--
--def load(config):
--
--    # n_channels = 1
--    n_features = config.input_size
--    
--    mlp = PerceptronNN(n_features,2)
--    
--    return mlp
-\ No newline at end of file
-diff --git a/checkpoints/feedforward/1/flags.json b/checkpoints/feedforward/1/flags.json
-deleted file mode 100644
-index 1d000c3..0000000
---- a/checkpoints/feedforward/1/flags.json
-+++ /dev/null
-@@ -1,17 +0,0 @@
--{
--    "batch_size": 100,
--    "data_config": "penn_dataset.py",
--    "include_coords": false,
--    "input_size": 39,
--    "learning_rate": 1e-05,
--    "model_config": "basic_feedforward.py",
--    "n_repeats": 1,
--    "report_loss_every": 50,
--    "rescale": true,
--    "results_dir": "checkpoints",
--    "resume": false,
--    "run_name": "feedforward",
--    "split_seed": 1,
--    "train_epochs": 20,
--    "train_split": 0.8
--}
-\ No newline at end of file
-diff --git a/checkpoints/feedforward/1/git_diff.txt b/checkpoints/feedforward/1/git_diff.txt
-deleted file mode 100644
-index 7b37e6f..0000000
---- a/checkpoints/feedforward/1/git_diff.txt
-+++ /dev/null
-@@ -1 +0,0 @@
--Mon Mar 4 11:45:48 PST 2024
-diff --git a/checkpoints/feedforward/1/penn_dataset.py b/checkpoints/feedforward/1/penn_dataset.py
-deleted file mode 100644
-index aa2f5a0..0000000
---- a/checkpoints/feedforward/1/penn_dataset.py
-+++ /dev/null
-@@ -1,132 +0,0 @@
--import os
--import torch
--import pandas as pd
--import numpy as np
--
--from torchvision import datasets, transforms
--from torch.utils.data import Dataset, DataLoader
--from sklearn.model_selection import RepeatedKFold
--
--from os import path as osp
--import forge
--from forge import flags
--
--
--# aspects of data managmement
--flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
--flags.DEFINE_boolean("rescale", True, "Rescales intensities")
--
--# Job management
--# flags.DEFINE_integer("batch size",5,"training batch size")
--flags.DEFINE_float("train_split",0.8,'Fraction of data to use for training.')
--flags.DEFINE_integer("n_repeats",1,"Times to repeat K-fold cross-validation")
--flags.DEFINE_integer("split_seed",1,"Seed for KFold split (integer for reproducibility")
--
--# "wavelengths between 0.05 and 1 mm in 0.025 mm increments."
--LSPACE = np.arange(0.05,1.05,0.025) # corresponds to 39 non-coord columns of data
--L_INDS = None
--
--DATAFOLDER = './penn_data'
--
--HEADINGS = np.array(['aaa0043','aaa0044','aaa0060','aaa0061','aaa0063','aaa0064','aaa0066','aaa0069','aaa0086','aaa0087','aaa_0051','aaa_0053','aaa_0054','aaa_0059','aaa_0071','aaa_0072'])
--
--
--class PennData(Dataset):
--
--    def __init__(self,path_to_data,headings,k_inds = None,include_coords = True,rescale = True,spectra_prefix = "kvals_fuse_rotate_",label_prefix = 'labels_fuse_rotate_'):
--        
--        self.data_dir = path_to_data
--        self.headings = headings
--
--        df_list = []
--        label_list = []
--        for heading in self.headings: # for each datafile heading,
--            data_name = osp.join(self.data_dir,spectra_prefix + heading+'.csv') # read kvals
--            df_temp = pd.read_csv(data_name,header=None)
--            df_list.append(df_temp)
--
--            label_name = osp.join(self.data_dir,label_prefix + heading + '.csv') # read labels
--            label_temp = pd.read_csv(label_name,header=None, names=['label'])
--            label_list.append(label_temp)
--
--        df = pd.concat(df_list, ignore_index=True)
--
--        labels = pd.concat(label_list, ignore_index=True)
--        df = pd.concat([labels, df], axis="columns") # Append labels to data
--
--        all_labels = df['label'].to_numpy()
--        all_data = df.iloc[:,1:].to_numpy()
--
--        if rescale: # rescale (normalize) wavelength intensity data
--            lambdas = all_data[:,2:] # wavelengths
--            lam_std = np.std(lambdas, axis=0)  # Calculate standard deviation along columns
--            lam_mean = np.mean(lambdas, axis=0)  # Calculate mean along columns
--            lambdas_rescaled = (lambdas - lam_mean) / lam_std 
--            all_data[:,2:] = lambdas_rescaled
--
--        if not include_coords: # removes x,y coordinates from data
--            all_data = all_data[:,2:]
--        
--        if k_inds != None: # in this case, only use subset of wavelengths
--            all_data = all_data[:,np.array(k_inds)]
--
--        self.all_data = all_data
--        self.all_labels = all_labels
--
--    def __len__(self):
--        return len(self.all_data)
--
--    def __getitem__(self,i):
--        state = {'label':self.all_labels[i],'data':self.all_data[i]}
--        return state
--
--    def __getstate__(self):
--        state = {
--            'data': self.all_data,
--            'label': self.all_labels,
--                }
--        return state
--
--    def __setstate__(self, state):
--        # Set the object's state from the provided dictionary
--        self.all_data = state['data']
--        self.all_labels = state['label']
--        
--
--
--def load(config):
--
--    n_splits = int(len(HEADINGS)/((1-config.train_split)*len(HEADINGS)))
--
--    kf = RepeatedKFold(n_splits = n_splits, n_repeats = config.n_repeats, random_state = config.split_seed) # K-fold cross validation
--
--    kf_dataloaders = []
--
--    for i, (train_ind, test_ind) in enumerate(kf.split(HEADINGS)): # for each K-fold split, 
--        n_val = len(test_ind)//2
--        n_test = len(test_ind)-n_val   
--        n_train = len(train_ind)
--        
--        # set up training DataLoader
--        train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, n_train),num_workers=0,shuffle = True)
--
--        # set up test DataLoader
--        test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, n_test),num_workers=0,shuffle = True)
--
--        # set up val DataLoader
--        val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, n_val),num_workers=0,shuffle = True)
--        
--
--        dataloaders = {'train':train_loader, 
--                       'test':test_loader,
--                       'val':val_loader,
--                       'train_inds':train_ind,
--                       'test_inds':test_ind,
--                       'n_val':n_val
--                      }
--        kf_dataloaders.append(dataloaders)
--
--    return kf_dataloaders
-diff --git a/georgehulsey_2024.pdf b/georgehulsey_2024.pdf
-deleted file mode 100644
-index 1ab17f6..0000000
-Binary files a/georgehulsey_2024.pdf and /dev/null differ
-diff --git a/penn_dataset.py b/penn_dataset.py
-index aa2f5a0..41d02d6 100644
---- a/penn_dataset.py
-+++ b/penn_dataset.py
-@@ -15,6 +15,7 @@ from forge import flags
- # aspects of data managmement
- flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
- flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-+flags.DEFINE_boolean("cross_validate",True,"Do K-fold cross-validation")
- 
- # Job management
- # flags.DEFINE_integer("batch size",5,"training batch size")
-@@ -24,7 +25,7 @@ flags.DEFINE_integer("split_seed",1,"Seed for KFold split (integer for reproduci
- 
- # "wavelengths between 0.05 and 1 mm in 0.025 mm increments."
- LSPACE = np.arange(0.05,1.05,0.025) # corresponds to 39 non-coord columns of data
--L_INDS = None
-+L_INDS = None # specific indices of data to select
- 
- DATAFOLDER = './penn_data'
- 
-@@ -33,100 +34,125 @@ HEADINGS = np.array(['aaa0043','aaa0044','aaa0060','aaa0061','aaa0063','aaa0064'
- 
- class PennData(Dataset):
- 
--    def __init__(self,path_to_data,headings,k_inds = None,include_coords = True,rescale = True,spectra_prefix = "kvals_fuse_rotate_",label_prefix = 'labels_fuse_rotate_'):
--        
--        self.data_dir = path_to_data
--        self.headings = headings
--
--        df_list = []
--        label_list = []
--        for heading in self.headings: # for each datafile heading,
--            data_name = osp.join(self.data_dir,spectra_prefix + heading+'.csv') # read kvals
--            df_temp = pd.read_csv(data_name,header=None)
--            df_list.append(df_temp)
--
--            label_name = osp.join(self.data_dir,label_prefix + heading + '.csv') # read labels
--            label_temp = pd.read_csv(label_name,header=None, names=['label'])
--            label_list.append(label_temp)
--
--        df = pd.concat(df_list, ignore_index=True)
--
--        labels = pd.concat(label_list, ignore_index=True)
--        df = pd.concat([labels, df], axis="columns") # Append labels to data
--
--        all_labels = df['label'].to_numpy()
--        all_data = df.iloc[:,1:].to_numpy()
--
--        if rescale: # rescale (normalize) wavelength intensity data
--            lambdas = all_data[:,2:] # wavelengths
--            lam_std = np.std(lambdas, axis=0)  # Calculate standard deviation along columns
--            lam_mean = np.mean(lambdas, axis=0)  # Calculate mean along columns
--            lambdas_rescaled = (lambdas - lam_mean) / lam_std 
--            all_data[:,2:] = lambdas_rescaled
--
--        if not include_coords: # removes x,y coordinates from data
--            all_data = all_data[:,2:]
--        
--        if k_inds != None: # in this case, only use subset of wavelengths
--            all_data = all_data[:,np.array(k_inds)]
--
--        self.all_data = all_data
--        self.all_labels = all_labels
--
--    def __len__(self):
--        return len(self.all_data)
--
--    def __getitem__(self,i):
--        state = {'label':self.all_labels[i],'data':self.all_data[i]}
--        return state
--
--    def __getstate__(self):
--        state = {
--            'data': self.all_data,
--            'label': self.all_labels,
--                }
--        return state
--
--    def __setstate__(self, state):
--        # Set the object's state from the provided dictionary
--        self.all_data = state['data']
--        self.all_labels = state['label']
--        
-+	def __init__(self,path_to_data,headings,k_inds = None,include_coords = True,rescale = True,spectra_prefix = "kvals_fuse_rotate_",label_prefix = 'labels_fuse_rotate_'):
-+		
-+		self.data_dir = path_to_data
-+		self.headings = headings
-+		self.inclx = include_coords
-+
-+		df_list = []
-+		label_list = []
-+		for idx,heading in enumerate(self.headings): # for each datafile heading,
-+			data_name = osp.join(self.data_dir,spectra_prefix + heading+'.csv') # read kvals
-+			df_temp = pd.read_csv(data_name,header=None)
-+			df_temp.insert(0, 'h_idx', idx)
-+			df_list.append(df_temp)
-+			
-+			label_name = osp.join(self.data_dir,label_prefix + heading + '.csv') # read labels
-+			label_temp = pd.read_csv(label_name,header=None, names=['label'])
-+			label_list.append(label_temp)
-+
-+		df = pd.concat(df_list, ignore_index=True)
-+
-+		labels = pd.concat(label_list, ignore_index=True)
-+		df = pd.concat([labels, df], axis="columns") # Append labels to data
-+
-+		all_labels = df['label'].to_numpy()
-+		all_data = df.iloc[:,1:].to_numpy()
-+
-+		lambdas = all_data[:,3:]
-+
-+		if rescale: # rescale (normalize) wavelength intensity data
-+			lam_std = np.std(lambdas, axis=0)  # Calculate standard deviation along columns
-+			lam_mean = np.mean(lambdas, axis=0)  # Calculate mean along columns
-+			lambdas_rescaled = (lambdas - lam_mean) / lam_std 
-+			lambdas = lambdas_rescaled
-+
-+		# if k_inds != None: # THIS DOES NOT MAKE SENSE HERE
-+		#     all_data[:,3:] = all_data[:,np.array(k_inds)]
-+		self.data = lambdas
-+		self.labels = all_labels
-+
-+		if include_coords: # removes x,y coordinates (and heading index) from data
-+			# all_data = all_data[:,3:]
-+			self.coords = all_data[:,:3]
-+		else:
-+			self.coords = None
-+
-+	def __len__(self):
-+		return len(self.data)
-+
-+	def __getitem__(self,i):
-+		if self.inclx:
-+			state = {'label':self.labels[i],'coords':self.coords[i],'data':self.data[i]}
-+			return state
-+		else:
-+			state = {'label':self.labels[i],'data':self.data[i]}
-+			return state
-+
-+	def __getstate__(self):
-+		if self.inclx:
-+			state = {
-+				'data': self.data,
-+				'label': self.labels,
-+				'coords':self.coords
-+					}
-+			return state
-+		else:
-+			state = {
-+				'data': self.data,
-+				'label': self.labels,
-+					}
-+			return state
-+
-+	def __setstate__(self, state):
-+		# Set the object's state from the provided dictionary
-+		if include_coords:
-+			self.data = state['data']
-+			self.labels = state['label']
-+			self.coords = state['coords']
-+		else:
-+			self.data = state['data']
-+			self.labels = state['label']
- 
- 
- def load(config):
- 
--    n_splits = int(len(HEADINGS)/((1-config.train_split)*len(HEADINGS)))
-+	n_splits = int(len(HEADINGS)/((1-config.train_split)*len(HEADINGS)))
-+
-+	kf = RepeatedKFold(n_splits = n_splits, n_repeats = config.n_repeats, random_state = config.split_seed) # K-fold cross validation
- 
--    kf = RepeatedKFold(n_splits = n_splits, n_repeats = config.n_repeats, random_state = config.split_seed) # K-fold cross validation
-+	kf_dataloaders = []
- 
--    kf_dataloaders = []
-+	for i, (train_ind, test_ind) in enumerate(kf.split(HEADINGS)): # for each K-fold split, 
-+		n_val = len(test_ind)//2
-+		n_test = len(test_ind)-n_val   
-+		n_train = len(train_ind)
-+		
-+		# set up training DataLoader
-+		train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+		train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
- 
--    for i, (train_ind, test_ind) in enumerate(kf.split(HEADINGS)): # for each K-fold split, 
--        n_val = len(test_ind)//2
--        n_test = len(test_ind)-n_val   
--        n_train = len(train_ind)
--        
--        # set up training DataLoader
--        train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, n_train),num_workers=0,shuffle = True)
-+		# set up test DataLoader
-+		test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+		test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
- 
--        # set up test DataLoader
--        test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, n_test),num_workers=0,shuffle = True)
-+		# set up val DataLoader
-+		val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+		val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-+		
- 
--        # set up val DataLoader
--        val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, n_val),num_workers=0,shuffle = True)
--        
-+		dataloaders = {'train':train_loader, 
-+					   'test':test_loader,
-+					   'val':val_loader,
-+					   'train_inds':train_ind,
-+					   'test_inds':test_ind,
-+					   'n_val':n_val,
-+					   'test_headings':list(HEADINGS[test_ind])
-+					  }
-+		kf_dataloaders.append(dataloaders)
- 
--        dataloaders = {'train':train_loader, 
--                       'test':test_loader,
--                       'val':val_loader,
--                       'train_inds':train_ind,
--                       'test_inds':test_ind,
--                       'n_val':n_val
--                      }
--        kf_dataloaders.append(dataloaders)
-+		if not config.cross_validate:
-+			break
- 
--    return kf_dataloaders
-+	return kf_dataloaders
-diff --git a/testing.ipynb b/testing.ipynb
-index e5a167b..5b7601a 100644
---- a/testing.ipynb
-+++ b/testing.ipynb
-@@ -2,7 +2,7 @@
-  "cells": [
-   {
-    "cell_type": "code",
--   "execution_count": 1,
-+   "execution_count": 7,
-    "id": "4dee7ff1-01a4-4038-b493-9729ff3693f7",
-    "metadata": {},
-    "outputs": [],
-@@ -18,24 +18,73 @@
-     "\n",
-     "import forge\n",
-     "from forge import flags\n",
--    "import forge.experiment_tools as fet"
-+    "import forge.experiment_tools as fet\n",
-+    "\n",
-+    "from penn_dataset import PennData"
-    ]
-   },
-   {
-    "cell_type": "code",
--   "execution_count": 2,
-+   "execution_count": 8,
-+   "id": "92bae5ef-5c95-4528-a76d-003bbe09786c",
-+   "metadata": {},
-+   "outputs": [],
-+   "source": [
-+    "headings = np.array(['aaa0043','aaa0044','aaa0060','aaa0061','aaa0063','aaa0064','aaa0066','aaa0069','aaa0086','aaa0087','aaa_0051','aaa_0053','aaa_0054','aaa_0059','aaa_0071','aaa_0072'])\n"
-+   ]
-+  },
-+  {
-+   "cell_type": "code",
-+   "execution_count": 14,
-+   "id": "9d401c3e-bbc9-4ee9-a4e1-7ca7f7a3d701",
-+   "metadata": {},
-+   "outputs": [],
-+   "source": [
-+    "dat = PennData('./penn_data',headings[:1],include_coords = True)"
-+   ]
-+  },
-+  {
-+   "cell_type": "code",
-+   "execution_count": 15,
-+   "id": "8ecb4309-6ea4-4313-a913-3d832e90fe25",
-+   "metadata": {},
-+   "outputs": [
-+    {
-+     "data": {
-+      "text/plain": [
-+       "array([[ 0.,  1.,  1.],\n",
-+       "       [ 0.,  2.,  1.],\n",
-+       "       [ 0.,  3.,  1.],\n",
-+       "       ...,\n",
-+       "       [ 0., 31., 41.],\n",
-+       "       [ 0., 32., 41.],\n",
-+       "       [ 0., 33., 41.]])"
-+      ]
-+     },
-+     "execution_count": 15,
-+     "metadata": {},
-+     "output_type": "execute_result"
-+    }
-+   ],
-+   "source": [
-+    "dat.coords"
-+   ]
-+  },
-+  {
-+   "cell_type": "code",
-+   "execution_count": 6,
-    "id": "cad0fdc8-5c35-4610-bba3-b71e60dc1b98",
-    "metadata": {},
-    "outputs": [],
-    "source": [
-     "flags.DEFINE_integer(\"batch_size\", 100, \"Mini-batch size.\")\n",
--    "\n",
-+    "flags.DEFINE_st\n",
-     "flags.DEFINE_integer(\"input_size\",39,\"Input shape to model\")"
-    ]
-   },
-   {
-    "cell_type": "code",
--   "execution_count": 3,
-+   "execution_count": 7,
-    "id": "ce1b936b-8a7c-426e-a3aa-3c1c38f645de",
-    "metadata": {},
-    "outputs": [
-@@ -54,8 +103,8 @@
-   },
-   {
-    "cell_type": "code",
--   "execution_count": 9,
--   "id": "e862b7e2-57f5-44bf-bcf1-a91160ba66cc",
-+   "execution_count": 5,
-+   "id": "4469cddf-4dac-4468-be88-241d440401c3",
-    "metadata": {},
-    "outputs": [
-     {
-@@ -67,35 +116,49 @@
-     }
-    ],
-    "source": [
--    "model = fet.load(\"basic_feedforward.py\",config)"
-+    "model,modelname = fet.load(\"basic_feedforward.py\",config)"
-    ]
-   },
-   {
-    "cell_type": "code",
--   "execution_count": 10,
--   "id": "07e0b160-d5d1-4e54-b4a7-ccaf2224598a",
-+   "execution_count": 13,
-+   "id": "7c9a9fe9-f5e8-456a-b964-4be13027725b",
-    "metadata": {},
-    "outputs": [
-     {
-      "data": {
-       "text/plain": [
--       "PerceptronNN(\n",
--       "  (fc1): Linear(in_features=39, out_features=128, bias=True)\n",
--       "  (fc2): Linear(in_features=128, out_features=64, bias=True)\n",
--       "  (fc3): Linear(in_features=64, out_features=64, bias=True)\n",
--       "  (fc4): Linear(in_features=64, out_features=2, bias=True)\n",
--       ")"
-+       "array([114170,    904])"
-       ]
-      },
--     "execution_count": 10,
-+     "execution_count": 13,
-      "metadata": {},
-      "output_type": "execute_result"
-     }
-    ],
-    "source": [
--    "model"
-+    "np.bincount(loaddat[0]['train'].dataset.all_labels)"
-    ]
-   },
-+  {
-+   "cell_type": "code",
-+   "execution_count": 13,
-+   "id": "07e0b160-d5d1-4e54-b4a7-ccaf2224598a",
-+   "metadata": {},
-+   "outputs": [
-+    {
-+     "data": {
-+      "text/plain": [
-+       "<generator object Module.parameters at 0x3007207b0>"
-+      ]
-+     },
-+     "execution_count": 13,
-+     "metadata": {},
-+     "output_type": "execute_result"
-+    }
-+   ],
-+   "source": []
-+  },
-   {
-    "cell_type": "code",
-    "execution_count": null,
-diff --git a/train.py b/train.py
-index c266102..baee91a 100644
---- a/train.py
-+++ b/train.py
-@@ -1,49 +1,467 @@
- from os import path as osp
-+import os
-+import numpy as np
-+import time
- 
- import torch
-+import torch.nn as nn
- import torch.nn.functional as F
- import torch.optim as optim
--
--import numpy as np
-+from torch.utils.tensorboard import SummaryWriter
- 
- import forge
- from forge import flags
- import forge.experiment_tools as fet
- 
-+from train_tools import (
-+	log_tensorboard,
-+	parse_reports,
-+	parse_reports_cpu,
-+	print_reports,
-+	load_checkpoint,
-+	save_checkpoint,
-+	nested_to,
-+	param_count,
-+)
-+
-+from copy import deepcopy
-+from attrdict import AttrDict
-+import deepdish as dd
-+from tqdm import tqdm
-+
-+# For reproducibility while researching, but might affect speed!
-+torch.backends.cudnn.deterministic = False
-+torch.backends.cudnn.benchmark = False
-+torch.manual_seed(0)
-+
- 
- # Job config
- flags.DEFINE_string('data_config', 'penn_dataset.py',
--                    'Path to a data config file.')
-+					'Path to a data config file.')
- flags.DEFINE_string('model_config', 'basic_feedforward.py',
--                    'Path to a model config file.')
-+					'Path to a model config file.')
- flags.DEFINE_string('results_dir', 'checkpoints',
--                    'Top directory for all experimental results.')
--flags.DEFINE_string('run_name', 'feedforward',
--                    'Name of this job and name of results folder.')
-+					'Top directory for all experimental results.')
-+flags.DEFINE_string('model_name', 'gpt-FCNN',
-+					'shorthand name for model.')
-+flags.DEFINE_string('run_name', 'hyperparam_testing',
-+					'Name of this job and name of results folder.')
- flags.DEFINE_boolean('resume', False, 'Tries to resume a job if True.')
- 
- # Logging config
- flags.DEFINE_integer('report_loss_every', 50,
--                     'Number of iterations between reporting minibatch loss.')
-+					 'Number of iterations between reporting minibatch loss.')
- flags.DEFINE_integer('train_epochs', 20, 'Maximum number of training epochs.')
-+flags.DEFINE_integer(
-+	"save_check_points",
-+	50,
-+	"frequency with which to save checkpoints, in number of epoches.",
-+)
-+flags.DEFINE_boolean("log_train_values", True, "Logs train values if True.")
-+flags.DEFINE_integer(
-+	"total_evaluations",
-+	100,
-+	"Maximum number of evaluations on test and validation data during training.",
-+)
-+flags.DEFINE_boolean(
-+	"save_test_predictions",
-+	False,
-+	"Makes and saves test predictions on one or more test sets (e.g. 5-step and 100-step predictions) at the end of training.",
-+)
-+flags.DEFINE_boolean(
-+    "log_val_test", True, "Turns off computation of validation and test errors."
-+)
-+
-+flags.DEFINE_boolean('use_mps',False,"Use Metal Performance Shaders (M1) for training.")
- 
- # Experiment config
- flags.DEFINE_integer('batch_size', 100, 'Mini-batch size.')
--flags.DEFINE_float('learning_rate', 1e-5, 'SGD learning rate.')
-+flags.DEFINE_float("learning_rate", 1e-3, "Adam learning rate.")
-+flags.DEFINE_float("beta1", 0.9, "Adam Beta 1 parameter")
-+flags.DEFINE_float("beta2", 0.999, "Adam Beta 2 parameter")
- 
- # Specific config options
- flags.DEFINE_integer("input_size",39,"Input shape to model")
- 
-+#########################################################################################
-+
-+def evaluate(model, loader, device,fold = 0,headings = [],loss_func = nn.CrossEntropyLoss()):
-+	# this function does not account for class weights when evaluating cross-entropy loss.
-+	# however, they are accounted for when evaluating training loss
-+	reports = None
-+	for data in loader:
-+		labels = data['label']
-+		inputs = nested_to(data['data'],device,torch.float32)
-+		
-+		labels_tensor = torch.zeros((len(labels), 2))
-+		for i, label in enumerate(labels):
-+			labels_tensor[i, label] = 1
-+
-+		model_output = model(inputs) # evaluate model
-+
-+		loss = loss_func(model_output, labels_tensor) # compute loss
-+		outputs = AttrDict({"loss": loss, "prediction": model_output,'data_fold':fold})
-+		outputs.reports = AttrDict({"cross_entropy": loss})
-+
-+		if reports is None:
-+			reports = {k: v.detach().clone().cpu() for k, v in outputs.reports.items()}
-+		else:
-+			for k, v in outputs.reports.items():
-+				reports[k] += v.detach().clone().cpu()
-+
-+	for k, v in reports.items():
-+		reports[k] = v / len(
-+			loader
-+		)  # SZ: note this can be slightly incorrect if mini-batch sizes vary (if batch_size doesn't divide train_size), but approximately correct.
-+
-+	# reports['test_headings'] = np.array(headings)
-+
-+	return reports
-+
-+def main():
-+
-+	config = forge.config()
-+
-+	# Set device
-+	if torch.cuda.is_available():
-+		device = f"cuda:{config.device}"
-+		torch.cuda.set_device(device)
-+	else:
-+		device = "cpu" # can change this to MPS on M1 Macs
-+
-+	if config.use_mps:
-+		device = "mps"
-+
-+	# Load data
-+	data_name = "penn_data"
-+	kfold_loaders = fet.load(config.data_config, config)
-+
-+	# Prepare environment
-+	params_in_run_name = [
-+		("batch_size", "bs"),
-+		("learning_rate", "lr"),
-+		("n_train", "ntrain"),
-+		("include_coords",'inclx'),
-+		("input_size",'inpsize'),
-+		("cross_validate",'crval'),
-+		("train_epochs",'n_epochs'),
-+		("n_repeats",'nrep')
-+	]
-+
-+	run_name = ""  # config.run_name
-+	for config_param in params_in_run_name:
-+		attr = config_param[0]
-+		abbrev = config_param[1]
-+
-+		if hasattr(config, attr):
-+			run_name += abbrev
-+			run_name += str(getattr(config, attr))
-+			run_name += "_"
-+
-+	results_folder_name = osp.join(
-+		data_name,
-+		config.model_name,
-+		config.run_name,
-+		run_name,
-+	)
-+
-+	# Prepare environment
-+	logdir = osp.join(config.results_dir, results_folder_name.replace(".", "_"))
-+	logdir, resume_checkpoint = fet.init_checkpoint(
-+		logdir, config.data_config, config.model_config, config.resume)
-+
-+	print("Checkpoint directory:",logdir)
-+
-+	# Print flags
-+	fet.print_flags()
-+
-+	n_folds = len(kfold_loaders)
-+	print("Doing {}-fold cross-validation.".format(n_folds))
-+
-+	# KFOLD TRAINING LOOP
-+	for k,loader_k in enumerate(kfold_loaders): # loop over data splits
-+
-+		print("Training fold {}...".format(k+1))
-+
-+		# Load model
-+		model,model_name = fet.load(config.model_config, config)
-+		model = model.to(device)
-+
-+		# Print model info
-+		print(model)
-+
-+		# Setup optimizer
-+		model_params = model.parameters()
-+		opt_learning_rate = config.learning_rate
-+		model_opt = torch.optim.Adam(
-+			model_params, lr=opt_learning_rate, betas=(config.beta1, config.beta2)
-+		)
-+		scheduler = torch.optim.lr_scheduler.StepLR(model_opt, step_size=10, gamma=0.5)
-+		print("Model Optimizer:")
-+		print(model_opt)
-+
-+		# Try to restore model and optimizer from checkpoint
-+		if resume_checkpoint is not None:
-+			start_epoch = load_checkpoint(resume_checkpoint, model, model_opt)
-+		else:
-+			start_epoch = 1
-+
-+		# load the training data
-+		train_loader = loader_k["train"]
-+		n_train = len(train_loader.dataset)
-+		train_batch_size = train_loader.batch_size
-+
-+		# load testing, validation
-+		test_loader = loader_k["test"]
-+		n_test = len(test_loader.dataset)
-+		val_loader = loader_k["val"]
-+		n_val = len(val_loader.dataset)
-+
-+		train_class_counts = np.bincount(train_loader.dataset.labels)
-+		train_total_counts = sum(train_class_counts)
-+		class_weight = torch.tensor(1.0 / train_class_counts) * train_total_counts / 2.0
-+
-+		loss_func = nn.CrossEntropyLoss(weight = class_weight) # define reweighted loss function
-+				
-+		# create folder for this data split
-+		fold_dir = osp.join(logdir,"data_fold{}".format(k+1))
-+		fold_dir_exists = osp.exists(fold_dir)
-+		if not fold_dir_exists:
-+			if config.resume:
-+				raise ValueError("Can't resume when the checkpoint/fold dir '{}' doesn't exist.".format(fold_dir))
-+			else:
-+				os.makedirs(fold_dir)
-+		checkpoint_name = osp.join(fold_dir, 'model_fold{}.ckpt'.format(k+1))
-+
-+		# keep track of which data is test data for a given Kfold data split
-+		test_headings = loader_k['test_headings']
-+		headingsFile = osp.join(fold_dir,"test_headings.txt")
-+		with open(headingsFile,'w') as headfile:
-+			for heading in test_headings:
-+				headfile.write(heading+'\n')
-+
-+		# print(checkpoint_name)
-+
-+		train_iter = (start_epoch - 1) * (
-+		len(train_loader.dataset) // train_batch_size
-+		) + 1
-+
-+		print("Starting training at epoch = {}, iter = {}".format(start_epoch, train_iter))
-+
-+		# Setup tensorboard writing
-+		summary_writer = SummaryWriter(logdir)
-+
-+		train_reports = []
-+		report_all = {}
-+		report_all_val = {}
-+
-+		# Saving model at epoch 0 before training
-+		print("saving model at epoch 0 before training ... ")
-+		save_checkpoint(checkpoint_name, 0, model, model_opt, loss=0.0)
-+		print("finished saving model at epoch 0 before training")
-+
-+		num_params = param_count(model)
-+		print(f"Number of model parameters: {num_params}")
-+
-+		# Training
-+		start_t = time.time()
-+
-+		total_train_iters = len(train_loader) * config.train_epochs
-+		iters_per_eval = max(1, int(total_train_iters / config.total_evaluations))
-+		# print('batch',train_batch_size)
-+		# print('ntrain',n_train)
-+		# assert (
-+		# 	n_train % min(train_batch_size, n_train) == 0
-+		# ), "Batch size doesn't divide dataset size. Can be inaccurate for loss computation (see below)."
-+
-+		training_failed = False
-+		best_val_loss_so_far = 1e7
-+
-+		for epoch in tqdm(range(start_epoch, config.train_epochs + 1)):
-+			model.train()
-+
-+			runsum = 0
-+			for batch_idx, data_dict in enumerate(train_loader): # Loop over batched data
-+
-+				labels = data_dict['label']
-+				data = data_dict['data']
-+
-+				# send data to device
-+				data = nested_to(data,device,torch.float32)
-+				# One-hot encode the data labels
-+				labels_tensor = torch.zeros((len(labels), 2))
-+				for i, label in enumerate(labels):
-+					labels_tensor[i, label] = 1
-+
-+				model_output = model(data) # evaluate model
-+
-+				loss = loss_func(model_output, labels_tensor) # compute loss
-+				runsum += loss.item() # track loss
-+				outputs = AttrDict({"loss": loss, "prediction": model_output})
-+				outputs.reports = AttrDict({"cross_entropy": loss})
-+
-+				if torch.isnan(outputs.loss): # check for failure in training
-+					if not training_failed:
-+						epoch_of_nan = epoch
-+					if (epoch > epoch_of_nan + 1) and training_failed:
-+						raise ValueError("Loss Nan-ed.")
-+					training_failed = True
-+
-+				model_opt.zero_grad()
-+				outputs.loss.backward(retain_graph=False)
-+
-+				model_opt.step() # move optimizer forward
-+
-+				if config.log_train_values:
-+					reports = parse_reports(outputs.reports)
-+					if batch_idx % config.report_loss_every == 0:
-+						train_reports.append([train_iter,runsum/config.report_loss_every])
-+						runsum = 0
-+						log_tensorboard(summary_writer, train_iter, reports, "train/")
-+						print_reports(
-+							reports,
-+							start_t,
-+							epoch,
-+							batch_idx,
-+							len(train_loader.dataset) // train_batch_size,
-+							prefix="train",
-+						)
-+						log_tensorboard(
-+							summary_writer,
-+							train_iter,
-+							{"lr": model_opt.param_groups[0]["lr"]},
-+							"hyperparams/",
-+						)
-+				# Logging and evaluation
-+				if (
-+					train_iter % iters_per_eval == 0 or (train_iter == total_train_iters)
-+				) and config.log_val_test:  # batch_idx % config.evaluate_every == 0:
-+					model.eval()
-+					
-+					with torch.no_grad():
-+						reports = evaluate(model, test_loader, device,fold = k,headings = loader_k['test_headings'])
-+						# print("REPORTS",reports)
-+						reports = parse_reports(reports)
-+						reports["time"] = time.time() - start_t
-+						if report_all == {}:
-+							report_all = deepcopy(reports)
-+
-+							for d in reports.keys():
-+								report_all[d] = [report_all[d]]
-+						else:
-+							for d in reports.keys():
-+								report_all[d].append(reports[d])
-+
-+						log_tensorboard(summary_writer, train_iter, reports, "test/")
-+						print_reports(
-+							reports,
-+							start_t,
-+							epoch,
-+							batch_idx,
-+							len(train_loader.dataset) // config.batch_size,
-+							prefix="test",
-+						)
-+
-+						# repeat for validation data
-+						reports = evaluate(model, val_loader, device,fold = k,headings = loader_k['test_headings'])
-+						reports = parse_reports(reports)
-+						reports["time"] = time.time() - start_t
-+						if report_all_val == {}:
-+							report_all_val = deepcopy(reports)
-+
-+							for d in reports.keys():
-+								report_all_val[d] = [report_all_val[d]]
-+						else:
-+							for d in reports.keys():
-+								report_all_val[d].append(reports[d])
-+
-+						log_tensorboard(summary_writer, train_iter, reports, "val/")
-+						print_reports(
-+							reports,
-+							start_t,
-+							epoch,
-+							batch_idx,
-+							len(train_loader.dataset) // config.batch_size,
-+							prefix="val",
-+						)
-+
-+						if report_all_val["cross_entropy"][-1] < best_val_loss_so_far:
-+							save_checkpoint(
-+								checkpoint_name,
-+								f"early_stop",
-+								model,
-+								model_opt,
-+								loss=outputs.loss,
-+							)
-+							best_val_loss_so_far = report_all_val["cross_entropy"][-1]
-+
-+					model.train()
-+
-+				train_iter += 1
-+
-+			scheduler.step()
-+
-+			
-+
-+			if epoch % config.save_check_points == 0:
-+				save_checkpoint(
-+					checkpoint_name, train_iter, model, model_opt, loss=outputs.loss
-+				)
-+		
-+		dd.io.save(fold_dir + "/results_dict_train.h5", train_reports)
-+		dd.io.save(fold_dir + "/results_dict.h5", report_all)
-+		dd.io.save(fold_dir + "/results_dict_val.h5", report_all_val)
-+
-+	# always save final model
-+	save_checkpoint(checkpoint_name, train_iter, model, model_opt, loss=outputs.loss)
-+
-+	
-+	if config.save_test_predictions:
-+		pass
-+		# print("Starting to make model predictions on test sets for *final model*.")
-+		# for chunk_len in [5, 100]:
-+		#     start_t_preds = time.time()
-+		#     data_config = SimpleNamespace(
-+		#         **{
-+		#             **config.__dict__["__flags"],
-+		#             **{"chunk_len": chunk_len, "batch_size": 500},
-+		#         }
-+		#     )
-+		#     dataloaders, data_name = fet.load(config.data_config, config=data_config)
-+		#     test_loader_preds = dataloaders["test"]
-+
-+		#     torch.cuda.empty_cache()
-+		#     with torch.no_grad():
-+		#         preds = []
-+		#         true = []
-+		#         num_datapoints = 0
-+		#         for idx, d in enumerate(test_loader_preds):
-+		#             true.append(d[-1])
-+		#             d = nested_to(d, device, torch.float32)
-+		#             outputs = model(d)
-+
-+		#             pred_zs = outputs.prediction
-+		#             preds.append(pred_zs)
-+
-+		#             num_datapoints += len(pred_zs)
-+
-+		#             if num_datapoints >= 2000:
-+		#                 break
- 
--config = forge.config()
-+		#         preds = torch.cat(preds, dim=0).cpu()
-+		#         true = torch.cat(true, dim=0).cpu()
- 
--# Prepare environment
--logdir = osp.join(config.results_dir, config.run_name)
--logdir, resume_checkpoint = fet.init_checkpoint(
--    logdir, config.data_config, config.model_config, config.resume)
--checkpoint_name = osp.join(logdir, 'model.ckpt')
-+		#         save_dir = osp.join(logdir, f"traj_preds_{chunk_len}_steps_2k_test.pt")
-+		#         torch.save(preds, save_dir)
- 
-+		#         save_dir = osp.join(logdir, f"traj_true_{chunk_len}_steps_2k_test.pt")
-+		#         torch.save(true, save_dir)
- 
--print(logdir)
-+		#         print(
-+		#             f"Completed making test predictions for chunk_len = {chunk_len} in {time.time() - start_t_preds:.2f} seconds."
-+		#         )	
-+		
- 
-+if __name__ == "__main__":
-+	main()
- 
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/penn_dataset.py b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/penn_dataset.py
deleted file mode 100644
index 41d02d6..0000000
--- a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep1_/2/penn_dataset.py
+++ /dev/null
@@ -1,158 +0,0 @@
-import os
-import torch
-import pandas as pd
-import numpy as np
-
-from torchvision import datasets, transforms
-from torch.utils.data import Dataset, DataLoader
-from sklearn.model_selection import RepeatedKFold
-
-from os import path as osp
-import forge
-from forge import flags
-
-
-# aspects of data managmement
-flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
-flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-flags.DEFINE_boolean("cross_validate",True,"Do K-fold cross-validation")
-
-# Job management
-# flags.DEFINE_integer("batch size",5,"training batch size")
-flags.DEFINE_float("train_split",0.8,'Fraction of data to use for training.')
-flags.DEFINE_integer("n_repeats",1,"Times to repeat K-fold cross-validation")
-flags.DEFINE_integer("split_seed",1,"Seed for KFold split (integer for reproducibility")
-
-# "wavelengths between 0.05 and 1 mm in 0.025 mm increments."
-LSPACE = np.arange(0.05,1.05,0.025) # corresponds to 39 non-coord columns of data
-L_INDS = None # specific indices of data to select
-
-DATAFOLDER = './penn_data'
-
-HEADINGS = np.array(['aaa0043','aaa0044','aaa0060','aaa0061','aaa0063','aaa0064','aaa0066','aaa0069','aaa0086','aaa0087','aaa_0051','aaa_0053','aaa_0054','aaa_0059','aaa_0071','aaa_0072'])
-
-
-class PennData(Dataset):
-
-	def __init__(self,path_to_data,headings,k_inds = None,include_coords = True,rescale = True,spectra_prefix = "kvals_fuse_rotate_",label_prefix = 'labels_fuse_rotate_'):
-		
-		self.data_dir = path_to_data
-		self.headings = headings
-		self.inclx = include_coords
-
-		df_list = []
-		label_list = []
-		for idx,heading in enumerate(self.headings): # for each datafile heading,
-			data_name = osp.join(self.data_dir,spectra_prefix + heading+'.csv') # read kvals
-			df_temp = pd.read_csv(data_name,header=None)
-			df_temp.insert(0, 'h_idx', idx)
-			df_list.append(df_temp)
-			
-			label_name = osp.join(self.data_dir,label_prefix + heading + '.csv') # read labels
-			label_temp = pd.read_csv(label_name,header=None, names=['label'])
-			label_list.append(label_temp)
-
-		df = pd.concat(df_list, ignore_index=True)
-
-		labels = pd.concat(label_list, ignore_index=True)
-		df = pd.concat([labels, df], axis="columns") # Append labels to data
-
-		all_labels = df['label'].to_numpy()
-		all_data = df.iloc[:,1:].to_numpy()
-
-		lambdas = all_data[:,3:]
-
-		if rescale: # rescale (normalize) wavelength intensity data
-			lam_std = np.std(lambdas, axis=0)  # Calculate standard deviation along columns
-			lam_mean = np.mean(lambdas, axis=0)  # Calculate mean along columns
-			lambdas_rescaled = (lambdas - lam_mean) / lam_std 
-			lambdas = lambdas_rescaled
-
-		# if k_inds != None: # THIS DOES NOT MAKE SENSE HERE
-		#     all_data[:,3:] = all_data[:,np.array(k_inds)]
-		self.data = lambdas
-		self.labels = all_labels
-
-		if include_coords: # removes x,y coordinates (and heading index) from data
-			# all_data = all_data[:,3:]
-			self.coords = all_data[:,:3]
-		else:
-			self.coords = None
-
-	def __len__(self):
-		return len(self.data)
-
-	def __getitem__(self,i):
-		if self.inclx:
-			state = {'label':self.labels[i],'coords':self.coords[i],'data':self.data[i]}
-			return state
-		else:
-			state = {'label':self.labels[i],'data':self.data[i]}
-			return state
-
-	def __getstate__(self):
-		if self.inclx:
-			state = {
-				'data': self.data,
-				'label': self.labels,
-				'coords':self.coords
-					}
-			return state
-		else:
-			state = {
-				'data': self.data,
-				'label': self.labels,
-					}
-			return state
-
-	def __setstate__(self, state):
-		# Set the object's state from the provided dictionary
-		if include_coords:
-			self.data = state['data']
-			self.labels = state['label']
-			self.coords = state['coords']
-		else:
-			self.data = state['data']
-			self.labels = state['label']
-
-
-def load(config):
-
-	n_splits = int(len(HEADINGS)/((1-config.train_split)*len(HEADINGS)))
-
-	kf = RepeatedKFold(n_splits = n_splits, n_repeats = config.n_repeats, random_state = config.split_seed) # K-fold cross validation
-
-	kf_dataloaders = []
-
-	for i, (train_ind, test_ind) in enumerate(kf.split(HEADINGS)): # for each K-fold split, 
-		n_val = len(test_ind)//2
-		n_test = len(test_ind)-n_val   
-		n_train = len(train_ind)
-		
-		# set up training DataLoader
-		train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-		train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
-
-		# set up test DataLoader
-		test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-		test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
-
-		# set up val DataLoader
-		val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-		val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-		
-
-		dataloaders = {'train':train_loader, 
-					   'test':test_loader,
-					   'val':val_loader,
-					   'train_inds':train_ind,
-					   'test_inds':test_ind,
-					   'n_val':n_val,
-					   'test_headings':list(HEADINGS[test_ind])
-					  }
-		kf_dataloaders.append(dataloaders)
-
-		if not config.cross_validate:
-			break
-
-	return kf_dataloaders
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep2_/.DS_Store b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep2_/.DS_Store
deleted file mode 100644
index 5008ddf..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs20_nrep2_/.DS_Store and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/1/basic_feedforward.py b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/1/basic_feedforward.py
deleted file mode 100644
index a814670..0000000
--- a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/1/basic_feedforward.py
+++ /dev/null
@@ -1,74 +0,0 @@
-import torch
-import torch.nn as nn
-import torch.nn.functional as F
-import numpy as np
-
-from forge import flags
-
-# flags.DEFINE_boolean(
-#     "model_with_dict",
-#     True,
-#     "Makes model output predictions in dictionary instead of directly."
-# )
-
-class PerceptronNN(nn.Module):
-    def __init__(self, input_size, num_labels):
-        super(PerceptronNN, self).__init__()
-        # Define the layers
-        self.fc1 = nn.Linear(input_size, 128)  # First dense layer
-        self.fc2 = nn.Linear(128, 64)         # Second dense layer
-        # self.fc23 = nn.Linear(64,64)
-        self.fc3 = nn.Linear(64, 64)          # Third dense layer
-        self.fc4 = nn.Linear(64, num_labels)  # Output layer
-        # self.softmax = nn.Softmax(dim=1)
-
-    def forward(self, x):
-        # Forward pass through the network
-        x = F.relu(self.fc1(x))  # Activation function between layers
-        x = F.relu(self.fc2(x))
-        # x = F.relu(self.fc23(x))
-        x = F.relu(self.fc3(x))
-        x = self.fc4(x)  # No activation, this will be included in the loss function
-        # x = self.softmax(x)
-        return x
-
-class GPT_PNN(nn.Module):
-    def __init__(self, input_size, num_labels):
-        super(GPT_PNN, self).__init__()
-        # Define the layers
-        self.fc1 = nn.Linear(input_size, 64)  # First dense layer, reduced size
-        self.bn1 = nn.BatchNorm1d(64)  # Batch Normalization for the first layer
-        self.dropout1 = nn.Dropout(0.5)  # Dropout with 50% probability
-        
-        # Commenting out to reduce model complexity
-        # self.fc2 = nn.Linear(128, 64)  # Second dense layer
-        # self.dropout2 = nn.Dropout(0.5)  # Additional dropout layer
-        
-        # Simplified to have fewer layers and neurons
-        self.fc2 = nn.Linear(64, 32)  # Reduced size for second dense layer
-        self.bn2 = nn.BatchNorm1d(32)  # Batch Normalization for the second layer
-        self.dropout2 = nn.Dropout(0.5)  # Dropout with 50% probability
-
-        # Output layer remains the same, adjusted for reduced prior layer size
-        self.fc3 = nn.Linear(32, num_labels)  # Output layer
-
-    def forward(self, x):
-        x = x[:,::2] # try using every other wavelength
-        # Forward pass through the network with activations, batch normalization, and dropout
-        x = F.relu(self.bn1(self.fc1(x)))
-        x = self.dropout1(x)
-        x = F.relu(self.bn2(self.fc2(x)))
-        x = self.dropout2(x)
-        x = self.fc3(x)  # No activation here, use sigmoid or softmax outside if needed for binary classification
-        return x
-
-def load(config):
-
-    # n_channels = 1
-    n_features = config.input_size
-    
-    # mlp = PerceptronNN(n_features,2)
-
-    mlp = GPT_PNN(n_features,2)
-    
-    return mlp, "gpt_feedforward_halfLs"
\ No newline at end of file
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/1/data_fold1/model_fold1.ckpt-0 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/1/data_fold1/model_fold1.ckpt-0
deleted file mode 100644
index 26d8425..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/1/data_fold1/model_fold1.ckpt-0 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/1/data_fold1/test_headings.txt b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/1/data_fold1/test_headings.txt
deleted file mode 100644
index 05c4825..0000000
--- a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/1/data_fold1/test_headings.txt
+++ /dev/null
@@ -1,4 +0,0 @@
-aaa0060
-aaa0061
-aaa0069
-aaa_0059
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/1/events.out.tfevents.1709692016.MacBook-Pro-4.local.4357.0 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/1/events.out.tfevents.1709692016.MacBook-Pro-4.local.4357.0
deleted file mode 100644
index 10d0d04..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/1/events.out.tfevents.1709692016.MacBook-Pro-4.local.4357.0 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/1/flags.json b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/1/flags.json
deleted file mode 100644
index 0a98821..0000000
--- a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/1/flags.json
+++ /dev/null
@@ -1,28 +0,0 @@
-{
-    "batch_size": 100,
-    "beta1": 0.9,
-    "beta2": 0.999,
-    "cross_validate": true,
-    "data_config": "penn_dataset.py",
-    "git_commit": "7416bf730b356aabfe0df644240e40948a8196bb",
-    "include_coords": false,
-    "input_size": 39,
-    "learning_rate": 0.001,
-    "log_train_values": true,
-    "log_val_test": true,
-    "model_config": "basic_feedforward.py",
-    "model_name": "gpt-FCNN",
-    "n_repeats": 1,
-    "report_loss_every": 50,
-    "rescale": true,
-    "results_dir": "checkpoints",
-    "resume": false,
-    "run_name": "hyperparam_testing",
-    "save_check_points": 50,
-    "save_test_predictions": false,
-    "split_seed": 1,
-    "total_evaluations": 100,
-    "train_epochs": 75,
-    "train_split": 0.8,
-    "use_mps": false
-}
\ No newline at end of file
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/1/git_diff.txt b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/1/git_diff.txt
deleted file mode 100644
index 3d04faf..0000000
--- a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/1/git_diff.txt
+++ /dev/null
@@ -1,1813 +0,0 @@
-Tue Mar 5 18:26:56 PST 2024
-diff --git a/.DS_Store b/.DS_Store
-index e2836a8..bf7630a 100644
-Binary files a/.DS_Store and b/.DS_Store differ
-diff --git a/.ipynb_checkpoints/basic_feedforward-checkpoint.py b/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-index 688c282..0c4bcd1 100644
---- a/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-+++ b/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-@@ -5,6 +5,12 @@ import numpy as np
- 
- from forge import flags
- 
-+flags.DEFINE_boolean(
-+    "model_with_dict",
-+    True,
-+    "Makes model output predictions in dictionary instead of directly."
-+)
-+
- class PerceptronNN(nn.Module):
-     def __init__(self, input_size, num_labels):
-         super(PerceptronNN, self).__init__()
-@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-+        self.softmax = nn.Softmax(dim=1)
- 
-     def forward(self, x):
-         # Forward pass through the network
-@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-         x = F.relu(self.fc2(x))
-         x = F.relu(self.fc3(x))
-         x = self.fc4(x)  # No activation, this will be included in the loss function
-+        x = self.softmax(x)
-         return x
- 
- def load(config):
-@@ -29,4 +37,4 @@ def load(config):
-     
-     mlp = PerceptronNN(n_features,2)
-     
--    return mlp
-\ No newline at end of file
-+    return mlp, "feedforward"
-\ No newline at end of file
-diff --git a/__pycache__/basic_feedforward.cpython-39.pyc b/__pycache__/basic_feedforward.cpython-39.pyc
-index f541140..adb613e 100644
-Binary files a/__pycache__/basic_feedforward.cpython-39.pyc and b/__pycache__/basic_feedforward.cpython-39.pyc differ
-diff --git a/__pycache__/penn_dataset.cpython-39.pyc b/__pycache__/penn_dataset.cpython-39.pyc
-index 0d7a4de..6fdde51 100644
-Binary files a/__pycache__/penn_dataset.cpython-39.pyc and b/__pycache__/penn_dataset.cpython-39.pyc differ
-diff --git a/basic_feedforward.py b/basic_feedforward.py
-index 688c282..a814670 100644
---- a/basic_feedforward.py
-+++ b/basic_feedforward.py
-@@ -5,21 +5,61 @@ import numpy as np
- 
- from forge import flags
- 
-+# flags.DEFINE_boolean(
-+#     "model_with_dict",
-+#     True,
-+#     "Makes model output predictions in dictionary instead of directly."
-+# )
-+
- class PerceptronNN(nn.Module):
-     def __init__(self, input_size, num_labels):
-         super(PerceptronNN, self).__init__()
-         # Define the layers
-         self.fc1 = nn.Linear(input_size, 128)  # First dense layer
-         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-+        # self.fc23 = nn.Linear(64,64)
-         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-+        # self.softmax = nn.Softmax(dim=1)
- 
-     def forward(self, x):
-         # Forward pass through the network
-         x = F.relu(self.fc1(x))  # Activation function between layers
-         x = F.relu(self.fc2(x))
-+        # x = F.relu(self.fc23(x))
-         x = F.relu(self.fc3(x))
-         x = self.fc4(x)  # No activation, this will be included in the loss function
-+        # x = self.softmax(x)
-+        return x
-+
-+class GPT_PNN(nn.Module):
-+    def __init__(self, input_size, num_labels):
-+        super(GPT_PNN, self).__init__()
-+        # Define the layers
-+        self.fc1 = nn.Linear(input_size, 64)  # First dense layer, reduced size
-+        self.bn1 = nn.BatchNorm1d(64)  # Batch Normalization for the first layer
-+        self.dropout1 = nn.Dropout(0.5)  # Dropout with 50% probability
-+        
-+        # Commenting out to reduce model complexity
-+        # self.fc2 = nn.Linear(128, 64)  # Second dense layer
-+        # self.dropout2 = nn.Dropout(0.5)  # Additional dropout layer
-+        
-+        # Simplified to have fewer layers and neurons
-+        self.fc2 = nn.Linear(64, 32)  # Reduced size for second dense layer
-+        self.bn2 = nn.BatchNorm1d(32)  # Batch Normalization for the second layer
-+        self.dropout2 = nn.Dropout(0.5)  # Dropout with 50% probability
-+
-+        # Output layer remains the same, adjusted for reduced prior layer size
-+        self.fc3 = nn.Linear(32, num_labels)  # Output layer
-+
-+    def forward(self, x):
-+        x = x[:,::2] # try using every other wavelength
-+        # Forward pass through the network with activations, batch normalization, and dropout
-+        x = F.relu(self.bn1(self.fc1(x)))
-+        x = self.dropout1(x)
-+        x = F.relu(self.bn2(self.fc2(x)))
-+        x = self.dropout2(x)
-+        x = self.fc3(x)  # No activation here, use sigmoid or softmax outside if needed for binary classification
-         return x
- 
- def load(config):
-@@ -27,6 +67,8 @@ def load(config):
-     # n_channels = 1
-     n_features = config.input_size
-     
--    mlp = PerceptronNN(n_features,2)
-+    # mlp = PerceptronNN(n_features,2)
-+
-+    mlp = GPT_PNN(n_features,2)
-     
--    return mlp
-\ No newline at end of file
-+    return mlp, "gpt_feedforward_halfLs"
-\ No newline at end of file
-diff --git a/checkpoints/feedforward/1/basic_feedforward.py b/checkpoints/feedforward/1/basic_feedforward.py
-index 688c282..3a65525 100644
---- a/checkpoints/feedforward/1/basic_feedforward.py
-+++ b/checkpoints/feedforward/1/basic_feedforward.py
-@@ -5,6 +5,12 @@ import numpy as np
- 
- from forge import flags
- 
-+# flags.DEFINE_boolean(
-+#     "model_with_dict",
-+#     True,
-+#     "Makes model output predictions in dictionary instead of directly."
-+# )
-+
- class PerceptronNN(nn.Module):
-     def __init__(self, input_size, num_labels):
-         super(PerceptronNN, self).__init__()
-@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-+        self.softmax = nn.Softmax(dim=1)
- 
-     def forward(self, x):
-         # Forward pass through the network
-@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-         x = F.relu(self.fc2(x))
-         x = F.relu(self.fc3(x))
-         x = self.fc4(x)  # No activation, this will be included in the loss function
-+        x = self.softmax(x)
-         return x
- 
- def load(config):
-@@ -29,4 +37,4 @@ def load(config):
-     
-     mlp = PerceptronNN(n_features,2)
-     
--    return mlp
-\ No newline at end of file
-+    return mlp, "feedforward"
-\ No newline at end of file
-diff --git a/checkpoints/feedforward/1/flags.json b/checkpoints/feedforward/1/flags.json
-index 1d000c3..889a6ea 100644
---- a/checkpoints/feedforward/1/flags.json
-+++ b/checkpoints/feedforward/1/flags.json
-@@ -1,9 +1,15 @@
- {
-     "batch_size": 100,
-+    "beta1": 0.9,
-+    "beta2": 0.999,
-+    "cross_validate": false,
-     "data_config": "penn_dataset.py",
-+    "git_commit": "7416bf730b356aabfe0df644240e40948a8196bb",
-     "include_coords": false,
-     "input_size": 39,
--    "learning_rate": 1e-05,
-+    "learning_rate": 0.0001,
-+    "log_train_values": true,
-+    "log_val_test": true,
-     "model_config": "basic_feedforward.py",
-     "n_repeats": 1,
-     "report_loss_every": 50,
-@@ -11,7 +17,10 @@
-     "results_dir": "checkpoints",
-     "resume": false,
-     "run_name": "feedforward",
-+    "save_check_points": 50,
-+    "save_test_predictions": false,
-     "split_seed": 1,
--    "train_epochs": 20,
-+    "total_evaluations": 100,
-+    "train_epochs": 100,
-     "train_split": 0.8
- }
-\ No newline at end of file
-diff --git a/checkpoints/feedforward/1/git_diff.txt b/checkpoints/feedforward/1/git_diff.txt
-index 7b37e6f..ec23707 100644
---- a/checkpoints/feedforward/1/git_diff.txt
-+++ b/checkpoints/feedforward/1/git_diff.txt
-@@ -1 +1,873 @@
--Mon Mar 4 11:45:48 PST 2024
-+Mon Mar 4 16:34:02 PST 2024
-+diff --git a/.DS_Store b/.DS_Store
-+index e2836a8..7e3fa32 100644
-+Binary files a/.DS_Store and b/.DS_Store differ
-+diff --git a/.ipynb_checkpoints/basic_feedforward-checkpoint.py b/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-+index 688c282..0c4bcd1 100644
-+--- a/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-++++ b/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-+@@ -5,6 +5,12 @@ import numpy as np
-+ 
-+ from forge import flags
-+ 
-++flags.DEFINE_boolean(
-++    "model_with_dict",
-++    True,
-++    "Makes model output predictions in dictionary instead of directly."
-++)
-++
-+ class PerceptronNN(nn.Module):
-+     def __init__(self, input_size, num_labels):
-+         super(PerceptronNN, self).__init__()
-+@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-+         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-+         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-+         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-++        self.softmax = nn.Softmax(dim=1)
-+ 
-+     def forward(self, x):
-+         # Forward pass through the network
-+@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-+         x = F.relu(self.fc2(x))
-+         x = F.relu(self.fc3(x))
-+         x = self.fc4(x)  # No activation, this will be included in the loss function
-++        x = self.softmax(x)
-+         return x
-+ 
-+ def load(config):
-+@@ -29,4 +37,4 @@ def load(config):
-+     
-+     mlp = PerceptronNN(n_features,2)
-+     
-+-    return mlp
-+\ No newline at end of file
-++    return mlp, "feedforward"
-+\ No newline at end of file
-+diff --git a/__pycache__/basic_feedforward.cpython-39.pyc b/__pycache__/basic_feedforward.cpython-39.pyc
-+index f541140..5ad96de 100644
-+Binary files a/__pycache__/basic_feedforward.cpython-39.pyc and b/__pycache__/basic_feedforward.cpython-39.pyc differ
-+diff --git a/__pycache__/penn_dataset.cpython-39.pyc b/__pycache__/penn_dataset.cpython-39.pyc
-+index 0d7a4de..19121eb 100644
-+Binary files a/__pycache__/penn_dataset.cpython-39.pyc and b/__pycache__/penn_dataset.cpython-39.pyc differ
-+diff --git a/basic_feedforward.py b/basic_feedforward.py
-+index 688c282..3a65525 100644
-+--- a/basic_feedforward.py
-++++ b/basic_feedforward.py
-+@@ -5,6 +5,12 @@ import numpy as np
-+ 
-+ from forge import flags
-+ 
-++# flags.DEFINE_boolean(
-++#     "model_with_dict",
-++#     True,
-++#     "Makes model output predictions in dictionary instead of directly."
-++# )
-++
-+ class PerceptronNN(nn.Module):
-+     def __init__(self, input_size, num_labels):
-+         super(PerceptronNN, self).__init__()
-+@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-+         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-+         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-+         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-++        self.softmax = nn.Softmax(dim=1)
-+ 
-+     def forward(self, x):
-+         # Forward pass through the network
-+@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-+         x = F.relu(self.fc2(x))
-+         x = F.relu(self.fc3(x))
-+         x = self.fc4(x)  # No activation, this will be included in the loss function
-++        x = self.softmax(x)
-+         return x
-+ 
-+ def load(config):
-+@@ -29,4 +37,4 @@ def load(config):
-+     
-+     mlp = PerceptronNN(n_features,2)
-+     
-+-    return mlp
-+\ No newline at end of file
-++    return mlp, "feedforward"
-+\ No newline at end of file
-+diff --git a/checkpoints/feedforward/1/basic_feedforward.py b/checkpoints/feedforward/1/basic_feedforward.py
-+index 688c282..3a65525 100644
-+--- a/checkpoints/feedforward/1/basic_feedforward.py
-++++ b/checkpoints/feedforward/1/basic_feedforward.py
-+@@ -5,6 +5,12 @@ import numpy as np
-+ 
-+ from forge import flags
-+ 
-++# flags.DEFINE_boolean(
-++#     "model_with_dict",
-++#     True,
-++#     "Makes model output predictions in dictionary instead of directly."
-++# )
-++
-+ class PerceptronNN(nn.Module):
-+     def __init__(self, input_size, num_labels):
-+         super(PerceptronNN, self).__init__()
-+@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-+         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-+         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-+         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-++        self.softmax = nn.Softmax(dim=1)
-+ 
-+     def forward(self, x):
-+         # Forward pass through the network
-+@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-+         x = F.relu(self.fc2(x))
-+         x = F.relu(self.fc3(x))
-+         x = self.fc4(x)  # No activation, this will be included in the loss function
-++        x = self.softmax(x)
-+         return x
-+ 
-+ def load(config):
-+@@ -29,4 +37,4 @@ def load(config):
-+     
-+     mlp = PerceptronNN(n_features,2)
-+     
-+-    return mlp
-+\ No newline at end of file
-++    return mlp, "feedforward"
-+\ No newline at end of file
-+diff --git a/checkpoints/feedforward/1/flags.json b/checkpoints/feedforward/1/flags.json
-+index 1d000c3..889a6ea 100644
-+--- a/checkpoints/feedforward/1/flags.json
-++++ b/checkpoints/feedforward/1/flags.json
-+@@ -1,9 +1,15 @@
-+ {
-+     "batch_size": 100,
-++    "beta1": 0.9,
-++    "beta2": 0.999,
-++    "cross_validate": false,
-+     "data_config": "penn_dataset.py",
-++    "git_commit": "7416bf730b356aabfe0df644240e40948a8196bb",
-+     "include_coords": false,
-+     "input_size": 39,
-+-    "learning_rate": 1e-05,
-++    "learning_rate": 0.0001,
-++    "log_train_values": true,
-++    "log_val_test": true,
-+     "model_config": "basic_feedforward.py",
-+     "n_repeats": 1,
-+     "report_loss_every": 50,
-+@@ -11,7 +17,10 @@
-+     "results_dir": "checkpoints",
-+     "resume": false,
-+     "run_name": "feedforward",
-++    "save_check_points": 50,
-++    "save_test_predictions": false,
-+     "split_seed": 1,
-+-    "train_epochs": 20,
-++    "total_evaluations": 100,
-++    "train_epochs": 100,
-+     "train_split": 0.8
-+ }
-+\ No newline at end of file
-+diff --git a/checkpoints/feedforward/1/git_diff.txt b/checkpoints/feedforward/1/git_diff.txt
-+index 7b37e6f..5c561db 100644
-+--- a/checkpoints/feedforward/1/git_diff.txt
-++++ b/checkpoints/feedforward/1/git_diff.txt
-+@@ -1 +1 @@
-+-Mon Mar 4 11:45:48 PST 2024
-++Mon Mar 4 16:34:02 PST 2024
-+diff --git a/checkpoints/feedforward/1/penn_dataset.py b/checkpoints/feedforward/1/penn_dataset.py
-+index aa2f5a0..7f5a4fc 100644
-+--- a/checkpoints/feedforward/1/penn_dataset.py
-++++ b/checkpoints/feedforward/1/penn_dataset.py
-+@@ -15,6 +15,7 @@ from forge import flags
-+ # aspects of data managmement
-+ flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
-+ flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-++flags.DEFINE_boolean("cross_validate",False,"Do K-fold cross-validation")
-+ 
-+ # Job management
-+ # flags.DEFINE_integer("batch size",5,"training batch size")
-+@@ -109,15 +110,15 @@ def load(config):
-+         
-+         # set up training DataLoader
-+         train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, n_train),num_workers=0,shuffle = True)
-++        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
-+ 
-+         # set up test DataLoader
-+         test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, n_test),num_workers=0,shuffle = True)
-++        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
-+ 
-+         # set up val DataLoader
-+         val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, n_val),num_workers=0,shuffle = True)
-++        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-+         
-+ 
-+         dataloaders = {'train':train_loader, 
-+@@ -125,8 +126,12 @@ def load(config):
-+                        'val':val_loader,
-+                        'train_inds':train_ind,
-+                        'test_inds':test_ind,
-+-                       'n_val':n_val
-++                       'n_val':n_val,
-++                       'test_headings':list(HEADINGS[test_ind])
-+                       }
-+         kf_dataloaders.append(dataloaders)
-+ 
-++        if not config.cross_validate:
-++        	break
-++
-+     return kf_dataloaders
-+diff --git a/penn_dataset.py b/penn_dataset.py
-+index aa2f5a0..7f5a4fc 100644
-+--- a/penn_dataset.py
-++++ b/penn_dataset.py
-+@@ -15,6 +15,7 @@ from forge import flags
-+ # aspects of data managmement
-+ flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
-+ flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-++flags.DEFINE_boolean("cross_validate",False,"Do K-fold cross-validation")
-+ 
-+ # Job management
-+ # flags.DEFINE_integer("batch size",5,"training batch size")
-+@@ -109,15 +110,15 @@ def load(config):
-+         
-+         # set up training DataLoader
-+         train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, n_train),num_workers=0,shuffle = True)
-++        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
-+ 
-+         # set up test DataLoader
-+         test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, n_test),num_workers=0,shuffle = True)
-++        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
-+ 
-+         # set up val DataLoader
-+         val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, n_val),num_workers=0,shuffle = True)
-++        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-+         
-+ 
-+         dataloaders = {'train':train_loader, 
-+@@ -125,8 +126,12 @@ def load(config):
-+                        'val':val_loader,
-+                        'train_inds':train_ind,
-+                        'test_inds':test_ind,
-+-                       'n_val':n_val
-++                       'n_val':n_val,
-++                       'test_headings':list(HEADINGS[test_ind])
-+                       }
-+         kf_dataloaders.append(dataloaders)
-+ 
-++        if not config.cross_validate:
-++        	break
-++
-+     return kf_dataloaders
-+diff --git a/testing.ipynb b/testing.ipynb
-+index e5a167b..a928d8d 100644
-+--- a/testing.ipynb
-++++ b/testing.ipynb
-+@@ -2,7 +2,7 @@
-+  "cells": [
-+   {
-+    "cell_type": "code",
-+-   "execution_count": 1,
-++   "execution_count": 2,
-+    "id": "4dee7ff1-01a4-4038-b493-9729ff3693f7",
-+    "metadata": {},
-+    "outputs": [],
-+@@ -23,19 +23,19 @@
-+   },
-+   {
-+    "cell_type": "code",
-+-   "execution_count": 2,
-++   "execution_count": 3,
-+    "id": "cad0fdc8-5c35-4610-bba3-b71e60dc1b98",
-+    "metadata": {},
-+    "outputs": [],
-+    "source": [
-+-    "flags.DEFINE_integer(\"batch_size\", 100, \"Mini-batch size.\")\n",
-++    "flags.DEFINE_integer(\"batch_size\", 10, \"Mini-batch size.\")\n",
-+     "\n",
-+     "flags.DEFINE_integer(\"input_size\",39,\"Input shape to model\")"
-+    ]
-+   },
-+   {
-+    "cell_type": "code",
-+-   "execution_count": 3,
-++   "execution_count": 4,
-+    "id": "ce1b936b-8a7c-426e-a3aa-3c1c38f645de",
-+    "metadata": {},
-+    "outputs": [
-+@@ -54,8 +54,8 @@
-+   },
-+   {
-+    "cell_type": "code",
-+-   "execution_count": 9,
-+-   "id": "e862b7e2-57f5-44bf-bcf1-a91160ba66cc",
-++   "execution_count": 5,
-++   "id": "4469cddf-4dac-4468-be88-241d440401c3",
-+    "metadata": {},
-+    "outputs": [
-+     {
-+@@ -67,35 +67,89 @@
-+     }
-+    ],
-+    "source": [
-+-    "model = fet.load(\"basic_feedforward.py\",config)"
-++    "model,modelname = fet.load(\"basic_feedforward.py\",config)"
-+    ]
-+   },
-+   {
-+    "cell_type": "code",
-+-   "execution_count": 10,
-+-   "id": "07e0b160-d5d1-4e54-b4a7-ccaf2224598a",
-++   "execution_count": 17,
-++   "id": "7c9a9fe9-f5e8-456a-b964-4be13027725b",
-+    "metadata": {},
-+    "outputs": [
-+     {
-+      "data": {
-+       "text/plain": [
-+-       "PerceptronNN(\n",
-+-       "  (fc1): Linear(in_features=39, out_features=128, bias=True)\n",
-+-       "  (fc2): Linear(in_features=128, out_features=64, bias=True)\n",
-+-       "  (fc3): Linear(in_features=64, out_features=64, bias=True)\n",
-+-       "  (fc4): Linear(in_features=64, out_features=2, bias=True)\n",
-+-       ")"
-++       "['aaa0060', 'aaa0061', 'aaa0069', 'aaa_0059']"
-+       ]
-+      },
-+-     "execution_count": 10,
-++     "execution_count": 17,
-+      "metadata": {},
-+      "output_type": "execute_result"
-+     }
-+    ],
-+    "source": [
-+-    "model"
-++    "loaddat[0]['test_headings']"
-++   ]
-++  },
-++  {
-++   "cell_type": "code",
-++   "execution_count": 19,
-++   "id": "e862b7e2-57f5-44bf-bcf1-a91160ba66cc",
-++   "metadata": {},
-++   "outputs": [
-++    {
-++     "name": "stdout",
-++     "output_type": "stream",
-++     "text": [
-++      "Keys: ['cross_entropy', 'time']\n"
-++     ]
-++    }
-++   ],
-++   "source": [
-++    "import h5py\n",
-++    "\n",
-++    "file_path = \"./checkpoints/feedforward/2/data_fold1/results_dict.h5\"\n",
-++    "# Replace 'your_file.h5' with the actual path to your file\n",
-++    "f =  h5py.File(file_path, 'r') \n",
-++    "\n",
-++    "    # Get information about the data stored in the file\n",
-++    "print(\"Keys:\", list(f.keys()))  # List the top-level datasets and groups\n",
-++    "\n",
-++    "    # # Access a dataset by its name\n",
-++    "    # dataset_name = \"your_dataset_name\"\n",
-++    "    # if dataset_name in f:\n",
-++    "    #     dataset = f[dataset_name]\n",
-++    "    #     print(\"Dataset shape:\", dataset.shape)\n",
-++    "    #     print(\"Dataset dtype:\", dataset.dtype)\n",
-++    "\n",
-++    "    #     # Access the data as a NumPy array\n",
-++    "    #     data = dataset[:]  # Read the entire dataset\n",
-++    "\n",
-++    "    #     # You can now work with the data as needed, for example:\n",
-++    "    #     # Perform calculations, visualizations, etc.\n",
-++    "    # else:\n",
-++    "    #     print(f\"Dataset '{dataset_name}' not found in the file.\")"
-+    ]
-+   },
-++  {
-++   "cell_type": "code",
-++   "execution_count": 13,
-++   "id": "07e0b160-d5d1-4e54-b4a7-ccaf2224598a",
-++   "metadata": {},
-++   "outputs": [
-++    {
-++     "data": {
-++      "text/plain": [
-++       "<generator object Module.parameters at 0x3007207b0>"
-++      ]
-++     },
-++     "execution_count": 13,
-++     "metadata": {},
-++     "output_type": "execute_result"
-++    }
-++   ],
-++   "source": []
-++  },
-+   {
-+    "cell_type": "code",
-+    "execution_count": null,
-+diff --git a/train.py b/train.py
-+index c266102..516bfa9 100644
-+--- a/train.py
-++++ b/train.py
-+@@ -1,49 +1,440 @@
-+ from os import path as osp
-++import os
-++import numpy as np
-++import time
-+ 
-+ import torch
-++import torch.nn as nn
-+ import torch.nn.functional as F
-+ import torch.optim as optim
-+-
-+-import numpy as np
-++from torch.utils.tensorboard import SummaryWriter
-+ 
-+ import forge
-+ from forge import flags
-+ import forge.experiment_tools as fet
-+ 
-++from train_tools import (
-++	log_tensorboard,
-++	parse_reports,
-++	parse_reports_cpu,
-++	print_reports,
-++	load_checkpoint,
-++	save_checkpoint,
-++	nested_to,
-++	param_count,
-++)
-++
-++from copy import deepcopy
-++from attrdict import AttrDict
-++import deepdish as dd
-++from tqdm import tqdm
-++
-++# For reproducibility while researching, but might affect speed!
-++torch.backends.cudnn.deterministic = True
-++torch.backends.cudnn.benchmark = False
-++torch.manual_seed(0)
-++
-+ 
-+ # Job config
-+ flags.DEFINE_string('data_config', 'penn_dataset.py',
-+-                    'Path to a data config file.')
-++					'Path to a data config file.')
-+ flags.DEFINE_string('model_config', 'basic_feedforward.py',
-+-                    'Path to a model config file.')
-++					'Path to a model config file.')
-+ flags.DEFINE_string('results_dir', 'checkpoints',
-+-                    'Top directory for all experimental results.')
-++					'Top directory for all experimental results.')
-+ flags.DEFINE_string('run_name', 'feedforward',
-+-                    'Name of this job and name of results folder.')
-++					'Name of this job and name of results folder.')
-+ flags.DEFINE_boolean('resume', False, 'Tries to resume a job if True.')
-+ 
-+ # Logging config
-+ flags.DEFINE_integer('report_loss_every', 50,
-+-                     'Number of iterations between reporting minibatch loss.')
-+-flags.DEFINE_integer('train_epochs', 20, 'Maximum number of training epochs.')
-++					 'Number of iterations between reporting minibatch loss.')
-++flags.DEFINE_integer('train_epochs', 100, 'Maximum number of training epochs.')
-++flags.DEFINE_integer(
-++	"save_check_points",
-++	50,
-++	"frequency with which to save checkpoints, in number of epoches.",
-++)
-++flags.DEFINE_boolean("log_train_values", True, "Logs train values if True.")
-++flags.DEFINE_integer(
-++	"total_evaluations",
-++	100,
-++	"Maximum number of evaluations on test and validation data during training.",
-++)
-++flags.DEFINE_boolean(
-++	"save_test_predictions",
-++	False,
-++	"Makes and saves test predictions on one or more test sets (e.g. 5-step and 100-step predictions) at the end of training.",
-++)
-++flags.DEFINE_boolean(
-++    "log_val_test", True, "Turns off computation of validation and test errors."
-++)
-+ 
-+ # Experiment config
-+ flags.DEFINE_integer('batch_size', 100, 'Mini-batch size.')
-+-flags.DEFINE_float('learning_rate', 1e-5, 'SGD learning rate.')
-++flags.DEFINE_float("learning_rate", 1e-4, "Adam learning rate.")
-++flags.DEFINE_float("beta1", 0.9, "Adam Beta 1 parameter")
-++flags.DEFINE_float("beta2", 0.999, "Adam Beta 2 parameter")
-+ 
-+ # Specific config options
-+ flags.DEFINE_integer("input_size",39,"Input shape to model")
-+ 
-++#########################################################################################
-++
-++def evaluate(model, loader, device,fold = 0,headings = [],loss_func = nn.CrossEntropyLoss()):
-++	reports = None
-++	for data in loader:
-++		labels = data['label']
-++		inputs = nested_to(data['data'],device,torch.float32)
-++		
-++		labels_tensor = torch.zeros((len(labels), 2))
-++		for i, label in enumerate(labels):
-++			labels_tensor[i, label] = 1
-++
-++		model_output = model(inputs) # evaluate model
-++
-++		loss = loss_func(model_output, labels_tensor) # compute loss
-++		outputs = AttrDict({"loss": loss, "prediction": model_output,'data_fold':fold})
-++		outputs.reports = AttrDict({"cross_entropy": loss})
-++
-++		if reports is None:
-++			reports = {k: v.detach().clone().cpu() for k, v in outputs.reports.items()}
-++		else:
-++			for k, v in outputs.reports.items():
-++				reports[k] += v.detach().clone().cpu()
-++
-++	for k, v in reports.items():
-++		reports[k] = v / len(
-++			loader
-++		)  # SZ: note this can be slightly incorrect if mini-batch sizes vary (if batch_size doesn't divide train_size), but approximately correct.
-++
-++	# reports['test_headings'] = np.array(headings)
-++
-++	return reports
-++
-++def main():
-++
-++	config = forge.config()
-++
-++	# Set device
-++	if torch.cuda.is_available():
-++		device = f"cuda:{config.device}"
-++		torch.cuda.set_device(device)
-++	else:
-++		device = "cpu" # can change this to MPS on M1 Macs
-++
-++	# Load data
-++	data_name = "penn_data"
-++	kfold_loaders = fet.load(config.data_config, config)
-++
-++	# Load model
-++	model,model_name = fet.load(config.model_config, config)
-++	model = model.to(device)
-++
-++	loss_func = nn.CrossEntropyLoss()
-++
-++	# Prepare environment
-++	params_in_run_name = [
-++		("batch_size", "bs"),
-++		("learning_rate", "lr"),
-++		("n_train", "ntrain")
-++	]
-++
-++	run_name = ""  # config.run_name
-++	for config_param in params_in_run_name:
-++		attr = config_param[0]
-++		abbrev = config_param[1]
-++
-++		if hasattr(config, attr):
-++			run_name += abbrev
-++			run_name += str(getattr(config, attr))
-++			run_name += "_"
-++
-++	results_folder_name = osp.join(
-++		data_name,
-++		model_name,
-++		config.run_name,
-++		run_name,
-++	)
-++
-++	# Prepare environment
-++	logdir = osp.join(config.results_dir, config.run_name)
-++	logdir, resume_checkpoint = fet.init_checkpoint(
-++		logdir, config.data_config, config.model_config, config.resume)
-++
-++	print("Checkpoint directory:",logdir)
-++
-++	# Print flags
-++	fet.print_flags()
-++	# Print model info
-++	print(model)
-++
-++	# Setup optimizer
-++	model_params = model.parameters()
-++	opt_learning_rate = config.learning_rate
-++	model_opt = torch.optim.Adam(
-++		model_params, lr=opt_learning_rate, betas=(config.beta1, config.beta2)
-++	)
-++	print("Model Optimizer:")
-++	print(model_opt)
-++
-++	# Try to restore model and optimizer from checkpoint
-++	if resume_checkpoint is not None:
-++		start_epoch = load_checkpoint(resume_checkpoint, model, model_opt)
-++	else:
-++		start_epoch = 1
-++
-++	n_folds = len(kfold_loaders)
-++	print("Doing {}-fold cross-validation.".format(n_folds))
-++
-++	# KFOLD TRAINING LOOP
-++	for k,loader_k in enumerate(kfold_loaders): # loop over data splits
-++
-++		print("Training fold {}...".format(k+1))
-++
-++		# load the training data
-++		train_loader = loader_k["train"]
-++		n_train = len(train_loader.dataset)
-++		train_batch_size = train_loader.batch_size
-++
-++		# load testing, validation
-++		test_loader = loader_k["test"]
-++		n_test = len(test_loader.dataset)
-++		val_loader = loader_k["val"]
-++		n_val = len(val_loader.dataset)
-++		
-++		# create folder for this data split
-++		fold_dir = osp.join(logdir,"data_fold{}".format(k+1))
-++		fold_dir_exists = osp.exists(fold_dir)
-++		if not fold_dir_exists:
-++			if config.resume:
-++				raise ValueError("Can't resume when the checkpoint/fold dir '{}' doesn't exist.".format(fold_dir))
-++			else:
-++				os.makedirs(fold_dir)
-++		checkpoint_name = osp.join(fold_dir, 'model_fold{}.ckpt'.format(k+1))
-++
-++		# keep track of which data is test data for a given Kfold data split
-++		test_headings = loader_k['test_headings']
-++		headingsFile = osp.join(fold_dir,"test_headings.txt")
-++		with open(headingsFile,'w') as headfile:
-++			for heading in test_headings:
-++				headfile.write(heading+'\n')
-++
-++		# print(checkpoint_name)
-++
-++		train_iter = (start_epoch - 1) * (
-++		len(train_loader.dataset) // train_batch_size
-++		) + 1
-++
-++		print("Starting training at epoch = {}, iter = {}".format(start_epoch, train_iter))
-++
-++		# Setup tensorboard writing
-++		summary_writer = SummaryWriter(logdir)
-++
-++		train_reports = []
-++		report_all = {}
-++		report_all_val = {}
-++
-++		# Saving model at epoch 0 before training
-++		print("saving model at epoch 0 before training ... ")
-++		save_checkpoint(checkpoint_name, 0, model, model_opt, loss=0.0)
-++		print("finished saving model at epoch 0 before training")
-++
-++		num_params = param_count(model)
-++		print(f"Number of model parameters: {num_params}")
-++
-++		# Training
-++		start_t = time.time()
-++
-++		total_train_iters = len(train_loader) * config.train_epochs
-++		iters_per_eval = max(1, int(total_train_iters / config.total_evaluations))
-++		# print('batch',train_batch_size)
-++		# print('ntrain',n_train)
-++		# assert (
-++		# 	n_train % min(train_batch_size, n_train) == 0
-++		# ), "Batch size doesn't divide dataset size. Can be inaccurate for loss computation (see below)."
-++
-++		training_failed = False
-++		best_val_loss_so_far = 1e7
-++
-++		for epoch in tqdm(range(start_epoch, config.train_epochs + 1)):
-++			model.train()
-++
-++			for batch_idx, data_dict in enumerate(train_loader): # Loop over batched data
-++
-++				labels = data_dict['label']
-++				data = data_dict['data']
-++
-++				# send data to device
-++				data = nested_to(data,device,torch.float32)
-++				# One-hot encode the data labels
-++				labels_tensor = torch.zeros((len(labels), 2))
-++				for i, label in enumerate(labels):
-++					labels_tensor[i, label] = 1
-++
-++				model_output = model(data) # evaluate model
-++
-++				loss = loss_func(model_output, labels_tensor) # compute loss
-++				outputs = AttrDict({"loss": loss, "prediction": model_output})
-++				outputs.reports = AttrDict({"cross_entropy": loss})
-++
-++				if torch.isnan(outputs.loss): # check for failure in training
-++					if not training_failed:
-++						epoch_of_nan = epoch
-++					if (epoch > epoch_of_nan + 1) and training_failed:
-++						raise ValueError("Loss Nan-ed.")
-++					training_failed = True
-++
-++				model_opt.zero_grad()
-++				outputs.loss.backward(retain_graph=False)
-++
-++				model_opt.step() # move optimizer forward
-++
-++				train_reports.append(parse_reports_cpu(outputs.reports))
-++
-++				if config.log_train_values:
-++					reports = parse_reports(outputs.reports)
-++					if batch_idx % config.report_loss_every == 0:
-++						log_tensorboard(summary_writer, train_iter, reports, "train/")
-++						print_reports(
-++							reports,
-++							start_t,
-++							epoch,
-++							batch_idx,
-++							len(train_loader.dataset) // train_batch_size,
-++							prefix="train",
-++						)
-++						log_tensorboard(
-++							summary_writer,
-++							train_iter,
-++							{"lr": model_opt.param_groups[0]["lr"]},
-++							"hyperparams/",
-++						)
-++				# Logging and evaluation
-++				if (
-++					train_iter % iters_per_eval == 0 or (train_iter == total_train_iters)
-++				) and config.log_val_test:  # batch_idx % config.evaluate_every == 0:
-++					model.eval()
-++					with torch.no_grad():
-++						reports = evaluate(model, test_loader, device,fold = k,headings = loader_k['test_headings'])
-++						# print("REPORTS",reports)
-++						reports = parse_reports(reports)
-++						reports["time"] = time.time() - start_t
-++						if report_all == {}:
-++							report_all = deepcopy(reports)
-++
-++							for d in reports.keys():
-++								report_all[d] = [report_all[d]]
-++						else:
-++							for d in reports.keys():
-++								report_all[d].append(reports[d])
-++
-++						log_tensorboard(summary_writer, train_iter, reports, "test/")
-++						print_reports(
-++							reports,
-++							start_t,
-++							epoch,
-++							batch_idx,
-++							len(train_loader.dataset) // config.batch_size,
-++							prefix="test",
-++						)
-++
-++						# repeat for validation data
-++						reports = evaluate(model, val_loader, device,fold = k,headings = loader_k['test_headings'])
-++						reports = parse_reports(reports)
-++						reports["time"] = time.time() - start_t
-++						if report_all_val == {}:
-++							report_all_val = deepcopy(reports)
-++
-++							for d in reports.keys():
-++								report_all_val[d] = [report_all_val[d]]
-++						else:
-++							for d in reports.keys():
-++								report_all_val[d].append(reports[d])
-++
-++						log_tensorboard(summary_writer, train_iter, reports, "val/")
-++						print_reports(
-++							reports,
-++							start_t,
-++							epoch,
-++							batch_idx,
-++							len(train_loader.dataset) // config.batch_size,
-++							prefix="val",
-++						)
-++
-++						if report_all_val["cross_entropy"][-1] < best_val_loss_so_far:
-++							save_checkpoint(
-++								checkpoint_name,
-++								f"early_stop",
-++								model,
-++								model_opt,
-++								loss=outputs.loss,
-++							)
-++							best_val_loss_so_far = report_all_val["cross_entropy"][-1]
-++
-++					model.train()
-++
-++				train_iter += 1
-++
-++			if epoch % config.save_check_points == 0:
-++				save_checkpoint(
-++					checkpoint_name, train_iter, model, model_opt, loss=outputs.loss
-++				)
-++
-++		dd.io.save(fold_dir + "/results_dict_train.h5", train_reports)
-++		dd.io.save(fold_dir + "/results_dict.h5", report_all)
-++		dd.io.save(fold_dir + "/results_dict_val.h5", report_all_val)
-++
-++	# always save final model
-++	save_checkpoint(checkpoint_name, train_iter, model, model_opt, loss=outputs.loss)
-++
-++	
-++	if config.save_test_predictions:
-++		pass
-++		# print("Starting to make model predictions on test sets for *final model*.")
-++		# for chunk_len in [5, 100]:
-++		#     start_t_preds = time.time()
-++		#     data_config = SimpleNamespace(
-++		#         **{
-++		#             **config.__dict__["__flags"],
-++		#             **{"chunk_len": chunk_len, "batch_size": 500},
-++		#         }
-++		#     )
-++		#     dataloaders, data_name = fet.load(config.data_config, config=data_config)
-++		#     test_loader_preds = dataloaders["test"]
-++
-++		#     torch.cuda.empty_cache()
-++		#     with torch.no_grad():
-++		#         preds = []
-++		#         true = []
-++		#         num_datapoints = 0
-++		#         for idx, d in enumerate(test_loader_preds):
-++		#             true.append(d[-1])
-++		#             d = nested_to(d, device, torch.float32)
-++		#             outputs = model(d)
-++
-++		#             pred_zs = outputs.prediction
-++		#             preds.append(pred_zs)
-++
-++		#             num_datapoints += len(pred_zs)
-++
-++		#             if num_datapoints >= 2000:
-++		#                 break
-+ 
-+-config = forge.config()
-++		#         preds = torch.cat(preds, dim=0).cpu()
-++		#         true = torch.cat(true, dim=0).cpu()
-+ 
-+-# Prepare environment
-+-logdir = osp.join(config.results_dir, config.run_name)
-+-logdir, resume_checkpoint = fet.init_checkpoint(
-+-    logdir, config.data_config, config.model_config, config.resume)
-+-checkpoint_name = osp.join(logdir, 'model.ckpt')
-++		#         save_dir = osp.join(logdir, f"traj_preds_{chunk_len}_steps_2k_test.pt")
-++		#         torch.save(preds, save_dir)
-+ 
-++		#         save_dir = osp.join(logdir, f"traj_true_{chunk_len}_steps_2k_test.pt")
-++		#         torch.save(true, save_dir)
-+ 
-+-print(logdir)
-++		#         print(
-++		#             f"Completed making test predictions for chunk_len = {chunk_len} in {time.time() - start_t_preds:.2f} seconds."
-++		#         )	
-++		
-+ 
-++if __name__ == "__main__":
-++	main()
-+ 
-diff --git a/checkpoints/feedforward/1/penn_dataset.py b/checkpoints/feedforward/1/penn_dataset.py
-index aa2f5a0..7f5a4fc 100644
---- a/checkpoints/feedforward/1/penn_dataset.py
-+++ b/checkpoints/feedforward/1/penn_dataset.py
-@@ -15,6 +15,7 @@ from forge import flags
- # aspects of data managmement
- flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
- flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-+flags.DEFINE_boolean("cross_validate",False,"Do K-fold cross-validation")
- 
- # Job management
- # flags.DEFINE_integer("batch size",5,"training batch size")
-@@ -109,15 +110,15 @@ def load(config):
-         
-         # set up training DataLoader
-         train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, n_train),num_workers=0,shuffle = True)
-+        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
- 
-         # set up test DataLoader
-         test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, n_test),num_workers=0,shuffle = True)
-+        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
- 
-         # set up val DataLoader
-         val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, n_val),num_workers=0,shuffle = True)
-+        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-         
- 
-         dataloaders = {'train':train_loader, 
-@@ -125,8 +126,12 @@ def load(config):
-                        'val':val_loader,
-                        'train_inds':train_ind,
-                        'test_inds':test_ind,
--                       'n_val':n_val
-+                       'n_val':n_val,
-+                       'test_headings':list(HEADINGS[test_ind])
-                       }
-         kf_dataloaders.append(dataloaders)
- 
-+        if not config.cross_validate:
-+        	break
-+
-     return kf_dataloaders
-diff --git a/georgehulsey_2024.pdf b/georgehulsey_2024.pdf
-deleted file mode 100644
-index 1ab17f6..0000000
-Binary files a/georgehulsey_2024.pdf and /dev/null differ
-diff --git a/penn_dataset.py b/penn_dataset.py
-index aa2f5a0..46c8e52 100644
---- a/penn_dataset.py
-+++ b/penn_dataset.py
-@@ -15,6 +15,7 @@ from forge import flags
- # aspects of data managmement
- flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
- flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-+flags.DEFINE_boolean("cross_validate",True,"Do K-fold cross-validation")
- 
- # Job management
- # flags.DEFINE_integer("batch size",5,"training batch size")
-@@ -109,15 +110,15 @@ def load(config):
-         
-         # set up training DataLoader
-         train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, n_train),num_workers=0,shuffle = True)
-+        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
- 
-         # set up test DataLoader
-         test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, n_test),num_workers=0,shuffle = True)
-+        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
- 
-         # set up val DataLoader
-         val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, n_val),num_workers=0,shuffle = True)
-+        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-         
- 
-         dataloaders = {'train':train_loader, 
-@@ -125,8 +126,12 @@ def load(config):
-                        'val':val_loader,
-                        'train_inds':train_ind,
-                        'test_inds':test_ind,
--                       'n_val':n_val
-+                       'n_val':n_val,
-+                       'test_headings':list(HEADINGS[test_ind])
-                       }
-         kf_dataloaders.append(dataloaders)
- 
-+        if not config.cross_validate:
-+        	break
-+
-     return kf_dataloaders
-diff --git a/testing.ipynb b/testing.ipynb
-index e5a167b..0110538 100644
---- a/testing.ipynb
-+++ b/testing.ipynb
-@@ -2,7 +2,7 @@
-  "cells": [
-   {
-    "cell_type": "code",
--   "execution_count": 1,
-+   "execution_count": 4,
-    "id": "4dee7ff1-01a4-4038-b493-9729ff3693f7",
-    "metadata": {},
-    "outputs": [],
-@@ -23,7 +23,7 @@
-   },
-   {
-    "cell_type": "code",
--   "execution_count": 2,
-+   "execution_count": 6,
-    "id": "cad0fdc8-5c35-4610-bba3-b71e60dc1b98",
-    "metadata": {},
-    "outputs": [],
-@@ -35,7 +35,7 @@
-   },
-   {
-    "cell_type": "code",
--   "execution_count": 3,
-+   "execution_count": 7,
-    "id": "ce1b936b-8a7c-426e-a3aa-3c1c38f645de",
-    "metadata": {},
-    "outputs": [
-@@ -54,8 +54,8 @@
-   },
-   {
-    "cell_type": "code",
--   "execution_count": 9,
--   "id": "e862b7e2-57f5-44bf-bcf1-a91160ba66cc",
-+   "execution_count": 5,
-+   "id": "4469cddf-4dac-4468-be88-241d440401c3",
-    "metadata": {},
-    "outputs": [
-     {
-@@ -67,35 +67,98 @@
-     }
-    ],
-    "source": [
--    "model = fet.load(\"basic_feedforward.py\",config)"
-+    "model,modelname = fet.load(\"basic_feedforward.py\",config)"
-    ]
-   },
-   {
-    "cell_type": "code",
--   "execution_count": 10,
--   "id": "07e0b160-d5d1-4e54-b4a7-ccaf2224598a",
-+   "execution_count": 13,
-+   "id": "7c9a9fe9-f5e8-456a-b964-4be13027725b",
-    "metadata": {},
-    "outputs": [
-     {
-      "data": {
-       "text/plain": [
--       "PerceptronNN(\n",
--       "  (fc1): Linear(in_features=39, out_features=128, bias=True)\n",
--       "  (fc2): Linear(in_features=128, out_features=64, bias=True)\n",
--       "  (fc3): Linear(in_features=64, out_features=64, bias=True)\n",
--       "  (fc4): Linear(in_features=64, out_features=2, bias=True)\n",
--       ")"
-+       "array([114170,    904])"
-       ]
-      },
--     "execution_count": 10,
-+     "execution_count": 13,
-      "metadata": {},
-      "output_type": "execute_result"
-     }
-    ],
-    "source": [
--    "model"
-+    "np.bincount(loaddat[0]['train'].dataset.all_labels)"
-    ]
-   },
-+  {
-+   "cell_type": "code",
-+   "execution_count": 1,
-+   "id": "e862b7e2-57f5-44bf-bcf1-a91160ba66cc",
-+   "metadata": {},
-+   "outputs": [
-+    {
-+     "ename": "FileNotFoundError",
-+     "evalue": "[Errno 2] Unable to open file (unable to open file: name = './checkpoints/feedforward/2/data_fold1/results_dict.h5', errno = 2, error message = 'No such file or directory', flags = 0, o_flags = 0)",
-+     "output_type": "error",
-+     "traceback": [
-+      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
-+      "\u001b[0;31mFileNotFoundError\u001b[0m                         Traceback (most recent call last)",
-+      "Cell \u001b[0;32mIn[1], line 5\u001b[0m\n\u001b[1;32m      3\u001b[0m file_path \u001b[38;5;241m=\u001b[39m \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124m./checkpoints/feedforward/2/data_fold1/results_dict.h5\u001b[39m\u001b[38;5;124m\"\u001b[39m\n\u001b[1;32m      4\u001b[0m \u001b[38;5;66;03m# Replace 'your_file.h5' with the actual path to your file\u001b[39;00m\n\u001b[0;32m----> 5\u001b[0m f \u001b[38;5;241m=\u001b[39m  \u001b[43mh5py\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mFile\u001b[49m\u001b[43m(\u001b[49m\u001b[43mfile_path\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[38;5;124;43mr\u001b[39;49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[43m)\u001b[49m \n\u001b[1;32m      7\u001b[0m     \u001b[38;5;66;03m# Get information about the data stored in the file\u001b[39;00m\n\u001b[1;32m      8\u001b[0m \u001b[38;5;28mprint\u001b[39m(\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mKeys:\u001b[39m\u001b[38;5;124m\"\u001b[39m, \u001b[38;5;28mlist\u001b[39m(f\u001b[38;5;241m.\u001b[39mkeys()))\n",
-+      "File \u001b[0;32m/Applications/miniconda3/envs/lietransformer/lib/python3.9/site-packages/h5py/_hl/files.py:562\u001b[0m, in \u001b[0;36mFile.__init__\u001b[0;34m(self, name, mode, driver, libver, userblock_size, swmr, rdcc_nslots, rdcc_nbytes, rdcc_w0, track_order, fs_strategy, fs_persist, fs_threshold, fs_page_size, page_buf_size, min_meta_keep, min_raw_keep, locking, alignment_threshold, alignment_interval, meta_block_size, **kwds)\u001b[0m\n\u001b[1;32m    553\u001b[0m     fapl \u001b[38;5;241m=\u001b[39m make_fapl(driver, libver, rdcc_nslots, rdcc_nbytes, rdcc_w0,\n\u001b[1;32m    554\u001b[0m                      locking, page_buf_size, min_meta_keep, min_raw_keep,\n\u001b[1;32m    555\u001b[0m                      alignment_threshold\u001b[38;5;241m=\u001b[39malignment_threshold,\n\u001b[1;32m    556\u001b[0m                      alignment_interval\u001b[38;5;241m=\u001b[39malignment_interval,\n\u001b[1;32m    557\u001b[0m                      meta_block_size\u001b[38;5;241m=\u001b[39mmeta_block_size,\n\u001b[1;32m    558\u001b[0m                      \u001b[38;5;241m*\u001b[39m\u001b[38;5;241m*\u001b[39mkwds)\n\u001b[1;32m    559\u001b[0m     fcpl \u001b[38;5;241m=\u001b[39m make_fcpl(track_order\u001b[38;5;241m=\u001b[39mtrack_order, fs_strategy\u001b[38;5;241m=\u001b[39mfs_strategy,\n\u001b[1;32m    560\u001b[0m                      fs_persist\u001b[38;5;241m=\u001b[39mfs_persist, fs_threshold\u001b[38;5;241m=\u001b[39mfs_threshold,\n\u001b[1;32m    561\u001b[0m                      fs_page_size\u001b[38;5;241m=\u001b[39mfs_page_size)\n\u001b[0;32m--> 562\u001b[0m     fid \u001b[38;5;241m=\u001b[39m \u001b[43mmake_fid\u001b[49m\u001b[43m(\u001b[49m\u001b[43mname\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mmode\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43muserblock_size\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mfapl\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mfcpl\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mswmr\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43mswmr\u001b[49m\u001b[43m)\u001b[49m\n\u001b[1;32m    564\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;28misinstance\u001b[39m(libver, \u001b[38;5;28mtuple\u001b[39m):\n\u001b[1;32m    565\u001b[0m     \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_libver \u001b[38;5;241m=\u001b[39m libver\n",
-+      "File \u001b[0;32m/Applications/miniconda3/envs/lietransformer/lib/python3.9/site-packages/h5py/_hl/files.py:235\u001b[0m, in \u001b[0;36mmake_fid\u001b[0;34m(name, mode, userblock_size, fapl, fcpl, swmr)\u001b[0m\n\u001b[1;32m    233\u001b[0m     \u001b[38;5;28;01mif\u001b[39;00m swmr \u001b[38;5;129;01mand\u001b[39;00m swmr_support:\n\u001b[1;32m    234\u001b[0m         flags \u001b[38;5;241m|\u001b[39m\u001b[38;5;241m=\u001b[39m h5f\u001b[38;5;241m.\u001b[39mACC_SWMR_READ\n\u001b[0;32m--> 235\u001b[0m     fid \u001b[38;5;241m=\u001b[39m \u001b[43mh5f\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mopen\u001b[49m\u001b[43m(\u001b[49m\u001b[43mname\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mflags\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mfapl\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43mfapl\u001b[49m\u001b[43m)\u001b[49m\n\u001b[1;32m    236\u001b[0m \u001b[38;5;28;01melif\u001b[39;00m mode \u001b[38;5;241m==\u001b[39m \u001b[38;5;124m'\u001b[39m\u001b[38;5;124mr+\u001b[39m\u001b[38;5;124m'\u001b[39m:\n\u001b[1;32m    237\u001b[0m     fid \u001b[38;5;241m=\u001b[39m h5f\u001b[38;5;241m.\u001b[39mopen(name, h5f\u001b[38;5;241m.\u001b[39mACC_RDWR, fapl\u001b[38;5;241m=\u001b[39mfapl)\n",
-+      "File \u001b[0;32mh5py/_objects.pyx:54\u001b[0m, in \u001b[0;36mh5py._objects.with_phil.wrapper\u001b[0;34m()\u001b[0m\n",
-+      "File \u001b[0;32mh5py/_objects.pyx:55\u001b[0m, in \u001b[0;36mh5py._objects.with_phil.wrapper\u001b[0;34m()\u001b[0m\n",
-+      "File \u001b[0;32mh5py/h5f.pyx:102\u001b[0m, in \u001b[0;36mh5py.h5f.open\u001b[0;34m()\u001b[0m\n",
-+      "\u001b[0;31mFileNotFoundError\u001b[0m: [Errno 2] Unable to open file (unable to open file: name = './checkpoints/feedforward/2/data_fold1/results_dict.h5', errno = 2, error message = 'No such file or directory', flags = 0, o_flags = 0)"
-+     ]
-+    }
-+   ],
-+   "source": [
-+    "import h5py\n",
-+    "\n",
-+    "file_path = \"./checkpoints/feedforward/2/data_fold1/results_dict.h5\"\n",
-+    "# Replace 'your_file.h5' with the actual path to your file\n",
-+    "f =  h5py.File(file_path, 'r') \n",
-+    "\n",
-+    "    # Get information about the data stored in the file\n",
-+    "print(\"Keys:\", list(f.keys()))  # List the top-level datasets and groups\n",
-+    "\n",
-+    "    # # Access a dataset by its name\n",
-+    "    # dataset_name = \"your_dataset_name\"\n",
-+    "    # if dataset_name in f:\n",
-+    "    #     dataset = f[dataset_name]\n",
-+    "    #     print(\"Dataset shape:\", dataset.shape)\n",
-+    "    #     print(\"Dataset dtype:\", dataset.dtype)\n",
-+    "\n",
-+    "    #     # Access the data as a NumPy array\n",
-+    "    #     data = dataset[:]  # Read the entire dataset\n",
-+    "\n",
-+    "    #     # You can now work with the data as needed, for example:\n",
-+    "    #     # Perform calculations, visualizations, etc.\n",
-+    "    # else:\n",
-+    "    #     print(f\"Dataset '{dataset_name}' not found in the file.\")"
-+   ]
-+  },
-+  {
-+   "cell_type": "code",
-+   "execution_count": 13,
-+   "id": "07e0b160-d5d1-4e54-b4a7-ccaf2224598a",
-+   "metadata": {},
-+   "outputs": [
-+    {
-+     "data": {
-+      "text/plain": [
-+       "<generator object Module.parameters at 0x3007207b0>"
-+      ]
-+     },
-+     "execution_count": 13,
-+     "metadata": {},
-+     "output_type": "execute_result"
-+    }
-+   ],
-+   "source": []
-+  },
-   {
-    "cell_type": "code",
-    "execution_count": null,
-diff --git a/train.py b/train.py
-index c266102..d389e88 100644
---- a/train.py
-+++ b/train.py
-@@ -1,49 +1,461 @@
- from os import path as osp
-+import os
-+import numpy as np
-+import time
- 
- import torch
-+import torch.nn as nn
- import torch.nn.functional as F
- import torch.optim as optim
--
--import numpy as np
-+from torch.utils.tensorboard import SummaryWriter
- 
- import forge
- from forge import flags
- import forge.experiment_tools as fet
- 
-+from train_tools import (
-+	log_tensorboard,
-+	parse_reports,
-+	parse_reports_cpu,
-+	print_reports,
-+	load_checkpoint,
-+	save_checkpoint,
-+	nested_to,
-+	param_count,
-+)
-+
-+from copy import deepcopy
-+from attrdict import AttrDict
-+import deepdish as dd
-+from tqdm import tqdm
-+
-+# For reproducibility while researching, but might affect speed!
-+torch.backends.cudnn.deterministic = True
-+torch.backends.cudnn.benchmark = False
-+torch.manual_seed(0)
-+
- 
- # Job config
- flags.DEFINE_string('data_config', 'penn_dataset.py',
--                    'Path to a data config file.')
-+					'Path to a data config file.')
- flags.DEFINE_string('model_config', 'basic_feedforward.py',
--                    'Path to a model config file.')
-+					'Path to a model config file.')
- flags.DEFINE_string('results_dir', 'checkpoints',
--                    'Top directory for all experimental results.')
--flags.DEFINE_string('run_name', 'feedforward',
--                    'Name of this job and name of results folder.')
-+					'Top directory for all experimental results.')
-+flags.DEFINE_string('model_name', 'gpt-FCNN',
-+					'shorthand name for model.')
-+flags.DEFINE_string('run_name', 'hyperparam_testing',
-+					'Name of this job and name of results folder.')
- flags.DEFINE_boolean('resume', False, 'Tries to resume a job if True.')
- 
- # Logging config
- flags.DEFINE_integer('report_loss_every', 50,
--                     'Number of iterations between reporting minibatch loss.')
--flags.DEFINE_integer('train_epochs', 20, 'Maximum number of training epochs.')
-+					 'Number of iterations between reporting minibatch loss.')
-+flags.DEFINE_integer('train_epochs', 75, 'Maximum number of training epochs.')
-+flags.DEFINE_integer(
-+	"save_check_points",
-+	50,
-+	"frequency with which to save checkpoints, in number of epoches.",
-+)
-+flags.DEFINE_boolean("log_train_values", True, "Logs train values if True.")
-+flags.DEFINE_integer(
-+	"total_evaluations",
-+	100,
-+	"Maximum number of evaluations on test and validation data during training.",
-+)
-+flags.DEFINE_boolean(
-+	"save_test_predictions",
-+	False,
-+	"Makes and saves test predictions on one or more test sets (e.g. 5-step and 100-step predictions) at the end of training.",
-+)
-+flags.DEFINE_boolean(
-+    "log_val_test", True, "Turns off computation of validation and test errors."
-+)
-+
-+flags.DEFINE_boolean('use_mps',False,"Use Metal Performance Shaders (M1) for training.")
- 
- # Experiment config
- flags.DEFINE_integer('batch_size', 100, 'Mini-batch size.')
--flags.DEFINE_float('learning_rate', 1e-5, 'SGD learning rate.')
-+flags.DEFINE_float("learning_rate", 1e-3, "Adam learning rate.")
-+flags.DEFINE_float("beta1", 0.9, "Adam Beta 1 parameter")
-+flags.DEFINE_float("beta2", 0.999, "Adam Beta 2 parameter")
- 
- # Specific config options
- flags.DEFINE_integer("input_size",39,"Input shape to model")
- 
-+#########################################################################################
-+
-+def evaluate(model, loader, device,fold = 0,headings = [],loss_func = nn.CrossEntropyLoss()):
-+	# this function does not account for class weights when evaluating cross-entropy loss.
-+	# however, they are accounted for when evaluating training loss
-+	reports = None
-+	for data in loader:
-+		labels = data['label']
-+		inputs = nested_to(data['data'],device,torch.float32)
-+		
-+		labels_tensor = torch.zeros((len(labels), 2))
-+		for i, label in enumerate(labels):
-+			labels_tensor[i, label] = 1
-+
-+		model_output = model(inputs) # evaluate model
-+
-+		loss = loss_func(model_output, labels_tensor) # compute loss
-+		outputs = AttrDict({"loss": loss, "prediction": model_output,'data_fold':fold})
-+		outputs.reports = AttrDict({"cross_entropy": loss})
-+
-+		if reports is None:
-+			reports = {k: v.detach().clone().cpu() for k, v in outputs.reports.items()}
-+		else:
-+			for k, v in outputs.reports.items():
-+				reports[k] += v.detach().clone().cpu()
-+
-+	for k, v in reports.items():
-+		reports[k] = v / len(
-+			loader
-+		)  # SZ: note this can be slightly incorrect if mini-batch sizes vary (if batch_size doesn't divide train_size), but approximately correct.
-+
-+	# reports['test_headings'] = np.array(headings)
-+
-+	return reports
-+
-+def main():
-+
-+	config = forge.config()
-+
-+	# Set device
-+	if torch.cuda.is_available():
-+		device = f"cuda:{config.device}"
-+		torch.cuda.set_device(device)
-+	else:
-+		device = "cpu" # can change this to MPS on M1 Macs
-+
-+	if config.use_mps:
-+		device = "mps"
-+
-+	# Load data
-+	data_name = "penn_data"
-+	kfold_loaders = fet.load(config.data_config, config)
-+
-+	# Prepare environment
-+	params_in_run_name = [
-+		("batch_size", "bs"),
-+		("learning_rate", "lr"),
-+		("n_train", "ntrain"),
-+		("include_coords",'inclx'),
-+		("input_size",'inpsize'),
-+		("cross_validate",'crval'),
-+		("train_epochs",'n_epochs'),
-+	]
-+
-+	run_name = ""  # config.run_name
-+	for config_param in params_in_run_name:
-+		attr = config_param[0]
-+		abbrev = config_param[1]
-+
-+		if hasattr(config, attr):
-+			run_name += abbrev
-+			run_name += str(getattr(config, attr))
-+			run_name += "_"
-+
-+	results_folder_name = osp.join(
-+		data_name,
-+		config.model_name,
-+		config.run_name,
-+		run_name,
-+	)
-+
-+	# Prepare environment
-+	logdir = osp.join(config.results_dir, results_folder_name.replace(".", "_"))
-+	logdir, resume_checkpoint = fet.init_checkpoint(
-+		logdir, config.data_config, config.model_config, config.resume)
-+
-+	print("Checkpoint directory:",logdir)
-+
-+	# Print flags
-+	fet.print_flags()
-+
-+	n_folds = len(kfold_loaders)
-+	print("Doing {}-fold cross-validation.".format(n_folds))
-+
-+	# KFOLD TRAINING LOOP
-+	for k,loader_k in enumerate(kfold_loaders): # loop over data splits
-+
-+		print("Training fold {}...".format(k+1))
-+
-+		# Load model
-+		model,model_name = fet.load(config.model_config, config)
-+		model = model.to(device)
-+
-+		# Print model info
-+		print(model)
-+
-+		# Setup optimizer
-+		model_params = model.parameters()
-+		opt_learning_rate = config.learning_rate
-+		model_opt = torch.optim.Adam(
-+			model_params, lr=opt_learning_rate, betas=(config.beta1, config.beta2)
-+		)
-+		scheduler = torch.optim.lr_scheduler.StepLR(model_opt, step_size=10, gamma=0.5)
-+		print("Model Optimizer:")
-+		print(model_opt)
-+
-+		# Try to restore model and optimizer from checkpoint
-+		if resume_checkpoint is not None:
-+			start_epoch = load_checkpoint(resume_checkpoint, model, model_opt)
-+		else:
-+			start_epoch = 1
-+
-+		# load the training data
-+		train_loader = loader_k["train"]
-+		n_train = len(train_loader.dataset)
-+		train_batch_size = train_loader.batch_size
-+
-+		# load testing, validation
-+		test_loader = loader_k["test"]
-+		n_test = len(test_loader.dataset)
-+		val_loader = loader_k["val"]
-+		n_val = len(val_loader.dataset)
-+
-+		train_class_counts = np.bincount(train_loader.dataset.all_labels)
-+		train_total_counts = sum(train_class_counts)
-+		class_weight = torch.tensor(1.0 / train_class_counts) * train_total_counts / 2.0
-+
-+		loss_func = nn.CrossEntropyLoss(weight = class_weight) # define reweighted loss function
-+				
-+		# create folder for this data split
-+		fold_dir = osp.join(logdir,"data_fold{}".format(k+1))
-+		fold_dir_exists = osp.exists(fold_dir)
-+		if not fold_dir_exists:
-+			if config.resume:
-+				raise ValueError("Can't resume when the checkpoint/fold dir '{}' doesn't exist.".format(fold_dir))
-+			else:
-+				os.makedirs(fold_dir)
-+		checkpoint_name = osp.join(fold_dir, 'model_fold{}.ckpt'.format(k+1))
-+
-+		# keep track of which data is test data for a given Kfold data split
-+		test_headings = loader_k['test_headings']
-+		headingsFile = osp.join(fold_dir,"test_headings.txt")
-+		with open(headingsFile,'w') as headfile:
-+			for heading in test_headings:
-+				headfile.write(heading+'\n')
-+
-+		# print(checkpoint_name)
-+
-+		train_iter = (start_epoch - 1) * (
-+		len(train_loader.dataset) // train_batch_size
-+		) + 1
-+
-+		print("Starting training at epoch = {}, iter = {}".format(start_epoch, train_iter))
-+
-+		# Setup tensorboard writing
-+		summary_writer = SummaryWriter(logdir)
-+
-+		train_reports = []
-+		report_all = {}
-+		report_all_val = {}
-+
-+		# Saving model at epoch 0 before training
-+		print("saving model at epoch 0 before training ... ")
-+		save_checkpoint(checkpoint_name, 0, model, model_opt, loss=0.0)
-+		print("finished saving model at epoch 0 before training")
-+
-+		num_params = param_count(model)
-+		print(f"Number of model parameters: {num_params}")
-+
-+		# Training
-+		start_t = time.time()
-+
-+		total_train_iters = len(train_loader) * config.train_epochs
-+		iters_per_eval = max(1, int(total_train_iters / config.total_evaluations))
-+		# print('batch',train_batch_size)
-+		# print('ntrain',n_train)
-+		# assert (
-+		# 	n_train % min(train_batch_size, n_train) == 0
-+		# ), "Batch size doesn't divide dataset size. Can be inaccurate for loss computation (see below)."
-+
-+		training_failed = False
-+		best_val_loss_so_far = 1e7
-+
-+		for epoch in tqdm(range(start_epoch, config.train_epochs + 1)):
-+			model.train()
-+
-+			for batch_idx, data_dict in enumerate(train_loader): # Loop over batched data
-+
-+				labels = data_dict['label']
-+				data = data_dict['data']
-+
-+				# send data to device
-+				data = nested_to(data,device,torch.float32)
-+				# One-hot encode the data labels
-+				labels_tensor = torch.zeros((len(labels), 2))
-+				for i, label in enumerate(labels):
-+					labels_tensor[i, label] = 1
-+
-+				model_output = model(data) # evaluate model
-+
-+				loss = loss_func(model_output, labels_tensor) # compute loss
-+				outputs = AttrDict({"loss": loss, "prediction": model_output})
-+				outputs.reports = AttrDict({"cross_entropy": loss})
-+
-+				if torch.isnan(outputs.loss): # check for failure in training
-+					if not training_failed:
-+						epoch_of_nan = epoch
-+					if (epoch > epoch_of_nan + 1) and training_failed:
-+						raise ValueError("Loss Nan-ed.")
-+					training_failed = True
-+
-+				model_opt.zero_grad()
-+				outputs.loss.backward(retain_graph=False)
-+
-+				model_opt.step() # move optimizer forward
-+
-+				train_reports.append(parse_reports_cpu(outputs.reports))
-+
-+				if config.log_train_values:
-+					reports = parse_reports(outputs.reports)
-+					if batch_idx % config.report_loss_every == 0:
-+						log_tensorboard(summary_writer, train_iter, reports, "train/")
-+						print_reports(
-+							reports,
-+							start_t,
-+							epoch,
-+							batch_idx,
-+							len(train_loader.dataset) // train_batch_size,
-+							prefix="train",
-+						)
-+						log_tensorboard(
-+							summary_writer,
-+							train_iter,
-+							{"lr": model_opt.param_groups[0]["lr"]},
-+							"hyperparams/",
-+						)
-+				# Logging and evaluation
-+				if (
-+					train_iter % iters_per_eval == 0 or (train_iter == total_train_iters)
-+				) and config.log_val_test:  # batch_idx % config.evaluate_every == 0:
-+					model.eval()
-+					with torch.no_grad():
-+						reports = evaluate(model, test_loader, device,fold = k,headings = loader_k['test_headings'])
-+						# print("REPORTS",reports)
-+						reports = parse_reports(reports)
-+						reports["time"] = time.time() - start_t
-+						if report_all == {}:
-+							report_all = deepcopy(reports)
-+
-+							for d in reports.keys():
-+								report_all[d] = [report_all[d]]
-+						else:
-+							for d in reports.keys():
-+								report_all[d].append(reports[d])
-+
-+						log_tensorboard(summary_writer, train_iter, reports, "test/")
-+						print_reports(
-+							reports,
-+							start_t,
-+							epoch,
-+							batch_idx,
-+							len(train_loader.dataset) // config.batch_size,
-+							prefix="test",
-+						)
-+
-+						# repeat for validation data
-+						reports = evaluate(model, val_loader, device,fold = k,headings = loader_k['test_headings'])
-+						reports = parse_reports(reports)
-+						reports["time"] = time.time() - start_t
-+						if report_all_val == {}:
-+							report_all_val = deepcopy(reports)
-+
-+							for d in reports.keys():
-+								report_all_val[d] = [report_all_val[d]]
-+						else:
-+							for d in reports.keys():
-+								report_all_val[d].append(reports[d])
-+
-+						log_tensorboard(summary_writer, train_iter, reports, "val/")
-+						print_reports(
-+							reports,
-+							start_t,
-+							epoch,
-+							batch_idx,
-+							len(train_loader.dataset) // config.batch_size,
-+							prefix="val",
-+						)
-+
-+						if report_all_val["cross_entropy"][-1] < best_val_loss_so_far:
-+							save_checkpoint(
-+								checkpoint_name,
-+								f"early_stop",
-+								model,
-+								model_opt,
-+								loss=outputs.loss,
-+							)
-+							best_val_loss_so_far = report_all_val["cross_entropy"][-1]
-+
-+					model.train()
-+
-+				train_iter += 1
-+
-+			scheduler.step()
-+
-+			if epoch % config.save_check_points == 0:
-+				save_checkpoint(
-+					checkpoint_name, train_iter, model, model_opt, loss=outputs.loss
-+				)
-+		
-+		dd.io.save(fold_dir + "/results_dict_train.h5", train_reports)
-+		dd.io.save(fold_dir + "/results_dict.h5", report_all)
-+		dd.io.save(fold_dir + "/results_dict_val.h5", report_all_val)
-+
-+	# always save final model
-+	save_checkpoint(checkpoint_name, train_iter, model, model_opt, loss=outputs.loss)
-+
-+	
-+	if config.save_test_predictions:
-+		pass
-+		# print("Starting to make model predictions on test sets for *final model*.")
-+		# for chunk_len in [5, 100]:
-+		#     start_t_preds = time.time()
-+		#     data_config = SimpleNamespace(
-+		#         **{
-+		#             **config.__dict__["__flags"],
-+		#             **{"chunk_len": chunk_len, "batch_size": 500},
-+		#         }
-+		#     )
-+		#     dataloaders, data_name = fet.load(config.data_config, config=data_config)
-+		#     test_loader_preds = dataloaders["test"]
-+
-+		#     torch.cuda.empty_cache()
-+		#     with torch.no_grad():
-+		#         preds = []
-+		#         true = []
-+		#         num_datapoints = 0
-+		#         for idx, d in enumerate(test_loader_preds):
-+		#             true.append(d[-1])
-+		#             d = nested_to(d, device, torch.float32)
-+		#             outputs = model(d)
-+
-+		#             pred_zs = outputs.prediction
-+		#             preds.append(pred_zs)
-+
-+		#             num_datapoints += len(pred_zs)
-+
-+		#             if num_datapoints >= 2000:
-+		#                 break
- 
--config = forge.config()
-+		#         preds = torch.cat(preds, dim=0).cpu()
-+		#         true = torch.cat(true, dim=0).cpu()
- 
--# Prepare environment
--logdir = osp.join(config.results_dir, config.run_name)
--logdir, resume_checkpoint = fet.init_checkpoint(
--    logdir, config.data_config, config.model_config, config.resume)
--checkpoint_name = osp.join(logdir, 'model.ckpt')
-+		#         save_dir = osp.join(logdir, f"traj_preds_{chunk_len}_steps_2k_test.pt")
-+		#         torch.save(preds, save_dir)
- 
-+		#         save_dir = osp.join(logdir, f"traj_true_{chunk_len}_steps_2k_test.pt")
-+		#         torch.save(true, save_dir)
- 
--print(logdir)
-+		#         print(
-+		#             f"Completed making test predictions for chunk_len = {chunk_len} in {time.time() - start_t_preds:.2f} seconds."
-+		#         )	
-+		
- 
-+if __name__ == "__main__":
-+	main()
- 
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/1/penn_dataset.py b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/1/penn_dataset.py
deleted file mode 100644
index 46c8e52..0000000
--- a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/1/penn_dataset.py
+++ /dev/null
@@ -1,137 +0,0 @@
-import os
-import torch
-import pandas as pd
-import numpy as np
-
-from torchvision import datasets, transforms
-from torch.utils.data import Dataset, DataLoader
-from sklearn.model_selection import RepeatedKFold
-
-from os import path as osp
-import forge
-from forge import flags
-
-
-# aspects of data managmement
-flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
-flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-flags.DEFINE_boolean("cross_validate",True,"Do K-fold cross-validation")
-
-# Job management
-# flags.DEFINE_integer("batch size",5,"training batch size")
-flags.DEFINE_float("train_split",0.8,'Fraction of data to use for training.')
-flags.DEFINE_integer("n_repeats",1,"Times to repeat K-fold cross-validation")
-flags.DEFINE_integer("split_seed",1,"Seed for KFold split (integer for reproducibility")
-
-# "wavelengths between 0.05 and 1 mm in 0.025 mm increments."
-LSPACE = np.arange(0.05,1.05,0.025) # corresponds to 39 non-coord columns of data
-L_INDS = None
-
-DATAFOLDER = './penn_data'
-
-HEADINGS = np.array(['aaa0043','aaa0044','aaa0060','aaa0061','aaa0063','aaa0064','aaa0066','aaa0069','aaa0086','aaa0087','aaa_0051','aaa_0053','aaa_0054','aaa_0059','aaa_0071','aaa_0072'])
-
-
-class PennData(Dataset):
-
-    def __init__(self,path_to_data,headings,k_inds = None,include_coords = True,rescale = True,spectra_prefix = "kvals_fuse_rotate_",label_prefix = 'labels_fuse_rotate_'):
-        
-        self.data_dir = path_to_data
-        self.headings = headings
-
-        df_list = []
-        label_list = []
-        for heading in self.headings: # for each datafile heading,
-            data_name = osp.join(self.data_dir,spectra_prefix + heading+'.csv') # read kvals
-            df_temp = pd.read_csv(data_name,header=None)
-            df_list.append(df_temp)
-
-            label_name = osp.join(self.data_dir,label_prefix + heading + '.csv') # read labels
-            label_temp = pd.read_csv(label_name,header=None, names=['label'])
-            label_list.append(label_temp)
-
-        df = pd.concat(df_list, ignore_index=True)
-
-        labels = pd.concat(label_list, ignore_index=True)
-        df = pd.concat([labels, df], axis="columns") # Append labels to data
-
-        all_labels = df['label'].to_numpy()
-        all_data = df.iloc[:,1:].to_numpy()
-
-        if rescale: # rescale (normalize) wavelength intensity data
-            lambdas = all_data[:,2:] # wavelengths
-            lam_std = np.std(lambdas, axis=0)  # Calculate standard deviation along columns
-            lam_mean = np.mean(lambdas, axis=0)  # Calculate mean along columns
-            lambdas_rescaled = (lambdas - lam_mean) / lam_std 
-            all_data[:,2:] = lambdas_rescaled
-
-        if not include_coords: # removes x,y coordinates from data
-            all_data = all_data[:,2:]
-        
-        if k_inds != None: # in this case, only use subset of wavelengths
-            all_data = all_data[:,np.array(k_inds)]
-
-        self.all_data = all_data
-        self.all_labels = all_labels
-
-    def __len__(self):
-        return len(self.all_data)
-
-    def __getitem__(self,i):
-        state = {'label':self.all_labels[i],'data':self.all_data[i]}
-        return state
-
-    def __getstate__(self):
-        state = {
-            'data': self.all_data,
-            'label': self.all_labels,
-                }
-        return state
-
-    def __setstate__(self, state):
-        # Set the object's state from the provided dictionary
-        self.all_data = state['data']
-        self.all_labels = state['label']
-        
-
-
-def load(config):
-
-    n_splits = int(len(HEADINGS)/((1-config.train_split)*len(HEADINGS)))
-
-    kf = RepeatedKFold(n_splits = n_splits, n_repeats = config.n_repeats, random_state = config.split_seed) # K-fold cross validation
-
-    kf_dataloaders = []
-
-    for i, (train_ind, test_ind) in enumerate(kf.split(HEADINGS)): # for each K-fold split, 
-        n_val = len(test_ind)//2
-        n_test = len(test_ind)-n_val   
-        n_train = len(train_ind)
-        
-        # set up training DataLoader
-        train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
-
-        # set up test DataLoader
-        test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
-
-        # set up val DataLoader
-        val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-        
-
-        dataloaders = {'train':train_loader, 
-                       'test':test_loader,
-                       'val':val_loader,
-                       'train_inds':train_ind,
-                       'test_inds':test_ind,
-                       'n_val':n_val,
-                       'test_headings':list(HEADINGS[test_ind])
-                      }
-        kf_dataloaders.append(dataloaders)
-
-        if not config.cross_validate:
-        	break
-
-    return kf_dataloaders
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/basic_feedforward.py b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/basic_feedforward.py
deleted file mode 100644
index c36011b..0000000
--- a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/basic_feedforward.py
+++ /dev/null
@@ -1,74 +0,0 @@
-import torch
-import torch.nn as nn
-import torch.nn.functional as F
-import numpy as np
-
-from forge import flags
-
-# flags.DEFINE_boolean(
-#     "model_with_dict",
-#     True,
-#     "Makes model output predictions in dictionary instead of directly."
-# )
-
-class PerceptronNN(nn.Module):
-    def __init__(self, input_size, num_labels):
-        super(PerceptronNN, self).__init__()
-        # Define the layers
-        self.fc1 = nn.Linear(input_size, 128)  # First dense layer
-        self.fc2 = nn.Linear(128, 64)         # Second dense layer
-        # self.fc23 = nn.Linear(64,64)
-        self.fc3 = nn.Linear(64, 64)          # Third dense layer
-        self.fc4 = nn.Linear(64, num_labels)  # Output layer
-        # self.softmax = nn.Softmax(dim=1)
-
-    def forward(self, x):
-        # Forward pass through the network
-        x = F.relu(self.fc1(x))  # Activation function between layers
-        x = F.relu(self.fc2(x))
-        # x = F.relu(self.fc23(x))
-        x = F.relu(self.fc3(x))
-        x = self.fc4(x)  # No activation, this will be included in the loss function
-        # x = self.softmax(x)
-        return x
-
-class GPT_PNN(nn.Module):
-    def __init__(self, input_size, num_labels):
-        super(GPT_PNN, self).__init__()
-        # Define the layers
-        self.fc1 = nn.Linear(input_size, 64)  # First dense layer, reduced size
-        self.bn1 = nn.BatchNorm1d(64)  # Batch Normalization for the first layer
-        self.dropout1 = nn.Dropout(0.5)  # Dropout with 50% probability
-        
-        # Commenting out to reduce model complexity
-        # self.fc2 = nn.Linear(128, 64)  # Second dense layer
-        # self.dropout2 = nn.Dropout(0.5)  # Additional dropout layer
-        
-        # Simplified to have fewer layers and neurons
-        self.fc2 = nn.Linear(64, 32)  # Reduced size for second dense layer
-        self.bn2 = nn.BatchNorm1d(32)  # Batch Normalization for the second layer
-        self.dropout2 = nn.Dropout(0.5)  # Dropout with 50% probability
-
-        # Output layer remains the same, adjusted for reduced prior layer size
-        self.fc3 = nn.Linear(32, num_labels)  # Output layer
-
-    def forward(self, x):
-        # x = x[:,::2] # try using every other wavelength
-        # Forward pass through the network with activations, batch normalization, and dropout
-        x = F.relu(self.bn1(self.fc1(x)))
-        x = self.dropout1(x)
-        x = F.relu(self.bn2(self.fc2(x)))
-        x = self.dropout2(x)
-        x = self.fc3(x)  # No activation here, use sigmoid or softmax outside if needed for binary classification
-        return x
-
-def load(config):
-
-    # n_channels = 1
-    n_features = config.input_size
-    
-    # mlp = PerceptronNN(n_features,2)
-
-    mlp = GPT_PNN(n_features,2)
-    
-    return mlp, "gpt_feedforward_halfLs"
\ No newline at end of file
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold1/model_fold1.ckpt-0 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold1/model_fold1.ckpt-0
deleted file mode 100644
index 26d8425..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold1/model_fold1.ckpt-0 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold1/model_fold1.ckpt-57551 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold1/model_fold1.ckpt-57551
deleted file mode 100644
index ef6957f..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold1/model_fold1.ckpt-57551 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold1/model_fold1.ckpt-early_stop b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold1/model_fold1.ckpt-early_stop
deleted file mode 100644
index e89d565..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold1/model_fold1.ckpt-early_stop and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold1/results_dict.h5 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold1/results_dict.h5
deleted file mode 100644
index 6a4f941..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold1/results_dict.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold1/results_dict_train.h5 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold1/results_dict_train.h5
deleted file mode 100644
index 37d9287..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold1/results_dict_train.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold1/results_dict_val.h5 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold1/results_dict_val.h5
deleted file mode 100644
index d79d26d..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold1/results_dict_val.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold1/test_headings.txt b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold1/test_headings.txt
deleted file mode 100644
index 05c4825..0000000
--- a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold1/test_headings.txt
+++ /dev/null
@@ -1,4 +0,0 @@
-aaa0060
-aaa0061
-aaa0069
-aaa_0059
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold2/model_fold2.ckpt-0 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold2/model_fold2.ckpt-0
deleted file mode 100644
index fae4036..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold2/model_fold2.ckpt-0 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold2/model_fold2.ckpt-60651 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold2/model_fold2.ckpt-60651
deleted file mode 100644
index f40d8b7..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold2/model_fold2.ckpt-60651 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold2/model_fold2.ckpt-early_stop b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold2/model_fold2.ckpt-early_stop
deleted file mode 100644
index 5aa0f8f..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold2/model_fold2.ckpt-early_stop and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold2/results_dict.h5 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold2/results_dict.h5
deleted file mode 100644
index ebb727b..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold2/results_dict.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold2/results_dict_train.h5 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold2/results_dict_train.h5
deleted file mode 100644
index d71d42b..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold2/results_dict_train.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold2/results_dict_val.h5 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold2/results_dict_val.h5
deleted file mode 100644
index b874e73..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold2/results_dict_val.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold2/test_headings.txt b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold2/test_headings.txt
deleted file mode 100644
index b87ab5e..0000000
--- a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold2/test_headings.txt
+++ /dev/null
@@ -1,3 +0,0 @@
-aaa0063
-aaa0066
-aaa_0051
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold3/model_fold3.ckpt-0 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold3/model_fold3.ckpt-0
deleted file mode 100644
index c5f3787..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold3/model_fold3.ckpt-0 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold3/model_fold3.ckpt-63751 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold3/model_fold3.ckpt-63751
deleted file mode 100644
index 4d20914..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold3/model_fold3.ckpt-63751 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold3/model_fold3.ckpt-early_stop b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold3/model_fold3.ckpt-early_stop
deleted file mode 100644
index 58de1d4..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold3/model_fold3.ckpt-early_stop and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold3/results_dict.h5 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold3/results_dict.h5
deleted file mode 100644
index 41fcc57..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold3/results_dict.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold3/results_dict_train.h5 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold3/results_dict_train.h5
deleted file mode 100644
index be8445c..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold3/results_dict_train.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold3/results_dict_val.h5 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold3/results_dict_val.h5
deleted file mode 100644
index 53daad1..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold3/results_dict_val.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold3/test_headings.txt b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold3/test_headings.txt
deleted file mode 100644
index 8417193..0000000
--- a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold3/test_headings.txt
+++ /dev/null
@@ -1,3 +0,0 @@
-aaa0043
-aaa0044
-aaa_0071
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold4/model_fold4.ckpt-0 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold4/model_fold4.ckpt-0
deleted file mode 100644
index 645928d..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold4/model_fold4.ckpt-0 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold4/model_fold4.ckpt-63601 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold4/model_fold4.ckpt-63601
deleted file mode 100644
index d178242..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold4/model_fold4.ckpt-63601 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold4/model_fold4.ckpt-early_stop b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold4/model_fold4.ckpt-early_stop
deleted file mode 100644
index 742921f..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold4/model_fold4.ckpt-early_stop and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold4/results_dict.h5 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold4/results_dict.h5
deleted file mode 100644
index a7d3e46..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold4/results_dict.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold4/results_dict_train.h5 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold4/results_dict_train.h5
deleted file mode 100644
index 7b449fd..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold4/results_dict_train.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold4/results_dict_val.h5 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold4/results_dict_val.h5
deleted file mode 100644
index f3695d4..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold4/results_dict_val.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold4/test_headings.txt b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold4/test_headings.txt
deleted file mode 100644
index ad5063c..0000000
--- a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold4/test_headings.txt
+++ /dev/null
@@ -1,3 +0,0 @@
-aaa0086
-aaa0087
-aaa_0072
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold5/model_fold5.ckpt-0 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold5/model_fold5.ckpt-0
deleted file mode 100644
index 40d8ce4..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold5/model_fold5.ckpt-0 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold5/model_fold5.ckpt-61201 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold5/model_fold5.ckpt-61201
deleted file mode 100644
index 1937784..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold5/model_fold5.ckpt-61201 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold5/model_fold5.ckpt-91801 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold5/model_fold5.ckpt-91801
deleted file mode 100644
index 7ed9ba7..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold5/model_fold5.ckpt-91801 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold5/model_fold5.ckpt-early_stop b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold5/model_fold5.ckpt-early_stop
deleted file mode 100644
index 801eee4..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold5/model_fold5.ckpt-early_stop and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold5/results_dict.h5 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold5/results_dict.h5
deleted file mode 100644
index 90f51dd..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold5/results_dict.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold5/results_dict_train.h5 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold5/results_dict_train.h5
deleted file mode 100644
index dca3b37..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold5/results_dict_train.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold5/results_dict_val.h5 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold5/results_dict_val.h5
deleted file mode 100644
index 1d72be6..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold5/results_dict_val.h5 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold5/test_headings.txt b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold5/test_headings.txt
deleted file mode 100644
index a4e6319..0000000
--- a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/data_fold5/test_headings.txt
+++ /dev/null
@@ -1,3 +0,0 @@
-aaa0064
-aaa_0053
-aaa_0054
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/events.out.tfevents.1709692040.MacBook-Pro-4.local.4381.0 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/events.out.tfevents.1709692040.MacBook-Pro-4.local.4381.0
deleted file mode 100644
index 6082775..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/events.out.tfevents.1709692040.MacBook-Pro-4.local.4381.0 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/events.out.tfevents.1709692226.MacBook-Pro-4.local.4381.1 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/events.out.tfevents.1709692226.MacBook-Pro-4.local.4381.1
deleted file mode 100644
index a8e8ecd..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/events.out.tfevents.1709692226.MacBook-Pro-4.local.4381.1 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/events.out.tfevents.1709692447.MacBook-Pro-4.local.4381.2 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/events.out.tfevents.1709692447.MacBook-Pro-4.local.4381.2
deleted file mode 100644
index 0e6ddd1..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/events.out.tfevents.1709692447.MacBook-Pro-4.local.4381.2 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/events.out.tfevents.1709692664.MacBook-Pro-4.local.4381.3 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/events.out.tfevents.1709692664.MacBook-Pro-4.local.4381.3
deleted file mode 100644
index 2b1bfec..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/events.out.tfevents.1709692664.MacBook-Pro-4.local.4381.3 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/events.out.tfevents.1709692864.MacBook-Pro-4.local.4381.4 b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/events.out.tfevents.1709692864.MacBook-Pro-4.local.4381.4
deleted file mode 100644
index 07bc3e0..0000000
Binary files a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/events.out.tfevents.1709692864.MacBook-Pro-4.local.4381.4 and /dev/null differ
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/flags.json b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/flags.json
deleted file mode 100644
index 0a98821..0000000
--- a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/flags.json
+++ /dev/null
@@ -1,28 +0,0 @@
-{
-    "batch_size": 100,
-    "beta1": 0.9,
-    "beta2": 0.999,
-    "cross_validate": true,
-    "data_config": "penn_dataset.py",
-    "git_commit": "7416bf730b356aabfe0df644240e40948a8196bb",
-    "include_coords": false,
-    "input_size": 39,
-    "learning_rate": 0.001,
-    "log_train_values": true,
-    "log_val_test": true,
-    "model_config": "basic_feedforward.py",
-    "model_name": "gpt-FCNN",
-    "n_repeats": 1,
-    "report_loss_every": 50,
-    "rescale": true,
-    "results_dir": "checkpoints",
-    "resume": false,
-    "run_name": "hyperparam_testing",
-    "save_check_points": 50,
-    "save_test_predictions": false,
-    "split_seed": 1,
-    "total_evaluations": 100,
-    "train_epochs": 75,
-    "train_split": 0.8,
-    "use_mps": false
-}
\ No newline at end of file
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/git_diff.txt b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/git_diff.txt
deleted file mode 100644
index db2e70d..0000000
--- a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/git_diff.txt
+++ /dev/null
@@ -1,1813 +0,0 @@
-Tue Mar 5 18:27:20 PST 2024
-diff --git a/.DS_Store b/.DS_Store
-index e2836a8..bf7630a 100644
-Binary files a/.DS_Store and b/.DS_Store differ
-diff --git a/.ipynb_checkpoints/basic_feedforward-checkpoint.py b/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-index 688c282..0c4bcd1 100644
---- a/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-+++ b/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-@@ -5,6 +5,12 @@ import numpy as np
- 
- from forge import flags
- 
-+flags.DEFINE_boolean(
-+    "model_with_dict",
-+    True,
-+    "Makes model output predictions in dictionary instead of directly."
-+)
-+
- class PerceptronNN(nn.Module):
-     def __init__(self, input_size, num_labels):
-         super(PerceptronNN, self).__init__()
-@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-+        self.softmax = nn.Softmax(dim=1)
- 
-     def forward(self, x):
-         # Forward pass through the network
-@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-         x = F.relu(self.fc2(x))
-         x = F.relu(self.fc3(x))
-         x = self.fc4(x)  # No activation, this will be included in the loss function
-+        x = self.softmax(x)
-         return x
- 
- def load(config):
-@@ -29,4 +37,4 @@ def load(config):
-     
-     mlp = PerceptronNN(n_features,2)
-     
--    return mlp
-\ No newline at end of file
-+    return mlp, "feedforward"
-\ No newline at end of file
-diff --git a/__pycache__/basic_feedforward.cpython-39.pyc b/__pycache__/basic_feedforward.cpython-39.pyc
-index f541140..4a02232 100644
-Binary files a/__pycache__/basic_feedforward.cpython-39.pyc and b/__pycache__/basic_feedforward.cpython-39.pyc differ
-diff --git a/__pycache__/penn_dataset.cpython-39.pyc b/__pycache__/penn_dataset.cpython-39.pyc
-index 0d7a4de..6fdde51 100644
-Binary files a/__pycache__/penn_dataset.cpython-39.pyc and b/__pycache__/penn_dataset.cpython-39.pyc differ
-diff --git a/basic_feedforward.py b/basic_feedforward.py
-index 688c282..c36011b 100644
---- a/basic_feedforward.py
-+++ b/basic_feedforward.py
-@@ -5,21 +5,61 @@ import numpy as np
- 
- from forge import flags
- 
-+# flags.DEFINE_boolean(
-+#     "model_with_dict",
-+#     True,
-+#     "Makes model output predictions in dictionary instead of directly."
-+# )
-+
- class PerceptronNN(nn.Module):
-     def __init__(self, input_size, num_labels):
-         super(PerceptronNN, self).__init__()
-         # Define the layers
-         self.fc1 = nn.Linear(input_size, 128)  # First dense layer
-         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-+        # self.fc23 = nn.Linear(64,64)
-         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-+        # self.softmax = nn.Softmax(dim=1)
- 
-     def forward(self, x):
-         # Forward pass through the network
-         x = F.relu(self.fc1(x))  # Activation function between layers
-         x = F.relu(self.fc2(x))
-+        # x = F.relu(self.fc23(x))
-         x = F.relu(self.fc3(x))
-         x = self.fc4(x)  # No activation, this will be included in the loss function
-+        # x = self.softmax(x)
-+        return x
-+
-+class GPT_PNN(nn.Module):
-+    def __init__(self, input_size, num_labels):
-+        super(GPT_PNN, self).__init__()
-+        # Define the layers
-+        self.fc1 = nn.Linear(input_size, 64)  # First dense layer, reduced size
-+        self.bn1 = nn.BatchNorm1d(64)  # Batch Normalization for the first layer
-+        self.dropout1 = nn.Dropout(0.5)  # Dropout with 50% probability
-+        
-+        # Commenting out to reduce model complexity
-+        # self.fc2 = nn.Linear(128, 64)  # Second dense layer
-+        # self.dropout2 = nn.Dropout(0.5)  # Additional dropout layer
-+        
-+        # Simplified to have fewer layers and neurons
-+        self.fc2 = nn.Linear(64, 32)  # Reduced size for second dense layer
-+        self.bn2 = nn.BatchNorm1d(32)  # Batch Normalization for the second layer
-+        self.dropout2 = nn.Dropout(0.5)  # Dropout with 50% probability
-+
-+        # Output layer remains the same, adjusted for reduced prior layer size
-+        self.fc3 = nn.Linear(32, num_labels)  # Output layer
-+
-+    def forward(self, x):
-+        # x = x[:,::2] # try using every other wavelength
-+        # Forward pass through the network with activations, batch normalization, and dropout
-+        x = F.relu(self.bn1(self.fc1(x)))
-+        x = self.dropout1(x)
-+        x = F.relu(self.bn2(self.fc2(x)))
-+        x = self.dropout2(x)
-+        x = self.fc3(x)  # No activation here, use sigmoid or softmax outside if needed for binary classification
-         return x
- 
- def load(config):
-@@ -27,6 +67,8 @@ def load(config):
-     # n_channels = 1
-     n_features = config.input_size
-     
--    mlp = PerceptronNN(n_features,2)
-+    # mlp = PerceptronNN(n_features,2)
-+
-+    mlp = GPT_PNN(n_features,2)
-     
--    return mlp
-\ No newline at end of file
-+    return mlp, "gpt_feedforward_halfLs"
-\ No newline at end of file
-diff --git a/checkpoints/feedforward/1/basic_feedforward.py b/checkpoints/feedforward/1/basic_feedforward.py
-index 688c282..3a65525 100644
---- a/checkpoints/feedforward/1/basic_feedforward.py
-+++ b/checkpoints/feedforward/1/basic_feedforward.py
-@@ -5,6 +5,12 @@ import numpy as np
- 
- from forge import flags
- 
-+# flags.DEFINE_boolean(
-+#     "model_with_dict",
-+#     True,
-+#     "Makes model output predictions in dictionary instead of directly."
-+# )
-+
- class PerceptronNN(nn.Module):
-     def __init__(self, input_size, num_labels):
-         super(PerceptronNN, self).__init__()
-@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-+        self.softmax = nn.Softmax(dim=1)
- 
-     def forward(self, x):
-         # Forward pass through the network
-@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-         x = F.relu(self.fc2(x))
-         x = F.relu(self.fc3(x))
-         x = self.fc4(x)  # No activation, this will be included in the loss function
-+        x = self.softmax(x)
-         return x
- 
- def load(config):
-@@ -29,4 +37,4 @@ def load(config):
-     
-     mlp = PerceptronNN(n_features,2)
-     
--    return mlp
-\ No newline at end of file
-+    return mlp, "feedforward"
-\ No newline at end of file
-diff --git a/checkpoints/feedforward/1/flags.json b/checkpoints/feedforward/1/flags.json
-index 1d000c3..889a6ea 100644
---- a/checkpoints/feedforward/1/flags.json
-+++ b/checkpoints/feedforward/1/flags.json
-@@ -1,9 +1,15 @@
- {
-     "batch_size": 100,
-+    "beta1": 0.9,
-+    "beta2": 0.999,
-+    "cross_validate": false,
-     "data_config": "penn_dataset.py",
-+    "git_commit": "7416bf730b356aabfe0df644240e40948a8196bb",
-     "include_coords": false,
-     "input_size": 39,
--    "learning_rate": 1e-05,
-+    "learning_rate": 0.0001,
-+    "log_train_values": true,
-+    "log_val_test": true,
-     "model_config": "basic_feedforward.py",
-     "n_repeats": 1,
-     "report_loss_every": 50,
-@@ -11,7 +17,10 @@
-     "results_dir": "checkpoints",
-     "resume": false,
-     "run_name": "feedforward",
-+    "save_check_points": 50,
-+    "save_test_predictions": false,
-     "split_seed": 1,
--    "train_epochs": 20,
-+    "total_evaluations": 100,
-+    "train_epochs": 100,
-     "train_split": 0.8
- }
-\ No newline at end of file
-diff --git a/checkpoints/feedforward/1/git_diff.txt b/checkpoints/feedforward/1/git_diff.txt
-index 7b37e6f..ec23707 100644
---- a/checkpoints/feedforward/1/git_diff.txt
-+++ b/checkpoints/feedforward/1/git_diff.txt
-@@ -1 +1,873 @@
--Mon Mar 4 11:45:48 PST 2024
-+Mon Mar 4 16:34:02 PST 2024
-+diff --git a/.DS_Store b/.DS_Store
-+index e2836a8..7e3fa32 100644
-+Binary files a/.DS_Store and b/.DS_Store differ
-+diff --git a/.ipynb_checkpoints/basic_feedforward-checkpoint.py b/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-+index 688c282..0c4bcd1 100644
-+--- a/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-++++ b/.ipynb_checkpoints/basic_feedforward-checkpoint.py
-+@@ -5,6 +5,12 @@ import numpy as np
-+ 
-+ from forge import flags
-+ 
-++flags.DEFINE_boolean(
-++    "model_with_dict",
-++    True,
-++    "Makes model output predictions in dictionary instead of directly."
-++)
-++
-+ class PerceptronNN(nn.Module):
-+     def __init__(self, input_size, num_labels):
-+         super(PerceptronNN, self).__init__()
-+@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-+         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-+         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-+         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-++        self.softmax = nn.Softmax(dim=1)
-+ 
-+     def forward(self, x):
-+         # Forward pass through the network
-+@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-+         x = F.relu(self.fc2(x))
-+         x = F.relu(self.fc3(x))
-+         x = self.fc4(x)  # No activation, this will be included in the loss function
-++        x = self.softmax(x)
-+         return x
-+ 
-+ def load(config):
-+@@ -29,4 +37,4 @@ def load(config):
-+     
-+     mlp = PerceptronNN(n_features,2)
-+     
-+-    return mlp
-+\ No newline at end of file
-++    return mlp, "feedforward"
-+\ No newline at end of file
-+diff --git a/__pycache__/basic_feedforward.cpython-39.pyc b/__pycache__/basic_feedforward.cpython-39.pyc
-+index f541140..5ad96de 100644
-+Binary files a/__pycache__/basic_feedforward.cpython-39.pyc and b/__pycache__/basic_feedforward.cpython-39.pyc differ
-+diff --git a/__pycache__/penn_dataset.cpython-39.pyc b/__pycache__/penn_dataset.cpython-39.pyc
-+index 0d7a4de..19121eb 100644
-+Binary files a/__pycache__/penn_dataset.cpython-39.pyc and b/__pycache__/penn_dataset.cpython-39.pyc differ
-+diff --git a/basic_feedforward.py b/basic_feedforward.py
-+index 688c282..3a65525 100644
-+--- a/basic_feedforward.py
-++++ b/basic_feedforward.py
-+@@ -5,6 +5,12 @@ import numpy as np
-+ 
-+ from forge import flags
-+ 
-++# flags.DEFINE_boolean(
-++#     "model_with_dict",
-++#     True,
-++#     "Makes model output predictions in dictionary instead of directly."
-++# )
-++
-+ class PerceptronNN(nn.Module):
-+     def __init__(self, input_size, num_labels):
-+         super(PerceptronNN, self).__init__()
-+@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-+         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-+         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-+         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-++        self.softmax = nn.Softmax(dim=1)
-+ 
-+     def forward(self, x):
-+         # Forward pass through the network
-+@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-+         x = F.relu(self.fc2(x))
-+         x = F.relu(self.fc3(x))
-+         x = self.fc4(x)  # No activation, this will be included in the loss function
-++        x = self.softmax(x)
-+         return x
-+ 
-+ def load(config):
-+@@ -29,4 +37,4 @@ def load(config):
-+     
-+     mlp = PerceptronNN(n_features,2)
-+     
-+-    return mlp
-+\ No newline at end of file
-++    return mlp, "feedforward"
-+\ No newline at end of file
-+diff --git a/checkpoints/feedforward/1/basic_feedforward.py b/checkpoints/feedforward/1/basic_feedforward.py
-+index 688c282..3a65525 100644
-+--- a/checkpoints/feedforward/1/basic_feedforward.py
-++++ b/checkpoints/feedforward/1/basic_feedforward.py
-+@@ -5,6 +5,12 @@ import numpy as np
-+ 
-+ from forge import flags
-+ 
-++# flags.DEFINE_boolean(
-++#     "model_with_dict",
-++#     True,
-++#     "Makes model output predictions in dictionary instead of directly."
-++# )
-++
-+ class PerceptronNN(nn.Module):
-+     def __init__(self, input_size, num_labels):
-+         super(PerceptronNN, self).__init__()
-+@@ -13,6 +19,7 @@ class PerceptronNN(nn.Module):
-+         self.fc2 = nn.Linear(128, 64)         # Second dense layer
-+         self.fc3 = nn.Linear(64, 64)          # Third dense layer
-+         self.fc4 = nn.Linear(64, num_labels)  # Output layer
-++        self.softmax = nn.Softmax(dim=1)
-+ 
-+     def forward(self, x):
-+         # Forward pass through the network
-+@@ -20,6 +27,7 @@ class PerceptronNN(nn.Module):
-+         x = F.relu(self.fc2(x))
-+         x = F.relu(self.fc3(x))
-+         x = self.fc4(x)  # No activation, this will be included in the loss function
-++        x = self.softmax(x)
-+         return x
-+ 
-+ def load(config):
-+@@ -29,4 +37,4 @@ def load(config):
-+     
-+     mlp = PerceptronNN(n_features,2)
-+     
-+-    return mlp
-+\ No newline at end of file
-++    return mlp, "feedforward"
-+\ No newline at end of file
-+diff --git a/checkpoints/feedforward/1/flags.json b/checkpoints/feedforward/1/flags.json
-+index 1d000c3..889a6ea 100644
-+--- a/checkpoints/feedforward/1/flags.json
-++++ b/checkpoints/feedforward/1/flags.json
-+@@ -1,9 +1,15 @@
-+ {
-+     "batch_size": 100,
-++    "beta1": 0.9,
-++    "beta2": 0.999,
-++    "cross_validate": false,
-+     "data_config": "penn_dataset.py",
-++    "git_commit": "7416bf730b356aabfe0df644240e40948a8196bb",
-+     "include_coords": false,
-+     "input_size": 39,
-+-    "learning_rate": 1e-05,
-++    "learning_rate": 0.0001,
-++    "log_train_values": true,
-++    "log_val_test": true,
-+     "model_config": "basic_feedforward.py",
-+     "n_repeats": 1,
-+     "report_loss_every": 50,
-+@@ -11,7 +17,10 @@
-+     "results_dir": "checkpoints",
-+     "resume": false,
-+     "run_name": "feedforward",
-++    "save_check_points": 50,
-++    "save_test_predictions": false,
-+     "split_seed": 1,
-+-    "train_epochs": 20,
-++    "total_evaluations": 100,
-++    "train_epochs": 100,
-+     "train_split": 0.8
-+ }
-+\ No newline at end of file
-+diff --git a/checkpoints/feedforward/1/git_diff.txt b/checkpoints/feedforward/1/git_diff.txt
-+index 7b37e6f..5c561db 100644
-+--- a/checkpoints/feedforward/1/git_diff.txt
-++++ b/checkpoints/feedforward/1/git_diff.txt
-+@@ -1 +1 @@
-+-Mon Mar 4 11:45:48 PST 2024
-++Mon Mar 4 16:34:02 PST 2024
-+diff --git a/checkpoints/feedforward/1/penn_dataset.py b/checkpoints/feedforward/1/penn_dataset.py
-+index aa2f5a0..7f5a4fc 100644
-+--- a/checkpoints/feedforward/1/penn_dataset.py
-++++ b/checkpoints/feedforward/1/penn_dataset.py
-+@@ -15,6 +15,7 @@ from forge import flags
-+ # aspects of data managmement
-+ flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
-+ flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-++flags.DEFINE_boolean("cross_validate",False,"Do K-fold cross-validation")
-+ 
-+ # Job management
-+ # flags.DEFINE_integer("batch size",5,"training batch size")
-+@@ -109,15 +110,15 @@ def load(config):
-+         
-+         # set up training DataLoader
-+         train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, n_train),num_workers=0,shuffle = True)
-++        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
-+ 
-+         # set up test DataLoader
-+         test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, n_test),num_workers=0,shuffle = True)
-++        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
-+ 
-+         # set up val DataLoader
-+         val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, n_val),num_workers=0,shuffle = True)
-++        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-+         
-+ 
-+         dataloaders = {'train':train_loader, 
-+@@ -125,8 +126,12 @@ def load(config):
-+                        'val':val_loader,
-+                        'train_inds':train_ind,
-+                        'test_inds':test_ind,
-+-                       'n_val':n_val
-++                       'n_val':n_val,
-++                       'test_headings':list(HEADINGS[test_ind])
-+                       }
-+         kf_dataloaders.append(dataloaders)
-+ 
-++        if not config.cross_validate:
-++        	break
-++
-+     return kf_dataloaders
-+diff --git a/penn_dataset.py b/penn_dataset.py
-+index aa2f5a0..7f5a4fc 100644
-+--- a/penn_dataset.py
-++++ b/penn_dataset.py
-+@@ -15,6 +15,7 @@ from forge import flags
-+ # aspects of data managmement
-+ flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
-+ flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-++flags.DEFINE_boolean("cross_validate",False,"Do K-fold cross-validation")
-+ 
-+ # Job management
-+ # flags.DEFINE_integer("batch size",5,"training batch size")
-+@@ -109,15 +110,15 @@ def load(config):
-+         
-+         # set up training DataLoader
-+         train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, n_train),num_workers=0,shuffle = True)
-++        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
-+ 
-+         # set up test DataLoader
-+         test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, n_test),num_workers=0,shuffle = True)
-++        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
-+ 
-+         # set up val DataLoader
-+         val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-+-        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, n_val),num_workers=0,shuffle = True)
-++        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-+         
-+ 
-+         dataloaders = {'train':train_loader, 
-+@@ -125,8 +126,12 @@ def load(config):
-+                        'val':val_loader,
-+                        'train_inds':train_ind,
-+                        'test_inds':test_ind,
-+-                       'n_val':n_val
-++                       'n_val':n_val,
-++                       'test_headings':list(HEADINGS[test_ind])
-+                       }
-+         kf_dataloaders.append(dataloaders)
-+ 
-++        if not config.cross_validate:
-++        	break
-++
-+     return kf_dataloaders
-+diff --git a/testing.ipynb b/testing.ipynb
-+index e5a167b..a928d8d 100644
-+--- a/testing.ipynb
-++++ b/testing.ipynb
-+@@ -2,7 +2,7 @@
-+  "cells": [
-+   {
-+    "cell_type": "code",
-+-   "execution_count": 1,
-++   "execution_count": 2,
-+    "id": "4dee7ff1-01a4-4038-b493-9729ff3693f7",
-+    "metadata": {},
-+    "outputs": [],
-+@@ -23,19 +23,19 @@
-+   },
-+   {
-+    "cell_type": "code",
-+-   "execution_count": 2,
-++   "execution_count": 3,
-+    "id": "cad0fdc8-5c35-4610-bba3-b71e60dc1b98",
-+    "metadata": {},
-+    "outputs": [],
-+    "source": [
-+-    "flags.DEFINE_integer(\"batch_size\", 100, \"Mini-batch size.\")\n",
-++    "flags.DEFINE_integer(\"batch_size\", 10, \"Mini-batch size.\")\n",
-+     "\n",
-+     "flags.DEFINE_integer(\"input_size\",39,\"Input shape to model\")"
-+    ]
-+   },
-+   {
-+    "cell_type": "code",
-+-   "execution_count": 3,
-++   "execution_count": 4,
-+    "id": "ce1b936b-8a7c-426e-a3aa-3c1c38f645de",
-+    "metadata": {},
-+    "outputs": [
-+@@ -54,8 +54,8 @@
-+   },
-+   {
-+    "cell_type": "code",
-+-   "execution_count": 9,
-+-   "id": "e862b7e2-57f5-44bf-bcf1-a91160ba66cc",
-++   "execution_count": 5,
-++   "id": "4469cddf-4dac-4468-be88-241d440401c3",
-+    "metadata": {},
-+    "outputs": [
-+     {
-+@@ -67,35 +67,89 @@
-+     }
-+    ],
-+    "source": [
-+-    "model = fet.load(\"basic_feedforward.py\",config)"
-++    "model,modelname = fet.load(\"basic_feedforward.py\",config)"
-+    ]
-+   },
-+   {
-+    "cell_type": "code",
-+-   "execution_count": 10,
-+-   "id": "07e0b160-d5d1-4e54-b4a7-ccaf2224598a",
-++   "execution_count": 17,
-++   "id": "7c9a9fe9-f5e8-456a-b964-4be13027725b",
-+    "metadata": {},
-+    "outputs": [
-+     {
-+      "data": {
-+       "text/plain": [
-+-       "PerceptronNN(\n",
-+-       "  (fc1): Linear(in_features=39, out_features=128, bias=True)\n",
-+-       "  (fc2): Linear(in_features=128, out_features=64, bias=True)\n",
-+-       "  (fc3): Linear(in_features=64, out_features=64, bias=True)\n",
-+-       "  (fc4): Linear(in_features=64, out_features=2, bias=True)\n",
-+-       ")"
-++       "['aaa0060', 'aaa0061', 'aaa0069', 'aaa_0059']"
-+       ]
-+      },
-+-     "execution_count": 10,
-++     "execution_count": 17,
-+      "metadata": {},
-+      "output_type": "execute_result"
-+     }
-+    ],
-+    "source": [
-+-    "model"
-++    "loaddat[0]['test_headings']"
-++   ]
-++  },
-++  {
-++   "cell_type": "code",
-++   "execution_count": 19,
-++   "id": "e862b7e2-57f5-44bf-bcf1-a91160ba66cc",
-++   "metadata": {},
-++   "outputs": [
-++    {
-++     "name": "stdout",
-++     "output_type": "stream",
-++     "text": [
-++      "Keys: ['cross_entropy', 'time']\n"
-++     ]
-++    }
-++   ],
-++   "source": [
-++    "import h5py\n",
-++    "\n",
-++    "file_path = \"./checkpoints/feedforward/2/data_fold1/results_dict.h5\"\n",
-++    "# Replace 'your_file.h5' with the actual path to your file\n",
-++    "f =  h5py.File(file_path, 'r') \n",
-++    "\n",
-++    "    # Get information about the data stored in the file\n",
-++    "print(\"Keys:\", list(f.keys()))  # List the top-level datasets and groups\n",
-++    "\n",
-++    "    # # Access a dataset by its name\n",
-++    "    # dataset_name = \"your_dataset_name\"\n",
-++    "    # if dataset_name in f:\n",
-++    "    #     dataset = f[dataset_name]\n",
-++    "    #     print(\"Dataset shape:\", dataset.shape)\n",
-++    "    #     print(\"Dataset dtype:\", dataset.dtype)\n",
-++    "\n",
-++    "    #     # Access the data as a NumPy array\n",
-++    "    #     data = dataset[:]  # Read the entire dataset\n",
-++    "\n",
-++    "    #     # You can now work with the data as needed, for example:\n",
-++    "    #     # Perform calculations, visualizations, etc.\n",
-++    "    # else:\n",
-++    "    #     print(f\"Dataset '{dataset_name}' not found in the file.\")"
-+    ]
-+   },
-++  {
-++   "cell_type": "code",
-++   "execution_count": 13,
-++   "id": "07e0b160-d5d1-4e54-b4a7-ccaf2224598a",
-++   "metadata": {},
-++   "outputs": [
-++    {
-++     "data": {
-++      "text/plain": [
-++       "<generator object Module.parameters at 0x3007207b0>"
-++      ]
-++     },
-++     "execution_count": 13,
-++     "metadata": {},
-++     "output_type": "execute_result"
-++    }
-++   ],
-++   "source": []
-++  },
-+   {
-+    "cell_type": "code",
-+    "execution_count": null,
-+diff --git a/train.py b/train.py
-+index c266102..516bfa9 100644
-+--- a/train.py
-++++ b/train.py
-+@@ -1,49 +1,440 @@
-+ from os import path as osp
-++import os
-++import numpy as np
-++import time
-+ 
-+ import torch
-++import torch.nn as nn
-+ import torch.nn.functional as F
-+ import torch.optim as optim
-+-
-+-import numpy as np
-++from torch.utils.tensorboard import SummaryWriter
-+ 
-+ import forge
-+ from forge import flags
-+ import forge.experiment_tools as fet
-+ 
-++from train_tools import (
-++	log_tensorboard,
-++	parse_reports,
-++	parse_reports_cpu,
-++	print_reports,
-++	load_checkpoint,
-++	save_checkpoint,
-++	nested_to,
-++	param_count,
-++)
-++
-++from copy import deepcopy
-++from attrdict import AttrDict
-++import deepdish as dd
-++from tqdm import tqdm
-++
-++# For reproducibility while researching, but might affect speed!
-++torch.backends.cudnn.deterministic = True
-++torch.backends.cudnn.benchmark = False
-++torch.manual_seed(0)
-++
-+ 
-+ # Job config
-+ flags.DEFINE_string('data_config', 'penn_dataset.py',
-+-                    'Path to a data config file.')
-++					'Path to a data config file.')
-+ flags.DEFINE_string('model_config', 'basic_feedforward.py',
-+-                    'Path to a model config file.')
-++					'Path to a model config file.')
-+ flags.DEFINE_string('results_dir', 'checkpoints',
-+-                    'Top directory for all experimental results.')
-++					'Top directory for all experimental results.')
-+ flags.DEFINE_string('run_name', 'feedforward',
-+-                    'Name of this job and name of results folder.')
-++					'Name of this job and name of results folder.')
-+ flags.DEFINE_boolean('resume', False, 'Tries to resume a job if True.')
-+ 
-+ # Logging config
-+ flags.DEFINE_integer('report_loss_every', 50,
-+-                     'Number of iterations between reporting minibatch loss.')
-+-flags.DEFINE_integer('train_epochs', 20, 'Maximum number of training epochs.')
-++					 'Number of iterations between reporting minibatch loss.')
-++flags.DEFINE_integer('train_epochs', 100, 'Maximum number of training epochs.')
-++flags.DEFINE_integer(
-++	"save_check_points",
-++	50,
-++	"frequency with which to save checkpoints, in number of epoches.",
-++)
-++flags.DEFINE_boolean("log_train_values", True, "Logs train values if True.")
-++flags.DEFINE_integer(
-++	"total_evaluations",
-++	100,
-++	"Maximum number of evaluations on test and validation data during training.",
-++)
-++flags.DEFINE_boolean(
-++	"save_test_predictions",
-++	False,
-++	"Makes and saves test predictions on one or more test sets (e.g. 5-step and 100-step predictions) at the end of training.",
-++)
-++flags.DEFINE_boolean(
-++    "log_val_test", True, "Turns off computation of validation and test errors."
-++)
-+ 
-+ # Experiment config
-+ flags.DEFINE_integer('batch_size', 100, 'Mini-batch size.')
-+-flags.DEFINE_float('learning_rate', 1e-5, 'SGD learning rate.')
-++flags.DEFINE_float("learning_rate", 1e-4, "Adam learning rate.")
-++flags.DEFINE_float("beta1", 0.9, "Adam Beta 1 parameter")
-++flags.DEFINE_float("beta2", 0.999, "Adam Beta 2 parameter")
-+ 
-+ # Specific config options
-+ flags.DEFINE_integer("input_size",39,"Input shape to model")
-+ 
-++#########################################################################################
-++
-++def evaluate(model, loader, device,fold = 0,headings = [],loss_func = nn.CrossEntropyLoss()):
-++	reports = None
-++	for data in loader:
-++		labels = data['label']
-++		inputs = nested_to(data['data'],device,torch.float32)
-++		
-++		labels_tensor = torch.zeros((len(labels), 2))
-++		for i, label in enumerate(labels):
-++			labels_tensor[i, label] = 1
-++
-++		model_output = model(inputs) # evaluate model
-++
-++		loss = loss_func(model_output, labels_tensor) # compute loss
-++		outputs = AttrDict({"loss": loss, "prediction": model_output,'data_fold':fold})
-++		outputs.reports = AttrDict({"cross_entropy": loss})
-++
-++		if reports is None:
-++			reports = {k: v.detach().clone().cpu() for k, v in outputs.reports.items()}
-++		else:
-++			for k, v in outputs.reports.items():
-++				reports[k] += v.detach().clone().cpu()
-++
-++	for k, v in reports.items():
-++		reports[k] = v / len(
-++			loader
-++		)  # SZ: note this can be slightly incorrect if mini-batch sizes vary (if batch_size doesn't divide train_size), but approximately correct.
-++
-++	# reports['test_headings'] = np.array(headings)
-++
-++	return reports
-++
-++def main():
-++
-++	config = forge.config()
-++
-++	# Set device
-++	if torch.cuda.is_available():
-++		device = f"cuda:{config.device}"
-++		torch.cuda.set_device(device)
-++	else:
-++		device = "cpu" # can change this to MPS on M1 Macs
-++
-++	# Load data
-++	data_name = "penn_data"
-++	kfold_loaders = fet.load(config.data_config, config)
-++
-++	# Load model
-++	model,model_name = fet.load(config.model_config, config)
-++	model = model.to(device)
-++
-++	loss_func = nn.CrossEntropyLoss()
-++
-++	# Prepare environment
-++	params_in_run_name = [
-++		("batch_size", "bs"),
-++		("learning_rate", "lr"),
-++		("n_train", "ntrain")
-++	]
-++
-++	run_name = ""  # config.run_name
-++	for config_param in params_in_run_name:
-++		attr = config_param[0]
-++		abbrev = config_param[1]
-++
-++		if hasattr(config, attr):
-++			run_name += abbrev
-++			run_name += str(getattr(config, attr))
-++			run_name += "_"
-++
-++	results_folder_name = osp.join(
-++		data_name,
-++		model_name,
-++		config.run_name,
-++		run_name,
-++	)
-++
-++	# Prepare environment
-++	logdir = osp.join(config.results_dir, config.run_name)
-++	logdir, resume_checkpoint = fet.init_checkpoint(
-++		logdir, config.data_config, config.model_config, config.resume)
-++
-++	print("Checkpoint directory:",logdir)
-++
-++	# Print flags
-++	fet.print_flags()
-++	# Print model info
-++	print(model)
-++
-++	# Setup optimizer
-++	model_params = model.parameters()
-++	opt_learning_rate = config.learning_rate
-++	model_opt = torch.optim.Adam(
-++		model_params, lr=opt_learning_rate, betas=(config.beta1, config.beta2)
-++	)
-++	print("Model Optimizer:")
-++	print(model_opt)
-++
-++	# Try to restore model and optimizer from checkpoint
-++	if resume_checkpoint is not None:
-++		start_epoch = load_checkpoint(resume_checkpoint, model, model_opt)
-++	else:
-++		start_epoch = 1
-++
-++	n_folds = len(kfold_loaders)
-++	print("Doing {}-fold cross-validation.".format(n_folds))
-++
-++	# KFOLD TRAINING LOOP
-++	for k,loader_k in enumerate(kfold_loaders): # loop over data splits
-++
-++		print("Training fold {}...".format(k+1))
-++
-++		# load the training data
-++		train_loader = loader_k["train"]
-++		n_train = len(train_loader.dataset)
-++		train_batch_size = train_loader.batch_size
-++
-++		# load testing, validation
-++		test_loader = loader_k["test"]
-++		n_test = len(test_loader.dataset)
-++		val_loader = loader_k["val"]
-++		n_val = len(val_loader.dataset)
-++		
-++		# create folder for this data split
-++		fold_dir = osp.join(logdir,"data_fold{}".format(k+1))
-++		fold_dir_exists = osp.exists(fold_dir)
-++		if not fold_dir_exists:
-++			if config.resume:
-++				raise ValueError("Can't resume when the checkpoint/fold dir '{}' doesn't exist.".format(fold_dir))
-++			else:
-++				os.makedirs(fold_dir)
-++		checkpoint_name = osp.join(fold_dir, 'model_fold{}.ckpt'.format(k+1))
-++
-++		# keep track of which data is test data for a given Kfold data split
-++		test_headings = loader_k['test_headings']
-++		headingsFile = osp.join(fold_dir,"test_headings.txt")
-++		with open(headingsFile,'w') as headfile:
-++			for heading in test_headings:
-++				headfile.write(heading+'\n')
-++
-++		# print(checkpoint_name)
-++
-++		train_iter = (start_epoch - 1) * (
-++		len(train_loader.dataset) // train_batch_size
-++		) + 1
-++
-++		print("Starting training at epoch = {}, iter = {}".format(start_epoch, train_iter))
-++
-++		# Setup tensorboard writing
-++		summary_writer = SummaryWriter(logdir)
-++
-++		train_reports = []
-++		report_all = {}
-++		report_all_val = {}
-++
-++		# Saving model at epoch 0 before training
-++		print("saving model at epoch 0 before training ... ")
-++		save_checkpoint(checkpoint_name, 0, model, model_opt, loss=0.0)
-++		print("finished saving model at epoch 0 before training")
-++
-++		num_params = param_count(model)
-++		print(f"Number of model parameters: {num_params}")
-++
-++		# Training
-++		start_t = time.time()
-++
-++		total_train_iters = len(train_loader) * config.train_epochs
-++		iters_per_eval = max(1, int(total_train_iters / config.total_evaluations))
-++		# print('batch',train_batch_size)
-++		# print('ntrain',n_train)
-++		# assert (
-++		# 	n_train % min(train_batch_size, n_train) == 0
-++		# ), "Batch size doesn't divide dataset size. Can be inaccurate for loss computation (see below)."
-++
-++		training_failed = False
-++		best_val_loss_so_far = 1e7
-++
-++		for epoch in tqdm(range(start_epoch, config.train_epochs + 1)):
-++			model.train()
-++
-++			for batch_idx, data_dict in enumerate(train_loader): # Loop over batched data
-++
-++				labels = data_dict['label']
-++				data = data_dict['data']
-++
-++				# send data to device
-++				data = nested_to(data,device,torch.float32)
-++				# One-hot encode the data labels
-++				labels_tensor = torch.zeros((len(labels), 2))
-++				for i, label in enumerate(labels):
-++					labels_tensor[i, label] = 1
-++
-++				model_output = model(data) # evaluate model
-++
-++				loss = loss_func(model_output, labels_tensor) # compute loss
-++				outputs = AttrDict({"loss": loss, "prediction": model_output})
-++				outputs.reports = AttrDict({"cross_entropy": loss})
-++
-++				if torch.isnan(outputs.loss): # check for failure in training
-++					if not training_failed:
-++						epoch_of_nan = epoch
-++					if (epoch > epoch_of_nan + 1) and training_failed:
-++						raise ValueError("Loss Nan-ed.")
-++					training_failed = True
-++
-++				model_opt.zero_grad()
-++				outputs.loss.backward(retain_graph=False)
-++
-++				model_opt.step() # move optimizer forward
-++
-++				train_reports.append(parse_reports_cpu(outputs.reports))
-++
-++				if config.log_train_values:
-++					reports = parse_reports(outputs.reports)
-++					if batch_idx % config.report_loss_every == 0:
-++						log_tensorboard(summary_writer, train_iter, reports, "train/")
-++						print_reports(
-++							reports,
-++							start_t,
-++							epoch,
-++							batch_idx,
-++							len(train_loader.dataset) // train_batch_size,
-++							prefix="train",
-++						)
-++						log_tensorboard(
-++							summary_writer,
-++							train_iter,
-++							{"lr": model_opt.param_groups[0]["lr"]},
-++							"hyperparams/",
-++						)
-++				# Logging and evaluation
-++				if (
-++					train_iter % iters_per_eval == 0 or (train_iter == total_train_iters)
-++				) and config.log_val_test:  # batch_idx % config.evaluate_every == 0:
-++					model.eval()
-++					with torch.no_grad():
-++						reports = evaluate(model, test_loader, device,fold = k,headings = loader_k['test_headings'])
-++						# print("REPORTS",reports)
-++						reports = parse_reports(reports)
-++						reports["time"] = time.time() - start_t
-++						if report_all == {}:
-++							report_all = deepcopy(reports)
-++
-++							for d in reports.keys():
-++								report_all[d] = [report_all[d]]
-++						else:
-++							for d in reports.keys():
-++								report_all[d].append(reports[d])
-++
-++						log_tensorboard(summary_writer, train_iter, reports, "test/")
-++						print_reports(
-++							reports,
-++							start_t,
-++							epoch,
-++							batch_idx,
-++							len(train_loader.dataset) // config.batch_size,
-++							prefix="test",
-++						)
-++
-++						# repeat for validation data
-++						reports = evaluate(model, val_loader, device,fold = k,headings = loader_k['test_headings'])
-++						reports = parse_reports(reports)
-++						reports["time"] = time.time() - start_t
-++						if report_all_val == {}:
-++							report_all_val = deepcopy(reports)
-++
-++							for d in reports.keys():
-++								report_all_val[d] = [report_all_val[d]]
-++						else:
-++							for d in reports.keys():
-++								report_all_val[d].append(reports[d])
-++
-++						log_tensorboard(summary_writer, train_iter, reports, "val/")
-++						print_reports(
-++							reports,
-++							start_t,
-++							epoch,
-++							batch_idx,
-++							len(train_loader.dataset) // config.batch_size,
-++							prefix="val",
-++						)
-++
-++						if report_all_val["cross_entropy"][-1] < best_val_loss_so_far:
-++							save_checkpoint(
-++								checkpoint_name,
-++								f"early_stop",
-++								model,
-++								model_opt,
-++								loss=outputs.loss,
-++							)
-++							best_val_loss_so_far = report_all_val["cross_entropy"][-1]
-++
-++					model.train()
-++
-++				train_iter += 1
-++
-++			if epoch % config.save_check_points == 0:
-++				save_checkpoint(
-++					checkpoint_name, train_iter, model, model_opt, loss=outputs.loss
-++				)
-++
-++		dd.io.save(fold_dir + "/results_dict_train.h5", train_reports)
-++		dd.io.save(fold_dir + "/results_dict.h5", report_all)
-++		dd.io.save(fold_dir + "/results_dict_val.h5", report_all_val)
-++
-++	# always save final model
-++	save_checkpoint(checkpoint_name, train_iter, model, model_opt, loss=outputs.loss)
-++
-++	
-++	if config.save_test_predictions:
-++		pass
-++		# print("Starting to make model predictions on test sets for *final model*.")
-++		# for chunk_len in [5, 100]:
-++		#     start_t_preds = time.time()
-++		#     data_config = SimpleNamespace(
-++		#         **{
-++		#             **config.__dict__["__flags"],
-++		#             **{"chunk_len": chunk_len, "batch_size": 500},
-++		#         }
-++		#     )
-++		#     dataloaders, data_name = fet.load(config.data_config, config=data_config)
-++		#     test_loader_preds = dataloaders["test"]
-++
-++		#     torch.cuda.empty_cache()
-++		#     with torch.no_grad():
-++		#         preds = []
-++		#         true = []
-++		#         num_datapoints = 0
-++		#         for idx, d in enumerate(test_loader_preds):
-++		#             true.append(d[-1])
-++		#             d = nested_to(d, device, torch.float32)
-++		#             outputs = model(d)
-++
-++		#             pred_zs = outputs.prediction
-++		#             preds.append(pred_zs)
-++
-++		#             num_datapoints += len(pred_zs)
-++
-++		#             if num_datapoints >= 2000:
-++		#                 break
-+ 
-+-config = forge.config()
-++		#         preds = torch.cat(preds, dim=0).cpu()
-++		#         true = torch.cat(true, dim=0).cpu()
-+ 
-+-# Prepare environment
-+-logdir = osp.join(config.results_dir, config.run_name)
-+-logdir, resume_checkpoint = fet.init_checkpoint(
-+-    logdir, config.data_config, config.model_config, config.resume)
-+-checkpoint_name = osp.join(logdir, 'model.ckpt')
-++		#         save_dir = osp.join(logdir, f"traj_preds_{chunk_len}_steps_2k_test.pt")
-++		#         torch.save(preds, save_dir)
-+ 
-++		#         save_dir = osp.join(logdir, f"traj_true_{chunk_len}_steps_2k_test.pt")
-++		#         torch.save(true, save_dir)
-+ 
-+-print(logdir)
-++		#         print(
-++		#             f"Completed making test predictions for chunk_len = {chunk_len} in {time.time() - start_t_preds:.2f} seconds."
-++		#         )	
-++		
-+ 
-++if __name__ == "__main__":
-++	main()
-+ 
-diff --git a/checkpoints/feedforward/1/penn_dataset.py b/checkpoints/feedforward/1/penn_dataset.py
-index aa2f5a0..7f5a4fc 100644
---- a/checkpoints/feedforward/1/penn_dataset.py
-+++ b/checkpoints/feedforward/1/penn_dataset.py
-@@ -15,6 +15,7 @@ from forge import flags
- # aspects of data managmement
- flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
- flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-+flags.DEFINE_boolean("cross_validate",False,"Do K-fold cross-validation")
- 
- # Job management
- # flags.DEFINE_integer("batch size",5,"training batch size")
-@@ -109,15 +110,15 @@ def load(config):
-         
-         # set up training DataLoader
-         train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, n_train),num_workers=0,shuffle = True)
-+        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
- 
-         # set up test DataLoader
-         test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, n_test),num_workers=0,shuffle = True)
-+        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
- 
-         # set up val DataLoader
-         val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, n_val),num_workers=0,shuffle = True)
-+        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-         
- 
-         dataloaders = {'train':train_loader, 
-@@ -125,8 +126,12 @@ def load(config):
-                        'val':val_loader,
-                        'train_inds':train_ind,
-                        'test_inds':test_ind,
--                       'n_val':n_val
-+                       'n_val':n_val,
-+                       'test_headings':list(HEADINGS[test_ind])
-                       }
-         kf_dataloaders.append(dataloaders)
- 
-+        if not config.cross_validate:
-+        	break
-+
-     return kf_dataloaders
-diff --git a/georgehulsey_2024.pdf b/georgehulsey_2024.pdf
-deleted file mode 100644
-index 1ab17f6..0000000
-Binary files a/georgehulsey_2024.pdf and /dev/null differ
-diff --git a/penn_dataset.py b/penn_dataset.py
-index aa2f5a0..46c8e52 100644
---- a/penn_dataset.py
-+++ b/penn_dataset.py
-@@ -15,6 +15,7 @@ from forge import flags
- # aspects of data managmement
- flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
- flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-+flags.DEFINE_boolean("cross_validate",True,"Do K-fold cross-validation")
- 
- # Job management
- # flags.DEFINE_integer("batch size",5,"training batch size")
-@@ -109,15 +110,15 @@ def load(config):
-         
-         # set up training DataLoader
-         train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, n_train),num_workers=0,shuffle = True)
-+        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
- 
-         # set up test DataLoader
-         test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, n_test),num_workers=0,shuffle = True)
-+        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
- 
-         # set up val DataLoader
-         val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
--        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, n_val),num_workers=0,shuffle = True)
-+        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-         
- 
-         dataloaders = {'train':train_loader, 
-@@ -125,8 +126,12 @@ def load(config):
-                        'val':val_loader,
-                        'train_inds':train_ind,
-                        'test_inds':test_ind,
--                       'n_val':n_val
-+                       'n_val':n_val,
-+                       'test_headings':list(HEADINGS[test_ind])
-                       }
-         kf_dataloaders.append(dataloaders)
- 
-+        if not config.cross_validate:
-+        	break
-+
-     return kf_dataloaders
-diff --git a/testing.ipynb b/testing.ipynb
-index e5a167b..0110538 100644
---- a/testing.ipynb
-+++ b/testing.ipynb
-@@ -2,7 +2,7 @@
-  "cells": [
-   {
-    "cell_type": "code",
--   "execution_count": 1,
-+   "execution_count": 4,
-    "id": "4dee7ff1-01a4-4038-b493-9729ff3693f7",
-    "metadata": {},
-    "outputs": [],
-@@ -23,7 +23,7 @@
-   },
-   {
-    "cell_type": "code",
--   "execution_count": 2,
-+   "execution_count": 6,
-    "id": "cad0fdc8-5c35-4610-bba3-b71e60dc1b98",
-    "metadata": {},
-    "outputs": [],
-@@ -35,7 +35,7 @@
-   },
-   {
-    "cell_type": "code",
--   "execution_count": 3,
-+   "execution_count": 7,
-    "id": "ce1b936b-8a7c-426e-a3aa-3c1c38f645de",
-    "metadata": {},
-    "outputs": [
-@@ -54,8 +54,8 @@
-   },
-   {
-    "cell_type": "code",
--   "execution_count": 9,
--   "id": "e862b7e2-57f5-44bf-bcf1-a91160ba66cc",
-+   "execution_count": 5,
-+   "id": "4469cddf-4dac-4468-be88-241d440401c3",
-    "metadata": {},
-    "outputs": [
-     {
-@@ -67,35 +67,98 @@
-     }
-    ],
-    "source": [
--    "model = fet.load(\"basic_feedforward.py\",config)"
-+    "model,modelname = fet.load(\"basic_feedforward.py\",config)"
-    ]
-   },
-   {
-    "cell_type": "code",
--   "execution_count": 10,
--   "id": "07e0b160-d5d1-4e54-b4a7-ccaf2224598a",
-+   "execution_count": 13,
-+   "id": "7c9a9fe9-f5e8-456a-b964-4be13027725b",
-    "metadata": {},
-    "outputs": [
-     {
-      "data": {
-       "text/plain": [
--       "PerceptronNN(\n",
--       "  (fc1): Linear(in_features=39, out_features=128, bias=True)\n",
--       "  (fc2): Linear(in_features=128, out_features=64, bias=True)\n",
--       "  (fc3): Linear(in_features=64, out_features=64, bias=True)\n",
--       "  (fc4): Linear(in_features=64, out_features=2, bias=True)\n",
--       ")"
-+       "array([114170,    904])"
-       ]
-      },
--     "execution_count": 10,
-+     "execution_count": 13,
-      "metadata": {},
-      "output_type": "execute_result"
-     }
-    ],
-    "source": [
--    "model"
-+    "np.bincount(loaddat[0]['train'].dataset.all_labels)"
-    ]
-   },
-+  {
-+   "cell_type": "code",
-+   "execution_count": 1,
-+   "id": "e862b7e2-57f5-44bf-bcf1-a91160ba66cc",
-+   "metadata": {},
-+   "outputs": [
-+    {
-+     "ename": "FileNotFoundError",
-+     "evalue": "[Errno 2] Unable to open file (unable to open file: name = './checkpoints/feedforward/2/data_fold1/results_dict.h5', errno = 2, error message = 'No such file or directory', flags = 0, o_flags = 0)",
-+     "output_type": "error",
-+     "traceback": [
-+      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
-+      "\u001b[0;31mFileNotFoundError\u001b[0m                         Traceback (most recent call last)",
-+      "Cell \u001b[0;32mIn[1], line 5\u001b[0m\n\u001b[1;32m      3\u001b[0m file_path \u001b[38;5;241m=\u001b[39m \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124m./checkpoints/feedforward/2/data_fold1/results_dict.h5\u001b[39m\u001b[38;5;124m\"\u001b[39m\n\u001b[1;32m      4\u001b[0m \u001b[38;5;66;03m# Replace 'your_file.h5' with the actual path to your file\u001b[39;00m\n\u001b[0;32m----> 5\u001b[0m f \u001b[38;5;241m=\u001b[39m  \u001b[43mh5py\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mFile\u001b[49m\u001b[43m(\u001b[49m\u001b[43mfile_path\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[38;5;124;43mr\u001b[39;49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[43m)\u001b[49m \n\u001b[1;32m      7\u001b[0m     \u001b[38;5;66;03m# Get information about the data stored in the file\u001b[39;00m\n\u001b[1;32m      8\u001b[0m \u001b[38;5;28mprint\u001b[39m(\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mKeys:\u001b[39m\u001b[38;5;124m\"\u001b[39m, \u001b[38;5;28mlist\u001b[39m(f\u001b[38;5;241m.\u001b[39mkeys()))\n",
-+      "File \u001b[0;32m/Applications/miniconda3/envs/lietransformer/lib/python3.9/site-packages/h5py/_hl/files.py:562\u001b[0m, in \u001b[0;36mFile.__init__\u001b[0;34m(self, name, mode, driver, libver, userblock_size, swmr, rdcc_nslots, rdcc_nbytes, rdcc_w0, track_order, fs_strategy, fs_persist, fs_threshold, fs_page_size, page_buf_size, min_meta_keep, min_raw_keep, locking, alignment_threshold, alignment_interval, meta_block_size, **kwds)\u001b[0m\n\u001b[1;32m    553\u001b[0m     fapl \u001b[38;5;241m=\u001b[39m make_fapl(driver, libver, rdcc_nslots, rdcc_nbytes, rdcc_w0,\n\u001b[1;32m    554\u001b[0m                      locking, page_buf_size, min_meta_keep, min_raw_keep,\n\u001b[1;32m    555\u001b[0m                      alignment_threshold\u001b[38;5;241m=\u001b[39malignment_threshold,\n\u001b[1;32m    556\u001b[0m                      alignment_interval\u001b[38;5;241m=\u001b[39malignment_interval,\n\u001b[1;32m    557\u001b[0m                      meta_block_size\u001b[38;5;241m=\u001b[39mmeta_block_size,\n\u001b[1;32m    558\u001b[0m                      \u001b[38;5;241m*\u001b[39m\u001b[38;5;241m*\u001b[39mkwds)\n\u001b[1;32m    559\u001b[0m     fcpl \u001b[38;5;241m=\u001b[39m make_fcpl(track_order\u001b[38;5;241m=\u001b[39mtrack_order, fs_strategy\u001b[38;5;241m=\u001b[39mfs_strategy,\n\u001b[1;32m    560\u001b[0m                      fs_persist\u001b[38;5;241m=\u001b[39mfs_persist, fs_threshold\u001b[38;5;241m=\u001b[39mfs_threshold,\n\u001b[1;32m    561\u001b[0m                      fs_page_size\u001b[38;5;241m=\u001b[39mfs_page_size)\n\u001b[0;32m--> 562\u001b[0m     fid \u001b[38;5;241m=\u001b[39m \u001b[43mmake_fid\u001b[49m\u001b[43m(\u001b[49m\u001b[43mname\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mmode\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43muserblock_size\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mfapl\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mfcpl\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mswmr\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43mswmr\u001b[49m\u001b[43m)\u001b[49m\n\u001b[1;32m    564\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;28misinstance\u001b[39m(libver, \u001b[38;5;28mtuple\u001b[39m):\n\u001b[1;32m    565\u001b[0m     \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_libver \u001b[38;5;241m=\u001b[39m libver\n",
-+      "File \u001b[0;32m/Applications/miniconda3/envs/lietransformer/lib/python3.9/site-packages/h5py/_hl/files.py:235\u001b[0m, in \u001b[0;36mmake_fid\u001b[0;34m(name, mode, userblock_size, fapl, fcpl, swmr)\u001b[0m\n\u001b[1;32m    233\u001b[0m     \u001b[38;5;28;01mif\u001b[39;00m swmr \u001b[38;5;129;01mand\u001b[39;00m swmr_support:\n\u001b[1;32m    234\u001b[0m         flags \u001b[38;5;241m|\u001b[39m\u001b[38;5;241m=\u001b[39m h5f\u001b[38;5;241m.\u001b[39mACC_SWMR_READ\n\u001b[0;32m--> 235\u001b[0m     fid \u001b[38;5;241m=\u001b[39m \u001b[43mh5f\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mopen\u001b[49m\u001b[43m(\u001b[49m\u001b[43mname\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mflags\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mfapl\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43mfapl\u001b[49m\u001b[43m)\u001b[49m\n\u001b[1;32m    236\u001b[0m \u001b[38;5;28;01melif\u001b[39;00m mode \u001b[38;5;241m==\u001b[39m \u001b[38;5;124m'\u001b[39m\u001b[38;5;124mr+\u001b[39m\u001b[38;5;124m'\u001b[39m:\n\u001b[1;32m    237\u001b[0m     fid \u001b[38;5;241m=\u001b[39m h5f\u001b[38;5;241m.\u001b[39mopen(name, h5f\u001b[38;5;241m.\u001b[39mACC_RDWR, fapl\u001b[38;5;241m=\u001b[39mfapl)\n",
-+      "File \u001b[0;32mh5py/_objects.pyx:54\u001b[0m, in \u001b[0;36mh5py._objects.with_phil.wrapper\u001b[0;34m()\u001b[0m\n",
-+      "File \u001b[0;32mh5py/_objects.pyx:55\u001b[0m, in \u001b[0;36mh5py._objects.with_phil.wrapper\u001b[0;34m()\u001b[0m\n",
-+      "File \u001b[0;32mh5py/h5f.pyx:102\u001b[0m, in \u001b[0;36mh5py.h5f.open\u001b[0;34m()\u001b[0m\n",
-+      "\u001b[0;31mFileNotFoundError\u001b[0m: [Errno 2] Unable to open file (unable to open file: name = './checkpoints/feedforward/2/data_fold1/results_dict.h5', errno = 2, error message = 'No such file or directory', flags = 0, o_flags = 0)"
-+     ]
-+    }
-+   ],
-+   "source": [
-+    "import h5py\n",
-+    "\n",
-+    "file_path = \"./checkpoints/feedforward/2/data_fold1/results_dict.h5\"\n",
-+    "# Replace 'your_file.h5' with the actual path to your file\n",
-+    "f =  h5py.File(file_path, 'r') \n",
-+    "\n",
-+    "    # Get information about the data stored in the file\n",
-+    "print(\"Keys:\", list(f.keys()))  # List the top-level datasets and groups\n",
-+    "\n",
-+    "    # # Access a dataset by its name\n",
-+    "    # dataset_name = \"your_dataset_name\"\n",
-+    "    # if dataset_name in f:\n",
-+    "    #     dataset = f[dataset_name]\n",
-+    "    #     print(\"Dataset shape:\", dataset.shape)\n",
-+    "    #     print(\"Dataset dtype:\", dataset.dtype)\n",
-+    "\n",
-+    "    #     # Access the data as a NumPy array\n",
-+    "    #     data = dataset[:]  # Read the entire dataset\n",
-+    "\n",
-+    "    #     # You can now work with the data as needed, for example:\n",
-+    "    #     # Perform calculations, visualizations, etc.\n",
-+    "    # else:\n",
-+    "    #     print(f\"Dataset '{dataset_name}' not found in the file.\")"
-+   ]
-+  },
-+  {
-+   "cell_type": "code",
-+   "execution_count": 13,
-+   "id": "07e0b160-d5d1-4e54-b4a7-ccaf2224598a",
-+   "metadata": {},
-+   "outputs": [
-+    {
-+     "data": {
-+      "text/plain": [
-+       "<generator object Module.parameters at 0x3007207b0>"
-+      ]
-+     },
-+     "execution_count": 13,
-+     "metadata": {},
-+     "output_type": "execute_result"
-+    }
-+   ],
-+   "source": []
-+  },
-   {
-    "cell_type": "code",
-    "execution_count": null,
-diff --git a/train.py b/train.py
-index c266102..d389e88 100644
---- a/train.py
-+++ b/train.py
-@@ -1,49 +1,461 @@
- from os import path as osp
-+import os
-+import numpy as np
-+import time
- 
- import torch
-+import torch.nn as nn
- import torch.nn.functional as F
- import torch.optim as optim
--
--import numpy as np
-+from torch.utils.tensorboard import SummaryWriter
- 
- import forge
- from forge import flags
- import forge.experiment_tools as fet
- 
-+from train_tools import (
-+	log_tensorboard,
-+	parse_reports,
-+	parse_reports_cpu,
-+	print_reports,
-+	load_checkpoint,
-+	save_checkpoint,
-+	nested_to,
-+	param_count,
-+)
-+
-+from copy import deepcopy
-+from attrdict import AttrDict
-+import deepdish as dd
-+from tqdm import tqdm
-+
-+# For reproducibility while researching, but might affect speed!
-+torch.backends.cudnn.deterministic = True
-+torch.backends.cudnn.benchmark = False
-+torch.manual_seed(0)
-+
- 
- # Job config
- flags.DEFINE_string('data_config', 'penn_dataset.py',
--                    'Path to a data config file.')
-+					'Path to a data config file.')
- flags.DEFINE_string('model_config', 'basic_feedforward.py',
--                    'Path to a model config file.')
-+					'Path to a model config file.')
- flags.DEFINE_string('results_dir', 'checkpoints',
--                    'Top directory for all experimental results.')
--flags.DEFINE_string('run_name', 'feedforward',
--                    'Name of this job and name of results folder.')
-+					'Top directory for all experimental results.')
-+flags.DEFINE_string('model_name', 'gpt-FCNN',
-+					'shorthand name for model.')
-+flags.DEFINE_string('run_name', 'hyperparam_testing',
-+					'Name of this job and name of results folder.')
- flags.DEFINE_boolean('resume', False, 'Tries to resume a job if True.')
- 
- # Logging config
- flags.DEFINE_integer('report_loss_every', 50,
--                     'Number of iterations between reporting minibatch loss.')
--flags.DEFINE_integer('train_epochs', 20, 'Maximum number of training epochs.')
-+					 'Number of iterations between reporting minibatch loss.')
-+flags.DEFINE_integer('train_epochs', 75, 'Maximum number of training epochs.')
-+flags.DEFINE_integer(
-+	"save_check_points",
-+	50,
-+	"frequency with which to save checkpoints, in number of epoches.",
-+)
-+flags.DEFINE_boolean("log_train_values", True, "Logs train values if True.")
-+flags.DEFINE_integer(
-+	"total_evaluations",
-+	100,
-+	"Maximum number of evaluations on test and validation data during training.",
-+)
-+flags.DEFINE_boolean(
-+	"save_test_predictions",
-+	False,
-+	"Makes and saves test predictions on one or more test sets (e.g. 5-step and 100-step predictions) at the end of training.",
-+)
-+flags.DEFINE_boolean(
-+    "log_val_test", True, "Turns off computation of validation and test errors."
-+)
-+
-+flags.DEFINE_boolean('use_mps',False,"Use Metal Performance Shaders (M1) for training.")
- 
- # Experiment config
- flags.DEFINE_integer('batch_size', 100, 'Mini-batch size.')
--flags.DEFINE_float('learning_rate', 1e-5, 'SGD learning rate.')
-+flags.DEFINE_float("learning_rate", 1e-3, "Adam learning rate.")
-+flags.DEFINE_float("beta1", 0.9, "Adam Beta 1 parameter")
-+flags.DEFINE_float("beta2", 0.999, "Adam Beta 2 parameter")
- 
- # Specific config options
- flags.DEFINE_integer("input_size",39,"Input shape to model")
- 
-+#########################################################################################
-+
-+def evaluate(model, loader, device,fold = 0,headings = [],loss_func = nn.CrossEntropyLoss()):
-+	# this function does not account for class weights when evaluating cross-entropy loss.
-+	# however, they are accounted for when evaluating training loss
-+	reports = None
-+	for data in loader:
-+		labels = data['label']
-+		inputs = nested_to(data['data'],device,torch.float32)
-+		
-+		labels_tensor = torch.zeros((len(labels), 2))
-+		for i, label in enumerate(labels):
-+			labels_tensor[i, label] = 1
-+
-+		model_output = model(inputs) # evaluate model
-+
-+		loss = loss_func(model_output, labels_tensor) # compute loss
-+		outputs = AttrDict({"loss": loss, "prediction": model_output,'data_fold':fold})
-+		outputs.reports = AttrDict({"cross_entropy": loss})
-+
-+		if reports is None:
-+			reports = {k: v.detach().clone().cpu() for k, v in outputs.reports.items()}
-+		else:
-+			for k, v in outputs.reports.items():
-+				reports[k] += v.detach().clone().cpu()
-+
-+	for k, v in reports.items():
-+		reports[k] = v / len(
-+			loader
-+		)  # SZ: note this can be slightly incorrect if mini-batch sizes vary (if batch_size doesn't divide train_size), but approximately correct.
-+
-+	# reports['test_headings'] = np.array(headings)
-+
-+	return reports
-+
-+def main():
-+
-+	config = forge.config()
-+
-+	# Set device
-+	if torch.cuda.is_available():
-+		device = f"cuda:{config.device}"
-+		torch.cuda.set_device(device)
-+	else:
-+		device = "cpu" # can change this to MPS on M1 Macs
-+
-+	if config.use_mps:
-+		device = "mps"
-+
-+	# Load data
-+	data_name = "penn_data"
-+	kfold_loaders = fet.load(config.data_config, config)
-+
-+	# Prepare environment
-+	params_in_run_name = [
-+		("batch_size", "bs"),
-+		("learning_rate", "lr"),
-+		("n_train", "ntrain"),
-+		("include_coords",'inclx'),
-+		("input_size",'inpsize'),
-+		("cross_validate",'crval'),
-+		("train_epochs",'n_epochs'),
-+	]
-+
-+	run_name = ""  # config.run_name
-+	for config_param in params_in_run_name:
-+		attr = config_param[0]
-+		abbrev = config_param[1]
-+
-+		if hasattr(config, attr):
-+			run_name += abbrev
-+			run_name += str(getattr(config, attr))
-+			run_name += "_"
-+
-+	results_folder_name = osp.join(
-+		data_name,
-+		config.model_name,
-+		config.run_name,
-+		run_name,
-+	)
-+
-+	# Prepare environment
-+	logdir = osp.join(config.results_dir, results_folder_name.replace(".", "_"))
-+	logdir, resume_checkpoint = fet.init_checkpoint(
-+		logdir, config.data_config, config.model_config, config.resume)
-+
-+	print("Checkpoint directory:",logdir)
-+
-+	# Print flags
-+	fet.print_flags()
-+
-+	n_folds = len(kfold_loaders)
-+	print("Doing {}-fold cross-validation.".format(n_folds))
-+
-+	# KFOLD TRAINING LOOP
-+	for k,loader_k in enumerate(kfold_loaders): # loop over data splits
-+
-+		print("Training fold {}...".format(k+1))
-+
-+		# Load model
-+		model,model_name = fet.load(config.model_config, config)
-+		model = model.to(device)
-+
-+		# Print model info
-+		print(model)
-+
-+		# Setup optimizer
-+		model_params = model.parameters()
-+		opt_learning_rate = config.learning_rate
-+		model_opt = torch.optim.Adam(
-+			model_params, lr=opt_learning_rate, betas=(config.beta1, config.beta2)
-+		)
-+		scheduler = torch.optim.lr_scheduler.StepLR(model_opt, step_size=10, gamma=0.5)
-+		print("Model Optimizer:")
-+		print(model_opt)
-+
-+		# Try to restore model and optimizer from checkpoint
-+		if resume_checkpoint is not None:
-+			start_epoch = load_checkpoint(resume_checkpoint, model, model_opt)
-+		else:
-+			start_epoch = 1
-+
-+		# load the training data
-+		train_loader = loader_k["train"]
-+		n_train = len(train_loader.dataset)
-+		train_batch_size = train_loader.batch_size
-+
-+		# load testing, validation
-+		test_loader = loader_k["test"]
-+		n_test = len(test_loader.dataset)
-+		val_loader = loader_k["val"]
-+		n_val = len(val_loader.dataset)
-+
-+		train_class_counts = np.bincount(train_loader.dataset.all_labels)
-+		train_total_counts = sum(train_class_counts)
-+		class_weight = torch.tensor(1.0 / train_class_counts) * train_total_counts / 2.0
-+
-+		loss_func = nn.CrossEntropyLoss(weight = class_weight) # define reweighted loss function
-+				
-+		# create folder for this data split
-+		fold_dir = osp.join(logdir,"data_fold{}".format(k+1))
-+		fold_dir_exists = osp.exists(fold_dir)
-+		if not fold_dir_exists:
-+			if config.resume:
-+				raise ValueError("Can't resume when the checkpoint/fold dir '{}' doesn't exist.".format(fold_dir))
-+			else:
-+				os.makedirs(fold_dir)
-+		checkpoint_name = osp.join(fold_dir, 'model_fold{}.ckpt'.format(k+1))
-+
-+		# keep track of which data is test data for a given Kfold data split
-+		test_headings = loader_k['test_headings']
-+		headingsFile = osp.join(fold_dir,"test_headings.txt")
-+		with open(headingsFile,'w') as headfile:
-+			for heading in test_headings:
-+				headfile.write(heading+'\n')
-+
-+		# print(checkpoint_name)
-+
-+		train_iter = (start_epoch - 1) * (
-+		len(train_loader.dataset) // train_batch_size
-+		) + 1
-+
-+		print("Starting training at epoch = {}, iter = {}".format(start_epoch, train_iter))
-+
-+		# Setup tensorboard writing
-+		summary_writer = SummaryWriter(logdir)
-+
-+		train_reports = []
-+		report_all = {}
-+		report_all_val = {}
-+
-+		# Saving model at epoch 0 before training
-+		print("saving model at epoch 0 before training ... ")
-+		save_checkpoint(checkpoint_name, 0, model, model_opt, loss=0.0)
-+		print("finished saving model at epoch 0 before training")
-+
-+		num_params = param_count(model)
-+		print(f"Number of model parameters: {num_params}")
-+
-+		# Training
-+		start_t = time.time()
-+
-+		total_train_iters = len(train_loader) * config.train_epochs
-+		iters_per_eval = max(1, int(total_train_iters / config.total_evaluations))
-+		# print('batch',train_batch_size)
-+		# print('ntrain',n_train)
-+		# assert (
-+		# 	n_train % min(train_batch_size, n_train) == 0
-+		# ), "Batch size doesn't divide dataset size. Can be inaccurate for loss computation (see below)."
-+
-+		training_failed = False
-+		best_val_loss_so_far = 1e7
-+
-+		for epoch in tqdm(range(start_epoch, config.train_epochs + 1)):
-+			model.train()
-+
-+			for batch_idx, data_dict in enumerate(train_loader): # Loop over batched data
-+
-+				labels = data_dict['label']
-+				data = data_dict['data']
-+
-+				# send data to device
-+				data = nested_to(data,device,torch.float32)
-+				# One-hot encode the data labels
-+				labels_tensor = torch.zeros((len(labels), 2))
-+				for i, label in enumerate(labels):
-+					labels_tensor[i, label] = 1
-+
-+				model_output = model(data) # evaluate model
-+
-+				loss = loss_func(model_output, labels_tensor) # compute loss
-+				outputs = AttrDict({"loss": loss, "prediction": model_output})
-+				outputs.reports = AttrDict({"cross_entropy": loss})
-+
-+				if torch.isnan(outputs.loss): # check for failure in training
-+					if not training_failed:
-+						epoch_of_nan = epoch
-+					if (epoch > epoch_of_nan + 1) and training_failed:
-+						raise ValueError("Loss Nan-ed.")
-+					training_failed = True
-+
-+				model_opt.zero_grad()
-+				outputs.loss.backward(retain_graph=False)
-+
-+				model_opt.step() # move optimizer forward
-+
-+				train_reports.append(parse_reports_cpu(outputs.reports))
-+
-+				if config.log_train_values:
-+					reports = parse_reports(outputs.reports)
-+					if batch_idx % config.report_loss_every == 0:
-+						log_tensorboard(summary_writer, train_iter, reports, "train/")
-+						print_reports(
-+							reports,
-+							start_t,
-+							epoch,
-+							batch_idx,
-+							len(train_loader.dataset) // train_batch_size,
-+							prefix="train",
-+						)
-+						log_tensorboard(
-+							summary_writer,
-+							train_iter,
-+							{"lr": model_opt.param_groups[0]["lr"]},
-+							"hyperparams/",
-+						)
-+				# Logging and evaluation
-+				if (
-+					train_iter % iters_per_eval == 0 or (train_iter == total_train_iters)
-+				) and config.log_val_test:  # batch_idx % config.evaluate_every == 0:
-+					model.eval()
-+					with torch.no_grad():
-+						reports = evaluate(model, test_loader, device,fold = k,headings = loader_k['test_headings'])
-+						# print("REPORTS",reports)
-+						reports = parse_reports(reports)
-+						reports["time"] = time.time() - start_t
-+						if report_all == {}:
-+							report_all = deepcopy(reports)
-+
-+							for d in reports.keys():
-+								report_all[d] = [report_all[d]]
-+						else:
-+							for d in reports.keys():
-+								report_all[d].append(reports[d])
-+
-+						log_tensorboard(summary_writer, train_iter, reports, "test/")
-+						print_reports(
-+							reports,
-+							start_t,
-+							epoch,
-+							batch_idx,
-+							len(train_loader.dataset) // config.batch_size,
-+							prefix="test",
-+						)
-+
-+						# repeat for validation data
-+						reports = evaluate(model, val_loader, device,fold = k,headings = loader_k['test_headings'])
-+						reports = parse_reports(reports)
-+						reports["time"] = time.time() - start_t
-+						if report_all_val == {}:
-+							report_all_val = deepcopy(reports)
-+
-+							for d in reports.keys():
-+								report_all_val[d] = [report_all_val[d]]
-+						else:
-+							for d in reports.keys():
-+								report_all_val[d].append(reports[d])
-+
-+						log_tensorboard(summary_writer, train_iter, reports, "val/")
-+						print_reports(
-+							reports,
-+							start_t,
-+							epoch,
-+							batch_idx,
-+							len(train_loader.dataset) // config.batch_size,
-+							prefix="val",
-+						)
-+
-+						if report_all_val["cross_entropy"][-1] < best_val_loss_so_far:
-+							save_checkpoint(
-+								checkpoint_name,
-+								f"early_stop",
-+								model,
-+								model_opt,
-+								loss=outputs.loss,
-+							)
-+							best_val_loss_so_far = report_all_val["cross_entropy"][-1]
-+
-+					model.train()
-+
-+				train_iter += 1
-+
-+			scheduler.step()
-+
-+			if epoch % config.save_check_points == 0:
-+				save_checkpoint(
-+					checkpoint_name, train_iter, model, model_opt, loss=outputs.loss
-+				)
-+		
-+		dd.io.save(fold_dir + "/results_dict_train.h5", train_reports)
-+		dd.io.save(fold_dir + "/results_dict.h5", report_all)
-+		dd.io.save(fold_dir + "/results_dict_val.h5", report_all_val)
-+
-+	# always save final model
-+	save_checkpoint(checkpoint_name, train_iter, model, model_opt, loss=outputs.loss)
-+
-+	
-+	if config.save_test_predictions:
-+		pass
-+		# print("Starting to make model predictions on test sets for *final model*.")
-+		# for chunk_len in [5, 100]:
-+		#     start_t_preds = time.time()
-+		#     data_config = SimpleNamespace(
-+		#         **{
-+		#             **config.__dict__["__flags"],
-+		#             **{"chunk_len": chunk_len, "batch_size": 500},
-+		#         }
-+		#     )
-+		#     dataloaders, data_name = fet.load(config.data_config, config=data_config)
-+		#     test_loader_preds = dataloaders["test"]
-+
-+		#     torch.cuda.empty_cache()
-+		#     with torch.no_grad():
-+		#         preds = []
-+		#         true = []
-+		#         num_datapoints = 0
-+		#         for idx, d in enumerate(test_loader_preds):
-+		#             true.append(d[-1])
-+		#             d = nested_to(d, device, torch.float32)
-+		#             outputs = model(d)
-+
-+		#             pred_zs = outputs.prediction
-+		#             preds.append(pred_zs)
-+
-+		#             num_datapoints += len(pred_zs)
-+
-+		#             if num_datapoints >= 2000:
-+		#                 break
- 
--config = forge.config()
-+		#         preds = torch.cat(preds, dim=0).cpu()
-+		#         true = torch.cat(true, dim=0).cpu()
- 
--# Prepare environment
--logdir = osp.join(config.results_dir, config.run_name)
--logdir, resume_checkpoint = fet.init_checkpoint(
--    logdir, config.data_config, config.model_config, config.resume)
--checkpoint_name = osp.join(logdir, 'model.ckpt')
-+		#         save_dir = osp.join(logdir, f"traj_preds_{chunk_len}_steps_2k_test.pt")
-+		#         torch.save(preds, save_dir)
- 
-+		#         save_dir = osp.join(logdir, f"traj_true_{chunk_len}_steps_2k_test.pt")
-+		#         torch.save(true, save_dir)
- 
--print(logdir)
-+		#         print(
-+		#             f"Completed making test predictions for chunk_len = {chunk_len} in {time.time() - start_t_preds:.2f} seconds."
-+		#         )	
-+		
- 
-+if __name__ == "__main__":
-+	main()
- 
diff --git a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/penn_dataset.py b/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/penn_dataset.py
deleted file mode 100644
index 46c8e52..0000000
--- a/checkpoints/penn_data/gpt-FCNN/hyperparam_testing/bs100_lr0_001_inclxFalse_inpsize39_crvalTrue_n_epochs75_/2/penn_dataset.py
+++ /dev/null
@@ -1,137 +0,0 @@
-import os
-import torch
-import pandas as pd
-import numpy as np
-
-from torchvision import datasets, transforms
-from torch.utils.data import Dataset, DataLoader
-from sklearn.model_selection import RepeatedKFold
-
-from os import path as osp
-import forge
-from forge import flags
-
-
-# aspects of data managmement
-flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
-flags.DEFINE_boolean("rescale", True, "Rescales intensities")
-flags.DEFINE_boolean("cross_validate",True,"Do K-fold cross-validation")
-
-# Job management
-# flags.DEFINE_integer("batch size",5,"training batch size")
-flags.DEFINE_float("train_split",0.8,'Fraction of data to use for training.')
-flags.DEFINE_integer("n_repeats",1,"Times to repeat K-fold cross-validation")
-flags.DEFINE_integer("split_seed",1,"Seed for KFold split (integer for reproducibility")
-
-# "wavelengths between 0.05 and 1 mm in 0.025 mm increments."
-LSPACE = np.arange(0.05,1.05,0.025) # corresponds to 39 non-coord columns of data
-L_INDS = None
-
-DATAFOLDER = './penn_data'
-
-HEADINGS = np.array(['aaa0043','aaa0044','aaa0060','aaa0061','aaa0063','aaa0064','aaa0066','aaa0069','aaa0086','aaa0087','aaa_0051','aaa_0053','aaa_0054','aaa_0059','aaa_0071','aaa_0072'])
-
-
-class PennData(Dataset):
-
-    def __init__(self,path_to_data,headings,k_inds = None,include_coords = True,rescale = True,spectra_prefix = "kvals_fuse_rotate_",label_prefix = 'labels_fuse_rotate_'):
-        
-        self.data_dir = path_to_data
-        self.headings = headings
-
-        df_list = []
-        label_list = []
-        for heading in self.headings: # for each datafile heading,
-            data_name = osp.join(self.data_dir,spectra_prefix + heading+'.csv') # read kvals
-            df_temp = pd.read_csv(data_name,header=None)
-            df_list.append(df_temp)
-
-            label_name = osp.join(self.data_dir,label_prefix + heading + '.csv') # read labels
-            label_temp = pd.read_csv(label_name,header=None, names=['label'])
-            label_list.append(label_temp)
-
-        df = pd.concat(df_list, ignore_index=True)
-
-        labels = pd.concat(label_list, ignore_index=True)
-        df = pd.concat([labels, df], axis="columns") # Append labels to data
-
-        all_labels = df['label'].to_numpy()
-        all_data = df.iloc[:,1:].to_numpy()
-
-        if rescale: # rescale (normalize) wavelength intensity data
-            lambdas = all_data[:,2:] # wavelengths
-            lam_std = np.std(lambdas, axis=0)  # Calculate standard deviation along columns
-            lam_mean = np.mean(lambdas, axis=0)  # Calculate mean along columns
-            lambdas_rescaled = (lambdas - lam_mean) / lam_std 
-            all_data[:,2:] = lambdas_rescaled
-
-        if not include_coords: # removes x,y coordinates from data
-            all_data = all_data[:,2:]
-        
-        if k_inds != None: # in this case, only use subset of wavelengths
-            all_data = all_data[:,np.array(k_inds)]
-
-        self.all_data = all_data
-        self.all_labels = all_labels
-
-    def __len__(self):
-        return len(self.all_data)
-
-    def __getitem__(self,i):
-        state = {'label':self.all_labels[i],'data':self.all_data[i]}
-        return state
-
-    def __getstate__(self):
-        state = {
-            'data': self.all_data,
-            'label': self.all_labels,
-                }
-        return state
-
-    def __setstate__(self, state):
-        # Set the object's state from the provided dictionary
-        self.all_data = state['data']
-        self.all_labels = state['label']
-        
-
-
-def load(config):
-
-    n_splits = int(len(HEADINGS)/((1-config.train_split)*len(HEADINGS)))
-
-    kf = RepeatedKFold(n_splits = n_splits, n_repeats = config.n_repeats, random_state = config.split_seed) # K-fold cross validation
-
-    kf_dataloaders = []
-
-    for i, (train_ind, test_ind) in enumerate(kf.split(HEADINGS)): # for each K-fold split, 
-        n_val = len(test_ind)//2
-        n_test = len(test_ind)-n_val   
-        n_train = len(train_ind)
-        
-        # set up training DataLoader
-        train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-        train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
-
-        # set up test DataLoader
-        test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-        test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
-
-        # set up val DataLoader
-        val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-        val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
-        
-
-        dataloaders = {'train':train_loader, 
-                       'test':test_loader,
-                       'val':val_loader,
-                       'train_inds':train_ind,
-                       'test_inds':test_ind,
-                       'n_val':n_val,
-                       'test_headings':list(HEADINGS[test_ind])
-                      }
-        kf_dataloaders.append(dataloaders)
-
-        if not config.cross_validate:
-        	break
-
-    return kf_dataloaders
diff --git a/eval_tools.py b/eval_tools.py
index b09c950..9012aa5 100644
--- a/eval_tools.py
+++ b/eval_tools.py
@@ -1,5 +1,6 @@
 import torch
 import numpy as np
+np.object = object # weird deprecation in current numpy version
 import json
 import torch.nn.functional as F
 import deepdish as dd
@@ -12,6 +13,7 @@ from os import path as osp
 import os
 import re
 import h5py
+from tqdm import tqdm
 
 import forge
 from forge import flags
@@ -20,13 +22,17 @@ from forge import load_from_checkpoint
 from attrdict import AttrDict
 
 from train_tools import param_count,nested_to
+from scipy.interpolate import interp1d
+from scipy.ndimage import uniform_filter1d
+
+from backbones_unet.model.losses import focal_loss
 
 ###########################################################################
-# Binary classification functions
+# Binary classification functions and others
 
 def get_acc(arr): # get accuracy of set of confusion matrices
     # arr.shape (n_thresholds,2,2)
-    return np.array([(x[1,1] + x[0,0])/(x[0,0] + x[0,1] + x[1,0] + x[1,1]) if (x[0,0] + x[0,1] + x[1,0] + x[1,1]) else 0 for x in arr])
+    return np.array([(x[1,1] + x[0,0])/(x[0,0] + x[0,1] + x[1,0] + x[1,1]) if (x[0,0] + x[0,1] + x[1,0] + x[1,1])>0 else 0 for x in arr])
 
 def get_prec(arr): # get precision of set of confusion matrices
     # arr.shape (n_thresholds,2,2)
@@ -44,11 +50,13 @@ def get_F1(arr): # get F1-score of set of confusion matrices
     # arr.shape (n_thresholds,2,2)
     return np.array([2*x[1,1]/(2*x[1,1] + x[0,1] + x[1,0]) if (2*x[1,1] + x[0,1] + x[1,0]) > 0 else 0 for x in arr])
 
+def moving_average(data, window_size):
+    return uniform_filter1d(data, size=window_size, mode='nearest')
 
 ###########################################################################
 # Main function for extracting metrics from a model run
 
-def get_metrics(run_dir,n_thresholds =100,checkpoint_num = None,softmax = True,nonlin_thresholds = False):
+def get_metrics(run_dir,n_thresholds =100,checkpoint_num = None,softmax = True,nonlin_thresholds = False,write_file = True,read_file = True):
     # run directory should contain folders 1,2,3... 
     if nonlin_thresholds:
         num_elements = n_thresholds
@@ -77,6 +85,12 @@ def get_metrics(run_dir,n_thresholds =100,checkpoint_num = None,softmax = True,n
 
     working_dir = osp.join(run_dir,str(checkpoint_num))
     print("Getting metrics from",working_dir)
+    metrics_fname = osp.join(working_dir,'metrics.h5')
+
+    if osp.exists(metrics_fname) and read_file: # check if metrics file exists and read metrics
+        print("Found info file, reading from from file.")
+        return dd.io.load(metrics_fname)
+    
     flag_file = osp.join(working_dir,'flags.json')
     with open(flag_file, 'r') as file:
         flag_info = json.load(file)
@@ -92,7 +106,7 @@ def get_metrics(run_dir,n_thresholds =100,checkpoint_num = None,softmax = True,n
     model,model_name = fet.load(model_config,config)
 
     # load data
-    kfold_loaders = fet.load(data_config, config)
+    kfold_loaders,k_inds = fet.load(data_config, config)
     nfolds = len(kfold_loaders)
     print("Data is {}-fold partitioned.".format(nfolds))
 
@@ -143,35 +157,52 @@ def get_metrics(run_dir,n_thresholds =100,checkpoint_num = None,softmax = True,n
         model.load_state_dict(model_wts['model_state_dict'])
         model.eval()
 
-        # set up model to make binary int class predictions from logit output
-        # def model_preds(x,threshold = 0.5,softmax = True):
-        #     if softmax:
-        #         probs = np.array(F.softmax(model(x),dim=1))
-        #     else:
-        #         probs = np.array(model(x))
-        #     print(probs[:,1])
-        #     preds = np.zeros(len(probs),dtype = int)
-        #     preds[probs[:,1] > threshold] = 1 # CONFUSED ABOUT DIRECTION OF THIS INEQ
-        #     return torch.tensor(preds)
-
         for subset in conf_mats.keys(): # loop over train,test,val data subsets
             print("in subset",subset)
             loader = loader_dict[subset] # specific dataloader
-            
-            all_labels = torch.tensor(loader.dataset.labels) # all predictions
-            # print('truelabels counts',np.bincount(all_labels))
-            all_data = torch.tensor(loader.dataset.data).float() # all inputs
 
-            with torch.no_grad():
-                if softmax:
-                    probs = np.array(F.softmax(model(all_data),dim=1))
+            # evaluate model with batched data
+            all_labels = []
+            probs = []
+            for dset in tqdm(loader):
+                all_labels.append(dset['label'])
+                batch_data = dset['data'].float()
+                if config.include_coords:
+                    batch_coords = dset['coords'].float()
+                    model_input = {'data':batch_data,'coords':batch_coords}
                 else:
-                    probs = np.array(model(all_data))
+                    model_input = {'data':batch_data}#batch_data
+
+                with torch.no_grad():
+                    if softmax:
+                        batch_probs = F.softmax(model(model_input),dim=1)
+                    else:
+                        batch_probs = model(model_input)
+                probs.append(batch_probs)
 
+            all_labels = torch.cat(all_labels,dim = 0)
+            probs = np.array(torch.cat(probs,dim = 0))
+            
+            # all_labels = torch.tensor(loader.dataset.labels) # all predictions
+            # # print('truelabels counts',np.bincount(all_labels))
+            # all_data = torch.tensor(loader.dataset.data).float() # all inputs
+
+            # if config.include_coords:
+            #     model_input = {'data':all_data,'coords':torch.tensor(loader.dataset.coords).float()}
+            # else:
+            #     model_input = all_data
+            # return model_input, model
+            # with torch.no_grad():
+            #     if softmax:
+            #         print('attempting to evaluated mode')
+            #         probs = np.array(F.softmax(model(model_input),dim=1))
+            #     else:
+            #         probs = np.array(model(model_input))
+
+            print("model evaluated.")
             for ii,t in enumerate(thresholds): # for all classification thresholds,
                  # make binary predicitions at this threshold,
-                    # print('threshold',t)
-                    # all_preds = model_preds(all_data,threshold = t)
+                    
                 all_preds = np.zeros(len(probs),dtype = int)
                 
                 all_preds[probs[:,1] > t] = 1 # as threshold increases, fewer positives (FPR-> 0)
@@ -198,7 +229,10 @@ def get_metrics(run_dir,n_thresholds =100,checkpoint_num = None,softmax = True,n
     interpolated_y_values = np.array([interp1d(x, y, bounds_error=False, fill_value='extrapolate')(common_t) for x, y in zip(test_times, test_losses)])
     average_loss = np.mean(interpolated_y_values, axis=0)
     
-    results['avg_loss'] = (common_t,average_loss)
+    results['avg_test_loss'] = (common_t,average_loss)
+    
+    # common_iter = 
+    # results['avg_train_loss']
     
     print("Models evaluated. Computing metrics...")
     for subset in conf_mats.keys(): # for train, test, val
@@ -214,28 +248,223 @@ def get_metrics(run_dir,n_thresholds =100,checkpoint_num = None,softmax = True,n
         results[subset+'_fpr'] = get_fpr(thresh_mats)
         # compute F1 score
         results[subset+'_F1'] = get_F1(thresh_mats)
+
+    if write_file:
+        fname = osp.join(working_dir,'metrics.h5')
+        print("Writing metrics to file",fname)
+        dd.io.save(fname,results)
+        
     print("Done.")
     return results
 
+
+def quadPlot(elem,losses,model,test_loader,class_pred = 1,name = 'Model'):# plot everything
+    fig, ax = plt.subplots(2, 2, figsize=(10, 10))  
+    # plot loss 
+    for case in ['train','test']:
+        ax[0,0].plot(losses['{}_loss'.format(case)],label = case)
+    ax[0,0].set_xlabel('epoch')
+    ax[0,0].set_ylabel('focal loss')
+    ax[0,0].set_yscale('log')
+    ax[0,0].set_title(name + ' loss vs epochs')
+    ax[0,0].legend()
+    
+    # plot spatial loss
+    ex_data,ex_labels = next(iter(test_loader))
+    preds = model.predict(ex_data).cpu()
+    loss = focal_loss(preds,ex_labels,gamma = 10,alpha = 2,spatial = True)
+    loss = loss.sum(dim = 1)
+    im = ax[0,1].imshow(loss[elem])
+    fig.colorbar(im, orientation='vertical')
+    ax[0,1].axis('off')
+    ax[0,1].set_title("Spatial loss on batch elem {}".format(elem))
+    
+    single_pred = preds[elem,...]
+    single_true = ex_labels[elem,...]
+    probs = torch.nn.functional.softmax(single_pred,dim = 0)
+    # _, predicted_labels = torch.max(probs[:1], dim=0)
+    predicted_labels = probs[class_pred,...]
+    im3 = ax[1,0].imshow(single_true)
+    ax[1,0].axis('off')
+    ax[1,0].set_title("Ground truth")
+    im2 = ax[1,1].imshow(predicted_labels,cmap = 'jet')  # You can change 'gray' to another colormap
+    ax[1,1].set_title('Predictions (class = {})'.format(class_pred) ) # Set title for the first image
+    ax[1,1].axis('off')
+    fig.colorbar(im2)
+    fig.colorbar(im3)
+
+def getImgMetrics(model,train_loader,test_loader,n_thresholds = 1000,mps = False):
+    conf_shape = (n_thresholds,2,2)
+    # list of confusion matrices (nfolds,n_thresholds)
+    conf_mats = {'train':np.zeros(conf_shape),
+                 'test':np.zeros(conf_shape)}
+    if mps:
+    	model = model.to('mps')
+    thresholds = np.linspace(1e-8,1,n_thresholds)
+    BCM = BinaryConfusionMatrix()
+    loader_dict = {'train':train_loader,'test':test_loader}
+    results = {'thresholds':thresholds}
+    for subset in conf_mats.keys():
+        loader = loader_dict[subset] # specific dataloader
+        all_labels = []
+        probs = []
+        for (data,labels) in tqdm(loader):
+            labels = torch.flatten(labels,start_dim = 1)
+            all_labels.append(labels)
+            inputs = data.float()
+            if mps: inputs = inputs.to('mps')
+            preds = model.predict(inputs).cpu()
+            batch_probs = torch.flatten(F.softmax(preds, dim = 1),start_dim = 2)
+            # print('bp',batch_probs.shape)
+            probs.append(batch_probs)
+        all_labels = torch.flatten(torch.cat(all_labels,dim = 0))
+        probs = torch.flatten(torch.cat(probs,dim = 0).permute(1,0,2),start_dim = 1).permute(1,0)
+
+        for ii,t in enumerate(thresholds): # for all classification thresholds,
+             # make binary predicitions at this threshold,    
+            all_preds = np.zeros(len(probs),dtype = int)
+            all_preds[probs[:,1] > t] = 1 # as threshold increases, fewer positives (FPR-> 0)
+            all_preds = torch.tensor(all_preds)
+            # compute confusion matrix
+            binary_confusion_matrix = np.array(BCM(all_preds,all_labels),dtype = int)
+            # record confusion matrix
+            conf_mats[subset][ii] = binary_confusion_matrix
+            
+    for subset in conf_mats.keys(): # for train, test, val
+        thresh_mats = conf_mats[subset] # sum confusion matrices over data folds
+        # compute accuracy
+        results[subset+'_acc'] = get_acc(thresh_mats)
+        # compute precision
+        results[subset+'_prec'] = get_prec(thresh_mats)
+        # compute TPR
+        results[subset+'_tpr'] = get_tpr(thresh_mats)
+        # compute FPR
+        results[subset+'_fpr'] = get_fpr(thresh_mats)
+        # compute F1 score
+        results[subset+'_F1'] = get_F1(thresh_mats)
+
+    return results
+
+def metricsPlot(run_info,model_name = None,savefile = False):
+    fig, ax = plt.subplots(2, 2, figsize=(10, 10))
+    fig.suptitle("Model: {} classifier metrics".format(model_name))
+    # plot accuracy
+    ts = run_info['thresholds']
+    subsets = ['train','test']
+    for subset in subsets:
+        accs = run_info[subset+'_acc']
+        ax[0,0].plot(ts,accs,label = subset)
+    ax[0,0].set_xlabel("classification threshold")
+    ax[0,0].set_ylabel("accuracy")
+    ax[0,0].set_title("Classifier accuracy vs. threshold")
+    ax[0,0].legend()
+    # plot F1
+    for subset in subsets:
+        accs = run_info[subset+'_F1']
+        thresh_max = ts[np.argmax(accs)]
+        ax[0,1].plot(ts,accs,label = subset,)
+    ax[0,1].set_xlabel("classification threshold")
+    ax[0,1].set_ylabel("F1 Score")
+    ax[0,1].set_title("F1 max at threshold = {}".format(np.round(thresh_max,decimals = 3)))
+    ax[0,1].legend()
+    # plot ROC
+    for subset in subsets:
+        tprs = np.append(run_info[subset+'_tpr'][::-1],1)
+        fprs = np.append(run_info[subset+'_fpr'][::-1],1)
+        auc = np.trapz(tprs,fprs)
+        ax[1,0].plot(fprs,tprs,label = subset + "; AUC = {}".format(np.round(auc,decimals = 4)))
+    line = np.linspace(0,1,100)
+    ax[1,0].plot(line,line,'k--')
+    ax[1,0].set_xlabel("False positive rate")
+    ax[1,0].set_ylabel("True positive rate")
+    ax[1,0].set_title("ROC Curves; in/out of sample")
+    ax[1,0].legend()
+    for subset in subsets:
+        precs = run_info[subset+'_prec'][::-1]
+        recs = run_info[subset+'_tpr'][::-1]
+        ax[1,1].plot(recs,precs,label = subset)
+    ax[1,1].set_xlabel("Recall")
+    ax[1,1].set_ylabel("Precision")
+    ax[1,1].set_title("PR Curves; out of sample")
+    ax[1,1].legend()
+    plt.show()
+
+    if savefile:
+        fig.savefig(osp.join('comparison_images',model_name+'_metrics.pdf'),bbox_inches = 'tight')
+
 ###########################################################################
 ###########################################################################
 # Plotting various metrics
 
 
 # PLOT TEST LOSS VS TIME
-def plot_loss(run_info,**kwargs):
+def plot_test_loss(run_info,**kwargs):
     times = run_info['test_time']
     losses = run_info['test_loss']
-    ts,avg = run_info['avg_loss']
+    ts,avg = run_info['avg_test_loss']
     for k in range(len(times)):
         plt.plot(times[k],losses[k],label = 'fold {} loss'.format(k+1))
     plt.plot(ts,avg,'k--',linewidth = 2,label = 'avg loss')
     plt.xlabel("training time")
     # plt.xscale('log')
     plt.ylabel("test loss")
+    plt.title("Test loss vs train time")
     plt.legend()
     plt.show()
 
+def plot_train_test_loss(run_info):
+    ts = run_info['train_iter']
+    ls = run_info['train_loss']
+    tts,avg = run_info['avg_test_loss']
+    
+    plt.plot(tts,avg,linewidth = 2,label = 'avg test loss')
+    min_time = min([np.min(t) for t in ts])
+    max_time = max([np.max(t) for t in ts])
+    ts_common = np.linspace(0, 1, 1000)
+    interpolated_arrays = []
+    cutoff = 10
+    for i,(t, l) in enumerate(zip(ts, ls)):
+        t = t[cutoff:]/max(t)
+        l = l[cutoff:]
+        smoothed_l = moving_average(l, 30)
+        interp_func = interp1d(t, smoothed_l, bounds_error=False, fill_value=(smoothed_l[0], smoothed_l[-1]))
+        interpolated_arrays.append(interp_func(ts_common))
+    
+    interpolated_arrays = np.array(interpolated_arrays)
+    ls_common = np.nanmean(interpolated_arrays, axis=0)
+    
+    plt.plot(ts_common[cutoff:],ls_common[cutoff:],linewidth = 2,label = "avg train loss")
+    plt.xlabel("progress fraction")
+    plt.ylabel("Cross-entropy loss")
+    plt.title("Test vs train loss")
+    plt.legend()
+
+# PLOT TRAIN LOSS VS ITER
+def plot_train_loss(run_info):
+    ts = run_info['train_iter']
+    ls = run_info['train_loss']
+    min_time = min([np.min(t) for t in ts])
+    max_time = max([np.max(t) for t in ts])
+    ts_common = np.linspace(min_time, max_time, 1000)
+    interpolated_arrays = []
+    cutoff = 10
+    for i,(t, l) in enumerate(zip(ts, ls)):
+        t = t[cutoff:]
+        l = l[cutoff:]
+        smoothed_l = moving_average(l, 50)
+        plt.plot(t,smoothed_l,label = "fold {}".format(i+1))
+        interp_func = interp1d(t, smoothed_l, bounds_error=False, fill_value=(smoothed_l[0], smoothed_l[-1]))
+        interpolated_arrays.append(interp_func(ts_common))
+    
+    interpolated_arrays = np.array(interpolated_arrays)
+    ls_common = np.nanmean(interpolated_arrays, axis=0)
+    
+    plt.plot(ts_common[cutoff:],ls_common[cutoff:], 'k--',linewidth = 2,label = "avg loss")
+    plt.xlabel("training iteration")
+    plt.ylabel("training loss")
+    plt.title("Training loss vs. iteration")
+    plt.legend()
+
 # PLOT ACCURACY VS THRESHOLD
 def plot_accuracy(run_info,**kwargs):
     ts = run_info['thresholds']
@@ -250,17 +479,19 @@ def plot_accuracy(run_info,**kwargs):
     plt.show()
 
 # PLOT F1 SCORE VS THRESHOLD
-def plot_F1(run_info,**kwargs):
+def plot_F1(run_info,get_max = True,**kwargs):
     ts = run_info['thresholds']
     subsets = ['test']
     for subset in subsets:
         accs = run_info[subset+'_F1']
+        thresh_max = ts[np.argmax(accs)]
         plt.plot(ts,accs,label = subset,**kwargs)
     plt.xlabel("classification threshold")
     plt.ylabel("F1 Score")
     plt.title("F1 score vs. threshold")
     plt.legend()
     plt.show()
+    print("F1 score maximized at threshold",np.round(thresh_max,decimals = 3))
 
 # PLOT ROC CURVES
 def plot_ROC(run_info,**kwargs):
@@ -269,7 +500,7 @@ def plot_ROC(run_info,**kwargs):
         tprs = np.append(run_info[subset+'_tpr'][::-1],1)
         fprs = np.append(run_info[subset+'_fpr'][::-1],1)
         auc = np.trapz(tprs,fprs)
-        plt.plot(fprs,tprs,label = subset + "; AUC = {}".format(auc),**kwargs)
+        plt.plot(fprs,tprs,label = subset + "; AUC = {}".format(np.round(auc,decimals = 4)),**kwargs)
     line = np.linspace(0,1,100)
     plt.plot(line,line,'k--')
     plt.xlabel("False positive rate")
diff --git a/penn_dataset.py b/penn_dataset.py
index 41d02d6..b822b21 100644
--- a/penn_dataset.py
+++ b/penn_dataset.py
@@ -4,7 +4,7 @@ import pandas as pd
 import numpy as np
 
 from torchvision import datasets, transforms
-from torch.utils.data import Dataset, DataLoader
+from torch.utils.data import Dataset, DataLoader, Sampler
 from sklearn.model_selection import RepeatedKFold
 
 from os import path as osp
@@ -16,6 +16,7 @@ from forge import flags
 flags.DEFINE_boolean("include_coords",False, "If False, remove coordinate information")
 flags.DEFINE_boolean("rescale", True, "Rescales intensities")
 flags.DEFINE_boolean("cross_validate",True,"Do K-fold cross-validation")
+# flags.DEFINE_boolean("patient_batch",True,"Batch data by patient (data heading)")
 
 # Job management
 # flags.DEFINE_integer("batch size",5,"training batch size")
@@ -25,12 +26,44 @@ flags.DEFINE_integer("split_seed",1,"Seed for KFold split (integer for reproduci
 
 # "wavelengths between 0.05 and 1 mm in 0.025 mm increments."
 LSPACE = np.arange(0.05,1.05,0.025) # corresponds to 39 non-coord columns of data
-L_INDS = None # specific indices of data to select
+L_INDS = None#None # specific indices of data to select
 
 DATAFOLDER = './penn_data'
 
 HEADINGS = np.array(['aaa0043','aaa0044','aaa0060','aaa0061','aaa0063','aaa0064','aaa0066','aaa0069','aaa0086','aaa0087','aaa_0051','aaa_0053','aaa_0054','aaa_0059','aaa_0071','aaa_0072'])
 
+def pad_dataframe(df): # make all data the same shape, add label "2" for no data
+    # Find the max for both dimensions
+    max_dim = max(df[0].max(), df[1].max())
+
+    # Create all possible combinations of x and y within the new bounds
+    mesh_x, mesh_y = np.meshgrid(range(max_dim + 1), range(max_dim + 1))  # New square grid
+    all_combinations = pd.DataFrame({
+        0: mesh_x.ravel(),
+        1: mesh_y.ravel()
+    })
+
+    # Merge with the original dataframe to find missing combinations
+    merged_df = pd.merge(all_combinations, df, how='left', on=[0, 1])
+
+    # Fill missing 'label' values with 2 (denoting 'no data')
+    merged_df['label'] = merged_df['label'].fillna(2)
+
+    # Identify columns other than 0, 1, and 'label' to fill with zeros
+    fill_zero_columns = [col for col in df.columns if col not in [0, 1, 'label']]
+
+    # Fill missing values for these columns with 0
+    merged_df[fill_zero_columns] = merged_df[fill_zero_columns].fillna(0)
+
+    # Fix any potential column naming due to merge
+    if any(isinstance(col, int) for col in merged_df.columns):  # Check if any column is integer
+        merged_df.columns = [str(col) if isinstance(col, int) else col for col in merged_df.columns]
+
+    # Remove any additional columns created from merging
+    drop_columns = [col for col in merged_df if col.endswith('_drop')]
+    merged_df.drop(columns=drop_columns, inplace=True)
+
+    return merged_df,max_dim
 
 class PennData(Dataset):
 
@@ -57,6 +90,10 @@ class PennData(Dataset):
 		labels = pd.concat(label_list, ignore_index=True)
 		df = pd.concat([labels, df], axis="columns") # Append labels to data
 
+		df = df.sample(frac = 1) # shuffle dataframe
+
+		self.df = df
+
 		all_labels = df['label'].to_numpy()
 		all_data = df.iloc[:,1:].to_numpy()
 
@@ -79,6 +116,9 @@ class PennData(Dataset):
 		else:
 			self.coords = None
 
+		if k_inds != None:
+			self.data = self.data[:,np.array(k_inds)]
+
 	def __len__(self):
 		return len(self.data)
 
@@ -116,6 +156,21 @@ class PennData(Dataset):
 			self.labels = state['label']
 
 
+class headingSampler(Sampler): # sample data so batches each come from unique patient
+    def __init__(self, data_source):
+        super().__init__()
+        self.data_source = data_source
+        # Sorting data so it is batched by patient
+        self.sorted_indices = sorted(range(len(data_source)), key=lambda idx: data_source[idx]['coords'][0])
+
+    def __iter__(self):
+        # Yielding indices batch-wise, but indices within each batch are sorted based on h_idx
+        for idx in self.sorted_indices:
+            yield idx
+
+    def __len__(self):
+        return len(self.data_source)
+
 def load(config):
 
 	n_splits = int(len(HEADINGS)/((1-config.train_split)*len(HEADINGS)))
@@ -128,18 +183,27 @@ def load(config):
 		n_val = len(test_ind)//2
 		n_test = len(test_ind)-n_val   
 		n_train = len(train_ind)
+
+
+		sampler = None
 		
 		# set up training DataLoader
 		train_data = PennData(DATAFOLDER,HEADINGS[train_ind],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-		train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,shuffle = True)
+		if config.include_coords:
+			sampler = headingSampler(train_data)
+		train_loader = DataLoader(train_data,batch_size = min(config.batch_size, len(train_data)),num_workers=0,sampler = sampler)
 
 		# set up test DataLoader
 		test_data = PennData(DATAFOLDER,HEADINGS[test_ind[:n_test]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-		test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,shuffle = True)
+		if config.include_coords:
+			sampler = headingSampler(test_data)
+		test_loader = DataLoader(test_data,batch_size = min(config.batch_size, len(test_data)),num_workers=0,sampler = sampler)
 
 		# set up val DataLoader
 		val_data = PennData(DATAFOLDER,HEADINGS[test_ind[n_test:]],k_inds = L_INDS,include_coords = config.include_coords,rescale = config.rescale)
-		val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,shuffle = True)
+		if config.include_coords:
+			sampler = headingSampler(val_data)
+		val_loader = DataLoader(val_data,batch_size = min(config.batch_size, len(val_data)),num_workers=0,sampler = sampler)
 		
 
 		dataloaders = {'train':train_loader, 
@@ -155,4 +219,4 @@ def load(config):
 		if not config.cross_validate:
 			break
 
-	return kf_dataloaders
+	return kf_dataloaders,L_INDS
diff --git a/testing.ipynb b/testing.ipynb
index 5b7601a..44b4dd2 100644
--- a/testing.ipynb
+++ b/testing.ipynb
@@ -2,16 +2,18 @@
  "cells": [
   {
    "cell_type": "code",
-   "execution_count": 7,
+   "execution_count": 1,
    "id": "4dee7ff1-01a4-4038-b493-9729ff3693f7",
    "metadata": {},
    "outputs": [],
    "source": [
     "import torch\n",
+    "import torch.nn as nn\n",
+    "import torch.nn.functional as F\n",
     "import numpy as np\n",
     "from sklearn.model_selection import RepeatedKFold\n",
     "import pandas as pd\n",
-    "from torch.utils.data import Dataset, DataLoader\n",
+    "from torch.utils.data import Dataset, DataLoader, Sampler\n",
     "\n",
     "import matplotlib.pyplot as plt\n",
     "from os import path as osp\n",
@@ -20,56 +22,367 @@
     "from forge import flags\n",
     "import forge.experiment_tools as fet\n",
     "\n",
-    "from penn_dataset import PennData"
+    "from penn_dataset import PennData,headingSampler"
    ]
   },
   {
    "cell_type": "code",
-   "execution_count": 8,
+   "execution_count": 42,
    "id": "92bae5ef-5c95-4528-a76d-003bbe09786c",
    "metadata": {},
    "outputs": [],
    "source": [
-    "headings = np.array(['aaa0043','aaa0044','aaa0060','aaa0061','aaa0063','aaa0064','aaa0066','aaa0069','aaa0086','aaa0087','aaa_0051','aaa_0053','aaa_0054','aaa_0059','aaa_0071','aaa_0072'])\n"
+    "headings = np.array(['aaa0043','aaa0044','aaa0060','aaa0061','aaa0063','aaa0064','aaa0066','aaa0069','aaa0086','aaa0087','aaa_0051','aaa_0053','aaa_0054','aaa_0059','aaa_0071','aaa_0072'])\n",
+    "kinds = None\n",
+    "dat = PennData('./penn_data',headings,include_coords = False,k_inds = kinds)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 53,
+   "id": "8ecb4309-6ea4-4313-a913-3d832e90fe25",
+   "metadata": {},
+   "outputs": [
+    {
+     "data": {
+      "text/plain": [
+       "torch.Size([10, 1, 39])"
+      ]
+     },
+     "execution_count": 53,
+     "metadata": {},
+     "output_type": "execute_result"
+    }
+   ],
+   "source": [
+    "df,bounds = pad_dataframe(dat.df)\n",
+    "loader = DataLoader(dat,batch_size = 10,sampler = None)\n",
+    "example = next(iter(loader))\n",
+    "xx = torch.unsqueeze(example['data'].float(),1)\n",
+    "s = xx.shape\n",
+    "s"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 86,
+   "id": "c15fbcaf-a7cd-4b52-9b94-81b3b16dee64",
+   "metadata": {},
+   "outputs": [
+    {
+     "data": {
+      "text/plain": [
+       "tensor([[-0.1314,  0.1730],\n",
+       "        [-0.1235,  0.1467],\n",
+       "        [-0.1051,  0.1324],\n",
+       "        [-0.1355,  0.1999],\n",
+       "        [-0.2359,  0.4004],\n",
+       "        [-0.2339,  0.4176],\n",
+       "        [-0.1553,  0.3063],\n",
+       "        [-0.1002,  0.1395],\n",
+       "        [-0.1073,  0.1191],\n",
+       "        [-0.0951,  0.1044]], grad_fn=<AddmmBackward0>)"
+      ]
+     },
+     "execution_count": 86,
+     "metadata": {},
+     "output_type": "execute_result"
+    }
+   ],
+   "source": [
+    "m = ConvNN(16,2,2)\n",
+    "m(example)"
    ]
   },
   {
    "cell_type": "code",
-   "execution_count": 14,
-   "id": "9d401c3e-bbc9-4ee9-a4e1-7ca7f7a3d701",
+   "execution_count": 84,
+   "id": "94bb950c-609a-44f2-a6f4-5d50f944cd90",
    "metadata": {},
    "outputs": [],
    "source": [
-    "dat = PennData('./penn_data',headings[:1],include_coords = True)"
+    "class ConvNN(nn.Module):\n",
+    "    def __init__(self, dim_hidden, kernel_size,num_classes):\n",
+    "        super(ConvNN, self).__init__()\n",
+    "        # Define the layers\n",
+    "        self.conv1 = nn.Conv1d(1,dim_hidden,kernel_size)  # First convolution layer\n",
+    "        self.conv2 = nn.Conv1d(dim_hidden,dim_hidden,kernel_size) # second convolution layer\n",
+    "\n",
+    "        self.fc1 = nn.Linear(dim_hidden,dim_hidden)\n",
+    "        self.fc2 = nn.Linear(dim_hidden,num_classes)\n",
+    "        # self.softmax = nn.Softmax(dim=1)\n",
+    "\n",
+    "    def forward(self, x):\n",
+    "        x = x['data']\n",
+    "        x = torch.unsqueeze(x,1).float() # add a single channel index\n",
+    "\n",
+    "        # Forward pass through the network\n",
+    "        x = F.relu(self.conv1(x))  # Activation function between layers\n",
+    "        \n",
+    "        x = F.relu(self.conv2(x))\n",
+    "\n",
+    "        global_max_pool = nn.MaxPool1d(kernel_size=x.size()[2])  # This takes the size of the third dimension\n",
+    "        x = global_max_pool(x).squeeze(2)\n",
+    "\n",
+    "        x = F.relu(self.fc1(x))\n",
+    "        x = self.fc2(x)\n",
+    "        \n",
+    "        return x\n"
    ]
   },
   {
    "cell_type": "code",
-   "execution_count": 15,
-   "id": "8ecb4309-6ea4-4313-a913-3d832e90fe25",
+   "execution_count": 38,
+   "id": "14013b2d-5847-4e1a-800e-edd273d8d791",
+   "metadata": {},
+   "outputs": [
+    {
+     "data": {
+      "text/plain": [
+       "{'label': tensor([0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),\n",
+       " 'coords': tensor([[ 0., 28., 18.],\n",
+       "         [ 0., 29., 48.],\n",
+       "         [ 0., 27., 25.],\n",
+       "         [ 0., 32., 17.],\n",
+       "         [ 0.,  8., 36.],\n",
+       "         [ 0., 19., 35.],\n",
+       "         [ 0., 33., 45.],\n",
+       "         [ 0.,  7., 25.],\n",
+       "         [ 0.,  6.,  5.],\n",
+       "         [ 0., 36., 35.]], dtype=torch.float64),\n",
+       " 'data': tensor([[-0.4918, -0.5943, -1.0721, -0.9575, -0.6650, -0.7359],\n",
+       "         [-0.6024, -1.1120, -0.5868,  0.0182,  0.7436, -0.2009],\n",
+       "         [-0.8743, -0.2060, -1.3125, -0.3913, -0.3318, -0.1418],\n",
+       "         [ 0.3684, -0.0516, -0.7292, -1.1248, -0.7590, -0.5693],\n",
+       "         [-0.7428, -0.7065, -1.0986, -0.8626, -1.0908, -1.0204],\n",
+       "         [ 0.0483, -0.7283,  1.1701, -0.0736, -1.2278, -0.2546],\n",
+       "         [-0.3632, -1.0483,  1.1965, -0.5309, -1.1567,  1.5961],\n",
+       "         [-1.2088, -0.7159, -0.7503, -0.7777, -0.2693, -0.7245],\n",
+       "         [-0.9576, -0.6151,  0.5618,  1.8565,  3.3299,  2.6075],\n",
+       "         [-0.3988, -0.2353,  0.0685, -1.2082, -0.7855, -1.1990]],\n",
+       "        dtype=torch.float64)}"
+      ]
+     },
+     "execution_count": 38,
+     "metadata": {},
+     "output_type": "execute_result"
+    }
+   ],
+   "source": [
+    "inps"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 33,
+   "id": "158d7836-db5c-4210-9814-43806dd777ad",
+   "metadata": {},
+   "outputs": [
+    {
+     "data": {
+      "text/plain": [
+       "torch.Size([153300, 2])"
+      ]
+     },
+     "execution_count": 33,
+     "metadata": {},
+     "output_type": "execute_result"
+    }
+   ],
+   "source": [
+    "torch.cat(outs,dim = 0).shape"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 24,
+   "id": "68243435-58a8-4717-ae96-bd281fbd64c5",
+   "metadata": {},
+   "outputs": [],
+   "source": [
+    "model = SpectralAttentionNet(len(kinds),16,2)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 25,
+   "id": "0dde6efa-3ce3-4f89-abc6-5893e066f9dc",
+   "metadata": {
+    "scrolled": true
+   },
+   "outputs": [
+    {
+     "data": {
+      "text/plain": [
+       "tensor([[-0.6669,  0.0875],\n",
+       "        [-0.7097,  0.0436],\n",
+       "        [-0.6941,  0.0615],\n",
+       "        [-0.6393,  0.1075],\n",
+       "        [-0.7090,  0.0438],\n",
+       "        [-0.7054,  0.0472],\n",
+       "        [-0.7099,  0.0442],\n",
+       "        [-0.7042,  0.0485],\n",
+       "        [-0.5686,  0.1150],\n",
+       "        [-0.7015,  0.0549]], grad_fn=<AddmmBackward0>)"
+      ]
+     },
+     "execution_count": 25,
+     "metadata": {},
+     "output_type": "execute_result"
+    }
+   ],
+   "source": [
+    "model(inps)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 19,
+   "id": "45e4cc12-5ef6-40ad-ad9e-45988ac7dbc1",
+   "metadata": {},
+   "outputs": [],
+   "source": [
+    "\n",
+    "\n",
+    "    "
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 18,
+   "id": "81dd05f3-bee8-43a4-8c51-f92e023bae25",
    "metadata": {},
    "outputs": [
     {
      "data": {
+      "text/html": [
+       "<div>\n",
+       "<style scoped>\n",
+       "    .dataframe tbody tr th:only-of-type {\n",
+       "        vertical-align: middle;\n",
+       "    }\n",
+       "\n",
+       "    .dataframe tbody tr th {\n",
+       "        vertical-align: top;\n",
+       "    }\n",
+       "\n",
+       "    .dataframe thead th {\n",
+       "        text-align: right;\n",
+       "    }\n",
+       "</style>\n",
+       "<table border=\"1\" class=\"dataframe\">\n",
+       "  <thead>\n",
+       "    <tr style=\"text-align: right;\">\n",
+       "      <th></th>\n",
+       "      <th>label</th>\n",
+       "      <th>h_idx</th>\n",
+       "      <th>nslice</th>\n",
+       "      <th>0</th>\n",
+       "      <th>1</th>\n",
+       "      <th>2</th>\n",
+       "      <th>3</th>\n",
+       "      <th>4</th>\n",
+       "      <th>5</th>\n",
+       "      <th>6</th>\n",
+       "      <th>...</th>\n",
+       "      <th>31</th>\n",
+       "      <th>32</th>\n",
+       "      <th>33</th>\n",
+       "      <th>34</th>\n",
+       "      <th>35</th>\n",
+       "      <th>36</th>\n",
+       "      <th>37</th>\n",
+       "      <th>38</th>\n",
+       "      <th>39</th>\n",
+       "      <th>40</th>\n",
+       "    </tr>\n",
+       "  </thead>\n",
+       "  <tbody>\n",
+       "    <tr>\n",
+       "      <th>4</th>\n",
+       "      <td>0</td>\n",
+       "      <td>0</td>\n",
+       "      <td>0</td>\n",
+       "      <td>2</td>\n",
+       "      <td>2</td>\n",
+       "      <td>0.001812</td>\n",
+       "      <td>0.002843</td>\n",
+       "      <td>0.001445</td>\n",
+       "      <td>0.003165</td>\n",
+       "      <td>0.002113</td>\n",
+       "      <td>...</td>\n",
+       "      <td>0.016286</td>\n",
+       "      <td>0.019752</td>\n",
+       "      <td>0.027634</td>\n",
+       "      <td>0.039219</td>\n",
+       "      <td>0.053746</td>\n",
+       "      <td>0.070735</td>\n",
+       "      <td>0.089852</td>\n",
+       "      <td>0.110827</td>\n",
+       "      <td>0.133419</td>\n",
+       "      <td>0.157407</td>\n",
+       "    </tr>\n",
+       "  </tbody>\n",
+       "</table>\n",
+       "<p>1 rows × 44 columns</p>\n",
+       "</div>"
+      ],
       "text/plain": [
-       "array([[ 0.,  1.,  1.],\n",
-       "       [ 0.,  2.,  1.],\n",
-       "       [ 0.,  3.,  1.],\n",
-       "       ...,\n",
-       "       [ 0., 31., 41.],\n",
-       "       [ 0., 32., 41.],\n",
-       "       [ 0., 33., 41.]])"
+       "   label  h_idx  nslice  0  1         2         3         4         5  \\\n",
+       "4      0      0       0  2  2  0.001812  0.002843  0.001445  0.003165   \n",
+       "\n",
+       "          6  ...        31        32        33        34        35        36  \\\n",
+       "4  0.002113  ...  0.016286  0.019752  0.027634  0.039219  0.053746  0.070735   \n",
+       "\n",
+       "         37        38        39        40  \n",
+       "4  0.089852  0.110827  0.133419  0.157407  \n",
+       "\n",
+       "[1 rows x 44 columns]"
       ]
      },
-     "execution_count": 15,
+     "execution_count": 18,
      "metadata": {},
      "output_type": "execute_result"
     }
    ],
    "source": [
-    "dat.coords"
+    "# imagemask = (df['h_idx'] == 0)\n",
+    "# coordmask = ((df[0] == 1) and (df[1] == 1))\n",
+    "df[(df['h_idx'] == 0) & ((df[0] == 2) & (df[1] == 2))]"
    ]
   },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "id": "52ef379d-ba80-4851-96d7-d9d6ba474406",
+   "metadata": {},
+   "outputs": [],
+   "source": []
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "id": "18686a3f-9652-4889-916e-8e70459381b4",
+   "metadata": {},
+   "outputs": [],
+   "source": []
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "id": "78b89c6b-8a3b-45e7-99a8-b00cfac50d49",
+   "metadata": {},
+   "outputs": [],
+   "source": []
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "id": "fd0a8ff8-df49-4b44-884f-588be5bc2d3c",
+   "metadata": {},
+   "outputs": [],
+   "source": []
+  },
   {
    "cell_type": "code",
    "execution_count": 6,
@@ -140,25 +453,6 @@
     "np.bincount(loaddat[0]['train'].dataset.all_labels)"
    ]
   },
-  {
-   "cell_type": "code",
-   "execution_count": 13,
-   "id": "07e0b160-d5d1-4e54-b4a7-ccaf2224598a",
-   "metadata": {},
-   "outputs": [
-    {
-     "data": {
-      "text/plain": [
-       "<generator object Module.parameters at 0x3007207b0>"
-      ]
-     },
-     "execution_count": 13,
-     "metadata": {},
-     "output_type": "execute_result"
-    }
-   ],
-   "source": []
-  },
   {
    "cell_type": "code",
    "execution_count": null,
diff --git a/todo.txt b/todo.txt
index 0fd9ad1..b151bc9 100644
--- a/todo.txt
+++ b/todo.txt
@@ -1,10 +1,7 @@
 To Do on modeling:
 
-- write results to file with deepdish, then read them to compare models
+- Try new padding scheme
 
-- get code working with a subset of kvals
-
-- get Conv1d working as an architecture
-
-- consider patch-attention based strategy
+- Test and fit selected models more completely
 
+- Extract model predictions for ROC etc from visual models
diff --git a/train.py b/train.py
index baee91a..4c0fc0e 100644
--- a/train.py
+++ b/train.py
@@ -42,9 +42,9 @@ flags.DEFINE_string('model_config', 'basic_feedforward.py',
 					'Path to a model config file.')
 flags.DEFINE_string('results_dir', 'checkpoints',
 					'Top directory for all experimental results.')
-flags.DEFINE_string('model_name', 'gpt-FCNN',
+flags.DEFINE_string('model_name', 'basicFFNN',
 					'shorthand name for model.')
-flags.DEFINE_string('run_name', 'hyperparam_testing',
+flags.DEFINE_string('run_name', 'demo',
 					'Name of this job and name of results folder.')
 flags.DEFINE_boolean('resume', False, 'Tries to resume a job if True.')
 
@@ -81,13 +81,15 @@ flags.DEFINE_float("beta1", 0.9, "Adam Beta 1 parameter")
 flags.DEFINE_float("beta2", 0.999, "Adam Beta 2 parameter")
 
 # Specific config options
-flags.DEFINE_integer("input_size",39,"Input shape to model")
+# flags.DEFINE_integer("input_size",39,"Input shape to model")
 
 #########################################################################################
 
 def evaluate(model, loader, device,fold = 0,headings = [],loss_func = nn.CrossEntropyLoss()):
 	# this function does not account for class weights when evaluating cross-entropy loss.
 	# however, they are accounted for when evaluating training loss
+
+	# MODIFY THIS FUNCTION TO ACCOUNT FOR COORDINATES BEING INCLUDED
 	reports = None
 	for data in loader:
 		labels = data['label']
@@ -96,8 +98,10 @@ def evaluate(model, loader, device,fold = 0,headings = [],loss_func = nn.CrossEn
 		labels_tensor = torch.zeros((len(labels), 2))
 		for i, label in enumerate(labels):
 			labels_tensor[i, label] = 1
+		labels_tensor = labels_tensor.to(device)
 
-		model_output = model(inputs) # evaluate model
+		model = model.to(device)
+		model_output = model(data) # evaluate model
 
 		loss = loss_func(model_output, labels_tensor) # compute loss
 		outputs = AttrDict({"loss": loss, "prediction": model_output,'data_fold':fold})
@@ -134,7 +138,17 @@ def main():
 
 	# Load data
 	data_name = "penn_data"
-	kfold_loaders = fet.load(config.data_config, config)
+	kfold_loaders,L_inds = fet.load(config.data_config, config)
+
+	if L_inds == None: # in this case we train on all wavelengths
+		Ldata_size = 39
+	else:
+		Ldata_size = len(L_inds)
+
+	config.input_size = Ldata_size
+
+	#############################################################
+	# ENVIRONMENT/DIRECTORY MANAGEMENT
 
 	# Prepare environment
 	params_in_run_name = [
@@ -178,11 +192,30 @@ def main():
 	n_folds = len(kfold_loaders)
 	print("Doing {}-fold cross-validation.".format(n_folds))
 
-	# KFOLD TRAINING LOOP
+	#############################################################
+	# ENVIRONMENT/DIRECTORY MANAGEMENT
+	# (KFOLD TRAINING LOOP)
 	for k,loader_k in enumerate(kfold_loaders): # loop over data splits
 
 		print("Training fold {}...".format(k+1))
 
+		# create folder for this data split
+		fold_dir = osp.join(logdir,"data_fold{}".format(k+1))
+		fold_dir_exists = osp.exists(fold_dir)
+		if not fold_dir_exists:
+			if config.resume:
+				raise ValueError("Can't resume when the checkpoint/fold dir '{}' doesn't exist.".format(fold_dir))
+			else:
+				os.makedirs(fold_dir)
+		checkpoint_name = osp.join(fold_dir, 'model_fold{}.ckpt'.format(k+1))
+
+		# keep track of which data is test data for a given Kfold data split
+		test_headings = loader_k['test_headings']
+		headingsFile = osp.join(fold_dir,"test_headings.txt")
+		with open(headingsFile,'w') as headfile:
+			for heading in test_headings:
+				headfile.write(heading+'\n')
+
 		# Load model
 		model,model_name = fet.load(config.model_config, config)
 		model = model.to(device)
@@ -221,24 +254,9 @@ def main():
 		train_total_counts = sum(train_class_counts)
 		class_weight = torch.tensor(1.0 / train_class_counts) * train_total_counts / 2.0
 
-		loss_func = nn.CrossEntropyLoss(weight = class_weight) # define reweighted loss function
-				
-		# create folder for this data split
-		fold_dir = osp.join(logdir,"data_fold{}".format(k+1))
-		fold_dir_exists = osp.exists(fold_dir)
-		if not fold_dir_exists:
-			if config.resume:
-				raise ValueError("Can't resume when the checkpoint/fold dir '{}' doesn't exist.".format(fold_dir))
-			else:
-				os.makedirs(fold_dir)
-		checkpoint_name = osp.join(fold_dir, 'model_fold{}.ckpt'.format(k+1))
+		class_weight = nested_to(class_weight,device,torch.float32)
 
-		# keep track of which data is test data for a given Kfold data split
-		test_headings = loader_k['test_headings']
-		headingsFile = osp.join(fold_dir,"test_headings.txt")
-		with open(headingsFile,'w') as headfile:
-			for heading in test_headings:
-				headfile.write(heading+'\n')
+		loss_func = nn.CrossEntropyLoss(weight = class_weight) # define reweighted loss function
 
 		# print(checkpoint_name)
 
@@ -293,7 +311,9 @@ def main():
 				for i, label in enumerate(labels):
 					labels_tensor[i, label] = 1
 
-				model_output = model(data) # evaluate model
+				labels_tensor = labels_tensor.to(device)
+
+				model_output = model(data_dict) # evaluate model
 
 				loss = loss_func(model_output, labels_tensor) # compute loss
 				runsum += loss.item() # track loss
